msgid ""
msgstr ""
"Project-Id-Version: The Starknet Book\n"
"POT-Creation-Date: 2024-04-07T21:56:52+08:00\n"
"PO-Revision-Date: 2024-04-07 23:12+0800\n"
"Last-Translator: StarknetAstro <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4.2\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Starknet Book"
msgstr "Starknet ä¹‹ä¹¦"

#: src/SUMMARY.md:3
#, fuzzy
msgid "The Starknet Book Introduction"
msgstr "Starknet ä¹‹ä¹¦"

#: src/SUMMARY.md:6
#, fuzzy
msgid "Getting started"
msgstr "å…¥é—¨"

#: src/SUMMARY.md:8 src/ch01-00-getting-started.md:1 src/ch02-09-starknet-js.md:29 src/ch03-02-01-madara.md:236
msgid "Getting Started"
msgstr "å…¥é—¨"

#: src/SUMMARY.md:10 src/SUMMARY.md:12
msgid "Tooling"
msgstr "å·¥å…·"

#: src/SUMMARY.md:13
msgid "Basic Installation"
msgstr "åŸºæœ¬å®‰è£…"

#: src/SUMMARY.md:14
msgid "Introduction: Starkli, Scarb and Katana"
msgstr "Starkli, Scarb and Katana çš„ç®€ä»‹"

#: src/SUMMARY.md:15 src/ch02-03-scarb.md:1
msgid "Scarb: The Package Manager"
msgstr "Scarbï¼šè½¯ä»¶åŒ…ç®¡ç†å™¨"

#: src/SUMMARY.md:16 src/ch02-04-katana.md:1
msgid "Katana: A Local Node"
msgstr "Katana: æœ¬åœ°èŠ‚ç‚¹"

#: src/SUMMARY.md:17 src/ch02-05-testnet-deployment.md:1
msgid "Testnet Deployment"
msgstr "æµ‹è¯•ç½‘éƒ¨ç½²"

#: src/SUMMARY.md:18
#, fuzzy
msgid "Get started with Sepolia"
msgstr "## å¼€å§‹ä½¿ç”¨Katana"

#: src/SUMMARY.md:19 src/ch02-06-starkli.md:1
#, fuzzy
msgid "Starkli: Querying Starknet"
msgstr "Starkli: Querying the Blockchain ğŸš§"

#: src/SUMMARY.md:20
#, fuzzy
msgid "Example - Beginner: Connection Script"
msgstr "ç¤ºä¾‹ - éƒ¨ç½²è„šæœ¬"

#: src/SUMMARY.md:21 src/ch02-07-starknet-devnet.md:1
#, fuzzy
msgid "Starknet Devnet"
msgstr "Starknet Devnet ğŸš§"

#: src/SUMMARY.md:22
msgid "Foundry Cast: Interacting with Starknet"
msgstr "Foundry Cast: ä¸ Starknet äº¤äº’"

#: src/SUMMARY.md:23
#, fuzzy
msgid "Example - Intermediate: Deployment Script"
msgstr "ç¤ºä¾‹ - éƒ¨ç½²è„šæœ¬"

#: src/SUMMARY.md:24 src/ch02-09-starknet-js.md:1
msgid "Starknet-js: Javascript SDK"
msgstr "Starknet-jsï¼šJavascript SDK"

#: src/SUMMARY.md:25
#, fuzzy
msgid "Example - Beginner: Counter UI"
msgstr "åˆå­¦è€… - è®¡æ•°å™¨ UI"

#: src/SUMMARY.md:26 src/SUMMARY.md:28
#, fuzzy
msgid "Example - Beginner: ERC-20 UI"
msgstr "åˆå­¦è€… - ERC-20 UI"

#: src/SUMMARY.md:27 src/ch02-10-starknet-react.md:1
msgid "Starknet-React: React Integration"
msgstr "Starknet-React: React é›†æˆ"

#: src/SUMMARY.md:29
#, fuzzy
msgid "Example - Intermediate: Million Dollar Homepage"
msgstr "ä¸­çº§ - ç™¾ä¸‡ç¾å…ƒçº§åˆ«çš„ä¸»é¡µ"

#: src/SUMMARY.md:30 src/ch02-11-starknet-py.md:1
msgid "Starknet-py: Python SDK ğŸš§"
msgstr "Starknet-py: Python SDK ğŸš§"

#: src/SUMMARY.md:31 src/ch02-12-starknet-rs.md:1
msgid "Starknet-rs: Rust SDK ğŸš§"
msgstr "Starknet-rs: Rust SDK ğŸš§"

#: src/SUMMARY.md:32 src/ch02-13-foundry-forge.md:1
msgid "Foundry Forge: Testing"
msgstr "Foundry Forge: æµ‹è¯•å·¥å…·"

#: src/SUMMARY.md:33 src/ch02-14-security-considerations.md:1
#, fuzzy
msgid "Security Considerations"
msgstr "## è€ƒé‡"

#: src/SUMMARY.md:34
msgid "Security Tools"
msgstr ""

#: src/SUMMARY.md:35
msgid "Cairo-fuzzer"
msgstr ""

#: src/SUMMARY.md:36 src/ch02-15-02-caracal.md:1
msgid "Caracal"
msgstr ""

#: src/SUMMARY.md:37 src/ch02-15-03-thoth.md:1
msgid "Thoth"
msgstr ""

#: src/SUMMARY.md:38 src/ch02-16-apibara.md:1
msgid "Apibara"
msgstr ""

#: src/SUMMARY.md:40 src/SUMMARY.md:42 src/ch03-00-architecture.md:1
msgid "Architecture"
msgstr "ç»“æ„"

#: src/SUMMARY.md:43
msgid "Transactions"
msgstr "äº¤æ˜“"

#: src/SUMMARY.md:44 src/ch03-01-01-transactions-lifecycle.md:1
msgid "Transactions Lifecycle"
msgstr "äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ"

#: src/SUMMARY.md:45 src/ch03-01-02-fee-mechanism.md:1
msgid "Fee Mechanism"
msgstr "è´¹ç”¨æœºåˆ¶"

#: src/SUMMARY.md:46 src/ch03-01-03-data-availability.md:1
msgid "Data Availability"
msgstr ""

#: src/SUMMARY.md:47 src/ch03-00-architecture.md:51 src/ch03-02-sequencers.md:1
msgid "Sequencers"
msgstr "æ’åºå™¨"

#: src/SUMMARY.md:48 src/ch03-02-01-madara.md:1
msgid "Madara ğŸš§"
msgstr ""

#: src/SUMMARY.md:49
msgid "Provers ğŸš§"
msgstr "è¯æ˜å™¨ ğŸš§"

#: src/SUMMARY.md:50 src/ch03-00-architecture.md:167 src/ch03-04-nodes.md:1
#, fuzzy
msgid "Nodes"
msgstr "èŠ‚ç‚¹ ğŸš§"

#: src/SUMMARY.md:51
msgid "Example: Pathfinder Node"
msgstr ""

#: src/SUMMARY.md:52
msgid "Layer 3 and App Chains ğŸš§ "
msgstr "Layer 3 å’Œåº”ç”¨é“¾ ğŸš§  "

#: src/SUMMARY.md:53 src/ch03-06-solidity-verifier.md:1
msgid "Solidity Verifier"
msgstr "Solidity éªŒè¯å™¨"

#: src/SUMMARY.md:54 src/ch03-07-decentralization.md:1
msgid "Decentralization ğŸš§"
msgstr "å»ä¸­å¿ƒåŒ– ğŸš§"

#: src/SUMMARY.md:55
#, fuzzy
msgid "Smart Contracts ğŸš§"
msgstr "çº¦æŸ ğŸš§"

#: src/SUMMARY.md:56 src/ch01-00-getting-started.md:305
#, fuzzy
msgid "Deployment and Interaction"
msgstr "### éƒ¨ç½²å’Œäº¤äº’"

#: src/SUMMARY.md:57
msgid "Important Methods"
msgstr ""

#: src/SUMMARY.md:59 src/SUMMARY.md:61 src/ch04-00-account-abstraction.md:1 src/ch04-05-03-auto-payments.md:29
msgid "Account Abstraction"
msgstr "è´¦æˆ·æŠ½è±¡"

#: src/SUMMARY.md:62
msgid "Accounts"
msgstr "è´¦æˆ·"

#: src/SUMMARY.md:63
#, fuzzy
msgid "Hello, Account Contract!"
msgstr "ä½ å¥½ï¼Œè´¦æˆ·ï¼"

#: src/SUMMARY.md:64 src/ch04-03-standard-account.md:1
#, fuzzy
msgid "Standard Account Contract"
msgstr "æ ‡å‡†è´¦æˆ· ğŸš§"

#: src/SUMMARY.md:65
#, fuzzy
msgid "Deploy Standard Account"
msgstr "éƒ¨ç½²è´¦æˆ·"

#: src/SUMMARY.md:66 src/ch04-05-examples.md:1
msgid "Examples"
msgstr "ç¤ºä¾‹"

#: src/SUMMARY.md:67
#, fuzzy
msgid "Multicaller"
msgstr "Multicaller ğŸš§"

#: src/SUMMARY.md:68
msgid "Multisig ğŸš§"
msgstr "å¤šç­¾ ğŸš§"

#: src/SUMMARY.md:69 src/ch04-05-03-auto-payments.md:1
msgid "Auto-Payments ğŸš§"
msgstr "è‡ªåŠ¨ä»˜æ¬¾ ğŸš§"

#: src/SUMMARY.md:70 src/ch04-05-04-alternative-signature-schemes.md:1
msgid "Alternative Signature Schemes ğŸš§"
msgstr "æ›¿ä»£ç­¾åæ–¹æ¡ˆ ğŸš§"

#: src/SUMMARY.md:71
msgid "Web Wallet: seedless, multi-device wallet"
msgstr ""

#: src/SUMMARY.md:73
#, fuzzy
msgid "STARKs"
msgstr "STARKs ğŸš§"

#: src/SUMMARY.md:75
msgid "STARKs ğŸš§"
msgstr "STARKs ğŸš§"

#: src/SUMMARY.md:76
msgid "Basics ğŸš§"
msgstr "åŸºç¡€çŸ¥è¯† ğŸš§"

#: src/SUMMARY.md:77
msgid "Math Primer ğŸš§"
msgstr "æ•°å­¦å…¥é—¨ ğŸš§"

#: src/SUMMARY.md:78
msgid "Number Theory ğŸš§"
msgstr "æ•°è®º ğŸš§"

#: src/SUMMARY.md:79
msgid "Geometry ğŸš§"
msgstr "å‡ ä½• ğŸš§"

#: src/SUMMARY.md:80
msgid "Cryptographic Primitives ğŸš§"
msgstr "åŠ å¯†åŸè¯­ ğŸš§"

#: src/SUMMARY.md:81
msgid "Arithimization ğŸš§"
msgstr "æ‹ŸçœŸ ğŸš§"

#: src/SUMMARY.md:82
msgid "Low Degree Testing ğŸš§"
msgstr "ä½åº¦æµ‹è¯• ğŸš§"

#: src/SUMMARY.md:83
msgid "FRI Protocol ğŸš§"
msgstr "FRI åè®® ğŸš§"

#: src/SUMMARY.md:84
msgid "Efficient STARKs"
msgstr "é«˜æ•ˆ STARKs"

#: src/SUMMARY.md:85
msgid "STARKs Protocol (Python) ğŸš§"
msgstr "STARKs åè®®ï¼ˆPythonï¼‰ ğŸš§"

#: src/SUMMARY.md:86 src/SUMMARY.md:91
msgid "Trace/Low Degree Extension ğŸš§"
msgstr "è¿½è¿¹/ä½åº¦ æ‰©å±• ğŸš§"

#: src/SUMMARY.md:87 src/SUMMARY.md:92
msgid "Constraints ğŸš§"
msgstr "çº¦æŸ ğŸš§"

#: src/SUMMARY.md:88 src/SUMMARY.md:93
msgid "FRI Commitments ğŸš§"
msgstr "FRI æ‰¿è¯º ğŸš§"

#: src/SUMMARY.md:89 src/SUMMARY.md:94
msgid "Query Phase ğŸš§"
msgstr "æŸ¥è¯¢é˜¶æ®µ ğŸš§"

#: src/SUMMARY.md:90
msgid "STARKs Protocol (Rust) ğŸš§"
msgstr "STARKs åè®®ï¼ˆRustï¼‰ ğŸš§"

#: src/title-page.md:3
#, fuzzy
msgid ""
"The Starknet Book is a work in progress, shaped by ongoing community input. Some sections may be incomplete or still under review and are marked under a ğŸš§ emoji. We welcome your suggestions, "
"feedback, and content contributions to make this book a reliable guide for everyone."
msgstr "Starknet Book æ˜¯ä¸€ä¸ªç”±ç¤¾åŒºçš„æŒç»­è´¡çŒ®çš„å°šåœ¨æ’°å†™ä¸­çš„ä½œå“ã€‚æŸäº›éƒ¨åˆ†å¯èƒ½ä¸å®Œæ•´æˆ–ä»åœ¨è¢«å®¡æ ¡ä¸­ï¼Œè¿™äº›éƒ¨åˆ†ä¼šè¢«ç”¨ğŸš§è¡¨æƒ…ç¬¦å·è¿›è¡Œæ ‡è®°ã€‚æˆ‘ä»¬æ¬¢è¿æ‚¨çš„å»ºè®®ã€åé¦ˆå’Œå†…å®¹è´¡çŒ®ï¼Œæ¥ä½¿å¾—æœ¬ä¹¦æˆä¸ºæ‰€æœ‰å¼€å‘è€…çš„å¯é æŒ‡å—ã€‚"

#: src/title-page.md:8
#, fuzzy
msgid "The Starknet Book is a step-by-step guide aimed at teaching you the essentials of Starknet development. Itâ€™s a community effort, with each chapter guiding you through the Starknet ecosystem."
msgstr ""
"Starknet Book æ˜¯ä¸€æœ¬å¾ªåºæ¸è¿›çš„æŒ‡å—ï¼Œæ—¨åœ¨å‘ä½ ä¼ æˆStarknet å¼€å‘çš„åŸºæœ¬çŸ¥è¯†ã€‚è¿™æœ¬ä¹¦ç”±ç¤¾åŒºçš„åˆåŠ›æ’°å†™ï¼Œæ¯ä¸€ç« éƒ½ä¼šå¼•å¯¼ä½ äº†è§£Starknet çš„ç”Ÿæ€ç³»ç»Ÿã€‚ä¸­æ–‡ç‰ˆç”±[StarknetAstro](https://twitter.com/StarknetAstroCN)ç¿»"
"è¯‘ã€‚"

#: src/title-page.md:12
#, fuzzy
msgid ""
"Understanding Cairo, the key programming language for Starknet smart contracts, is crucial. Thatâ€™s why this book works hand-in-hand with the Cairo Book, another community resource. You can access the "
"Cairo Book [**here**](https://book.cairo-lang.org/)."
msgstr ""
"äº†è§£åœ¨Starknet æ™ºèƒ½åˆçº¦ä¸­å¤„äºå…³é”®ä½ç½®çš„ç¼–ç¨‹è¯­è¨€Cairoï¼Œæ˜¯è‡³å…³é‡è¦çš„ã€‚å› æ­¤ï¼Œæœ¬ä¹¦ä¸å¦ä¸€ä¸ªç”±ç¤¾åŒºç¼–å†™çš„ã€ŠCairoä¹‹ä¹¦ã€‹ï¼ˆCairo Bookï¼‰æºæ‰‹åˆä½œã€‚ä½ å¯ä»¥ä»[**è¿™é‡Œ**](https://book.cairo-lang.org/)è®¿é—®Cairo Bookã€‚"

#: src/title-page.md:17
#, fuzzy
msgid ""
"In short, the Cairo Book helps you master Cairo, while The Starknet Book focuses on Starknetâ€™s specific features. For a well-rounded understanding, we recommend exploring both. This book will "
"introduce you to tools, architecture, account setups, STARKs, and Starknet-specific apps."
msgstr "ç®€è€Œè¨€ä¹‹ï¼ŒCairo Book å¸®åŠ©æ‚¨æŒæ¡Cairoè¯­è¨€ï¼Œè€ŒStarknet Bookåˆ™ä¾§é‡äºStarknetçš„å…·ä½“åŠŸèƒ½ã€‚ä¸ºäº†å…¨é¢äº†è§£ï¼Œæˆ‘ä»¬å»ºè®®æ‚¨åŒæ—¶é˜…è¯»è¿™ä¸¤æœ¬ä¹¦ã€‚æœ¬ä¹¦å°†å‘ä½ ä»‹ç»å·¥å…·ã€æ¶æ„ã€è´¦æˆ·è®¾ç½®ã€STARK å’ŒStarknetä¸“ç”¨åº”ç”¨ç¨‹åºã€‚"

#: src/title-page.md:23
#, fuzzy
msgid "Table of Contents"
msgstr "## å†…å®¹ç›®å½•"

#: src/title-page.md:25
msgid "**Chapter Titles**"
msgstr "**ç« èŠ‚æ ‡é¢˜**"

#: src/title-page.md:27
msgid "Chapter"
msgstr ""

#: src/title-page.md:27
msgid "Description"
msgstr ""

#: src/title-page.md:29
#, fuzzy
msgid "1: Starknet Introduction"
msgstr "ä»‹ç»"

#: src/title-page.md:29
msgid "Delve into the fundamental concepts of Starknet and acquaint yourself with the deployment of smart contracts."
msgstr ""

#: src/title-page.md:30
#, fuzzy
msgid "2: Starknet Tooling"
msgstr "# Starknetå·¥å…·"

#: src/title-page.md:30
msgid ""
"Familiarize yourself with vital tools, such as Starkli, Katana, Scarb, Starknet-Foundry and more. Explore how languages like Javascript, Python, and Rust can be leveraged for Starknet interactions."
msgstr ""

#: src/title-page.md:31
#, fuzzy
msgid "3: Starknet Architecture"
msgstr "# æ¶æ„"

#: src/title-page.md:31
msgid "Uncover Starknetâ€™s core structure, gaining insights into the transaction lifecycle and the interplay between the Sequencer, Prover, and Nodes."
msgstr ""

#: src/title-page.md:32
#, fuzzy
msgid "4: Account Abstraction"
msgstr "4: è´¦æˆ·æŠ½è±¡"

#: src/title-page.md:32
msgid "Delve deep into Starknetâ€™s unique approach to user accounts, and master the art of crafting custom accounts."
msgstr ""

#: src/title-page.md:33
#, fuzzy
msgid "5: STARKs"
msgstr "STARKs ğŸš§"

#: src/title-page.md:33
msgid "Dive into the intricacies of STARKs and their pivotal role in shaping Starknetâ€™s landscape."
msgstr ""

#: src/title-page.md:35
#, fuzzy
msgid "Where to Start?"
msgstr "ä»å“ªé‡Œå¼€å§‹ï¼Ÿ"

#: src/title-page.md:37
#, fuzzy
msgid "Depending on your goals and interests, you can choose different paths through the Starknet Book. Here are some recommendations based on various objectives:"
msgstr "æ ¹æ®æ‚¨çš„ç›®æ ‡å’Œå…´è¶£ï¼Œæ‚¨å¯ä»¥åœ¨Starknet Bookä¸­é€‰æ‹©ä¸åŒçš„å­¦ä¹ è·¯å¾„ã€‚ä¸‹é¢æ˜¯ä¸€äº›åŸºäºä¸åŒç›®æ ‡çš„å»ºè®®ï¼š"

#: src/title-page.md:41
msgid "If youâ€™re a **complete beginner** and want to start learning about Cairo and Starknet from scratch, follow the book in its entirety, starting with **Introduction to Starknet**."
msgstr ""

#: src/title-page.md:45
msgid ""
"If youâ€™re an **experienced developer** looking to quickly dive into writing scalable and decentralized smart contracts, focus on the Cairo Book, particularly **chapter 12: Starknet Smart Contracts** "
"([link](https://book.cairo-lang.org/ch13-00-introduction-to-starknet-smart-contracts.html))."
msgstr ""

#: src/title-page.md:50
msgid "If youâ€™re a **frontend developer** wanting to integrate Starknet with a React frontend using Javascript, prioritize the **starknet-js** and **starknet-react** subchapters in **Starknet Tooling**"
msgstr ""

#: src/title-page.md:55
msgid "If youâ€™re a **DevOps engineer** or **node operator** interested in running a Starknet node and indexer, head straight to **Starknet Architecture**."
msgstr ""

#: src/title-page.md:59
msgid "If youâ€™re a **security researcher** or **smart contract auditor** wanting to learn about the Account Abstraction feature and its implications, go for **Account Abstraction**."
msgstr ""

#: src/title-page.md:63
msgid "If youâ€™re a **blockchain enthusiast** curious about the underlying architecture and mechanics of Starknet and Cairo, explore **Starknet Architecture**."
msgstr ""

#: src/title-page.md:67
msgid "If youâ€™re a **cryptography expert** or **researcher** eager to understand the fundamentals of STARKs and their connection to the Starknet ecosystem, delve into **STARKs**."
msgstr ""

#: src/title-page.md:71
#, fuzzy
msgid "Feel free to mix and match these paths based on your unique interests and requirements."
msgstr "æ‚¨å¯ä»¥æ ¹æ®è‡ªå·±çš„ç‹¬ç‰¹å…´è¶£å’Œè¦æ±‚è‡ªç”±æ­é…è¿™äº›å­¦ä¹ è·¯å¾„ã€‚"

#: src/title-page.md:74
#, fuzzy
msgid "Your Contributions Matter"
msgstr "# æ‚¨çš„è´¡çŒ®å¾ˆé‡è¦"

#: src/title-page.md:76
#, fuzzy
msgid ""
"Welcome aboard! By contributing to the Starknet Book, youâ€™re doing more than sharing expertiseâ€”youâ€™re shaping the future of decentralized tech. Letâ€™s build a guide that helps developers unlock "
"Starknetâ€™s potential."
msgstr "æ¬¢è¿åŠ å…¥ï¼é€šè¿‡ä¸ºã€ŠStarknet Bookã€‹åšå‡ºè´¡çŒ®ï¼Œæ‚¨æ‰€åšçš„ä¸ä»…ä»…æ˜¯åˆ†äº«ä¸“ä¸šçŸ¥è¯†ï¼Œæ‚¨è¿˜åœ¨å¡‘é€ å»ä¸­å¿ƒåŒ–æŠ€æœ¯çš„æœªæ¥ã€‚è®©æˆ‘ä»¬å…±åŒæ‰“é€ ä¸€æœ¬å¸®åŠ©å¼€å‘è€…é‡Šæ”¾Starknetæ½œåŠ›çš„æŒ‡å—ã€‚"

#: src/title-page.md:80
#, fuzzy
msgid ""
"For detailed contribution guidelines, visit the [Contributors Guide](https://github.com/starknet-edu/starknetbook/blob/main/README.md#contribution). Every contribution counts. Your skills and passion "
"will help make this book an invaluable tool."
msgstr "æœ‰å…³è¯¦ç»†çš„æŠ•ç¨¿æŒ‡å—ï¼Œè¯·è®¿é—® [Contributors Guide](https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc)ã€‚æ¯ä¸€ä»½è´¡çŒ®éƒ½å¾ˆé‡è¦ã€‚æ‚¨çš„æŠ€èƒ½å’Œçƒ­æƒ…å°†å¸®åŠ©æœ¬ä¹¦æˆä¸ºä¸€æœ¬å®è´µçš„å·¥å…·ä¹¦ã€‚"

#: src/title-page.md:85
#, fuzzy
msgid "How You Can Help"
msgstr "## æ‚¨å¯ä»¥å¦‚ä½•æä¾›å¸®åŠ©"

#: src/title-page.md:87
msgid "Found an empty section? Fill it in!"
msgstr ""

#: src/title-page.md:89
msgid "Think we need a new section? Suggest one."
msgstr ""

#: src/title-page.md:91
msgid "See room for improvement? Go ahead and tweak it."
msgstr ""

#: src/title-page.md:93
msgid "Want to add code in a new programming language? Go for it."
msgstr ""

#: src/title-page.md:95
msgid "Found a bug? Fix it."
msgstr ""

#: src/title-page.md:97
msgid "Exercises unclear? Add explanations."
msgstr ""

#: src/title-page.md:99
msgid "Show off your favorite Cairo features through new exercises."
msgstr ""

#: src/title-page.md:101
#, fuzzy
msgid "Additional Key Educational Resources"
msgstr "# å…¶ä»–é‡è¦æ•™è‚²èµ„æº"

#: src/title-page.md:103
#, fuzzy
msgid "Weâ€™ve compiled a list of valuable educational resources that will help deepen your understanding and enhance your skills in coding with Cairo and staying abreast with Starknet developments:"
msgstr "æˆ‘ä»¬ç¼–æ’°äº†ä¸€ä»½æœ‰ä»·å€¼çš„æ•™è‚²èµ„æºæ¸…å•ï¼Œè¿™äº›èµ„æºå°†æœ‰åŠ©äºåŠ æ·±æ‚¨å¯¹Cairoè¯­è¨€çš„ç†è§£ï¼Œæé«˜æ‚¨çš„æŠ€èƒ½ï¼Œå¹¶ç´§è·ŸStarknetå‘å±•çš„æ­¥ä¼ï¼š"

#: src/title-page.md:107
msgid ""
"**Starklings**: A resource specifically designed to guide you through learning Cairo programming, ensuring that you reach a proficient level. You can access it [here](https://github.com/shramee/"
"starklings-cairo1)."
msgstr ""

#: src/title-page.md:112
msgid "**Starknet Community Forum**: An online platform where you can engage in discussions about the latest developments in Starknet. Join the conversation [here](https://community.starknet.io/)."
msgstr ""

#: src/title-page.md:116
msgid "**Starknet Documentation**: You can browse through the documentation [here](https://docs.starknet.io/)."
msgstr ""

#: src/title-page.md:119
msgid "**Cairo Documentation**: Explore it [here](https://www.cairo-lang.org/docs)."
msgstr ""

#: src/title-page.md:122
msgid ""
"**Starknet Developer Telegram (English)**: A community for English-speaking Starknet developers. This is a great platform for networking, sharing ideas, and troubleshooting together. Join us on "
"Telegram [here](https://t.me/starknetna)."
msgstr ""

#: src/ch00-00-introduction.md:1
#, fuzzy
msgid "The Starknet Network"
msgstr "# Starknetç½‘ç»œ"

#: src/ch00-00-introduction.md:3
#, fuzzy
msgid "Preamble"
msgstr "## åºè¨€"

#: src/ch00-00-introduction.md:5
msgid ""
"Historically, societal roles like currency, property rights, and social status titles have been governed by _protocols_ and _registries_. Their value stems from a widely accepted understanding of "
"their integrity. These functions have predominantly been overseen by centralized entities prone to challenges such as corruption, agency conflicts, and exclusion ([Eli Ben-Sasson, Bareli, Brandt, "
"Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"ä»å†å²ä¸Šçœ‹ï¼Œè´§å¸ã€è´¢äº§æƒå’Œç¤¾ä¼šåœ°ä½ç§°å·ç­‰ç¤¾ä¼šè§’è‰²éƒ½æ˜¯ç”± _åè®®_ å’Œ _ç™»è®°æœºæ„_ ç®¡ç†çš„ã€‚å®ƒä»¬çš„ä»·å€¼æºäºäººä»¬å¯¹å…¶å®Œæ•´æ€§çš„å¹¿æ³›è®¤å¯ã€‚è¿™äº›åŠŸèƒ½ä¸»è¦ç”±ä¸­å¤®é›†æƒçš„å®ä½“æ¥è´Ÿè´£ç›‘ç£ï¼Œå®¹æ˜“å‡ºç°è…è´¥ã€æœºæ„å†²çªå’Œæ’æ–¥ç­‰é—®é¢˜"
"ï¼ˆ[Eli Ben-Sassonã€Bareliã€Brandtã€Volokhï¼Œ2023](https://hackmd.io/@Elibensasson/ryMelVulp)ï¼‰ã€‚"

#: src/ch00-00-introduction.md:7
msgid "Satoshi's creation, Bitcoin, introduced a novel approach for these functions, termed an _integrity web_. This is an infrastructure for societal roles that:"
msgstr "ä¸­æœ¬èªåˆ›é€ çš„æ¯”ç‰¹å¸ï¼Œä¸ºè¿™äº›åŠŸèƒ½å¼•å…¥äº†ä¸€ç§æ–°é¢–çš„æ–¹å¼ï¼Œç§°ä¸º _å®Œæ•´æ€§ç½‘ç»œ_ ã€‚è¿™æ˜¯ä¸€ä¸ªé’ˆå¯¹ç¤¾ä¼šè§’è‰²çš„åŸºç¡€è®¾æ–½ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š"

#: src/ch00-00-introduction.md:9
msgid "Is openly described by a public protocol."
msgstr ""

#: src/ch00-00-introduction.md:10
msgid "Operates over a wide, inclusive, peer-to-peer network."
msgstr ""

#: src/ch00-00-introduction.md:11
#, fuzzy
msgid "Distributes value fairly and extensively to maintain societal consensus on its integrity."
msgstr ""
"1.é€šè¿‡å…¬å…±åè®®å…¬å¼€æè¿°ã€‚\n"
"2.é€šè¿‡å¹¿æ³›ã€åŒ…å®¹çš„ç‚¹å¯¹ç‚¹ç½‘ç»œè¿è¡Œã€‚\n"
"3.å…¬å¹³ã€å¹¿æ³›åœ°åˆ†é…ä»·å€¼ï¼Œä»¥ä¿æŒç¤¾ä¼šå¯¹å…¶å®Œæ•´æ€§çš„å…±è¯†ã€‚"

#: src/ch00-00-introduction.md:13
msgid ""
"While Bitcoin addressed monetary functions, Ethereum expanded this to include any function that can be defined by computer programming. Both faced the challenge of balancing scalability with "
"decentralization. These integrity webs have often favored inclusivity over capacity, ensuring even those with limited resources can authenticate the system's integrity. Yet, this means they struggle "
"to meet global demand."
msgstr ""
"æ¯”ç‰¹å¸è§£å†³çš„æ˜¯è´§å¸åŠŸèƒ½ï¼Œè€Œä»¥å¤ªåŠåˆ™å°†å…¶æ‰©å±•åˆ°åŒ…æ‹¬ä»»ä½•å¯ä»¥é€šè¿‡è®¡ç®—æœºç¼–ç¨‹å®šä¹‰çš„åŠŸèƒ½ã€‚ä¸¤è€…éƒ½é¢ä¸´ç€å¹³è¡¡å¯æ‰©å±•æ€§ä¸å»ä¸­å¿ƒåŒ–çš„æŒ‘æˆ˜ã€‚è¿™äº›å®Œæ•´æ€§ç½‘ç»œé€šå¸¸å€¾å‘äºåŒ…å®¹æ€§è€Œéå®¹é‡ï¼Œä»¥ç¡®ä¿å³ä½¿èµ„æºæœ‰é™çš„äººä¹Ÿèƒ½éªŒè¯ç³»ç»Ÿçš„"
"å®Œæ•´æ€§ã€‚ç„¶è€Œï¼Œè¿™æ„å‘³ç€å®ƒä»¬å¾ˆéš¾æ»¡è¶³å…¨çƒçº§çš„éœ€æ±‚ã€‚"

#: src/ch00-00-introduction.md:15
#, fuzzy
msgid "Defining \"Blockchain\""
msgstr "## å®šä¹‰ \"åŒºå—é“¾\""

#: src/ch00-00-introduction.md:17
msgid ""
"In the ever-evolving realm of technology, defining a term as multifaceted as \"Blockchain\" can be challenging. Based on current understandings and applications, a Blockchain can be characterized by "
"the following three properties ([Eli Ben-Sasson, 2023](https://twitter.com/EliBenSasson/status/1709272086504485265)):"
msgstr ""
"åœ¨ä¸æ–­å‘å±•çš„æŠ€æœ¯é¢†åŸŸï¼Œå®šä¹‰ä¸€ä¸ªåƒ \"åŒºå—é“¾ \"è¿™æ ·å¤šå±‚é¢çš„æœ¯è¯­å¯èƒ½å…·æœ‰æŒ‘æˆ˜æ€§ã€‚æ ¹æ®ç›®å‰çš„ç†è§£å’Œåº”ç”¨ï¼ŒåŒºå—é“¾å¯å…·æœ‰ä»¥ä¸‹ä¸‰ä¸ªç‰¹æ€§ï¼ˆ[Eli Ben-Sassonï¼Œ2023](https://twitter.com/EliBenSasson/"
"status/1709272086504485265)ï¼‰ï¼š"

#: src/ch00-00-introduction.md:19
msgid ""
"**Public Protocol:** The foundation of a Blockchain rests upon a protocol that is openly available. This transparency ensures that any interested party can understand its workings, fostering trust and "
"enabling wider adoption."
msgstr ""

#: src/ch00-00-introduction.md:20
msgid ""
"**Open P2P Network:** Instead of relying on a centralized entity, a Blockchain operates over a peer-to-peer (P2P) network. This decentralized approach ensures that operations are distributed across "
"various participants or nodes, making the system more resilient to failures and censorship."
msgstr ""

#: src/ch00-00-introduction.md:21
msgid ""
"**Value Distribution:** Central to the Blockchain's operation is the way it rewards its operators. The system autonomously distributes value in a manner that is wide-ranging and equitable. This "
"incentivization not only motivates participants to maintain the system's integrity but also ensures a broader societal consensus."
msgstr ""

#: src/ch00-00-introduction.md:23
msgid ""
"While these properties capture the essence of many Blockchains, the term's definition might need refinement as the technology matures and finds new applications. Engaging in continuous dialogue and "
"revisiting definitions will be crucial in this dynamic landscape."
msgstr "è™½ç„¶è¿™äº›ç‰¹æ€§æŠ“ä½äº†è®¸å¤šåŒºå—é“¾çš„æœ¬è´¨ï¼Œä½†éšç€æŠ€æœ¯çš„æˆç†Ÿå’Œæ–°åº”ç”¨çš„å‡ºç°ï¼Œè¯¥æœ¯è¯­çš„å®šä¹‰å¯èƒ½ä¾ç„¶éœ€è¦å®Œå–„ã€‚åœ¨è¿™ä¸€åŠ¨æ€ç¯å¢ƒä¸­ï¼ŒæŒç»­çš„å¯¹è¯å’Œé‡æ–°å®¡è§†å®šä¹‰è‡³å…³é‡è¦ã€‚"

#: src/ch00-00-introduction.md:25
#, fuzzy
msgid "Starknet Definition"
msgstr "## Starknetçš„å®šä¹‰"

#: src/ch00-00-introduction.md:27
msgid ""
"Starknet is a Layer-2 network that makes Ethereum transactions faster, cheaper, and more secure using zk-STARKs technology. Think of it as a boosted layer on top of Ethereum, optimized for speed and "
"cost."
msgstr "Starknet æ˜¯ä¸€ä¸ªäºŒå±‚ç½‘ç»œï¼Œåˆ©ç”¨ zk-STARKs æŠ€æœ¯ä½¿ä»¥å¤ªåŠäº¤æ˜“æ›´å¿«ã€æ›´ä¾¿å®œã€æ›´å®‰å…¨ã€‚ä½ å¯ä»¥å°†å…¶è§†ä¸ºä»¥å¤ªåŠä¹‹ä¸Šçš„ä¸€ä¸ªå¢å¼ºå±‚ï¼Œåœ¨é€Ÿåº¦å’Œæˆæœ¬æ–¹é¢è¿›è¡Œäº†ä¼˜åŒ–ã€‚"

#: src/ch00-00-introduction.md:29
msgid ""
"Starknet bridges the gap between scalability and broad consensus. It integrates a mathematical framework to navigate the balance between capacity and inclusivity. Its integrity hinges on the "
"robustness of succinct, transparent proofs of computational integrity. This method lets powerful operators enhance Starknet's capacity, ensuring everyone can authenticate Starknet's integrity using "
"universally accessible tools ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"Starknet å¼¥è¡¥äº†å¯æ‰©å±•æ€§ä¸å¹¿æ³›å…±è¯†ä¹‹é—´çš„å·®è·ã€‚å®ƒæ•´åˆäº†ä¸€ä¸ªæ•°å­¦æ¡†æ¶ï¼Œåœ¨å®¹é‡å’ŒåŒ…å®¹æ€§ä¹‹é—´å–å¾—å¹³è¡¡ã€‚å®ƒçš„å®Œæ•´æ€§å–å†³äºç®€æ´ã€é€æ˜çš„è®¡ç®—å®Œæ•´æ€§è¯æ˜çš„ç¨³å¥æ€§ã€‚è¿™ç§æ–¹æ³•æå¤§çš„æé«˜Starknetçš„å®¹é‡ï¼Œç¡®ä¿æ¯ä¸ªç”¨æˆ·éƒ½èƒ½ä½¿ç”¨"
"æ™®éå¯ç”¨çš„å·¥å…·éªŒè¯Starknetçš„å®Œæ•´æ€§ï¼ˆ[Eli Ben-Sassonã€Bareliã€Brandtã€Volokhï¼Œ2023](https://hackmd.io/@Elibensasson/ryMelVulp)ï¼‰ã€‚"

#: src/ch00-00-introduction.md:31
#, fuzzy
msgid "Starknetâ€™s Mission"
msgstr "## Starknetçš„ä½¿å‘½"

#: src/ch00-00-introduction.md:33
msgid "_Starknetâ€™s mission is to allow individuals to freely implement and use any social function they desire._"
msgstr "_Starknetçš„ä½¿å‘½æ˜¯å…è®¸ä¸ªäººè‡ªç”±å®ç°å’Œä½¿ç”¨ä»–ä»¬æ‰€å¸Œæœ›çš„ä»»ä½•ç¤¾ä¼šæœºèƒ½ã€‚_"

#: src/ch00-00-introduction.md:35
#, fuzzy
msgid "Starknetâ€™s Values"
msgstr "## Starknetçš„ä»·å€¼è§‚"

#: src/ch00-00-introduction.md:37
msgid "Starknet's ethos is anchored in core principles ([Eli Ben-Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"
msgstr "Starknetçš„ç²¾ç¥æ˜¯ä»¥æ ¸å¿ƒåŸåˆ™ä¸ºåŸºç¡€çš„ï¼ˆ[Eli Ben-Sassonã€Bareliã€Brandtã€Volokhï¼Œ2023](https://hackmd.io/@Elibensasson/ryMelVulp)ï¼‰ï¼š"

#: src/ch00-00-introduction.md:39
msgid "**Lasting Broadness.** Starknet continuously resists power consolidation. Key points include:"
msgstr ""

#: src/ch00-00-introduction.md:41
msgid "Broad power distribution underpins Starknet's legitimacy and must persist across operations and decision-making. While centralized operation may be necessary at times, it should be short-lived."
msgstr ""

#: src/ch00-00-introduction.md:42
msgid "Starknet's protocol and governance should always be open and transparent."
msgstr ""

#: src/ch00-00-introduction.md:43
msgid "Governance should bolster inclusivity, with a flexible structure that can evolve to ensure enduring inclusivity."
msgstr ""

#: src/ch00-00-introduction.md:45
msgid "**Neutrality.** Starknet remains impartial to the societal functions it supports."
msgstr ""

#: src/ch00-00-introduction.md:47
msgid "The objectives and ethos of functions on Starknet lie with their creators."
msgstr ""

#: src/ch00-00-introduction.md:48
msgid "**Censorship resistance:** Starknet remains agnostic to the nature and meaning of user transactions."
msgstr ""

#: src/ch00-00-introduction.md:50
msgid ""
"**Individual Empowerment.** At its core, Starknet thrives on a well-informed and autonomous user base. This is achieved by fostering a culture rooted in its core mission and values, with a strong "
"emphasis on education."
msgstr ""

#: src/ch00-00-introduction.md:52
#, fuzzy
msgid "Key Features"
msgstr "## å…³é”®ç‰¹æ€§"

#: src/ch00-00-introduction.md:54
msgid "These are some key features of Starknet:"
msgstr "è¿™äº›æ˜¯Starknetçš„ä¸€äº›å…³é”®ç‰¹æ€§ï¼š"

#: src/ch00-00-introduction.md:56
msgid "Low Costs: Transactions on Starknet cost less than on Ethereum. Future updates like Volition and EIP 4844 will make it even cheaper."
msgstr ""

#: src/ch00-00-introduction.md:59
msgid "Developer-Friendly: Starknet lets developers easily build decentralized apps using its native language, Cairo."
msgstr ""

#: src/ch00-00-introduction.md:62
msgid "Speed and Efficiency: Upcoming releases aim to make transactions even faster and cheaper."
msgstr ""

#: src/ch00-00-introduction.md:65
msgid ""
"CVM: Thanks to Cairo, Starknet runs on it's own VM, called Cairo VM (CVM), that allow us to innovate beyond the Ethereum Virtual Machine (EVM) and create a new paradigm for decentralized applications."
msgstr ""

#: src/ch00-00-introduction.md:69
#, fuzzy
msgid "Here are some of them:"
msgstr "è¿™é‡Œæœ‰ä¸€äº›ä¾‹å­ï¼š"

#: src/ch00-00-introduction.md:71
msgid "Account Abstraction: Implemented at the protocol level, this facilitates diverse signing schemes while ensuring user security and self-custody of assets."
msgstr ""

#: src/ch00-00-introduction.md:75
msgid ""
"Volition: Will be implemented on testnet during Q4 2023 will allow developers to regulate data availability on Ethereum (L1) or on Starknet (L2). Reducing L1 onchain data can radically reduce costs."
msgstr ""

#: src/ch00-00-introduction.md:79
#, fuzzy
msgid ""
"Paymaster: Starknet will allow users to choose how to pay for transaction fee, follows the guidelines laid out in EIP 4337 and allows the transaction to specify a specific contract, a **Paymaster**, "
"to pay for their transaction. Supports gasless transactions, enhancing user accessibility."
msgstr ""
"- è´¦æˆ·æŠ½è±¡ï¼šåœ¨åè®®å±‚é¢å®æ–½\n"
"  åœ¨ç¡®ä¿ç”¨æˆ·å®‰å…¨å’Œèµ„äº§è‡ªæˆ‘ä¿ç®¡çš„åŒæ—¶ï¼Œä¸ºå„ç§ç­¾åæ–¹æ¡ˆæä¾›ä¾¿åˆ©ã€‚\n"
"\n"
"- Volitionï¼šå°†äº 2023 å¹´ç¬¬å››å­£åº¦åœ¨æµ‹è¯•ç½‘ä¸Šå®æ–½ï¼Œå°†å…è®¸\n"
"  å¼€å‘è€…ä¿®æ”¹ä»¥å¤ªåŠï¼ˆL1ï¼‰æˆ–Starknetï¼ˆL2ï¼‰ä¸Šçš„æ•°æ®å¯ç”¨æ€§ã€‚å‡å°‘ L1 çš„é“¾ä¸Šæ•°æ®å¯ä»¥ä»æ ¹æœ¬ä¸Šé™ä½æˆæœ¬ã€‚\n"
"\n"
"- Paymasterï¼šStarknet å°†å…è®¸ç”¨æˆ·é€‰æ‹©å¦‚ä½•æ”¯ä»˜\n"
"  äº¤æ˜“è´¹ï¼Œéµå¾ª EIP 4337 ä¸­è§„å®šçš„å‡†åˆ™ï¼Œå¹¶\n"
"  å…è®¸äº¤æ˜“æŒ‡å®šä¸€ä¸ªç‰¹å®šçš„åˆçº¦ï¼Œå³\n"
"  **Paymaster**ï¼Œä»¥æ”¯ä»˜äº¤æ˜“è´¹ç”¨ã€‚æ”¯æŒæ— gas\n"
"  äº¤æ˜“ï¼Œæé«˜ç”¨æˆ·çš„ä½¿ç”¨ä¾¿åˆ©æ€§ã€‚"

#: src/ch00-00-introduction.md:85
#, fuzzy
msgid "Cairo: The Language of Starknet"
msgstr "## Cairoï¼š Starknetçš„è¯­è¨€"

#: src/ch00-00-introduction.md:87
#, fuzzy
msgid ""
"Cairo is tailor-made for creating STARK-based smart contracts. As Starknetâ€™s native language, itâ€™s central to building scalable and secure decentralized apps. To start learning now, check out the "
"[Cairo Book](https://book.cairo-lang.org/) and [Starklings](https://github.com/shramee/starklings-cairo1)."
msgstr ""
"Cairoæ˜¯ä¸ºåˆ›å»ºåŸºäº STARK çš„æ™ºèƒ½åˆçº¦è€Œé‡èº«å®šåˆ¶çš„ã€‚ä½œä¸ºStarknetçš„æ¯è¯­ï¼Œå®ƒæ˜¯æ„å»ºå¯æ‰©å±•å’Œå®‰å…¨çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºçš„æ ¸å¿ƒã€‚ç°åœ¨å°±å¼€å§‹å­¦ä¹ å§ï¼Œè¯·æŸ¥çœ‹ [Cairo Book](https://cairo-book.github.io/) å’Œ  [Starklings]"
"(https://github.com/shramee/starklings-cairo1)ã€‚"

#: src/ch00-00-introduction.md:93
#, fuzzy
msgid "Inspired by Rust, Cairo lets you write contracts safely and conveniently."
msgstr "Cairoå—åˆ° Rust çš„å¯å‘ï¼Œ å¹¶å¯ä»¥è®©ä½ å®‰å…¨æ–¹ä¾¿åœ°ç¼–å†™åˆçº¦ã€‚"

#: src/ch00-00-introduction.md:96
#, fuzzy
msgid "Governance"
msgstr "## æ²»ç†"

#: src/ch00-00-introduction.md:98
#, fuzzy
msgid "The Starknet Foundation oversees Starknetâ€™s governance. Its duties include:"
msgstr "StarknetåŸºé‡‘ä¼šè´Ÿè´£ç›‘ç£Starknetçš„æ²»ç†ã€‚å…¶èŒè´£åŒ…æ‹¬ï¼š"

#: src/ch00-00-introduction.md:101
msgid "Managing Starknetâ€™s development and operations"
msgstr ""

#: src/ch00-00-introduction.md:103
msgid "Overseeing the Starknet DAO, which enables community involvement"
msgstr ""

#: src/ch00-00-introduction.md:105
msgid "Setting rules to maintain network integrity"
msgstr ""

#: src/ch00-00-introduction.md:107
#, fuzzy
msgid "Our focus is on technical input and debate for improving the protocol. While we value all perspectives, itâ€™s often the technical insights that steer us forward."
msgstr "æˆ‘ä»¬çš„å·¥ä½œé‡å¿ƒæ˜¯æŠ€æœ¯æŠ•å…¥å’Œæ”¹è¿›åè®®çš„è®¨è®ºã€‚è™½ç„¶æˆ‘ä»¬é‡è§†æ‰€æœ‰çš„è§‚ç‚¹ï¼Œä½†æŠ€æœ¯æ–¹é¢çš„è§è§£å¾€å¾€æ˜¯æˆ‘ä»¬å‰è¿›çš„æ–¹å‘ã€‚"

#: src/ch00-00-introduction.md:111
#, fuzzy
msgid ""
"Members can influence Starknet by voting on changes. Hereâ€™s the process: A new version is tested on the Goerli Testnet. Members then have six days to review it. A Snapshot proposal is made, and the "
"community votes. A majority of _YES_ votes means an upgrade to the Mainnet."
msgstr ""
"æˆå‘˜å¯ä»¥é€šè¿‡æŠ•ç¥¨æ¥å½±å“Starknetçš„å˜åŒ–ã€‚å…·ä½“è¿‡ç¨‹å¦‚ä¸‹ï¼šæ–°ç‰ˆæœ¬åœ¨ Goerli æµ‹è¯•ç½‘ä¸Šè¿›è¡Œæµ‹è¯•ã€‚ç„¶åï¼Œæˆå‘˜æœ‰å…­å¤©çš„æ—¶é—´å¯¹å…¶è¿›è¡Œå®¡æŸ¥ã€‚Starknetä¼šæå‡ºä¸€ä¸ªå¿«ç…§å»ºè®®ï¼Œç„¶åç¤¾åŒºä¼šè¿›è¡ŒæŠ•ç¥¨ã€‚å¤šæ•°æŠ• _èµæˆ_ åˆ™è¡¨ç¤ºç€è¯¥å‡çº§å°†"
"ä¼šåº”ç”¨åˆ°ä¸»ç½‘ã€‚"

#: src/ch00-00-introduction.md:116
msgid "In short, governance is key to Starknetâ€™s evolution."
msgstr "æ€»ä¹‹ï¼Œæ²»ç†æ˜¯Starknetå‘å±•çš„å…³é”®ã€‚"

#: src/ch00-00-introduction.md:118
msgid "To propose an improvement, create a SNIP."
msgstr "è¦æå‡ºæ”¹è¿›å»ºè®®ï¼Œè¯·åˆ›å»ºä¸€ä¸ª SNIPã€‚"

#: src/ch00-00-introduction.md:120
#, fuzzy
msgid "SNIP: Starknet Improvement Proposals"
msgstr "### SNIPï¼šStarknetæ”¹è¿›ææ¡ˆ"

#: src/ch00-00-introduction.md:122
#, fuzzy
msgid ""
"SNIP is short for Starknet Improvement Proposal. Itâ€™s essentially a blueprint that details proposed enhancements or changes to the Starknet ecosystem. A well-crafted SNIP includes both the technical "
"specifications of the change and the reasons behind it. If youâ€™re proposing a SNIP, itâ€™s your job to rally community support and document any objections (more details [here](https://community.starknet."
"io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)). Once a SNIP is approved, it becomes a part of the Starknet protocol. All the SNIPs can be found in [this repository](https://"
"github.com/starknet-io/SNIPs)."
msgstr ""
"SNIP æ˜¯ Starknet æ”¹è¿›ææ¡ˆçš„ç®€ç§°ã€‚å®ƒæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªè“å›¾ï¼Œè¯¦ç»†æè¿°äº†å¯¹ Starknet ç”Ÿæ€ç³»ç»Ÿæå‡ºçš„æ”¹è¿›æˆ–å˜æ›´å»ºè®®ã€‚ä¸€ä»½æ’°å†™è‰¯å¥½çš„ SNIP æ—¢åº”åŒ…æ‹¬å˜æ›´çš„æŠ€æœ¯è§„èŒƒï¼Œä¹Ÿåº”åŒ…æ‹¬å˜æ›´èƒŒåçš„åŸå› ã€‚å¦‚æœæ‚¨è¦æå‡º SNIPï¼Œæ‚¨çš„å·¥ä½œ"
"å°±æ˜¯äº‰å–ç¤¾åŒºçš„æ”¯æŒå¹¶è®°å½•ä»»ä½•åå¯¹æ„è§ï¼ˆæ›´å¤šè¯¦æƒ…è§ [æ­¤å¤„](https://community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-a-snip-2)ï¼‰ã€‚ä¸€æ—¦ SNIP è·å¾—æ‰¹å‡†ï¼Œå®ƒå°†æˆä¸ºStarknetåè®®çš„ä¸€éƒ¨"
"åˆ†ã€‚æ‰€æœ‰çš„ SNIP éƒ½å¯ä»¥åœ¨ [è¿™ä¸ªä»“åº“](https://github.com/starknet-io/SNIPs) ä¸­æ‰¾åˆ°ã€‚"

#: src/ch00-00-introduction.md:133
msgid "SNIPs serve three crucial roles:"
msgstr "SNIP æœ‰ä¸‰ä¸ªé‡è¦ä½œç”¨ï¼š"

#: src/ch00-00-introduction.md:135
msgid "They are the main avenue for proposing new features or changes."
msgstr ""

#: src/ch00-00-introduction.md:137
msgid "They act as a platform for technical discussions within the community."
msgstr ""

#: src/ch00-00-introduction.md:140
msgid "They document the decision-making process, offering a historical view of how Starknet has evolved."
msgstr ""

#: src/ch00-00-introduction.md:143
#, fuzzy
msgid ""
"Because SNIPs are stored as text files in a [version-controlled repository](https://github.com/starknet-io/SNIPs/tree/main/SNIPS), you can easily track changes and understand the history of proposals."
msgstr "ç”±äº SNIP ä»¥æ–‡æœ¬æ–‡ä»¶çš„å½¢å¼å­˜å‚¨åœ¨[ç‰ˆæœ¬æ§åˆ¶ä»“åº“](https://github.com/starknet-io/SNIPs)ä¸­ï¼Œå› æ­¤æ‚¨å¯ä»¥è½»æ¾åœ°è·Ÿè¸ªæ›´æ”¹å¹¶äº†è§£ææ¡ˆçš„å†å²ã€‚"

#: src/ch00-00-introduction.md:147
#, fuzzy
msgid ""
"For those who are building on Starknet, SNIPs arenâ€™t just suggestionsâ€”theyâ€™re a roadmap. Itâ€™s beneficial for implementers to keep a list of the SNIPs theyâ€™ve executed. This transparency helps users "
"gauge the state of a particular implementation or software library."
msgstr ""
"å¯¹äºåœ¨ Starknet ä¸Šè¿›è¡Œå¼€å‘çš„äººå‘˜æ¥è¯´ï¼ŒSNIP ä¸ä»…ä»…æ˜¯ææ¡ˆï¼Œæ›´æ˜¯è·¯çº¿å›¾ã€‚å¯¹äºå®é™…çš„ææ¡ˆå®ç°è€…æ¥è¯´ï¼Œä¿å­˜ä¸€ä»½ä»–ä»¬å·²ç»å®ç°äº†çš„ SNIP çš„æ¸…å•æ˜¯éå¸¸æœ‰ç›Šçš„ã€‚è¿™ç§é€æ˜æ€§æœ‰åŠ©äºç”¨æˆ·è¡¡é‡ç‰¹å®šçš„å®ç°æˆ–è½¯ä»¶åº“çš„çŠ¶å†µã€‚"

#: src/ch01-00-getting-started.md:3
msgid ""
"Starknet is a scalable layer 2 solution on Ethereum. This guide will walk you through the process of deploying and interacting with your first Starknet smart contract using the Cairo programming "
"language, a general-purpose programming language for creating proofs of validity using Starknet. For experienced developers looking to understand the basics and gain hands-on experience, this guide "
"provides step-by-step instructions and essential details."
msgstr ""
"Starknet æ˜¯ä»¥å¤ªåŠä¸Šå¯æ‰©å±•çš„ç¬¬ 2 å±‚è§£å†³æ–¹æ¡ˆã€‚æœ¬æŒ‡å—å°†æ•™ä½ éƒ¨ç½²ä¸€ä¸ªCairo è¯­è¨€ç¼–å†™çš„ Starknet æ™ºèƒ½åˆçº¦å¹¶ä¸ä¹‹äº¤äº’ï¼ŒCairo æ˜¯ä¸“ä¸ºåˆ›å»ºæœ‰æ•ˆæ€§è¯æ˜è€Œå®šåˆ¶çš„è¯­è¨€ï¼ŒStarknet ä¹Ÿä½¿ç”¨è¿™ç§è¯­è¨€ã€‚é’ˆå¯¹é‚£äº›å¸Œæœ›äº†è§£åŸºç¡€å¹¶å®è·µ"
"çš„æœ‰ç»éªŒå¼€å‘è€…ï¼Œæœ¬æŒ‡å—æä¾›äº†åˆ†æ­¥æŒ‡å¯¼å’Œå¿…è¦çš„ä¿¡æ¯ã€‚"

#: src/ch01-00-getting-started.md:5
msgid ""
"We will use the [Starknet Remix Plugin](https://github.com/NethermindEth/starknet-remix-plugin?tab=readme-ov-file) to compile, deploy, and interact with our smart contract. It's a great tool for "
"getting started with Starknet development because you don't need to install anything on your computer."
msgstr "æˆ‘ä»¬å°†ä½¿ç”¨ [Starknet Remix Plugin](https://github.com/NethermindEth/starknet-remix-plugin?tab=readme-ov-file)  æ¥ç¼–è¯‘ã€éƒ¨ç½²æ™ºèƒ½åˆçº¦å¹¶ä¸ä¹‹äº¤äº’ã€‚å®ƒæ˜¯å…¥é—¨ Starknet å¼€å‘çš„ç»ä½³å·¥å…·ã€‚"

#: src/ch01-00-getting-started.md:7
msgid ""
"Visit the [Remix IDE](https://remix.ethereum.org/#activate=Starknet&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.24+commit.e11b9ed9.js) website with the Starknet plugin enabled."
msgstr "è®¿é—® [Remix IDE](https://remix.ethereum.org/#activate=Starknet&lang=en&optimize=false&runs=200&evmVersion=null&version=soljson-v0.8.24+commit.e11b9ed9.js)  ç½‘ç«™å¹¶å¯ç”¨ Starknet æ’ä»¶ã€‚"

#: src/ch01-00-getting-started.md:11
msgid "Then go to **settings** option and choose the Cairo version as shown in the image below. The latest version available in Remix is `v2.5.4`."
msgstr "ç„¶åè¿›å…¥ **settings**  é€‰é¡¹ï¼Œé€‰æ‹© Cairo ç‰ˆæœ¬ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒRemix çš„æœ€æ–°ç‰ˆæœ¬æ˜¯ `v2.5.4` ã€‚"

#: src/ch01-00-getting-started.md:15
msgid ""
"Now click on the `file explorer` tab to check the sample project details. On the `Scarb.toml` file you can find the version of this sample project. Since we want to use version 2.5.4 for this project, "
"we have to verify that it matches in our `Scarb.toml`, otherwise modify to the correct version, `starknet = \"2.5.4\"`."
msgstr ""
"ç‚¹å‡» `file explorer` æ ‡ç­¾æŸ¥çœ‹é¡¹ç›®ç›®å½•ï¼Œåœ¨ `Scarb.toml` æ–‡ä»¶ä¸­æœ‰ Cairo ç‰ˆæœ¬ä¿¡æ¯ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„ Cairo ç‰ˆæœ¬æ˜¯ 2.5.4ï¼Œæ‰€ä»¥è¦ç¡®è®¤  `Scarb.toml` æ–‡ä»¶ä¸­æœ‰ `starknet = â€œ2.5.4â€` è¿™ä¸€è¡Œï¼Œå¦‚æœä¸å¯¹è¯·ä¿®æ”¹ã€‚"

#: src/ch01-00-getting-started.md:19
msgid "Clean your sample project"
msgstr ""

#: src/ch01-00-getting-started.md:21
msgid "By default we got a sample project, however on this tutorial, we plan to show the `Ownable contract` example. To acomplish this we have to edit and delete some files and directories."
msgstr ""

#: src/ch01-00-getting-started.md:23
msgid "Rename the root directory to `ownable`. Go to your `Scarb.toml`, on \\[package\\] section, set `name` to `ownable`."
msgstr ""

#: src/ch01-00-getting-started.md:24
msgid "Delete `balance.cairo` and `forty_two.cairo` files, if present."
msgstr ""

#: src/ch01-00-getting-started.md:25
#, fuzzy
msgid "Go to `lib.cairo` and remove all the content there. It should be empty."
msgstr "ç°åœ¨ç¼–è¾‘ `src/lib.cairo`ï¼Œå°†å†…å®¹æ›¿æ¢ä¸º"

#: src/ch01-00-getting-started.md:27
#, fuzzy
msgid "At the end, your new project should look something like this."
msgstr "ç„¶åï¼Œä½ åº”è¯¥ä¼šçœ‹åˆ°ç±»ä¼¼è¿™æ ·çš„å†…å®¹ï¼š"

#: src/ch01-00-getting-started.md:31
#, fuzzy
msgid "Introduction to Starknet Smart Contracts"
msgstr "## Starknetæ™ºèƒ½åˆçº¦ç®€ä»‹"

#: src/ch01-00-getting-started.md:33
msgid "The script below is a simple `Ownable` contract pattern written in Cairo for Starknet. It features:"
msgstr "ä¸‹é¢çš„è„šæœ¬æ˜¯ç”¨Cairoè¯­è¨€ä¸ºStarknetç¼–å†™çš„ä¸€ä¸ªç®€å•çš„ `Ownable` åˆçº¦æ¨¡å¼ã€‚å®ƒçš„ç‰¹ç‚¹æ˜¯ï¼š"

#: src/ch01-00-getting-started.md:35
msgid "An ownership system."
msgstr ""

#: src/ch01-00-getting-started.md:36
msgid "A method to transfer ownership."
msgstr ""

#: src/ch01-00-getting-started.md:37
msgid "A method to check the current owner."
msgstr ""

#: src/ch01-00-getting-started.md:38
msgid "An event notification for ownership changes."
msgstr ""

#: src/ch01-00-getting-started.md:40
#, fuzzy
msgid "Cairo Example Contract"
msgstr "## ç¤ºä¾‹ï¼šæµ‹è¯• ERC20 åˆçº¦"

#: src/ch01-00-getting-started.md:107
#, fuzzy
msgid "Components Breakdown"
msgstr "### ç»„ä»¶ç»†åˆ†"

#: src/ch01-00-getting-started.md:109
msgid ""
"The following is a brief description of the components in the contract. We will get into more details when we get deeper into Cairo so feel free to skip this section for now if you are not familiar "
"with smart contract development."
msgstr "ä¸‹é¢å°†ç®€è¦ä»‹ç»åˆçº¦ä¸­çš„ç»„ä»¶ã€‚æˆ‘ä»¬å°†åœ¨æ·±å…¥äº†è§£Cairoåä»‹ç»æ›´å¤šç»†èŠ‚ï¼Œæ‰€ä»¥å¦‚æœä½ ä¸ç†Ÿæ‚‰æ™ºèƒ½åˆçº¦å¼€å‘ï¼Œå¯ä»¥æš‚æ—¶è·³è¿‡è¿™ä¸€éƒ¨åˆ†ã€‚"

#: src/ch01-00-getting-started.md:111
msgid "**Dependencies and Interface**:"
msgstr ""

#: src/ch01-00-getting-started.md:112
msgid "**`starknet::ContractAddress`**: Represents a Starknet contract address."
msgstr ""

#: src/ch01-00-getting-started.md:113
msgid "**`OwnableTrait`**: Specifies functions for transferring and getting ownership."
msgstr ""

#: src/ch01-00-getting-started.md:114
msgid "**Events**:"
msgstr ""

#: src/ch01-00-getting-started.md:115
msgid "**`OwnershipTransferred`**: Indicates ownership change with previous and new owner details."
msgstr ""

#: src/ch01-00-getting-started.md:116
#, fuzzy
msgid "**Storage**:"
msgstr "**å­˜å‚¨**:"

#: src/ch01-00-getting-started.md:117
msgid "**`Storage`**: Holds the contract's state with the current owner's address."
msgstr ""

#: src/ch01-00-getting-started.md:118
#, fuzzy
msgid "**Constructor**:"
msgstr "**æ„é€ å‡½æ•°**ï¼š"

#: src/ch01-00-getting-started.md:119
msgid "Initializes the contract with a starting owner."
msgstr ""

#: src/ch01-00-getting-started.md:120
#, fuzzy
msgid "**External Functions**:"
msgstr "**å¤–éƒ¨å‡½æ•°**ï¼š"

#: src/ch01-00-getting-started.md:121
msgid "Functions for transferring ownership and retrieving the current owner's details."
msgstr ""

#: src/ch01-00-getting-started.md:122
msgid "**Private Methods**:"
msgstr ""

#: src/ch01-00-getting-started.md:123
msgid "**`only_owner`**: Validates if the caller is the current owner."
msgstr ""

#: src/ch01-00-getting-started.md:125
#, fuzzy
msgid "Compilation Process"
msgstr "## ç¼–è¯‘è¿‡ç¨‹"

#: src/ch01-00-getting-started.md:127
msgid "To compile using Remix:"
msgstr "æˆ‘ä»¬å°†ä½¿ç”¨ Remix è¿›è¡Œç¼–è¯‘ï¼š"

#: src/ch01-00-getting-started.md:129
msgid "**File Creation**"
msgstr ""

#: src/ch01-00-getting-started.md:131
msgid "Navigate to the \"File Explorer\" tab in Remix."
msgstr ""

#: src/ch01-00-getting-started.md:132
msgid "Go to file named `lib.cairo` and paste the previous [code](#cairo-example-contract) into it."
msgstr ""

#: src/ch01-00-getting-started.md:134
#, fuzzy
msgid "**Compilation**"
msgstr "Cairo æ˜¯ç”± Starkware å‘æ˜çš„ä¸€ç§å¼€æºç¼–ç¨‹è¯­è¨€ã€‚å®ƒæ˜¯ä¸€ç§å›¾çµå®Œå¤‡çš„è¯­è¨€ï¼Œç”¨äºé€šç”¨è®¡ç®—ã€‚å®ƒæ˜¯ä¸€ç§ä½çº§è¯­è¨€ï¼Œæ—¨åœ¨ç¼–è¯‘åˆ°Cairoè™šæ‹Ÿæœºã€‚ç‚¹å‡»æ­¤å¤„äº†è§£æ›´å¤šä¿¡æ¯ï¼š[Cairo](.../theory/cairo.md)ã€‚"

#: src/ch01-00-getting-started.md:136
msgid "Navigate to the \"Starknet\" tab in Remix and click on `Home`."
msgstr ""

#: src/ch01-00-getting-started.md:137
msgid "In the `1 Compile` section choose `compile a single file`."
msgstr ""

#: src/ch01-00-getting-started.md:141
msgid "Accept the permissions. Click `Remember my choice` to avoid this step in the future."
msgstr ""

#: src/ch01-00-getting-started.md:145
msgid "Click on `Compile lib.cairo`."
msgstr ""

#: src/ch01-00-getting-started.md:149
#, fuzzy
msgid ""
"Post-compilation, an \"artifacts\" folder emerges containing the compiled contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet deployment, Remix will use the Sierra file. Do not "
"worry about this process for now; we will cover it in detail in a later chapter. For now, Remix will handle the compilation and deployment for us."
msgstr ""
"1. **æ–‡ä»¶åˆ›å»º**\n"
"\n"
"   - è¿›å…¥ Remix çš„ \"File Explorer\" é€‰é¡¹å¡ã€‚\n"
"   - åˆ›å»ºä¸€ä¸ªåä¸º `Ownable.cairo` çš„æ–°æ–‡ä»¶ï¼Œå¹¶è¾“å…¥ä¹‹å‰çš„ä»£ç ã€‚\n"
"\n"
"2. **ç¼–è¯‘**\n"
"\n"
"   - é€‰æ‹© `Ownable.cairo` æ–‡ä»¶ã€‚\n"
"   - åœ¨ \"Starknet \"é€‰é¡¹å¡ä¸­ï¼Œé€‰æ‹© \"Compile Ownable.cairo\"ã€‚\n"
"   - ç¼–è¯‘åï¼Œä¼šå‡ºç°ä¸€ä¸ª\"artifacts\"æ–‡ä»¶å¤¹ï¼Œå…¶ä¸­åŒ…å«ä¸¤ç§ä¸åŒæ ¼å¼çš„ç¼–è¯‘åˆçº¦ï¼šSierraï¼ˆJSON æ–‡ä»¶ï¼‰å’Œ CASMã€‚å¯¹äºStarknetéƒ¨ç½²ï¼ŒRemix å°†ä½¿ç”¨ Sierra æ–‡ä»¶ã€‚ç°åœ¨ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­è¯¦ç»†ä»‹ç»ã€‚"
"ç°åœ¨ï¼ŒRemix å°†ä¸ºæˆ‘ä»¬å¤„ç†ç¼–è¯‘å’Œéƒ¨ç½²å·¥ä½œã€‚"

#: src/ch01-00-getting-started.md:153
#, fuzzy
msgid "Artifacts folder after compilation"
msgstr "<span class=\"caption\">Artifacts folder after compilation</span>"

#: src/ch01-00-getting-started.md:155
#, fuzzy
msgid "Deployment on the Development Network"
msgstr "## åœ¨å¼€å‘ç½‘ç»œä¸Šéƒ¨ç½²"

#: src/ch01-00-getting-started.md:157
msgid "To set your smart contract in motion, an initial owner must be defined. The Constructor function needs this information."
msgstr "è¦å¯åŠ¨æ™ºèƒ½åˆçº¦ï¼Œå¿…é¡»å®šä¹‰åˆå§‹æ‰€æœ‰è€…ã€‚æ„é€ å‡½æ•°éœ€è¦è¿™äº›ä¿¡æ¯ã€‚"

#: src/ch01-00-getting-started.md:159
msgid "Here's a step-by-step guide to deploying your smart contract on the development network:"
msgstr "ä»¥ä¸‹æ˜¯åœ¨å¼€å‘ç½‘ç»œä¸Šéƒ¨ç½²æ™ºèƒ½åˆçº¦çš„åˆ†æ­¥æŒ‡å—ï¼š"

#: src/ch01-00-getting-started.md:161
msgid "**Select the Appropriate Network**"
msgstr ""

#: src/ch01-00-getting-started.md:163
msgid "In the Starknet tab, click on the top button `Remote Devnet`."
msgstr ""

#: src/ch01-00-getting-started.md:167
msgid "**Choose a Devnet Account**"
msgstr ""

#: src/ch01-00-getting-started.md:169
msgid "Under \"Devnet account selection\", a list of accounts specific to the chosen devnet is presented."
msgstr ""

#: src/ch01-00-getting-started.md:173
msgid "Pick any account and copy its address."
msgstr ""

#: src/ch01-00-getting-started.md:175
msgid "**Declare**"
msgstr ""

#: src/ch01-00-getting-started.md:177
msgid "Click on \"Declare lib.cairo\""
msgstr ""

#: src/ch01-00-getting-started.md:181
#, fuzzy
msgid "Post-declared, Remix's terminal will send various logs. These logs provide crucial details, including:"
msgstr "éƒ¨ç½²åï¼ŒRemix çš„ç»ˆç«¯å°†æ‰“å°å‡ºå„ç§æ—¥å¿—ã€‚è¿™äº›æ—¥å¿—æä¾›äº†é‡è¦çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š"

#: src/ch01-00-getting-started.md:182 src/ch01-00-getting-started.md:205
msgid "`transaction_hash`: The unique hash of the transaction. This hash can be used to track the transaction's status."
msgstr ""

#: src/ch01-00-getting-started.md:183
msgid "`class_hash`: The class hash is like the id of the definition of the smart contract."
msgstr ""

#: src/ch01-00-getting-started.md:188 src/ch01-00-getting-started.md:211
#, fuzzy
msgid "\"transaction_hash\""
msgstr "äº¤æ˜“"

#: src/ch01-00-getting-started.md:188
msgid "\"0x36dabf43f4962c97cf67ba132fb520091f268e7e33477d77d01747eeb0d7b43\""
msgstr ""

#: src/ch01-00-getting-started.md:189 src/ch02-05-testnet-deployment.md:274 src/ch04-03-01-deploy-standard-account.md:100 src/ch04-03-01-deploy-standard-account.md:148
msgid "\"class_hash\""
msgstr ""

#: src/ch01-00-getting-started.md:189
msgid "\"0x540779cd109ad20f46cb36d8de1ce30c75469862b4dc75f2f29d1b4d1454f60\""
msgstr ""

#: src/ch01-00-getting-started.md:195
#, fuzzy
msgid "**Initiating Deployment**"
msgstr "æµ‹è¯•ç½‘éƒ¨ç½²"

#: src/ch01-00-getting-started.md:197
msgid "Input the copied address into the `init_owner` variable."
msgstr ""

#: src/ch01-00-getting-started.md:201
msgid "Click on **\"Deploy\"**."
msgstr ""

#: src/ch01-00-getting-started.md:203
msgid "Post-deployment, Remix's terminal will send various logs. These logs provide crucial details, including:"
msgstr "éƒ¨ç½²åï¼ŒRemix çš„ç»ˆç«¯å°†æ‰“å°å‡ºå„ç§æ—¥å¿—ã€‚è¿™äº›æ—¥å¿—æä¾›äº†é‡è¦çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼š"

#: src/ch01-00-getting-started.md:206
msgid "`contract_address`: The address of the deployed contract. Use this address to interact with your contract."
msgstr ""

#: src/ch01-00-getting-started.md:207
msgid "`data`: Contains the `init_owner` address fed to the constructor."
msgstr ""

#: src/ch01-00-getting-started.md:211
msgid "\"0x624f5b9f57e53f6b5b62e588f0f949442172b3ad5d04f0827928b4d12c2fa58\""
msgstr ""

#: src/ch01-00-getting-started.md:212
msgid "\"contract_address\""
msgstr ""

#: src/ch01-00-getting-started.md:213
msgid "\"0x699952dc736661d0ed573cd2b0956c80a1602169e034fdaa3515bfbc36d6410\""
msgstr ""

#: src/ch01-00-getting-started.md:216
msgid "\"data\""
msgstr ""

#: src/ch01-00-getting-started.md:217 src/ch01-00-getting-started.md:247
msgid "\"0x6b0ee6f418e47408cf56c6f98261c1c5693276943be12db9597b933d363df\""
msgstr ""

#: src/ch01-00-getting-started.md:224
#, fuzzy
msgid "By following the above process, you will successfully deploy your smart contract on the development network."
msgstr "æŒ‰ç…§ä¸Šè¿°æµç¨‹æ“ä½œï¼Œæ‚¨å°±æˆåŠŸåœ°åœ¨å¼€å‘ç½‘ç»œä¸Šéƒ¨ç½²äº†æ™ºèƒ½åˆçº¦ã€‚"

#: src/ch01-00-getting-started.md:226
#, fuzzy
msgid "Interaction with the Contract"
msgstr "## ä¸åˆçº¦çš„äº¤äº’"

#: src/ch01-00-getting-started.md:228
msgid "With the contract now active on the development network, interaction becomes possible. Here's a guide to effectively interact with your contract on Starknet:"
msgstr "ç°åœ¨ï¼Œåˆçº¦å·²åœ¨å¼€å‘ç½‘ç»œä¸Šæ¿€æ´»ï¼Œä¸ä¹‹äº¤äº’æˆä¸ºå¯èƒ½ã€‚ä»¥ä¸‹æ˜¯åœ¨Starknetä¸åˆçº¦æœ‰æ•ˆäº¤äº’çš„æŒ‡å—ï¼š"

#: src/ch01-00-getting-started.md:230
#, fuzzy
msgid "**Initiating Interaction**"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch01-00-getting-started.md:232
msgid "Navigate to the \"Starknet\" plugin tab."
msgstr ""

#: src/ch01-00-getting-started.md:233
msgid "Select the \"Interact\" option."
msgstr ""

#: src/ch01-00-getting-started.md:235
#, fuzzy
msgid "**Calling the `get_owner` Function**"
msgstr "3. **è°ƒç”¨ `transfer_ownership` å‡½æ•°**"

#: src/ch01-00-getting-started.md:237
msgid "Choose the `get_owner` function. Since this function doesn't require arguments, the calldata field remains blank. (This is a read function, hence calling it is termed as a \"call\".)"
msgstr ""

#: src/ch01-00-getting-started.md:241
msgid "Press the **\"Call\"** button. Your terminal will display the result, revealing the owner's address provided during the contract's deployment as calldata for the constructor:"
msgstr ""

#: src/ch01-00-getting-started.md:245 src/ch01-00-getting-started.md:271
msgid "\"resp\""
msgstr ""

#: src/ch01-00-getting-started.md:246 src/ch01-00-getting-started.md:272 src/ch03-02-01-madara.md:353
#, fuzzy
msgid "\"result\""
msgstr "ç»“æœæ˜¯ï¼š"

#: src/ch01-00-getting-started.md:250 src/ch01-00-getting-started.md:276
#, fuzzy
msgid "\"contract\""
msgstr "## åˆçº¦"

#: src/ch01-00-getting-started.md:250 src/ch01-00-getting-started.md:276
msgid "\"lib.cairo\""
msgstr ""

#: src/ch01-00-getting-started.md:251 src/ch01-00-getting-started.md:277
msgid "\"function\""
msgstr ""

#: src/ch01-00-getting-started.md:251 src/ch01-00-getting-started.md:277
msgid "\"get_owner\""
msgstr ""

#: src/ch01-00-getting-started.md:255
msgid "This call currently doesn't spend gas because the function does not change the state of the contract."
msgstr "ç”±äºè¯¥å‡½æ•°ä¸ä¼šæ”¹å˜åˆçº¦çš„çŠ¶æ€ï¼Œå› æ­¤è¯¥è°ƒç”¨ç›®å‰ä¸ä¼šæ¶ˆè€—gasã€‚"

#: src/ch01-00-getting-started.md:257
#, fuzzy
msgid "**Invoking the `transfer_ownership` Function**"
msgstr "3. **è°ƒç”¨ `transfer_ownership` å‡½æ•°**"

#: src/ch01-00-getting-started.md:259
msgid "Choose the **\"Write\"** in the interaction area. Here you can see the functions that alter the contract's state."
msgstr ""

#: src/ch01-00-getting-started.md:263
msgid "In this case **`transfer_ownership`** function, which requires the new owner's address as input."
msgstr ""

#: src/ch01-00-getting-started.md:264
msgid "Enter this address into the `new_owner` field. (For this, use any address from the \"Devnet account selection\" listed in the Environment tab.)"
msgstr ""

#: src/ch01-00-getting-started.md:265
#, fuzzy
msgid ""
"Click the **\"Call\"** button. The terminal then showcases the transaction hash indicating the contract's state alteration. Since we are altering the contract's state this type of interaction is "
"called an \"invoke\" and needs to be signed by the account that is calling the function."
msgstr ""
"- ç°åœ¨ï¼Œ**`transfer_ownership`** å‡½æ•°éœ€è¦è¾“å…¥æ–°æ‰€æœ‰è€…çš„åœ°å€ã€‚\n"
"- åœ¨ calldata å­—æ®µä¸­è¾“å…¥è¯¥åœ°å€ã€‚(ä¸ºæ­¤ï¼Œè¯·ä½¿ç”¨ç¯å¢ƒé€‰é¡¹å¡ä¸­åˆ—å‡ºçš„ \"Devnet account selection\"ä¸­çš„ä»»ä½•åœ°å€ï¼‰ã€‚\n"
"- ç‚¹å‡» \"transfer_ownershipï¼ˆè½¬è®©æ‰€æœ‰æƒï¼‰\"æŒ‰é’®ã€‚ç„¶åï¼Œç»ˆç«¯ä¼šæ˜¾ç¤ºäº¤æ˜“å“ˆå¸Œå€¼ï¼Œè¡¨æ˜åˆçº¦çš„çŠ¶æ€å·²æ›´æ”¹ã€‚ç”±äºæˆ‘ä»¬æ­£åœ¨æ”¹å˜åˆçº¦çš„çŠ¶æ€ï¼Œå› æ­¤è¿™ç§ä¸åŒäºâ€œcallâ€çš„äº¤äº’ç§°ä¸º \"invoke\"ï¼Œéœ€è¦ç”±è°ƒç”¨å‡½æ•°çš„è´¦æˆ·ç­¾åã€‚"

#: src/ch01-00-getting-started.md:267
#, fuzzy
msgid ""
"For these transactions, the terminal logs will exhibit a \"status\" variable, indicating the transaction's fate. If the status is \"ACCEPTED_ON_L2\", it means the Sequencer, the component that "
"receives and processes transactions, has accepted the transaction, which is now awaiting inclusion in an upcoming block. However, a \"REJECTED\" status signifies the Sequencer's disapproval, and the "
"transaction won't feature in the upcoming block. More often than not, this transaction gains acceptance, leading to a contract state modification. See [this chapter](https://book.starknet.io/ch03-00-"
"architecture.html) for more on Starknet's architecture and the Sequencer. On calling the **`get_owner`** function again we get this:"
msgstr ""
"å¯¹äºè¿™äº›äº¤æ˜“ï¼Œç»ˆç«¯æ—¥å¿—å°†æ˜¾ç¤ºä¸€ä¸ª\"status\"  å˜é‡ï¼Œè¡¨æ˜è¯¥äº¤æ˜“çš„å‘½è¿ã€‚å¦‚æœçŠ¶æ€æ˜¾ç¤ºä¸º \"ACCEPTED_ON_L2\"ï¼Œåˆ™è¡¨ç¤ºæ’åºå™¨å·²æ¥å—è¯¥äº¤æ˜“ï¼Œç­‰å¾…å°†å…¶åŠ å…¥åŒºå—ã€‚ä½†æ˜¯ï¼Œå¦‚æœçŠ¶æ€ä¸º \"REJECTED\"ï¼Œåˆ™è¡¨ç¤ºæ’åºå™¨ä¸æ¥å—è¯¥äº¤"
"æ˜“ï¼Œè¯¥äº¤æ˜“å°†ä¸ä¼šå‡ºç°åœ¨å³å°†åˆ°æ¥çš„åŒºå—ä¸­ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¯¥äº¤æ˜“ä¼šè¢«æ¥å—ï¼Œä»è€Œå¯¼è‡´åˆçº¦çŠ¶æ€ä¿®æ”¹ã€‚å†æ¬¡è°ƒç”¨**`get_owner`**å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä»¥ä¸‹ç»“æœï¼š"

#: src/ch01-00-getting-started.md:273
msgid "\"0x5495d56633745aa3b97bdb89c255d522e98fd2cb481974efe898560839aa472\""
msgstr ""

#: src/ch01-00-getting-started.md:281
msgid "You've now adeptly compiled, deployed, and interacted with your inaugural Starknet smart contract. Well done!"
msgstr "æ‚¨ç°åœ¨å·²ç»èƒ½ç†Ÿç»ƒåœ°ç¼–è¯‘ã€éƒ¨ç½²å¹¶ä¸æ‚¨çš„é¦–ä»½Starknetæ™ºèƒ½åˆçº¦è¿›è¡Œäº¤äº’äº†ã€‚å¹²å¾—ä¸é”™ï¼"

#: src/ch01-00-getting-started.md:283
#, fuzzy
msgid "Deploying on Starknet Testnet"
msgstr "## åœ¨Starknetæµ‹è¯•ç½‘ä¸Šéƒ¨ç½²"

#: src/ch01-00-getting-started.md:285
msgid ""
"After testing your smart contract on a development network, it's time to deploy it to the Starknet Testnet. Starknet Testnet is a public platform available for everyone, ideal for testing smart "
"contracts and collaborating with fellow developers."
msgstr "åœ¨å¼€å‘ç½‘ç»œä¸Šæµ‹è¯•å®Œæ™ºèƒ½åˆçº¦åï¼Œå°±å¯ä»¥å°†å…¶éƒ¨ç½²åˆ°Starknetæµ‹è¯•ç½‘ç»œä¸Šäº†ã€‚Starknet æµ‹è¯•ç½‘ç»œæ˜¯ä¸€ä¸ªé¢å‘æ‰€æœ‰äººçš„å…¬å…±å¹³å°ï¼Œæ˜¯æµ‹è¯•æ™ºèƒ½åˆçº¦å’Œä¸å…¶ä»–å¼€å‘è€…åˆä½œçš„ç†æƒ³å¹³å°ã€‚"

#: src/ch01-00-getting-started.md:287
#, fuzzy
msgid "First, you need to create a Starknet account."
msgstr "é¦–å…ˆï¼Œæ‚¨éœ€è¦åˆ›å»ºä¸€ä¸ªStarknetè´¦æˆ·ã€‚"

#: src/ch01-00-getting-started.md:289 src/ch02-05-testnet-deployment.md:12
#, fuzzy
msgid "Smart Wallet Setup"
msgstr "## æ™ºèƒ½é’±åŒ…è®¾ç½®"

#: src/ch01-00-getting-started.md:291
msgid ""
"Before deploying your smart contract to Starknet, you must handle the transaction cost. While deploying to the Starknet Goerli Testnet is free, a smart wallet account is essential. You can set up a "
"smart wallet using either:"
msgstr "åœ¨å°†æ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°Starknetä¹‹å‰ï¼Œæ‚¨å¿…é¡»å¤„ç†å¥½äº¤æ˜“æˆæœ¬ç›¸å…³çš„é—®é¢˜ã€‚è™½ç„¶éƒ¨ç½²åˆ°Starknet Goerli Testnet æ˜¯å…è´¹çš„ï¼Œä½†æ™ºèƒ½é’±åŒ…è´¦æˆ·å´æ˜¯å¿…ä¸å¯å°‘çš„ã€‚ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¸¤ç§æ–¹æ³•ä¹‹ä¸€å»ºç«‹æ™ºèƒ½é’±åŒ…ï¼š"

#: src/ch01-00-getting-started.md:293
#, fuzzy
msgid "[Argent](https://www.argent.xyz/argent-x/)"
msgstr ""
"- [Braavos](https://braavos.app/)\n"
"- [Argent](https://www.argent.xyz/argent-x/)"

#: src/ch01-00-getting-started.md:294
msgid "[Braavos](https://braavos.app/)"
msgstr ""

#: src/ch01-00-getting-started.md:296
msgid ""
"Both are reliable Starknet wallets offering enhanced security and accessibility features thanks to the possibilities that the Cairo VM brings, such as Account Abstraction (keep reading the Book for "
"more on this)."
msgstr "ä¸¤è€…çš†æ˜¯å¯é çš„Starkneté’±åŒ…ï¼Œç”±äºCairoè™šæ‹Ÿæœºå¸¦æ¥äº†æ›´å¤šå¯èƒ½æ€§ï¼Œå¦‚è´¦æˆ·æŠ½è±¡ï¼ˆè¯·ç»§ç»­é˜…è¯»æœ¬ä¹¦äº†è§£æ›´å¤šç›¸å…³ä¿¡æ¯ï¼‰ï¼Œå› æ­¤Starknetä¸Šçš„é’±åŒ…æ¯”èµ·EOAé’±åŒ…å…·æœ‰æ›´å¼ºçš„å®‰å…¨æ€§å’Œå¯è®¿é—®æ€§ã€‚"

#: src/ch01-00-getting-started.md:298
msgid "Install the recommended chrome/brave extension for your chosen wallet."
msgstr ""

#: src/ch01-00-getting-started.md:299
msgid "Follow your wallet provider's instructions to deploy your account."
msgstr ""

#: src/ch01-00-getting-started.md:300
msgid "Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your account."
msgstr ""

#: src/ch01-00-getting-started.md:301
msgid "Deploy the account to the network. This usually takes around 10 seconds."
msgstr ""

#: src/ch01-00-getting-started.md:303
msgid "Once set up, you're ready to deploy your smart contracts to the Starknet Testnet."
msgstr "å½“è®¾ç½®å®Œæˆåï¼Œæ‚¨å°±å¯ä»¥å°†æ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°Starknetæµ‹è¯•ç½‘ç»œäº†ã€‚"

#: src/ch01-00-getting-started.md:307
msgid "Follow the previous deployment steps."
msgstr ""

#: src/ch01-00-getting-started.md:308
msgid "In the 'Environment selection' tab, choose 'Wallet'."
msgstr ""

#: src/ch01-00-getting-started.md:309
#, fuzzy
msgid "Select your Starknet account and continue with deploying and interacting with your contract."
msgstr ""
"1.æŒ‰ç…§ä¹‹å‰çš„éƒ¨ç½²æ­¥éª¤è¿›è¡Œã€‚\n"
"2.åœ¨ 'Environment selection' é€‰é¡¹å¡ä¸­ï¼Œé€‰æ‹© 'Wallet Selection'ã€‚\n"
"3.é€‰æ‹©æ‚¨çš„Starknetè´¦æˆ·ï¼Œç„¶åç»§ç»­éƒ¨ç½²å¹¶ä¸æ‚¨çš„åˆçº¦äº¤äº’ã€‚"

#: src/ch01-00-getting-started.md:313
msgid "You can monitor transaction hashes and addresses using any Starknet block explorers like:"
msgstr "æ‚¨å¯ä»¥ä½¿ç”¨ä»»ä½• Starknet åŒºå—æµè§ˆå™¨ç›‘æ§äº¤æ˜“å“ˆå¸Œå€¼å’Œåœ°å€ï¼š"

#: src/ch01-00-getting-started.md:315
#, fuzzy
msgid "[Starkscan](https://testnet.starkscan.co/)"
msgstr ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)"

#: src/ch01-00-getting-started.md:316
#, fuzzy
msgid "[Voyager](https://goerli.voyager.online/)"
msgstr ""
"- [Starkscan](https://testnet.starkscan.co/)\n"
"- [Voyager](https://goerli.voyager.online/)"

#: src/ch01-00-getting-started.md:317
msgid "[ViewBlock](https://viewblock.io/starknet)"
msgstr ""

#: src/ch01-00-getting-started.md:318
msgid "[oklink](https://www.oklink.com/starknet)"
msgstr ""

#: src/ch01-00-getting-started.md:320
msgid ""
"These tools provide a visual representation of transactions and contract state alterations. Notably, when you alter the contract ownership using the `transfer_ownership` function, the event emitted by "
"the contract appears in the block explorer. It's an effective method to track contract events."
msgstr "è¿™äº›å·¥å…·æä¾›äº†äº‹åŠ¡å’Œåˆçº¦çŠ¶æ€æ›´æ”¹çš„å¯è§†åŒ–è¡¨ç¤ºã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“ä½ ä½¿ç”¨ `transfer_ownership` å‡½æ•°æ›´æ”¹åˆçº¦æ‰€æœ‰æƒæ—¶ï¼Œåˆçº¦å‘å‡ºçš„äº‹ä»¶å°±ä¼šå‡ºç°åœ¨åŒºå—æµè§ˆå™¨ä¸­ã€‚è¿™æ˜¯è·Ÿè¸ªåˆçº¦äº‹ä»¶çš„æœ‰æ•ˆæ–¹æ³•ã€‚"

#: src/ch01-00-getting-started.md:322
#, fuzzy
msgid "Your Next Steps"
msgstr "## æ¥ä¸‹æ¥çš„æ­¥éª¤"

#: src/ch01-00-getting-started.md:324
msgid "Decide your direction from the following choices:"
msgstr "ä½ å¯ä»¥ä»ä»¥ä¸‹é€‰é¡¹ä¸­å†³å®šä½ çš„å­¦ä¹ æ–¹å‘ï¼š"

#: src/ch01-00-getting-started.md:326
msgid ""
"**Deepen Your Starknet Knowledge**: For an extensive grasp of Starknet's inner workings and potential use cases, delve into Chapter 3 of the Starknet Book. This chapter details Starknetâ€™s "
"architectural nuances. Then go ahead from there."
msgstr ""

#: src/ch01-00-getting-started.md:328
#, fuzzy
msgid ""
"**Dive into Cairo**: If you're more attuned to coding and wish to craft Starknet contracts, then Cairo is essential. It stands as Starknet's core contract language. Begin with Chapters 1-6 of the "
"[Cairo Book](https://book.cairo-lang.org/title-page.html), ranging from basics in _Getting Started_ to more advanced aspects such as _Enums and Pattern Matching_. Conclude by navigating to the "
"[Starknet Smart Contracts chapter](https://book.cairo-lang.org/ch13-00-introduction-to-starknet-smart-contracts.html), ensuring you have a well-rounded understanding."
msgstr ""
"1. **æ·±åŒ–æ‚¨çš„StarknetçŸ¥è¯†**ï¼šè¦å¹¿æ³›äº†è§£ Starknet çš„å†…éƒ¨è¿ä½œå’Œæ½œåœ¨ç”¨ä¾‹ï¼Œè¯·æ·±å…¥é˜…è¯»ã€ŠStarknet ä¹‹ä¹¦ã€‹ç¬¬ 3 ç« ã€‚æœ¬ç« è¯¦ç»†ä»‹ç»äº†Starknetæ¶æ„çš„ç»†å¾®å·®åˆ«ã€‚ç„¶åç»§ç»­å­¦ä¹ ã€‚\n"
"\n"
"2. **æ·±å…¥äº†è§£Cairo**ï¼šå¦‚æœä½ æ›´æ“…é•¿ç¼–ç ï¼Œå¹¶å¸Œæœ›ç¼–å†™Starknetåˆçº¦ï¼Œé‚£ä¹ˆCairoæ˜¯å¿…ä¸å¯å°‘çš„ã€‚å®ƒæ˜¯Starknetçš„æ ¸å¿ƒåˆçº¦è¯­è¨€ã€‚è¯·ä»[Cairo Book](https://book.cairo-lang.org/title-page.html)çš„ç¬¬1-6ç« å¼€å§‹ï¼Œå­¦ä¹ ä» _å…¥"
"é—¨_ çš„åŸºç¡€çŸ¥è¯†åˆ° _æšä¸¾å’Œæ¨¡å¼åŒ¹é…_ ç­‰æ›´é«˜çº§çš„å†…å®¹ã€‚æœ€åï¼Œæµè§ˆ[Starknet æ™ºèƒ½åˆçº¦ç« èŠ‚](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)ï¼Œç¡®ä¿æ‚¨æœ‰ä¸€ä¸ªå…¨é¢çš„äº†è§£ã€‚"

#: src/ch02-00-starknet-tooling.md:1
#, fuzzy
msgid "Starknet Tooling"
msgstr "# Starknetå·¥å…·"

#: src/ch02-00-starknet-tooling.md:3 src/ch02-03-scarb.md:3
#, fuzzy
msgid ""
"To make the most of this chapter, a basic grasp of the Cairo programming language is advised. We suggest reading chapters 1-6 of the [Cairo Book](https://book.cairo-lang.org/title-page.html), covering "
"topics from _Getting Started_ to _Enums and Pattern Matching._ Follow this by studying the [Starknet Smart Contracts chapter](https://book.cairo-lang.org/ch13-00-introduction-to-starknet-smart-"
"contracts.html) in the same book. With this background, youâ€™ll be well-equipped to understand the examples presented here."
msgstr ""
"è¦å……åˆ†ç†è§£æœ¬ç« å†…å®¹ï¼Œå»ºè®®å…ˆæŒæ¡Cairoç¼–ç¨‹è¯­è¨€çš„åŸºæœ¬çŸ¥è¯†ã€‚æˆ‘ä»¬å»ºè®®é˜…è¯»[Cairo Book](https://book.cairo-lang.org/zh-cn/title-page.html)çš„ç¬¬1-6ç« ï¼Œå†…å®¹åŒ…æ‹¬ä» _å…¥é—¨_ ç« èŠ‚çš„åŸºç¡€çŸ¥è¯†åˆ° _æšä¸¾å’Œæ¨¡å¼åŒ¹é…_ã€‚ä¹‹åï¼Œ"
"å†å­¦ä¹ åŒä¸€æœ¬ä¹¦ä¸­çš„[Starknet æ™ºèƒ½åˆçº¦](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.htmll)ã€‚æœ‰äº†è¿™äº›èƒŒæ™¯çŸ¥è¯†ï¼Œä½ å°±èƒ½å¾ˆå¥½åœ°ç†è§£è¿™é‡Œä»‹ç»çš„ç¤ºä¾‹äº†ã€‚"

#: src/ch02-00-starknet-tooling.md:12
#, fuzzy
msgid ""
"Today, Starknet provides all essential tools for building decentralized applications (dApps), compatible with multiple languages like JavaScript, Rust, and Python. You can use the Starknet SDK for "
"development. Front-end developers can use Starknet.js with React, while Rust and Python work well for back-end tasks."
msgstr ""
"å¦‚ä»Šï¼ŒStarknetæä¾›äº†æ„å»ºå»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºï¼ˆdAppsï¼‰çš„æ‰€æœ‰åŸºæœ¬å·¥å…·ï¼Œå…¼å®¹ JavaScriptã€Rust å’Œ Python ç­‰å¤šç§è¯­è¨€ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ Starknet SDK è¿›è¡Œå¼€å‘ã€‚å‰ç«¯å¼€å‘äººå‘˜å¯ä»¥ä½¿ç”¨å¸¦æœ‰ React çš„ Starknet.jsï¼Œè€Œ Rust å’Œ "
"Python åˆ™å¯ä»¥å¾ˆå¥½åœ°å®Œæˆåç«¯ä»»åŠ¡ã€‚"

#: src/ch02-00-starknet-tooling.md:18
#, fuzzy
msgid "We welcome contributors to enhance existing tools or develop new solutions."
msgstr "æˆ‘ä»¬æ¬¢è¿è´¡çŒ®è€…æ”¹è¿›ç°æœ‰å·¥å…·æˆ–å¼€å‘æ–°çš„è§£å†³æ–¹æ¡ˆã€‚"

#: src/ch02-00-starknet-tooling.md:21
msgid "In this chapter, youâ€™ll explore:"
msgstr "åœ¨æœ¬ç« ä¸­ï¼Œæ‚¨å°†äº†è§£ï¼š"

#: src/ch02-00-starknet-tooling.md:23
msgid "**Frameworks:** Build using Starknet-Foundry"
msgstr ""

#: src/ch02-00-starknet-tooling.md:25
msgid "**SDKs:** Discover multi-language support through Starknet.js, Starknet-rs, Starknet_py, and Cairo"
msgstr ""

#: src/ch02-00-starknet-tooling.md:28
msgid "**Front-end Development:** Use Starknet.js and React"
msgstr ""

#: src/ch02-00-starknet-tooling.md:30
msgid "**Testing:** Understand testing methods with Starknet-Foundry and the Devnet"
msgstr ""

#: src/ch02-00-starknet-tooling.md:32
#, fuzzy
msgid "By chapterâ€™s end, youâ€™ll have a complete grasp of Starknetâ€™s toolset, enabling efficient dApp development."
msgstr "æœ¬ç« ç»“æŸæ—¶ï¼Œæ‚¨å°†èƒ½å®Œå…¨æŒæ¡ Starknet çš„å·¥å…·é›†ï¼Œå®ç°é«˜æ•ˆçš„ dApp å¼€å‘ã€‚"

#: src/ch02-00-starknet-tooling.md:35
#, fuzzy
msgid "Hereâ€™s a quick rundown of the tools that could be used for Starknet development and that weâ€™ll cover in this chapter:"
msgstr "ä»¥ä¸‹æ˜¯å¯ç”¨äºStarknetå¼€å‘çš„å·¥å…·çš„ç®€è¦ä»‹ç»ï¼Œæˆ‘ä»¬å°†åœ¨æœ¬ç« ä»‹ç»è¿™äº›å·¥å…·ï¼š"

#: src/ch02-00-starknet-tooling.md:38
msgid "**Scarb:** A package manager that compiles your contracts."
msgstr ""

#: src/ch02-00-starknet-tooling.md:40
#, fuzzy
msgid "**Starkli:** A CLI tool for interacting with the Starknet network."
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-00-starknet-tooling.md:42
msgid "**Starknet Foundry:** For contract testing."
msgstr ""

#: src/ch02-00-starknet-tooling.md:44
msgid "**Katana:** Creates a local test node."
msgstr ""

#: src/ch02-00-starknet-tooling.md:46
msgid "**SDKs:** starknet.js, Starknet.py, and starknet.rs interface with Starknet using common programming languages."
msgstr ""

#: src/ch02-00-starknet-tooling.md:49
msgid "**Starknet-react:** Builds front-end apps using React."
msgstr ""

#: src/ch02-01-basic-installation.md:1 src/ch02-01-basic-installation.md:51 src/ch02-03-scarb.md:34 src/ch02-07-starknet-devnet.md:5 src/ch02-09-starknet-js.md:13 src/ch02-15-02-caracal.md:13
#: src/ch02-15-03-thoth.md:22 src/ch03-02-01-madara.md:25
#, fuzzy
msgid "Installation"
msgstr "# å®‰è£…"

#: src/ch02-01-basic-installation.md:3
#, fuzzy
msgid "This chapter walks you through setting up your Starknet development tools."
msgstr "æœ¬ç« å°†æŒ‡å¯¼æ‚¨å®‰è£…ä¸è®¾ç½® Starknet å¼€å‘å·¥å…·ã€‚"

#: src/ch02-01-basic-installation.md:6
msgid "Essential tools to install:"
msgstr "å®‰è£…å¿…å¤‡å·¥å…·ï¼š"

#: src/ch02-01-basic-installation.md:8
msgid "[Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for interacting with Starknet. More tools are discussed in Chapter 2."
msgstr ""

#: src/ch02-01-basic-installation.md:11
msgid ""
"[Scarb](https://github.com/software-mansion/scarb) - Cairoâ€™s package manager that compiles code to [Sierra](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/cairo-and-"
"sierra), a mid-level language between Cairo and CASM."
msgstr ""

#: src/ch02-01-basic-installation.md:15
msgid "[Katana](https://github.com/dojoengine/dojo) - Katana is a Starknet node, built for local development."
msgstr ""

#: src/ch02-01-basic-installation.md:17
#, fuzzy
msgid "For support or queries, visit our [GitHub Issues](https://github.com/starknet-edu/starknetbook/issues) or contact espejelomar on Telegram."
msgstr "æœ‰å…³æ”¯æŒæˆ–é—®é¢˜ï¼Œè¯·è®¿é—®æˆ‘ä»¬çš„ [GitHub Issues](https://github.com/starknet-edu/starknetbook/issues) æˆ–åœ¨ Telegram ä¸Šè”ç³» espejelomarã€‚"

#: src/ch02-01-basic-installation.md:21
#, fuzzy
msgid "Starkli Installation"
msgstr "## Starkli å®‰è£…"

#: src/ch02-01-basic-installation.md:23
#, fuzzy
msgid "Easily install Starkli using Starkliup, an installer invoked through the command line."
msgstr "ä½¿ç”¨é€šè¿‡å‘½ä»¤è¡Œè°ƒç”¨å®‰è£…ç¨‹åº Starkliupï¼Œå¯è½»æ¾å®‰è£… Starkliã€‚"

#: src/ch02-01-basic-installation.md:31
msgid "Restart your terminal and confirm installation:"
msgstr "é‡æ–°å¯åŠ¨ç»ˆç«¯å¹¶ç¡®è®¤å®‰è£…æˆåŠŸï¼š"

#: src/ch02-01-basic-installation.md:37
msgid "To upgrade Starkli, simply repeat the steps."
msgstr "è¦å‡çº§ Starkliï¼Œåªéœ€é‡å¤ä¸Šè¿°æ­¥éª¤å³å¯ã€‚"

#: src/ch02-01-basic-installation.md:39
#, fuzzy
msgid "Scarb Package Manager Installation"
msgstr "## å®‰è£… Scarb è½¯ä»¶åŒ…ç®¡ç†å™¨"

#: src/ch02-01-basic-installation.md:41
msgid "Scarb is also Cairo's package manager and is heavily inspired by [Cargo](https://doc.rust-lang.org/cargo/), Rustâ€™s build system and package manager."
msgstr ""

#: src/ch02-01-basic-installation.md:44
msgid "Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries."
msgstr ""

#: src/ch02-01-basic-installation.md:47 src/ch02-08-foundry-cast.md:18 src/ch02-08-01-deployment-script.md:9 src/ch02-15-02-caracal.md:21
#, fuzzy
msgid "Requirements"
msgstr "**æœ€ä½è¦æ±‚ï¼š**"

#: src/ch02-01-basic-installation.md:49
msgid "Scarb requires a Git executable to be available in the `PATH` environment variable."
msgstr ""

#: src/ch02-01-basic-installation.md:53
msgid ""
"To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We strongly recommend that you install Scarb [via asdf](https://docs.swmansion.com/scarb/"
"download.html#install-via-asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure that the version of Scarb you use to work on a project always "
"matches the one defined in the project settings, avoiding problems related to version mismatches."
msgstr ""

#: src/ch02-01-basic-installation.md:60
msgid "Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-started.html) to install all prerequisites."
msgstr ""

#: src/ch02-01-basic-installation.md:63
msgid "Once you have asdf installed locally, you can download Scarb plugin with the following command:"
msgstr ""

#: src/ch02-01-basic-installation.md:69
msgid "This will allow you to download specific versions:"
msgstr ""

#: src/ch02-01-basic-installation.md:75
msgid "and set a global version:"
msgstr ""

#: src/ch02-01-basic-installation.md:81
msgid "Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb."
msgstr ""

#: src/ch02-01-basic-installation.md:85 src/ch04-02-hello-account.md:24 src/ch04-03-standard-account.md:18
msgid "'=https'"
msgstr ""

#: src/ch02-01-basic-installation.md:88
msgid "In both cases, you can verify installation by running the following command in a new terminal session, it should print both Scarb and Cairo language versions, e.g:"
msgstr ""

#: src/ch02-01-basic-installation.md:97
#, fuzzy
msgid "For Windows, follow manual setup in the [Scarb documentation](https://docs.swmansion.com/scarb/download.html#windows)."
msgstr "å¯¹äº Windowsï¼Œè¯·æŒ‰ç…§ [Scarb æ–‡æ¡£](https://docs.swmansion.com/scarb/download.html#windows)ä¸­çš„æ‰‹å†Œè¿›è¡Œè®¾ç½®ã€‚"

#: src/ch02-01-basic-installation.md:100
#, fuzzy
msgid "Katana Node Installation"
msgstr "## Katana Node å®‰è£…"

#: src/ch02-01-basic-installation.md:102 src/ch02-04-katana.md:36
msgid "To install Katana, use the `dojoup` installer from the command line:"
msgstr "è¦å®‰è£… Katanaï¼Œè¯·ä½¿ç”¨å‘½ä»¤è¡Œä¸­çš„ `dojoup` å®‰è£…ç¨‹åºï¼š"

#: src/ch02-01-basic-installation.md:109 src/ch02-04-katana.md:43
msgid "After restarting your terminal, verify the installation with:"
msgstr "é‡å¯ç»ˆç«¯åï¼Œç”¨ä»¥ä¸‹å‘½ä»¤éªŒè¯å®‰è£…ï¼š"

#: src/ch02-01-basic-installation.md:115 src/ch02-04-katana.md:49
msgid "To upgrade Katana, rerun the installation command."
msgstr "è¦å‡çº§å¡å¡”å¨œï¼Œè¯·é‡æ–°è¿è¡Œå®‰è£…å‘½ä»¤ã€‚"

#: src/ch02-01-basic-installation.md:117
msgid "You are now set to code in Cairo and deploy to Starknet."
msgstr "ç°åœ¨æ‚¨å·²ç»å°†ç”¨Cairoç¼–å†™ä»£ç å¹¶å°†å…¶éƒ¨ç½²åˆ°Starknetæ‰€éœ€çš„å¼€å‘ç¯å¢ƒè®¾ç½®å®Œæˆäº†ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:1
#, fuzzy
msgid "Introduction to Starkli, Scarb and Katana"
msgstr "# Starkliã€Scarb å’Œ Katana çš„ç®€ä»‹"

#: src/ch02-02-starkli-scarb-katana.md:3
#, fuzzy
msgid "In this chapter, youâ€™ll learn how to compile, deploy, and interact with a Starknet smart contract written in Cairo using starkli, scarb and katana."
msgstr "åœ¨æœ¬ç« ä¸­ï¼Œä½ å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨starkli, scarb å’Œ katanaæ¥ç¼–è¯‘ã€éƒ¨ç½²ç”¨ Cairo ç¼–å†™çš„ Starknet æ™ºèƒ½åˆçº¦ï¼Œå¹¶ä¸ä¹‹äº¤äº’ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:6
#, fuzzy
msgid "First, confirm that the following commands work on your system. If they donâ€™t, refer to Basic Installation in this chapter."
msgstr "é¦–å…ˆï¼Œè¯·ç¡®è®¤ä»¥ä¸‹å‘½ä»¤åœ¨æ‚¨çš„ç³»ç»Ÿä¸Šæ˜¯å¦æœ‰æ•ˆã€‚å¦‚æœä¸è¡Œï¼Œè¯·å‚é˜…æœ¬ç« çš„åŸºæœ¬å®‰è£…ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:10 src/ch02-05-testnet-deployment.md:8
msgid "# For Cairo code compilation\n"
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:11 src/ch02-05-testnet-deployment.md:9
#, fuzzy
msgid "# To interact with Starknet\n"
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-02-starkli-scarb-katana.md:12
msgid "# To declare and deploy on local development\n"
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:15
#, fuzzy
msgid "Crafting a Starknet Smart Contract"
msgstr "## ä»å¤´ç¼–å†™ä¸€ä¸ªStarknetæ™ºèƒ½åˆçº¦"

#: src/ch02-02-starkli-scarb-katana.md:17
msgid "**Important:** Before we proceed with this example, please ensure that the versions of both `katana` and `starkli` match the specified versions provided below."
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:24
msgid "If this is not your case, you have to install them like this:"
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:31
#, fuzzy
msgid "Now begin by initiating a Scarb project:"
msgstr "é¦–å…ˆå¯åŠ¨ä¸€ä¸ª Scarb é¡¹ç›®ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:37
#, fuzzy
msgid "Configure Environment Variables and the `Scarb.toml` File"
msgstr "## é…ç½®ç¯å¢ƒå˜é‡å’Œ `Scarb.toml` æ–‡ä»¶"

#: src/ch02-02-starkli-scarb-katana.md:39
msgid "Review the `my_contract` project. Its structure appears as:"
msgstr "æŸ¥çœ‹ `my_contract` é¡¹ç›®ã€‚å…¶ç»“æ„å¦‚ä¸‹ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:48
msgid "Amend the `Scarb.toml` file to integrate the `starknet` dependency and introduce the `starknet-contract` target:"
msgstr "ä¿®æ”¹ `Scarb.toml` æ–‡ä»¶ä»¥æ•´åˆ `starknet` ä¾èµ–å…³ç³»ï¼Œå¹¶å¼•å…¥ `starknet-contract` ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:50
#, fuzzy
msgid ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.5.4\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"    [dependencies]\n"
"    starknet = \">=2.3.0\"\n"
"\n"
"    [[target.starknet-contract]]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:57
msgid "For streamlined Starkli command execution, establish environment variables. Two primary variables are essential:"
msgstr "ä¸ºäº†ç®€åŒ– Starkli å‘½ä»¤çš„æ‰§è¡Œï¼Œéœ€è¦å»ºç«‹ç¯å¢ƒå˜é‡ã€‚æœ‰ä¸¤ä¸ªä¸»è¦å˜é‡å¿…ä¸å¯å°‘ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:59
#, fuzzy
msgid "One for your account, a pre-funded account on the local development network"
msgstr ""
"- ä¸€ä¸ªç”¨äºæ‚¨çš„è´¦æˆ·ï¼Œå³æœ¬åœ°å¼€å‘ç½‘ç»œä¸Šçš„é¢„èµ„åŠ©è´¦æˆ·\n"
"- å¦ä¸€ä¸ªç”¨äºæŒ‡å®šç½‘ç»œï¼Œç‰¹åˆ«æ˜¯æœ¬åœ° katana å¼€å‘ç½‘ç»œ"

#: src/ch02-02-starkli-scarb-katana.md:60
#, fuzzy
msgid "Another for designating the network, specifically the local katana devnet"
msgstr ""
"- ä¸€ä¸ªç”¨äºæ‚¨çš„è´¦æˆ·ï¼Œå³æœ¬åœ°å¼€å‘ç½‘ç»œä¸Šçš„é¢„èµ„åŠ©è´¦æˆ·\n"
"- å¦ä¸€ä¸ªç”¨äºæŒ‡å®šç½‘ç»œï¼Œç‰¹åˆ«æ˜¯æœ¬åœ° katana å¼€å‘ç½‘ç»œ"

#: src/ch02-02-starkli-scarb-katana.md:62
msgid "In the `src/` directory, create a `.env` file with the following:"
msgstr "åœ¨ `src/` ç›®å½•ä¸­ï¼Œåˆ›å»ºåŒ…å«ä»¥ä¸‹å†…å®¹çš„ `.env` æ–‡ä»¶ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:65
msgid "katana-0"
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:66
msgid "http://0.0.0.0:5050"
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:69
msgid "These settings streamline Starkli command operations."
msgstr "è¿™äº›è®¾ç½®å¯ç®€åŒ– Starkli å‘½ä»¤æ“ä½œã€‚"

#: src/ch02-02-starkli-scarb-katana.md:71 src/ch02-05-testnet-deployment.md:297
#, fuzzy
msgid "Declaring Smart Contracts in Starknet"
msgstr "## åœ¨ Starknet ä¸Šå£°æ˜æ™ºèƒ½åˆçº¦"

#: src/ch02-02-starkli-scarb-katana.md:73
msgid "Deploying a Starknet smart contract requires two primary steps:"
msgstr "åœ¨ Starknet ä¸Šéƒ¨ç½²æ™ºèƒ½åˆçº¦åŒ…æ‹¬ä¸¤ä¸ªæ­¥éª¤ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:75
#, fuzzy
msgid "Declare the contract's code."
msgstr "2.å£°æ˜åˆçº¦"

#: src/ch02-02-starkli-scarb-katana.md:76
#, fuzzy
msgid "Deploy an instance of that declared code."
msgstr ""
"- å£°æ˜æ‚¨çš„åˆçº¦ä»£ç ã€‚\n"
"- éƒ¨ç½²å·²å£°æ˜ä»£ç çš„å®ä¾‹ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:78
msgid "Begin with the `src/lib.cairo` file, which provides a foundational template. Remove its contents and insert the following:"
msgstr "ä»æä¾›åŸºç¡€æ¨¡æ¿çš„`src/lib.cairo`æ–‡ä»¶å¼€å§‹ã€‚åˆ é™¤å…¶å†…å®¹å¹¶æ’å…¥ä»¥ä¸‹å†…å®¹ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:112
msgid "This rudimentary smart contract serves as a starting point."
msgstr "è¿™ä¸ªåˆçº§æ™ºèƒ½åˆçº¦åªæ˜¯ä¸€ä¸ªèµ·ç‚¹ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:114
msgid "Compile the contract with the Scarb compiler. If Scarb isn't installed, consult the [Installation](ch02-01-basic-installation.md) section."
msgstr "ä½¿ç”¨ Scarb ç¼–è¯‘å™¨ç¼–è¯‘åˆçº¦ã€‚å¦‚æœå°šæœªå®‰è£… Scarbï¼Œè¯·æŸ¥é˜… [å®‰è£…](ch02-01-basic-installation.md) éƒ¨åˆ†ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:120
msgid "The above command results in a compiled contract under `target/dev/`, named \"`my_contract_hello.contract_class.json`\" (check Scarb's subchapter for more details)."
msgstr "ä¸Šè¿°å‘½ä»¤ä¼šåœ¨ `target/dev/` ä¸‹ç”Ÿæˆä¸€ä¸ªç¼–è¯‘åçš„åˆåŒï¼Œåä¸º\"`my_contract_hello.contract_class.json`\"ï¼ˆæ›´å¤šè¯¦æƒ…è¯·æŸ¥çœ‹ Scarb çš„å­ç« èŠ‚ï¼‰ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:122
msgid "Having compiled the smart contract, it's time to declare it with Starkli and katana. First, ensure your project acknowledges the environmental variables:"
msgstr "ç¼–è¯‘å®Œæ™ºèƒ½åˆçº¦åï¼Œå°±è¯¥ç”¨ Starkli å’Œ katana å£°æ˜å®ƒäº†ã€‚é¦–å…ˆï¼Œç¡®ä¿ä½ çš„é¡¹ç›®é…ç½®å¥½äº†ç¯å¢ƒå˜é‡ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:128
msgid "Next, launch Katana. In a separate terminal, run (more details in the Katan subchapter):"
msgstr "æ¥ä¸‹æ¥ï¼Œå¯åŠ¨Katanaã€‚åœ¨ä¸€ä¸ªå•ç‹¬çš„ç»ˆç«¯ä¸­è¿è¡Œï¼ˆæ›´å¤šè¯¦æƒ…è¯·å‚é˜… Katana å­ç« èŠ‚ï¼‰ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:134
msgid "To declare your contract, execute:"
msgstr "è¦å£°æ˜æ‚¨çš„åˆçº¦ï¼Œè¯·æ‰§è¡Œï¼š"

#: src/ch02-02-starkli-scarb-katana.md:140
msgid ""
"Facing an \"Error: Invalid contract class\"? It indicates a version mismatch between Scarb's compiler and Starkli. Refer to the earlier steps to sync the versions. Typically, Starkli supports compiler "
"versions approved by mainnet, even if the most recent Scarb version isn't compatible."
msgstr ""
"å¦‚æœé‡åˆ° `\"Error: Invalid contract class\"`ï¼Œè¿™å¾ˆå¯èƒ½æ„å‘³ç€ä½ çš„ Scarb ç¼–è¯‘å™¨ç‰ˆæœ¬ä¸ Starkli ä¸å…¼å®¹ã€‚è¯·æŒ‰ç…§ä¸Šé¢çš„æ­¥éª¤è°ƒæ•´ç‰ˆæœ¬ã€‚Starkli é€šå¸¸æ”¯æŒä¸»ç½‘æ¥å—çš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œå³ä½¿ Scarb çš„æœ€æ–°ç‰ˆæœ¬è¿˜ä¸å…¼å®¹ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:142
#, fuzzy
msgid "Upon successful command execution, you'll obtain a contract class hash: This unique hash serves as the identifier for your contract class within Starknet. For example:"
msgstr "è¿è¡Œè¯¥å‘½ä»¤åï¼Œæ‚¨å°†æ”¶åˆ°ä¸€ä¸ªåˆçº¦çš„class hashï¼ˆç±»å“ˆå¸Œï¼‰ã€‚è¿™ä¸ªå”¯ä¸€çš„å“ˆå¸Œå€¼æ˜¯æ‚¨çš„åˆçº¦ç±»åœ¨Starknetä¸­çš„æ ‡è¯†ç¬¦ã€‚ä¾‹å¦‚:"

#: src/ch02-02-starkli-scarb-katana.md:150
msgid "Consider this hash as the contract class's _address_."
msgstr "ä½ å¯å°†æ­¤å“ˆå¸Œå€¼è§†ä¸ºåˆçº¦ç±»çš„ _address_ ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:152
msgid "If you try to declare an already existing contract class, don't fret. Just proceed. You might see:"
msgstr "å¦‚æœæ‚¨å°è¯•å£°æ˜ä¸€ä¸ªå·²ç»å­˜åœ¨çš„åˆçº¦ç±»ï¼Œè¯·ä¸è¦æ‹…å¿ƒåªç®¡ç»§ç»­ã€‚ä½ å¯èƒ½ä¼šçœ‹åˆ°ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:159
#, fuzzy
msgid "Deploying Starknet Smart Contracts"
msgstr "## éƒ¨ç½²Starknetæ™ºèƒ½åˆçº¦"

#: src/ch02-02-starkli-scarb-katana.md:161
msgid "To deploy a smart contract on the katana local devnet, use the following command. It primarily requires:"
msgstr "è¦åœ¨ katana æœ¬åœ°å¼€å‘ç½‘ç»œä¸Šéƒ¨ç½²æ™ºèƒ½åˆçº¦ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ã€‚å®ƒä¸»è¦éœ€è¦ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:163
msgid "Your contract's class hash."
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:164
#, fuzzy
msgid "Constructor arguments your contract needs (in our example, a _name_ of type `felt252`)."
msgstr ""
"1.æ‚¨åˆçº¦çš„ç±»å“ˆå¸Œå€¼ã€‚\n"
"2.åˆçº¦æ‰€éœ€çš„æ„é€ å‡½æ•°å‚æ•°ï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæ˜¯ä¸€ä¸ª åä¸º  _name_  çš„`felt252` ç±»å‹ï¼‰ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:166
msgid "Here's the command structure:"
msgstr "è¿™æ˜¯å‘½ä»¤çš„ç»“æ„ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:174
msgid "Notice the constructor inputs are in felt format. So we need to convert a short string to a felt252 format. We can use the `to-cairo-string` command for this:"
msgstr "è¯·æ³¨æ„ï¼Œæ„é€ å‡½æ•°ä½¿ç”¨çš„è¾“å…¥æ˜¯ felt æ ¼å¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°†çŸ­å­—ç¬¦ä¸²è½¬æ¢ä¸º felt252 æ ¼å¼ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `to-cairo-string` å‘½ä»¤ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:180
msgid "In this case, we'll use the string \"starknetbook\" as the name:"
msgstr "åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å­—ç¬¦ä¸² \"starknetbook \"ä½œä¸ºåç§°å‚æ•°ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:186
msgid "The output:"
msgstr "è¾“å‡ºç»“æœï¼š"

#: src/ch02-02-starkli-scarb-katana.md:192
msgid "Now deploy using a class hash and constructor input:"
msgstr "ç°åœ¨ä½¿ç”¨ç±»å“ˆå¸Œå€¼å’Œæ„é€ å‡½æ•°å‚æ•°è¿›è¡Œéƒ¨ç½²ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:200
msgid "After running, expect an output similar to:"
msgstr "è¿è¡Œåï¼Œè¾“å‡ºç»“æœç±»ä¼¼äºï¼š"

#: src/ch02-02-starkli-scarb-katana.md:209
#, fuzzy
msgid "Interacting with Starknet Contracts"
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-02-starkli-scarb-katana.md:211
msgid "Using Starkli, you can interact with smart contracts through two primary methods:"
msgstr "ä½¿ç”¨ Starkliï¼Œä½ å¯ä»¥é€šè¿‡ä¸¤ç§ä¸»è¦æ–¹æ³•ä¸æ™ºèƒ½åˆçº¦è¿›è¡Œäº¤äº’ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:213
msgid "`call`: For read-only functions."
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:214
#, fuzzy
msgid "`invoke`: For functions that alter the state."
msgstr ""
"- `call`ï¼šç”¨äºåªè¯»å‡½æ•°ã€‚\n"
"- `invoke`ï¼šç”¨äºæ”¹å˜çŠ¶æ€çš„å‡½æ•°ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:216
#, fuzzy
msgid "Reading Data with `call`"
msgstr "### ä½¿ç”¨ `call` è¯»å–æ•°æ®"

#: src/ch02-02-starkli-scarb-katana.md:218
#, fuzzy
msgid ""
"The `call` command let's you query contract functions without transacting. For instance, if you want to determine the current contract owner using the `get_name` function, which requires no arguments:"
msgstr "`call`å‘½ä»¤ä½¿ä½ å¯ä»¥åœ¨ä¸å‘é€äº¤æ˜“çš„æƒ…å†µä¸‹æŸ¥è¯¢æ™ºèƒ½åˆçº¦å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œè¦æƒ³çŸ¥é“è°æ˜¯åˆçº¦çš„å½“å‰æ‰€æœ‰è€…ï¼Œå¯ä»¥ä½¿ç”¨`get_owner`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸éœ€è¦å‚æ•°ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:227
#, fuzzy
msgid "Replace `<CONTRACT_ADDRESS>` with the address of your contract. The command will return the ownerâ€™s address, which was initially set during the contractâ€™s deployment:"
msgstr "è¯·å°† `<CONTRACT_ADDRESS>` æ›¿æ¢ä¸ºæ‚¨çš„åˆçº¦åœ°å€ã€‚è¯¥å‘½ä»¤å°†è¿”å›æ‰€æœ‰è€…çš„åœ°å€ï¼Œè¯¥åœ°å€æœ€åˆæ˜¯åœ¨éƒ¨ç½²åˆçº¦æ—¶è®¾ç½®çš„ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:233
#, fuzzy
msgid "\"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\""
msgstr ""
"```bash\n"
"    [\n"
"        \"0x0000000000000000000000000000000000000000737461726b6e6574626f6f6b\"\n"
"    ]\n"
"```"

#: src/ch02-02-starkli-scarb-katana.md:237
msgid "But what is this lengthy output? In Starknet, we use the `felt252` data type to represent strings. This can be decoded into its string representation:"
msgstr "ä½†è¿™ä¸ªä¸€é•¿ä¸²è¾“å‡ºæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿåœ¨Starknetä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ `felt252` æ•°æ®ç±»å‹æ¥è¡¨ç¤ºå­—ç¬¦ä¸²ã€‚è¿™å¯ä»¥è§£ç æˆå­—ç¬¦ä¸²è¡¨ç¤ºæ³•ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:243
msgid "The result:"
msgstr "ç»“æœæ˜¯ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:249
#, fuzzy
msgid "Modifying Contract State with `invoke`"
msgstr "## ä½¿ç”¨`invoke`ä¿®æ”¹åˆçº¦çŠ¶æ€"

#: src/ch02-02-starkli-scarb-katana.md:251
msgid "To alter the contract's state, use the `invoke` command. For instance, if you want to update the name field in the storage, utilize the `set_name` function:"
msgstr "è¦æ”¹å˜åˆçº¦çš„çŠ¶æ€ï¼Œè¯·ä½¿ç”¨ `invoke` å‘½ä»¤ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¦æ›´æ–°å­˜å‚¨ä¸­çš„åç§°å­—æ®µï¼Œè¯·ä½¿ç”¨ `set_name` å‡½æ•°ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:260
msgid "Where:"
msgstr "åœ¨è¿™é‡Œï¼š"

#: src/ch02-02-starkli-scarb-katana.md:262
msgid "**`<CONTRACT_ADDRESS>`** is the address of your contract."
msgstr ""

#: src/ch02-02-starkli-scarb-katana.md:263
#, fuzzy
msgid "**`<felt252>`** is the new value for the **`name`** field, in felt252 format."
msgstr ""
"- **`<CONTRACT_ADDRESS>`** æ˜¯ä½ çš„åˆçº¦åœ°å€ã€‚\n"
"- **`<felt252>`** æ˜¯ **`name`** å­—æ®µçš„æ–°å€¼ï¼Œæ ¼å¼ä¸º felt252ã€‚"

#: src/ch02-02-starkli-scarb-katana.md:265
msgid "For example, to update the name to \"Omar\", first convert the string \"Omar\" to its felt252 representation:"
msgstr "ä¾‹å¦‚ï¼Œè¦å°†åç§°æ›´æ–°ä¸º \"Omar\"ï¼Œé¦–å…ˆè¦å°†å­—ç¬¦ä¸² \"Omar \"è½¬æ¢ä¸ºå…¶ felt252 è¡¨ç¤ºå½¢å¼ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:271
msgid "This will return:"
msgstr "å°†è¿”å›ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:277
msgid "Now, proceed with the `invoke` command:"
msgstr "ç°åœ¨ï¼Œæ‰§è¡Œ `invoke` å‘½ä»¤ï¼š"

#: src/ch02-02-starkli-scarb-katana.md:283
msgid "Bravo! You've adeptly modified and interfaced with your Starknet contract."
msgstr "å¹²å¾—å¥½ï¼é€šè¿‡æ¥å£çš„äº¤äº’ï¼Œä½ å¯¹ä½ çš„Starknetåˆçº¦è¿›è¡Œäº†å·§å¦™çš„ä¿®æ”¹ã€‚"

#: src/ch02-03-scarb.md:12
#, fuzzy
msgid ""
"Scarb is Cairoâ€™s package manager designed for both Cairo and Starknet projects. It handles dependencies, compiles projects, and integrates with tools like Foundry. It is built by the same team that "
"created Foundry for Starknet."
msgstr "Scarb æ˜¯ Cairo çš„è½¯ä»¶åŒ…ç®¡ç†å™¨ï¼Œä¸“ä¸º Cairo å’Œ Starknet é¡¹ç›®è®¾è®¡ã€‚å®ƒå¤„ç†ä¾èµ–å…³ç³»ã€ç¼–è¯‘é¡¹ç›®ï¼Œå¹¶ä¸ Foundry ç­‰å·¥å…·é›†æˆã€‚å®ƒç”±ä¸º Starknet åˆ›å»º Foundry çš„åŒä¸€å›¢é˜Ÿæ‰“é€ ã€‚"

#: src/ch02-03-scarb.md:17
#, fuzzy
msgid "Scarb Workflow"
msgstr "# Scarb å·¥ä½œæµç¨‹"

#: src/ch02-03-scarb.md:19
msgid "Follow these steps to develop a Starknet contract using Scarb:"
msgstr "è¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ä½¿ç”¨ Scarb æ¥å¼€å‘Starknetåˆçº¦ï¼š"

#: src/ch02-03-scarb.md:21
msgid "**Initialize:** Use `scarb new` to set up a new project, generating a `Scarb.toml` file and initial `src/lib.cairo`."
msgstr ""

#: src/ch02-03-scarb.md:24
msgid "**Code:** Add your Cairo code in the `src` directory."
msgstr ""

#: src/ch02-03-scarb.md:26
msgid "**Dependencies:** Add external libraries using `scarb add`."
msgstr ""

#: src/ch02-03-scarb.md:28
msgid "**Compile:** Execute `scarb build` to convert your contract into Sierra code."
msgstr ""

#: src/ch02-03-scarb.md:31
#, fuzzy
msgid "Scarb simplifies your development workflow, making it efficient and streamlined."
msgstr "Scarb ç®€åŒ–äº†æ‚¨çš„å¼€å‘å·¥ä½œæµç¨‹ï¼Œä½¿å…¶é«˜æ•ˆã€ç²¾ç®€ã€‚"

#: src/ch02-03-scarb.md:36
#, fuzzy
msgid "Scarb is cross-platform, supporting macOS, Linux, and Windows. For installation, refer to the [Basic installation guide](./ch02-01-basic-installation.html#scarb-package-manager-installation)."
msgstr "Scarb å¯è·¨å¹³å°è¿è¡Œï¼Œæ”¯æŒ macOSã€Linux å’Œ Windowsã€‚æœ‰å…³å®‰è£…ï¼Œè¯·å‚é˜… [ç¬¬1ç« çš„å®‰è£…æŒ‡å—](https://book.starknet.io/chapter_1/environment_setup.html#the_scarb_package_manager_installation)ã€‚"

#: src/ch02-03-scarb.md:39
#, fuzzy
msgid "Cairo Project Structure"
msgstr "# Cairoé¡¹ç›®ç»“æ„"

#: src/ch02-03-scarb.md:41
msgid "Next, weâ€™ll dive into the key components that make up a Cairo project."
msgstr "æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨Cairoé¡¹ç›®çš„å…³é”®ç»„æˆéƒ¨åˆ†ã€‚"

#: src/ch02-03-scarb.md:43
#, fuzzy
msgid "Cairo Packages"
msgstr "## Cairo åŒ…"

#: src/ch02-03-scarb.md:45
#, fuzzy
msgid "Cairo packages, also referred to as \"crates\" in some contexts, are the building blocks of a Cairo project. Each package must follow several rules:"
msgstr "Cairo åŒ…åœ¨æŸäº›æƒ…å†µä¸‹ä¹Ÿè¢«ç§°ä¸º \"crate\"ï¼Œæ˜¯ Cairo é¡¹ç›®çš„ç»„æˆéƒ¨åˆ†ã€‚æ¯ä¸ªåŒ…éƒ½å¿…é¡»éµå¾ªå‡ æ¡è§„åˆ™ï¼š"

#: src/ch02-03-scarb.md:49
#, fuzzy
msgid "A package must include a `Scarb.toml` file, which is Scarbâ€™s manifest file. It contains the dependencies for your package."
msgstr ""
"- åŒ…å¿…é¡»åŒ…å«ä¸€ä¸ª `Scarb.toml` æ–‡ä»¶ï¼Œå®ƒæ˜¯ Scarb çš„\n"
"  æ¸…å•æ–‡ä»¶ã€‚å®ƒåŒ…å«è½¯ä»¶åŒ…çš„ä¾èµ–é¡¹ã€‚\n"
"\n"
"- åŒ…å¿…é¡»åŒ…å«ä¸€ä¸ª `src/lib.cairo` æ–‡ä»¶ï¼Œå®ƒæ˜¯åŒ…çš„æ ‘å½¢ç»“æ„çš„æ ¹æ–‡ä»¶ã€‚\n"
"  å®ƒå…è®¸ä½ å®šä¹‰å‡½æ•°å’Œå£°æ˜ä½¿ç”¨è¿‡çš„æ¨¡å—ã€‚"

#: src/ch02-03-scarb.md:52
#, fuzzy
msgid "A package must include a `src/lib.cairo` file, which is the root of the package tree. It allows you to define functions and declare used modules."
msgstr ""
"- åŒ…å¿…é¡»åŒ…å«ä¸€ä¸ª `Scarb.toml` æ–‡ä»¶ï¼Œå®ƒæ˜¯ Scarb çš„\n"
"  æ¸…å•æ–‡ä»¶ã€‚å®ƒåŒ…å«è½¯ä»¶åŒ…çš„ä¾èµ–é¡¹ã€‚\n"
"\n"
"- åŒ…å¿…é¡»åŒ…å«ä¸€ä¸ª `src/lib.cairo` æ–‡ä»¶ï¼Œå®ƒæ˜¯åŒ…çš„æ ‘å½¢ç»“æ„çš„æ ¹æ–‡ä»¶ã€‚\n"
"  å®ƒå…è®¸ä½ å®šä¹‰å‡½æ•°å’Œå£°æ˜ä½¿ç”¨è¿‡çš„æ¨¡å—ã€‚"

#: src/ch02-03-scarb.md:56
#, fuzzy
msgid ""
"Package structures might look like the following case where we have a package named `my_package`, which includes a `src` directory with the `lib.cairo` file inside, a `snips` directory which in itself "
"a package we can use, and a `Scarb.toml` file in the top-level directory."
msgstr "è½¯ä»¶åŒ…ç»“æ„å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼šæˆ‘ä»¬æœ‰ä¸€ä¸ªåä¸º `my_package`çš„åŒ…ï¼Œå…¶ä¸­åŒ…æ‹¬ä¸€ä¸ªåŒ…å«`lib.cairo` æ–‡ä»¶çš„ `src` ç›®å½•ã€ä¸€ä¸ªæœ¬èº«å°±æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨çš„è½¯ä»¶åŒ…çš„ `snips`ç›®å½•å’Œä¸€ä¸ªä½äºé¡¶å±‚ç›®å½•çš„`Scarb.toml`æ–‡ä»¶ã€‚"

#: src/ch02-03-scarb.md:72
msgid "Within the `Scarb.toml` file, you might have:"
msgstr "åœ¨ `Scarb.toml` æ–‡ä»¶ä¸­ï¼Œå¯èƒ½æœ‰ï¼š"

#: src/ch02-03-scarb.md:74
#, fuzzy
msgid ""
"```\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.0.1\"\n"
"snips = { path = \"snips\" }\n"
"```"
msgstr ""
"[package]\n"
"    name = \"my_package\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    [dependencies]\n"
"    starknet = \">=2.0.1\"\n"
"    snips = { path = \"snips\" }"

#: src/ch02-03-scarb.md:82
#, fuzzy
msgid ""
"Here starknet and snips are the dependencies of the package. The `starknet` dependency is hosted on the Scarb registry (we do not need to download it), while the `snips` dependency is located in the "
"`snips` directory."
msgstr "è¿™é‡Œçš„ `starknet`  å’Œ `snips` æ˜¯è½¯ä»¶åŒ…çš„ä¾èµ–é¡¹ã€‚`starknet` ä¾èµ–é¡¹ä½äº Scarb æ³¨å†Œè¡¨ä¸­ï¼ˆæˆ‘ä»¬æ— éœ€ä¸‹è½½ï¼‰ï¼Œè€Œ `snips`ä¾èµ–é¡¹ä½äº `snips`ç›®å½•ä¸­ã€‚"

#: src/ch02-03-scarb.md:87
#, fuzzy
msgid "Setting Up a Project with Scarb"
msgstr "# ä½¿ç”¨ Scarb è®¾ç½®é¡¹ç›®"

#: src/ch02-03-scarb.md:89
#, fuzzy
msgid "To create a new project using Scarb, navigate to your desired project directory and execute the following command:"
msgstr "è¦ä½¿ç”¨ Scarb åˆ›å»ºæ–°é¡¹ç›®ï¼Œè¯·å¯¼èˆªåˆ°æ‰€éœ€çš„é¡¹ç›®ç›®å½•å¹¶æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-03-scarb.md:94
#, fuzzy
msgid ""
"This command will create a new project directory named `hello_scarb`, including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file inside, and initialize a new Git repository with a `."
"gitignore` file."
msgstr "è¯¥å‘½ä»¤å°†åˆ›å»ºä¸€ä¸ªåä¸º `hello_scarb` çš„æ–°é¡¹ç›®ç›®å½•ï¼ŒåŒ…æ‹¬ä¸€ä¸ª `Scarb.toml` æ–‡ä»¶ã€ä¸€ä¸ªåŒ…å« `lib.cairo` æ–‡ä»¶çš„ `src` ç›®å½•ï¼Œå¹¶ä½¿ç”¨ `.gitignore` æ–‡ä»¶åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ Git ä»“åº“ã€‚"

#: src/ch02-03-scarb.md:103
#, fuzzy
msgid "Upon opening `Scarb.toml` in a text editor, you should see something similar to the code snippet below:"
msgstr "åœ¨æ–‡æœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€`Scarb.toml`åï¼Œæ‚¨åº”è¯¥ä¼šçœ‹åˆ°ä¸ä¸‹é¢ä»£ç ç‰‡æ®µç±»ä¼¼çš„å†…å®¹ï¼š"

#: src/ch02-03-scarb.md:106
#, fuzzy
msgid ""
"```\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"[package]\n"
"    name = \"hello_scarb\"\n"
"    version = \"0.1.0\"\n"
"\n"
"    # See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"    [dependencies]\n"
"    # foo = { path = \"vendor/foo\" }"

#: src/ch02-03-scarb.md:114
#, fuzzy
msgid "Building a Scarb Project"
msgstr "# ç¼–è¯‘Scarbé¡¹ç›®"

#: src/ch02-03-scarb.md:116
msgid "Clear all content in `src/lib.cairo` and replace with the following:"
msgstr "åˆ é™¤ `src/lib.cairo` ä¸­çš„æ‰€æœ‰å†…å®¹ï¼Œå¹¶æ›¿æ¢ä¸ºä»¥ä¸‹å†…å®¹ï¼š"

#: src/ch02-03-scarb.md:118
#, fuzzy
msgid ""
"```\n"
"// src/lib.cairo\n"
"mod hello_scarb;\n"
"```"
msgstr ""
"// src/lib.cairo\n"
"    mod hello_scarb;"

#: src/ch02-03-scarb.md:121
#, fuzzy
msgid "Next, create a new file titled `src/hello_scarb.cairo` and add the following:"
msgstr "æ¥ä¸‹æ¥ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `src/hello_scarb.cairo` çš„æ–°æ–‡ä»¶ï¼Œå¹¶æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š"

#: src/ch02-03-scarb.md:124
#, fuzzy
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use debug::PrintTrait;\n"
"    fn main() {\n"
"        'Hello, Scarb!'.print();\n"
"    }"

#: src/ch02-03-scarb.md:130
#, fuzzy
msgid ""
"In this instance, the `lib.cairo` file contains a module declaration referencing _hello_scarb_, which includes the _hello_scarb.cairo_ fileâ€™s implementation. For more on modules, imports, and the `lib."
"cairo` file, please refer to the cairo-book on [Managing Cairo Projects in Chapter 7](https://book.cairo-lang.org/ch07-00-managing-cairo-projects-with-packages-crates-and-modules.html)."
msgstr ""
"åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`lib.cairo`æ–‡ä»¶åŒ…å«äº†å¼•ç”¨ _hello_scarb_ çš„æ¨¡å—å£°æ˜ï¼Œå…¶ä¸­åŒ…å«äº† _hello_scarb.cairo_ æ–‡ä»¶çš„å®ç°ã€‚æœ‰å…³æ¨¡å—ã€å¯¼å…¥å’Œ`lib.cairo`æ–‡ä»¶çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…[ç¬¬2ç« é‡Œçš„ å¯¼å…¥ ](https://book.starknet.io/"
"chapter_2/imports.html)ã€‚"

#: src/ch02-03-scarb.md:136
#, fuzzy
msgid "Scarb mandates that your source files be located within the `src` directory."
msgstr "Scarb è¦æ±‚ä»£ç æºæ–‡ä»¶åº”ä½äº `src` ç›®å½•ä¸­ã€‚"

#: src/ch02-03-scarb.md:139
#, fuzzy
msgid "To build (compile) your project from your `hello_scarb` directory, use the following command:"
msgstr "è¦åœ¨ `hello_scarb` ç›®å½•ä¸­æ„å»ºï¼ˆç¼–è¯‘ï¼‰é¡¹ç›®ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-03-scarb.md:144
#, fuzzy
msgid ""
"This command compiles your project and produces the Sierra code in the `target/dev/hello_scarb.sierra.json` file. Sierra serves as an intermediate layer between high-level Cairo and compilation "
"targets such as Cairo Assembly (CASM). To understand more about Sierra, check out this [article](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)."
msgstr ""
"è¯¥å‘½ä»¤å¯ç¼–è¯‘é¡¹ç›®å¹¶åœ¨ `target/dev/hello_scarb.sierra` æ–‡ä»¶ä¸­ç”Ÿæˆ Sierra ä»£ç ã€‚Sierra æ˜¯é«˜çº§ Cairo å’Œç¼–è¯‘ç›®æ ‡ï¼ˆå¦‚ Cairo Assembly (CASM)ï¼‰ä¹‹é—´çš„ä¸­é—´å±‚ã€‚è¦äº†è§£æœ‰å…³ Sierra çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…æ­¤ [æ–‡ç« ]"
"(https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)ã€‚"

#: src/ch02-03-scarb.md:150
#, fuzzy
msgid "To remove the build artifacts and delete the target directory, use the `scarb clean` command."
msgstr "è¦ç§»é™¤ç¼–è¯‘æˆæœå¹¶åˆ é™¤ç›®æ ‡ç›®å½•ï¼Œè¯·ä½¿ç”¨ `scarb clean` å‘½ä»¤ã€‚"

#: src/ch02-03-scarb.md:153
#, fuzzy
msgid "Adding Dependencies"
msgstr "## æ·»åŠ ä¾èµ–é¡¹"

#: src/ch02-03-scarb.md:155
#, fuzzy
msgid "Scarb facilitates the seamless management of dependencies for your Cairo packages. Here are two methods to add dependencies to your project:"
msgstr "Scarb å¯ä»¥å¸®åŠ©ä½ æ— ç¼ç®¡ç† Cairo è½¯ä»¶åŒ…çš„ä¾èµ–å…³ç³»ã€‚ä»¥ä¸‹æ˜¯ä¸ºé¡¹ç›®æ·»åŠ ä¾èµ–åŒ…çš„ä¸¤ç§æ–¹æ³•ï¼š"

#: src/ch02-03-scarb.md:158
#, fuzzy
msgid "Edit Scarb.toml File"
msgstr "ç¼–è¾‘ Scarb.toml æ–‡ä»¶"

#: src/ch02-03-scarb.md:160
#, fuzzy
msgid ""
"Open the Scarb.toml file in your project directory and locate the `[dependencies]` section. If it doesnâ€™t exist, add it. To include a dependency hosted on a Git repository, use the following format:"
msgstr "æ‰“å¼€é¡¹ç›®ç›®å½•ä¸­çš„ Scarb.toml æ–‡ä»¶ï¼Œæ‰¾åˆ°`[dependencies]`éƒ¨åˆ†ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œè¯·æ·»åŠ ã€‚è¦åŒ…å«æ‰˜ç®¡åœ¨ Git ä»“åº“ä¸­çš„ä¾èµ–é¡¹ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹æ ¼å¼ï¼š"

#: src/ch02-03-scarb.md:164
#, fuzzy
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }\n"
"```"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\" }"

#: src/ch02-03-scarb.md:167
#, fuzzy
msgid "For consistency, itâ€™s recommended to pin Git dependencies to specific commits. This can be done by adding the `rev` field with the commit hash:"
msgstr "ä¸ºä¿æŒä¸€è‡´æ€§ï¼Œå»ºè®®å°† Git ä¾èµ–é¡¹å›ºå®šåœ¨æŸä¸ªç‰¹å®šæäº¤ä¸Šã€‚è¿™å¯ä»¥é€šè¿‡æ·»åŠ å¸¦æœ‰æäº¤å“ˆå¸Œå€¼çš„ `rev` å­—æ®µæ¥å®ç°ï¼š"

#: src/ch02-03-scarb.md:171
#, fuzzy
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }\n"
"```"
msgstr ""
"[dependencies]\n"
"    alexandria_math = { git = \"https://github.com/keep-starknet-strange/alexandria.git\", rev = \"81bb93c\" }"

#: src/ch02-03-scarb.md:174
msgid "After adding the dependency, remember to save the file."
msgstr "æ·»åŠ ä¾èµ–é¡¹åï¼Œè®°å¾—ä¿å­˜æ–‡ä»¶ã€‚"

#: src/ch02-03-scarb.md:176
#, fuzzy
msgid "Use the scarb add Command"
msgstr "- ä½¿ç”¨ scarb add å‘½ä»¤"

#: src/ch02-03-scarb.md:178
#, fuzzy
msgid "Alternatively, you can use the `scarb add` command to add dependencies to your project. Open your terminal and execute the following command:"
msgstr "æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ `scarb add` å‘½ä»¤ä¸ºé¡¹ç›®æ·»åŠ ä¾èµ–é¡¹ã€‚æ‰“å¼€ç»ˆç«¯å¹¶æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-03-scarb.md:181
#, fuzzy
msgid ""
"```\n"
"$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git\n"
"```"
msgstr "$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/alexandria.git"

#: src/ch02-03-scarb.md:183
#, fuzzy
msgid "This command will add the alexandria_math dependency from the specified Git repository to your project."
msgstr "è¿™æ¡å‘½ä»¤ä¼šå°†æŒ‡å®š Git ä»“åº“ä¸­çš„ alexandria_math å¤–éƒ¨ä¾èµ–é¡¹æ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚"

#: src/ch02-03-scarb.md:186
msgid "To remove a dependency, you can use the `scarb rm` command."
msgstr "è¦åˆ é™¤ä¾èµ–é¡¹ï¼Œå¯ä»¥ä½¿ç”¨ `scarb rm` å‘½ä»¤ã€‚"

#: src/ch02-03-scarb.md:188
#, fuzzy
msgid "Once a dependency is added, the Scarb.toml file will be automatically updated with the new dependency information."
msgstr "ä¸€æ—¦æ·»åŠ äº†ä¾èµ–é¡¹ï¼ŒScarb.toml æ–‡ä»¶å°±ä¼šè‡ªåŠ¨æ›´æ–°ï¼ŒåŠ å…¥æ–°çš„ä¾èµ–é¡¹ä¿¡æ¯ã€‚"

#: src/ch02-03-scarb.md:191
#, fuzzy
msgid "Using Dependencies in Your Code"
msgstr "## åœ¨ä»£ç ä¸­ä½¿ç”¨ä¾èµ–é¡¹"

#: src/ch02-03-scarb.md:193
#, fuzzy
msgid "After dependencies are added to your project, you can start utilizing them in your Cairo code."
msgstr "å°†ä¾èµ–é¡¹æ·»åŠ åˆ°é¡¹ç›®ä¸­åï¼Œå°±å¯ä»¥å¼€å§‹åœ¨ Cairo ä»£ç ä¸­ä½¿ç”¨å®ƒä»¬äº†ã€‚"

#: src/ch02-03-scarb.md:196
#, fuzzy
msgid "For example, letâ€™s assume you have added the alexandria_math dependency. Now, you can import and utilize functions from the alexandria_math library in your `src/hello_scarb.cairo` file:"
msgstr "ä¾‹å¦‚ï¼Œå‡è®¾ä½ å·²ç»æ·»åŠ äº† alexandria_math ä¾èµ–é¡¹ã€‚ç°åœ¨ï¼Œä½ å¯ä»¥åœ¨ä½ çš„ `src/hello_scarb.cairo` æ–‡ä»¶ä¸­å¯¼å…¥å¹¶ä½¿ç”¨ alexandria_math åº“ä¸­çš„å‡½æ•°ï¼š"

#: src/ch02-03-scarb.md:200
#, fuzzy
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use alexandria_math::fibonacci;\n"
"\n"
"fn main() -> felt252 {\n"
"    fibonacci::fib(0, 1, 10)\n"
"}\n"
"```"
msgstr ""
"// src/hello_scarb.cairo\n"
"    use alexandria_math::fibonacci;\n"
"\n"
"    fn main() -> felt252 {\n"
"        fibonacci::fib(0, 1, 10)\n"
"    }"

#: src/ch02-03-scarb.md:207
#, fuzzy
msgid "In the above example, we import the fibonacci function from the alexandria_math library and utilize it in the main function."
msgstr "åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬ä» alexandria_math åº“ä¸­å¯¼å…¥äº† fibonacci å‡½æ•°ï¼Œå¹¶åœ¨ä¸»å‡½æ•°ä¸­ä½¿ç”¨äº†å®ƒã€‚"

#: src/ch02-03-scarb.md:210
#, fuzzy
msgid "Scarb Cheat Sheet"
msgstr "# Scarb Cheat Sheet"

#: src/ch02-03-scarb.md:212
#, fuzzy
msgid "Hereâ€™s a quick cheat sheet of some of the most commonly used Scarb commands:"
msgstr "ä¸‹é¢æ˜¯ä¸€äº›æœ€å¸¸ç”¨çš„ Scarb å‘½ä»¤çš„cheat sheetï¼š"

#: src/ch02-03-scarb.md:215
msgid "`scarb new <project_name>`: Initialize a new project with the given project name."
msgstr ""

#: src/ch02-03-scarb.md:218
msgid "`scarb build`: Compile your Cairo code into Sierra code."
msgstr ""

#: src/ch02-03-scarb.md:220
msgid "`scarb add <dependency> --git <repository>`: Add a dependency to your project from a specified Git repository."
msgstr ""

#: src/ch02-03-scarb.md:223
msgid "`scarb rm <dependency>`: Remove a dependency from your project."
msgstr ""

#: src/ch02-03-scarb.md:225
msgid "`scarb run <script>`: Run a custom script defined in your `Scarb.toml` file."
msgstr ""

#: src/ch02-03-scarb.md:228
msgid "What is new since version 2.3.0"
msgstr ""

#: src/ch02-03-scarb.md:230
msgid "JSON containing Sierra code of Starknet contract class becomes: `contract.contract_class.json`."
msgstr ""

#: src/ch02-03-scarb.md:231
msgid "JSON containing CASM code of Starknet contract class becomes: `contract.compiled_contract_class.json`."
msgstr ""

#: src/ch02-03-scarb.md:232
msgid ""
"Now cairo supports `Components`. They are modular add-ons encapsulating reusable logic, storage, and events that can be incorporated into multiple contracts. They can be used to extend a contract's "
"functionality, without having to reimplement the same logic over and over again."
msgstr ""

#: src/ch02-03-scarb.md:234
#, fuzzy
msgid "Project using Components"
msgstr "ä¸»è¦ç»„æˆéƒ¨åˆ†ï¼š"

#: src/ch02-03-scarb.md:236
msgid ""
"One of the most important features since `scarb 2.3.0` version is `Components`. Think of components as Lego blocks. They allow you to enrich your contracts by plugging in a module that you or someone "
"else wrote."
msgstr ""

#: src/ch02-03-scarb.md:238
msgid ""
"Lets see and example. Recover our project from [Testnet Deployment](./ch02-05-testnet-deployment.md) section. We used the `Ownable-Starknet` example to interact with the blockchain, now we are going "
"to use the same project, but we will refactor the code in order to use `components`"
msgstr ""

#: src/ch02-03-scarb.md:240
msgid "This is how our smart contract looks now"
msgstr ""

#: src/ch02-03-scarb.md:243
msgid "// ...rest of the code\n"
msgstr ""

#: src/ch02-03-scarb.md:349
msgid ""
"Basically we decided to apply `components` on the section related to `ownership` and created a separated module `ownable_component`. Then we kept the `data` section in our main module "
"`ownable_contract`."
msgstr ""

#: src/ch02-03-scarb.md:351
#, fuzzy
msgid ""
"To get the full implementation of this project, navigate to the `src/` directory in the [examples/Ownable-Components](https://github.com/starknet-edu/starknetbook/tree/main/examples/Ownable-Starknet) "
"directory of the Starknet Book repo. The `src/lib.cairo` file contains the contract to practice with."
msgstr ""
"è¦å¼€å§‹å­¦ä¹ ï¼Œè¯·å¯¼èˆªåˆ°Starknetä¹‹ä¹¦ githubä»“åº“çš„ [ç¬¬ä¸€ç« ](https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts) ä¸­çš„ `contracts/` ç›®å½•ã€‚`src/lib.cairo` æ–‡"
"ä»¶åŒ…å«ä¸€ä¸ªåŸºæœ¬åˆçº¦ï¼Œå¯ä¾›ç»ƒä¹ ã€‚"

#: src/ch02-03-scarb.md:353
msgid "After you get the full code on your machine, open your terminal, input `scarb build` to compile it, deploy your contract and call functions."
msgstr ""

#: src/ch02-03-scarb.md:355
#, fuzzy
msgid ""
"You can learn more about components in [Chapter 16 of The Cairo Book](https://book.cairo-lang.org/ch15-02-composability-and-components.html?highlight=ownable%20componen#example-an-ownable-component)."
msgstr ""
"åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæ„é€ å‡½æ•°æœŸæœ›å¾—åˆ°ä¸€ä¸ª _owner_ åœ°å€ã€‚å…³äºæ„é€ å‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [Cairoä¹‹ä¹¦ ç¬¬12ç« ](<https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-"
"constructors>)ã€‚"

#: src/ch02-03-scarb.md:357
#, fuzzy
msgid ""
"Scarb is a versatile tool, and this is just the beginning of what you can achieve with it. As you gain more experience in the Cairo language and the Starknet platform, youâ€™ll discover how much more "
"you can do with Scarb."
msgstr "Scarb æ˜¯ä¸€ä¸ªå¤šåŠŸèƒ½å·¥å…·ï¼Œä¸Šé¢çš„æ•™ç¨‹åªæ˜¯ä¸€ä¸ªå¼€å§‹ï¼Œè¿™è¿™äº›ä»…ä»…åªæ˜¯å®ƒæ‰€èƒ½å®ç°åŠŸèƒ½çš„ä¸€å°éƒ¨åˆ†ã€‚éšç€æ‚¨åœ¨Cairoè¯­è¨€å’ŒStarknetå¹³å°ä¸Šè·å¾—æ›´å¤šçš„ç»éªŒï¼Œæ‚¨ä¼šå‘ç° Scarb èƒ½ä¸ºæ‚¨åšæ›´å¤šçš„äº‹æƒ…ã€‚"

#: src/ch02-03-scarb.md:362
#, fuzzy
msgid "To stay updated on Scarb and its features, be sure to check the [official Scarb documentation](https://docs.swmansion.com/scarb/docs.html) regularly. Happy coding!"
msgstr "è¦äº†è§£ Scarb åŠå…¶åŠŸèƒ½çš„æœ€æ–°æƒ…å†µï¼Œè¯·åŠ¡å¿…å®šæœŸæŸ¥çœ‹ [Scarb å®˜æ–¹æ–‡æ¡£](https://docs.swmansion.com/scarb/docs.html)ã€‚ç¥æ‚¨ä»£ç å†™çš„æ„‰å¿«ï¼"

#: src/ch02-03-scarb.md:367 src/ch04-05-01-multicaller.md:605
msgid "The Book is a community-driven effort created for the community."
msgstr "è¿™æœ¬ä¹¦ç”±ç¤¾åŒºæ¨åŠ¨ï¼Œä¸ºç¤¾åŒºè€Œç”Ÿã€‚"

#: src/ch02-03-scarb.md:369 src/ch04-05-01-multicaller.md:607
#, fuzzy
msgid ""
"If youâ€™ve learned something, or not, please take a moment to provide feedback through [this 3-question survey](https://a.sprig.com/"
"WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)."
msgstr ""
"- å¦‚æœæ‚¨å­¦åˆ°äº†ä»€ä¹ˆï¼Œæˆ–è€…æ²¡æœ‰å­¦åˆ°ä»€ä¹ˆï¼Œè¯·èŠ±ç‚¹æ—¶é—´é€šè¿‡è¿™ä¸ª[3 ä¸ªé—®é¢˜çš„è°ƒæŸ¥è¡¨](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)æä¾›åé¦ˆæ„è§ã€‚\n"
"\n"
"- å¦‚æœæ‚¨å‘ç°ä»»ä½•é”™è¯¯æˆ–æœ‰å…¶ä»–å»ºè®®ï¼Œè¯·åœ¨Githubä»“åº“ä¸Šæ‰“å¼€ä¸€ä¸ª[issue](https://github.com/starknet-edu/starknetbook/issues)ã€‚"

#: src/ch02-03-scarb.md:373 src/ch04-05-01-multicaller.md:611
#, fuzzy
msgid "If you discover any errors or have additional suggestions, donâ€™t hesitate to open an [issue on our GitHub repository](https://github.com/starknet-edu/starknetbook/issues)."
msgstr ""
"- å¦‚æœæ‚¨å­¦åˆ°äº†ä»€ä¹ˆï¼Œæˆ–è€…æ²¡æœ‰å­¦åˆ°ä»€ä¹ˆï¼Œè¯·èŠ±ç‚¹æ—¶é—´é€šè¿‡è¿™ä¸ª[3 ä¸ªé—®é¢˜çš„è°ƒæŸ¥è¡¨](https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)æä¾›åé¦ˆæ„è§ã€‚\n"
"\n"
"- å¦‚æœæ‚¨å‘ç°ä»»ä½•é”™è¯¯æˆ–æœ‰å…¶ä»–å»ºè®®ï¼Œè¯·åœ¨Githubä»“åº“ä¸Šæ‰“å¼€ä¸€ä¸ª[issue](https://github.com/starknet-edu/starknetbook/issues)ã€‚"

#: src/ch02-04-katana.md:3
#, fuzzy
msgid ""
"`Katana` is designed to aid in local development. This creation by the [Dojo team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md) enables you to perform all Starknet-related "
"activities in a local environment, thus serving as an efficient platform for development and testing."
msgstr ""
"`Katana` is designed to aid in local development.\n"
"This creation by the [Dojo\n"
"team](https://github.com/dojoengine/dojo/blob/main/crates/katana/README.md)\n"
"enables you to perform all Starknet-related activities in a local\n"
"environment, thus serving as an efficient platform for development and\n"
"testing."

#: src/ch02-04-katana.md:10
#, fuzzy
msgid ""
"We suggest employing either `katana` or `starknet-devnet` for testing your contracts, with the latter discussed in another subchapter. The `starknet-devnet` is a public testnet, maintained by the "
"[Shard Labs team](https://github.com/0xSpaceShard/starknet-devnet-rs). Both these tools offer an effective environment for development and testing."
msgstr ""
"æˆ‘ä»¬å»ºè®®ä½¿ç”¨ `katana` æˆ– `starknet-devnet` \"æ¥æµ‹è¯•ä½ çš„åˆçº¦ï¼Œåè€…å°†åœ¨ä¸‹ä¸€ç« ä¸­è¯¦ç»†è®¨è®ºã€‚`starknet-devnet`æ˜¯ä¸€ä¸ªå…¬å…±æµ‹è¯•ç½‘ç»œï¼Œç”±[Shard Labs team](https://github.com/Shard-Labs/starknet-devnet)ç»´æŠ¤ã€‚è¿™ä¸¤"
"ç§å·¥å…·éƒ½ä¸ºå¼€å‘å’Œæµ‹è¯•æä¾›äº†æœ‰æ•ˆçš„ç¯å¢ƒã€‚"

#: src/ch02-04-katana.md:16
#, fuzzy
msgid ""
"For an example of how to use `katana` to deploy and interact with a contract, see the introduction subchapter of this Chapter or a voting contract example in [The Cairo Book](https://book.cairo-lang."
"org/ch99-01-04-01-voting-contract.html)."
msgstr "æœ‰å…³å¦‚ä½•ä½¿ç”¨ `katana` æ¥éƒ¨ç½²åˆçº¦å¹¶ä¸ä¹‹äº¤äº’çš„ç¤ºä¾‹ï¼Œè¯·å‚é˜…æœ¬ç« çš„ä»‹ç»åˆ†ç« æˆ– [Cairoä¹‹ä¹¦](https://book.cairo-lang.org/zh-cn/ch99-01-04-01-voting-contract.html) ä¸­çš„æŠ•ç¥¨åˆåŒç¤ºä¾‹ã€‚"

#: src/ch02-04-katana.md:19
#, fuzzy
msgid "Understanding RPC in Starknet"
msgstr "## äº†è§£Starknetä¸­çš„ RPC"

#: src/ch02-04-katana.md:21
#, fuzzy
msgid ""
"Remote Procedure Call (RPC) establishes the communication between nodes in the Starknet network. Essentially, it allows us to interact with a node in the Starknet network. The RPC server is "
"responsible for receiving these calls."
msgstr "è¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼ˆRPCï¼‰å»ºç«‹äº†StarknetèŠ‚ç‚¹ä¹‹é—´çš„é€šä¿¡ã€‚ä»æœ¬è´¨ä¸Šè®²ï¼Œå®ƒå…è®¸æˆ‘ä»¬ä¸ Starknet ç½‘ç»œä¸­çš„èŠ‚ç‚¹è¿›è¡Œäº¤äº’ã€‚RPC æœåŠ¡å™¨è´Ÿè´£æ¥æ”¶è¿™äº›è°ƒç”¨ã€‚"

#: src/ch02-04-katana.md:26
#, fuzzy
msgid ""
"RPC can be obtained from various sources: . To support the decentralization of the Network, you can use your own local Starknet node. For ease of access, consider using a provider such as [Infura]"
"(https://docs.infura.io/networks/starknet/how-to) or [Alchemy](https://www.alchemy.com/starknet) to get an RPC client. For development and testing, a temporary local node such as `katana` can be used."
msgstr ""
"RPC å¯ä»å„ç§æ¥æºè·å–ï¼šä¸ºäº†æ”¯æŒç½‘ç»œçš„åˆ†æ•£åŒ–ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨è‡ªå·±çš„æœ¬åœ°StarknetèŠ‚ç‚¹ã€‚ä¸ºäº†ä¾¿äºè®¿é—®ï¼Œæ‚¨å¯è€ƒè™‘ä½¿ç”¨ [Infura](https://docs.infura.io/networks/starknet/how-to) æˆ– [Alchemy](https://www.alchemy.com/"
"starknet) ç­‰æä¾›å•†æ¥è·å– RPC å®¢æˆ·ç«¯ã€‚ä¸ºä¾¿äºå¼€å‘å’Œæµ‹è¯•ï¼Œå¯ä½¿ç”¨ä¸´æ—¶æœ¬åœ°èŠ‚ç‚¹ï¼ˆå¦‚ `katana`ï¼‰ã€‚"

#: src/ch02-04-katana.md:34
#, fuzzy
msgid "Getting Started with Katana"
msgstr "## å¼€å§‹ä½¿ç”¨Katana"

#: src/ch02-04-katana.md:51
msgid "To initialize a local Starknet node, execute the following command:"
msgstr "è¦åˆå§‹åŒ–æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-04-katana.md:57
#, fuzzy
msgid ""
"The `--accounts` flag determines the number of accounts to be created, while the `--seed` flag sets the seed for the private keys of these accounts. This ensures that initializing the node with the "
"same seed will always yield the same accounts."
msgstr "`--accounts` æ ‡å¿—å†³å®šè¦åˆ›å»ºçš„è´¦æˆ·æ•°é‡ï¼Œè€Œ `--seed` æ ‡å¿—åˆ™ä¸ºè¿™äº›è´¦æˆ·çš„ç§é’¥è®¾ç½®ç§å­ã€‚è¿™æ ·å¯ä»¥ç¡®ä¿ç”¨ç›¸åŒçš„ç§å­åˆå§‹åŒ–èŠ‚ç‚¹æ—¶ï¼Œæ€»æ˜¯ä¼šäº§ç”Ÿç›¸åŒçš„è´¦æˆ·ã€‚æœ€åï¼Œ\"--gas-price \"æ ‡å¿—æŒ‡å®šäº†äº¤æ˜“gasçš„ä»·æ ¼ã€‚"

#: src/ch02-04-katana.md:62
msgid "Running the command produces output similar to this:"
msgstr "è¿è¡Œè¯¥å‘½ä»¤ä¼šäº§ç”Ÿç±»ä¼¼ä¸‹é¢çš„è¾“å‡ºç»“æœï¼š"

#: src/ch02-04-katana.md:64
#, fuzzy
msgid ""
"```\n"
"â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n"
"â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\n"
"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n"
"â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\n"
"â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\n"
"â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•\n"
"\n"
"PREDEPLOYED CONTRACTS\n"
"==================\n"
"\n"
"| Contract        | Fee Token\n"
"| Address         | 0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\n"
"| Class Hash      | 0x02a8846878b6ad1f54f6ba46f5f40e11cee755c677f130b2c4b60566c9003f1f\n"
"\n"
"| Contract        | Universal Deployer\n"
"| Address         | 0x41a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf\n"
"| Class Hash      | 0x07b3e05f48f0c69e4a65ce5e076a66271a527aff2c34ce1083ec6e1526997a69\n"
"\n"
"| Contract        | Account Contract\n"
"| Class Hash      | 0x05400e90f7e0ae78bd02c77cd75527280470e2fe19c54970dd79dc37a9d3645c\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  0x2d71e9c974539bb3ffb4b115e66a23d0f62a641ea66c4016e903454c8753bbc\n"
"| Private key     |  0x33003003001800009900180300d206308b0070db00121318d17b5e6262150b\n"
"| Public key      |  0x4c0f884b8e5b4f00d97a3aad26b2e5de0c0c76a555060c837da2e287403c01d\n"
"\n"
"| Account address |  0x6162896d1d7ab204c7ccac6dd5f8e9e7c25ecd5ae4fcb4ad32e57786bb46e03\n"
"| Private key     |  0x1800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  0x2b191c2f3ecf685a91af7cf72a43e7b90e2e41220175de5c4f7498981b10053\n"
"\n"
"| Account address |  0x6b86e40118f29ebe393a75469b4d926c7a44c2e2681b6d319520b7c1156d114\n"
"| Private key     |  0x1c9053c053edf324aec366a34c6901b1095b07af69495bffec7d7fe21effb1b\n"
"| Public key      |  0x4c339f18b9d1b95b64a6d378abd1480b2e0d5d5bd33cd0828cbce4d65c27284\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"ğŸš€ JSON-RPC server started: http://0.0.0.0:5050\n"
"```"
msgstr ""
"â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—\n"
"    â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—\n"
"    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘\n"
"    â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘\n"
"    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘\n"
"    â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•  â•šâ•â•\n"
"\n"
"\n"
"    PREFUNDED ACCOUNTS\n"
"    ==================\n"
"\n"
"    | Account address |  0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"    | Private key     |  0x0300001800000000300000180000000000030000000000003006001800006600\n"
"    | Public key      |  0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"    | Account address |  0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"    | Private key     |  0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"    | Public key      |  0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"    | Account address |  0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"    | Private key     |  0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"    | Public key      |  0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"    ACCOUNTS SEED\n"
"    =============\n"
"    0\n"
"\n"
"\n"
"    ğŸš€ JSON-RPC server started: http://0.0.0.0:5050"

#: src/ch02-04-katana.md:106
#, fuzzy
msgid ""
"The output includes the addresses, private keys, and public keys of the created accounts. It also contains the seed used to generate the accounts. This seed can be reused to create identical accounts "
"in future runs. Additionally, the output provides the URL of the JSON-RPC server. This URL can be used to establish a connection to the local Starknet node."
msgstr ""
"è¾“å‡ºç»“æœåŒ…æ‹¬å·²åˆ›å»ºè´¦æˆ·çš„åœ°å€ã€ç§é’¥å’Œå…¬é’¥ã€‚å®ƒè¿˜åŒ…å«ç”¨äºç”Ÿæˆè´¦æˆ·çš„ç§å­ã€‚è¯¥ç§å­å¯é‡å¤ä½¿ç”¨ï¼Œä»¥ä¾¿åœ¨ä»¥åçš„è¿è¡Œä¸­åˆ›å»ºç›¸åŒçš„è´¦æˆ·ã€‚æ­¤å¤–ï¼Œè¾“å‡ºè¿˜æä¾›äº† JSON-RPC æœåŠ¡å™¨çš„ URLã€‚è¯¥ URL å¯ç”¨äºå»ºç«‹ä¸æœ¬åœ° Starknet èŠ‚ç‚¹"
"çš„è¿æ¥ã€‚"

#: src/ch02-04-katana.md:113
msgid "To stop the local Starknet node, simply press `Ctrl+C`."
msgstr "è¦åœæ­¢æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œåªéœ€æŒ‰`Ctrl+C`é”®ã€‚"

#: src/ch02-04-katana.md:115
#, fuzzy
msgid "The local Starknet node does not persist data. Hence, once itâ€™s stopped, all data will be erased."
msgstr "æœ¬åœ° Starknet èŠ‚ç‚¹ä¸ä¼šæ°¸ä¹…ä¿å­˜æ•°æ®ã€‚å› æ­¤ï¼Œä¸€æ—¦åœæ­¢è¿è¡Œï¼Œæ‰€æœ‰æ•°æ®éƒ½å°†è¢«æ¸…é™¤ã€‚"

#: src/ch02-04-katana.md:118
#, fuzzy
msgid "For a practical demonstration of `katana` to deploy and interact with a contract, see [Introduction: Starkli, Scarb and Katana](ch02-02-starkli-scarb-katana.md)."
msgstr "æœ‰å…³ `katana` éƒ¨ç½²åˆçº¦å¹¶ä¸ä¹‹äº¤äº’çš„å®é™…æ¼”ç¤ºï¼Œè¯·å‚é˜… [ç¬¬ 2 ç«  æŠ•ç¥¨åˆçº¦ç¤ºä¾‹](https://book.starknet.io/chapter_2/deploy_call_invoke.html)ã€‚"

#: src/ch02-05-testnet-deployment.md:3
msgid ""
"This chapter guides developers through the process of compiling, deploying, and interacting with a Starknet smart contract written in Cairo on the testnet. Earlier, the focus was on deploying "
"contracts using a local node, Katana. This time, the deployment and interaction target the Starknet testnet."
msgstr "æœ¬ç« å°†æŒ‡å¯¼å¼€å‘è€…åœ¨ testnet ä¸Šç¼–è¯‘ã€éƒ¨ç½²ç”¨Cairoç¼–å†™çš„Starknetæ™ºèƒ½åˆçº¦ï¼Œå¹¶ä¸ä¹‹äº¤äº’ã€‚å‰é¢çš„é‡ç‚¹æ˜¯ä½¿ç”¨æœ¬åœ°èŠ‚ç‚¹ Katana éƒ¨ç½²åˆçº¦ã€‚è¿™ä¸€æ¬¡ï¼Œéƒ¨ç½²å’Œäº¤äº’çš„ç›®æ ‡æ˜¯ Starknet æµ‹è¯•ç½‘ã€‚"

#: src/ch02-05-testnet-deployment.md:5
#, fuzzy
msgid "Ensure the following commands run successfully on your system. If not, see the [Basic Installation](./ch02-01-basic-installation.md) section:"
msgstr "ç¡®ä¿ä»¥ä¸‹å‘½ä»¤åœ¨ç³»ç»Ÿä¸ŠæˆåŠŸè¿è¡Œã€‚å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜… 'åŸºæœ¬å®‰è£…' éƒ¨åˆ†ï¼š"

#: src/ch02-05-testnet-deployment.md:14
#, fuzzy
msgid ""
"A smart wallet comprises a Signer and an Account Descriptor. The Signer is a smart contract with a private key for signing transactions, while the Account Descriptor is a JSON file detailing the "
"walletâ€™s address and public key."
msgstr "æ™ºèƒ½é’±åŒ…ç”±ç­¾åè€…å’Œè´¦æˆ·æè¿°ç¬¦ç»„æˆã€‚ç­¾åè€…æ˜¯ä¸€ä¸ªæ™ºèƒ½åˆçº¦ï¼Œå¸¦æœ‰ç”¨äºç­¾ç½²äº¤æ˜“çš„ç§é’¥ï¼Œè€Œè´¦æˆ·æè¿°ç¬¦æ˜¯ä¸€ä¸ª JSON æ–‡ä»¶ï¼Œè¯¦ç»†è¯´æ˜äº†é’±åŒ…çš„åœ°å€å’Œå…¬é’¥ã€‚"

#: src/ch02-05-testnet-deployment.md:19
#, fuzzy
msgid ""
"In order for an account to be used as a signer it must be deployed to the appropriate network, Starknet Goerli, Sepolia or mainnet, and funded. For this example we are going to use Goerli Testnet. To "
"deploy your wallet, visit [Smart Wallet Setup](./ch01-00-getting-started.html#smart-wallet-setup). Now youâ€™re ready to interact with Starknet smart contracts."
msgstr ""
"è¦å°†ä¸€ä¸ªè´¦æˆ·ç”¨ä½œç­¾åè€…ï¼Œè¯¥è´¦æˆ·å¿…é¡»éƒ¨ç½²åˆ°ç›¸åº”çš„ç½‘ç»œã€\n"
"æ˜Ÿç½‘ Goerli æˆ–ä¸»ç½‘ï¼Œå¹¶ä¸ºå…¶æä¾›èµ„é‡‘ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Goerli Testnetã€‚è¦éƒ¨ç½²ä½ çš„é’±åŒ…ï¼Œè¯·è®¿é—®[å…¥é—¨](ch01-00-getting-started.md)å¹¶æ‰¾åˆ° \"æ™ºèƒ½é’±åŒ…è®¾ç½® \"éƒ¨åˆ†ã€‚"

#: src/ch02-05-testnet-deployment.md:23
#, fuzzy
msgid "Creating a Signer"
msgstr "### åˆ›å»ºç­¾åè€…"

#: src/ch02-05-testnet-deployment.md:25
#, fuzzy
msgid "The Signer is an essential smart contract capable of signing transactions in Starknet. Youâ€™ll need the private key from your smart wallet to create one, from which the public key can be derived."
msgstr "ç­¾åè€…æ˜¯ä¸€ç§é‡è¦çš„æ™ºèƒ½åˆçº¦ï¼Œèƒ½å¤Ÿåœ¨Starknetä¸­ç­¾ç½²äº¤æ˜“ã€‚ä½ éœ€è¦ä»ä½ çš„æ™ºèƒ½é’±åŒ…ä¸­è·å–ç§é’¥æ¥åˆ›å»ºç­¾åè€…ï¼Œå¹¶ä»ä¸­è·å–å…¬é’¥ã€‚"

#: src/ch02-05-testnet-deployment.md:29
#, fuzzy
msgid "Starkli enables secure storage of your private key through a keystore file. This encrypted file can be accessed using a password and is generally stored in the default Starkli directory."
msgstr "Starkli å¯ä»¥é€šè¿‡å¯†é’¥å­˜å‚¨æ–‡ä»¶å®‰å…¨å­˜å‚¨ä½ çš„ç§äººå¯†é’¥ã€‚è¯¥åŠ å¯†æ–‡ä»¶å¯ä»¥é€šè¿‡å¯†ç è®¿é—®ï¼Œé€šå¸¸å­˜å‚¨åœ¨é»˜è®¤çš„ Starkli ç›®å½•ä¸­ã€‚"

#: src/ch02-05-testnet-deployment.md:33
msgid "First, create the default directory:"
msgstr "é¦–å…ˆï¼Œåˆ›å»ºé»˜è®¤ç›®å½•ï¼š"

#: src/ch02-05-testnet-deployment.md:39
#, fuzzy
msgid ""
"Then generate the keystore file. The signer command contains subcommands for creating a keystore file from a private key or completely create a new one. In this tutorial, weâ€™ll use the private key "
"option which is the most common use case. You need to provide the path to the keystore file you want to create. You can give any name to the keystore file, you will likely have several wallets. In "
"this tutorial, we will use the name `my_keystore_1.json`."
msgstr ""
"ç„¶åç”Ÿæˆå¯†é’¥å­˜å‚¨æ–‡ä»¶ã€‚ç­¾åè€…å‘½ä»¤åŒ…å«ä»ç§é’¥åˆ›å»ºå¯†é’¥å­˜å‚¨æ–‡ä»¶æˆ–å®Œå…¨åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶çš„å­å‘½ä»¤ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æœ€å¸¸ç”¨çš„ç§é’¥é€‰é¡¹ã€‚ä½ éœ€è¦æä¾›è¦åˆ›å»ºçš„å¯†é’¥å­˜å‚¨æ–‡ä»¶çš„è·¯å¾„ã€‚ä½ å¯ä»¥ç»™å¯†é’¥å­˜å‚¨æ–‡ä»¶èµ·ä»»ä½•åå­—ï¼Œå› "
"ä¸ºä½ å¯èƒ½ä¼šæœ‰å¤šä¸ªé’±åŒ…ã€‚åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `my_keystore_ 1.json`ã€‚"

#: src/ch02-05-testnet-deployment.md:53
#, fuzzy
msgid "In the private key prompt, paste the private key of your smart wallet. In the password prompt, enter a password of your choice. You will need this password to sign transactions using Starkli."
msgstr "åœ¨ç§é’¥æç¤ºç¬¦ä¸‹ï¼Œç²˜è´´æ™ºèƒ½é’±åŒ…çš„ç§é’¥ã€‚åœ¨å¯†ç æç¤ºä¸­ï¼Œè¾“å…¥ä½ é€‰æ‹©çš„å¯†ç ã€‚ä½¿ç”¨ Starkli ç­¾ç½²äº¤æ˜“æ—¶éœ€è¦è¿™ä¸ªå¯†ç ã€‚"

#: src/ch02-05-testnet-deployment.md:57
msgid "How to get the private key?"
msgstr ""

#: src/ch02-05-testnet-deployment.md:59
#, fuzzy
msgid ""
"Export the private key from your Braavos or Argent wallet. For Argent X, you can find it in the \"Settings\" section â†’ Select your Account â†’ \"Export Private Key\". For Braavos, you can find it in the "
"\"Settings\" section â†’ \"Privacy and Security\" â†’ \"Export Private Key\"."
msgstr "ä»æ‚¨çš„Braavosæˆ– Argent é’±åŒ…ä¸­å¯¼å‡ºç§é’¥ã€‚å¯¹äº Argent Xï¼Œå¯ä»¥åœ¨ \"è®¾ç½®\"â†’\"é€‰æ‹©è´¦æˆ·\"â†’\"å¯¼å‡ºç§é’¥ \"ä¸­æ‰¾åˆ°ã€‚å¯¹äºBraavosï¼Œæ‚¨å¯ä»¥åœ¨ \"è®¾ç½®\"â†’\"éšç§å’Œå®‰å…¨\"â†’\"å¯¼å‡ºç§äººå¯†é’¥ \"ä¸­æ‰¾åˆ°å®ƒã€‚"

#: src/ch02-05-testnet-deployment.md:64
#, fuzzy
msgid ""
"While knowing the private key of a smart wallet is necessary to sign transactions, itâ€™s not sufficient. We also need to inform Starkli about the signing mechanism employed by our smart wallet created "
"by Braavos or Argent X. Does it use an elliptic curve? If yes, which one? This is the reason why we need an account descriptor file."
msgstr "è™½ç„¶ç­¾ç½²äº¤æ˜“çš„å¿…è¦æ¡ä»¶æ˜¯éœ€è¦çŸ¥æ™“æ™ºèƒ½é’±åŒ…çš„ç§é’¥ï¼Œä½†è¿™è¿˜ä¸å¤Ÿã€‚æˆ‘ä»¬è¿˜éœ€è¦å‘ŠçŸ¥Starkliï¼Œç”± Braavos æˆ– Argent X åˆ›å»ºçš„æ™ºèƒ½é’±åŒ…æ‰€é‡‡ç”¨çš„ç­¾åæœºåˆ¶ã€‚å¦‚æœæ˜¯ï¼Œæ˜¯å“ªä¸€ç§ï¼Ÿè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦è´¦æˆ·æè¿°æ–‡ä»¶çš„åŸå› ã€‚"

#: src/ch02-05-testnet-deployment.md:70
#, fuzzy
msgid "\\[OPTIONAL\\] The Architecture of the Starknet Signer"
msgstr "#### [OPTIONAL] Starknetç­¾åè€…çš„æ¶æ„"

#: src/ch02-05-testnet-deployment.md:72
msgid "This section is optional and is intended for those who want to learn more about the Starknet Signer. If you are not interested in the details, you can skip it."
msgstr "æœ¬èŠ‚ä¸ºå¯é€‰å†…å®¹ï¼Œä¾›å¸Œæœ›è¿›ä¸€æ­¥äº†è§£Starknetç­¾åè€…çš„ç”¨æˆ·ä½¿ç”¨ã€‚å¦‚æœå¯¹ç»†èŠ‚ä¸æ„Ÿå…´è¶£ï¼Œå¯ä»¥è·³è¿‡ã€‚"

#: src/ch02-05-testnet-deployment.md:74
#, fuzzy
msgid "The Starknet Signer plays an instrumental role in securing your transactions. Letâ€™s demystify what goes on under the hood."
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch02-05-testnet-deployment.md:77
msgid "Key Components:"
msgstr "ä¸»è¦ç»„æˆéƒ¨åˆ†ï¼š"

#: src/ch02-05-testnet-deployment.md:79
msgid "**Private Key**: A 256-bit/32-byte/64-character (ignoring the _0x_ prefix) hexadecimal key that is the cornerstone of your walletâ€™s security."
msgstr ""

#: src/ch02-05-testnet-deployment.md:83
msgid "**Public Key**: Derived from the private key, itâ€™s also a 256-bit/32-byte/64-character hexadecimal key."
msgstr ""

#: src/ch02-05-testnet-deployment.md:86
#, fuzzy
msgid ""
"**Smart Wallet Address**: Unlike Ethereum, the address here is influenced by the public key, class hash, and a salt. **[Learn more in Starknet Documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-address/)**."
msgstr ""
"1.  **ç§é’¥**ï¼š256 ä½/32 å­—èŠ‚/64 ä¸ªå­—ç¬¦ï¼ˆå¿½ç•¥ _0x_\n"
"    å‰ç¼€ï¼‰çš„åå…­è¿›åˆ¶å¯†é’¥ï¼Œå®ƒæ˜¯é’±åŒ…å®‰å…¨çš„åŸºçŸ³ã€‚\n"
"\n"
"2.  **å…¬é’¥**ï¼šæºè‡ªç§é’¥ï¼Œä¹Ÿæ˜¯ä¸€ä¸ª\n"
"    256 ä½/32 å­—èŠ‚/64 ä¸ªå­—ç¬¦çš„åå…­è¿›åˆ¶å¯†é’¥ã€‚\n"
"\n"
"3.  **æ™ºèƒ½é’±åŒ…åœ°å€**ï¼šä¸ä»¥å¤ªåŠä¸åŒï¼Œè¿™é‡Œçš„åœ°å€\n"
"    å—å…¬é’¥ã€class hashå’Œsaltçš„å½±å“ã€‚\n"
"    ** åœ¨[Starknet æ–‡æ¡£](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-address/) äº†è§£æ›´å¤š**ã€‚"

#: src/ch02-05-testnet-deployment.md:91
msgid "To view the details of the previously created keystore file:"
msgstr "æŸ¥çœ‹å…ˆå‰åˆ›å»ºçš„å¯†é’¥å­˜å‚¨æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯ï¼š"

#: src/ch02-05-testnet-deployment.md:97
msgid "Anatomy of the `keystore.json` File:"
msgstr "`keystore.json` æ–‡ä»¶çš„å‰–æï¼š"

#: src/ch02-05-testnet-deployment.md:101
msgid "\"crypto\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:102
msgid "\"cipher\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:102
msgid "\"aes-128-ctr\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:103
msgid "\"cipherparams\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:104
msgid "\"iv\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:104
msgid "\"dba5f9a67456b121f3f486aa18e24db7\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:106
msgid "\"ciphertext\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:106
msgid "\"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:107
msgid "\"kdf\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:107
msgid "\"scrypt\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:108
msgid "\"kdfparams\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:109
msgid "\"dklen\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:110
msgid "\"n\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:111
msgid "\"p\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:112
msgid "\"r\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:113 src/ch04-03-01-deploy-standard-account.md:101 src/ch04-03-01-deploy-standard-account.md:149
msgid "\"salt\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:113
msgid "\"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:115
msgid "\"mac\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:115
msgid "\"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:117 src/ch03-02-01-madara.md:354
msgid "\"id\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:117
msgid "\"afbb9007-8f61-4e62-bf14-e491c30fd09a\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:118 src/ch02-05-testnet-deployment.md:257 src/ch02-05-testnet-deployment.md:260 src/ch04-03-01-deploy-standard-account.md:91
#: src/ch04-03-01-deploy-standard-account.md:94 src/ch04-03-01-deploy-standard-account.md:139 src/ch04-03-01-deploy-standard-account.md:142
msgid "\"version\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:122
msgid "**`version`**: The version of the smart wallet implementation."
msgstr ""

#: src/ch02-05-testnet-deployment.md:124
msgid "**`id`**: A randomly generated identification string."
msgstr ""

#: src/ch02-05-testnet-deployment.md:126
msgid "**`crypto`**: Houses all encryption details."
msgstr ""

#: src/ch02-05-testnet-deployment.md:128
msgid "Inside **`crypto`**:"
msgstr "åœ¨ **`crypto`** å†…éƒ¨:"

#: src/ch02-05-testnet-deployment.md:130
msgid "**`cipher`**: Specifies the encryption algorithm used, which in this case is AES-128-CTR."
msgstr ""

#: src/ch02-05-testnet-deployment.md:133
msgid "**AES (Advanced Encryption Standard)**: A globally accepted encryption standard."
msgstr ""

#: src/ch02-05-testnet-deployment.md:136
msgid "**128**: Refers to the key size in bits, making it a 128-bit key."
msgstr ""

#: src/ch02-05-testnet-deployment.md:139
msgid "**CTR (Counter Mode)**: A specific mode of operation for the AES cipher."
msgstr ""

#: src/ch02-05-testnet-deployment.md:142
msgid "**`cipherparams`**: Contains an Initialization Vector (IV), which ensures that encrypting the same plaintext with the same key will produce different ciphertexts."
msgstr ""

#: src/ch02-05-testnet-deployment.md:146
msgid "**`iv` (Initialization Vector)**: A 16-byte hex string that serves as a random and unique starting point for each encryption operation."
msgstr ""

#: src/ch02-05-testnet-deployment.md:150
msgid "**`ciphertext`**: This is the private key after encryption, securely stored so that only the correct password can reveal it."
msgstr ""

#: src/ch02-05-testnet-deployment.md:153
msgid "**`kdf` and `kdfparams`**: KDF stands for Key Derivation Function. This adds a layer of security by requiring computational work, making brute-force attacks harder."
msgstr ""

#: src/ch02-05-testnet-deployment.md:157
msgid "**`dklen`**: The length (in bytes) of the derived key. Typically 32 bytes."
msgstr ""

#: src/ch02-05-testnet-deployment.md:160
msgid "**`n`**: A cost factor representing CPU/memory usage. A higher value means more computational work is needed, thus increasing security."
msgstr ""

#: src/ch02-05-testnet-deployment.md:164
msgid "**`p`**: Parallelization factor, affecting the computational complexity."
msgstr ""

#: src/ch02-05-testnet-deployment.md:167
msgid "**`r`**: Block size for the hash function, again affecting computational requirements."
msgstr ""

#: src/ch02-05-testnet-deployment.md:170
msgid "**`salt`**: A random value that is combined with the password to deter dictionary attacks."
msgstr ""

#: src/ch02-05-testnet-deployment.md:173
msgid ""
"**`mac` (Message Authentication Code)**: This is a cryptographic code that ensures the integrity of the message (the encrypted private key in this case). It is generated using a hash of both the "
"ciphertext and a portion of the derived key."
msgstr ""

#: src/ch02-05-testnet-deployment.md:178
msgid "Before to continue, we have to choose a rpc provider"
msgstr ""

#: src/ch02-05-testnet-deployment.md:180
#, fuzzy
msgid "Choosing an RPC Provider"
msgstr "### é€‰æ‹© RPC æä¾›å•†"

#: src/ch02-05-testnet-deployment.md:182
msgid "There are three main options for RPC providers, sorted by ease of use:"
msgstr "ä½ ä¸»è¦æœ‰ä¸‰ç§RPC æä¾›å•†å¯ä¾›é€‰æ‹©ï¼ŒæŒ‰æ˜“ç”¨æ€§æ’åºï¼š"

#: src/ch02-05-testnet-deployment.md:184
msgid ""
"**Infura or Alchemy**: A step up in complexity. Youâ€™ll need to set up an API key and choose an endpoint. For Infura, it would look like `https://starknet-sepolia.infura.io/v3/<API_KEY>`. Learn more in "
"the [Infura documentation](https://docs.infura.io/networks/starknet/how-to/choose-a-network)."
msgstr ""

#: src/ch02-05-testnet-deployment.md:190
msgid ""
"**Your Own Node**: For those who want full control. Itâ€™s the most complex but offers the most freedom. Check out [Chapter 3 of the Starknet Book](./ch03-00-architecture.html#nodes) or [Kasar](https://"
"www.kasar.io/) for setup guides."
msgstr ""

#: src/ch02-05-testnet-deployment.md:195
msgid ""
"**Free RPC vendor**: These 3 networks are eligible for free RPC vendors: mainet, goerli, sepolia. You can choose [Blast](https://blastapi.io/public-api/starknet) or [Nethermind](https://data.voyager."
"online/)"
msgstr ""

#: src/ch02-05-testnet-deployment.md:198
#, fuzzy
msgid "Creating an Account Descriptor"
msgstr "### åˆ›å»ºè´¦æˆ·æè¿°ç¬¦"

#: src/ch02-05-testnet-deployment.md:200
#, fuzzy
msgid ""
"An Account Descriptor informs Starkli about your smart walletâ€™s unique features, such as its signing mechanism. You can generate this descriptor using Starkliâ€™s `fetch` subcommand under the `account` "
"command. The `fetch` subcommand takes your on-chain wallet address as input and generates the account descriptor file. The account descriptor file is a JSON file that contains the details of your "
"smart wallet. We also have to pass the rpc provider here."
msgstr ""
"è´¦æˆ·æè¿°ç¬¦ï¼ˆAccount Descriptorï¼‰ä¼šå‘ŠçŸ¥ Starkli ä½ çš„æ™ºèƒ½é’±åŒ…çš„ç‹¬ç‰¹åŠŸèƒ½ï¼Œæ¯”å¦‚å®ƒçš„ç­¾åæœºåˆ¶ã€‚ä½ å¯ä»¥ä½¿ç”¨ Starkli `account` å‘½ä»¤ä¸‹çš„ `fetch` å­å‘½ä»¤æ¥ç”Ÿæˆè¿™ä¸ªæè¿°ç¬¦ã€‚`fetch`å­å‘½ä»¤å°†ä½ çš„é“¾ä¸Šé’±åŒ…åœ°å€ä½œä¸ºè¾“å…¥ï¼Œ"
"å¹¶ç”Ÿæˆè´¦æˆ·æè¿°æ–‡ä»¶ã€‚è´¦æˆ·æè¿°æ–‡ä»¶æ˜¯ä¸€ä¸ª JSON æ–‡ä»¶ï¼ŒåŒ…å«äº†ä½ çš„æ™ºèƒ½é’±åŒ…çš„è¯¦ç»†ä¿¡æ¯ã€‚"

#: src/ch02-05-testnet-deployment.md:211
msgid ""
"Note: Here we used the Public RPC Endpoint v0.6 Starknet (Goerli) Testnet from **Blast**. If you don't specify the rpc provider, Starkli will use Goerli, which will be deprecated in the upcoming "
"months. Thus you can check the rpc url for Sepolia network on [Blast](https://blastapi.io/public-api/starknet)."
msgstr ""

#: src/ch02-05-testnet-deployment.md:213
msgid "âš ï¸ **Contract not found?**"
msgstr ""

#: src/ch02-05-testnet-deployment.md:215
msgid "In case you face an error like this:"
msgstr "å¦‚æœæ‚¨é‡åˆ°è¿™æ ·çš„é”™è¯¯ï¼š"

#: src/ch02-05-testnet-deployment.md:221
msgid "ğŸŸ© Solution:"
msgstr ""

#: src/ch02-05-testnet-deployment.md:223
#, fuzzy
msgid ""
"It means you probably just created a new wallet and it has **not been deployed yet**. To accomplish this you have to fund your wallet with tokens and **transfer tokens** to a **different** wallet "
"address. For goerli tokens you can check this [faucet](https://faucet.goerli.starknet.io/). For Sepolia tokens detailed intructons can be found in the [Get Sepolia Tokens](./ch02-05-01-start-with-"
"sepolia.md) section."
msgstr ""
"è¿™æ„å‘³ç€æ‚¨å¯èƒ½åˆšåˆšåˆ›å»ºäº†ä¸€ä¸ªæ–°é’±åŒ…ï¼Œä½†å°šæœªéƒ¨ç½²ã€‚ä¸ºæ­¤ï¼Œæ‚¨å¿…é¡»ä¸ºé’±åŒ…æ³¨å…¥ä»£å¸èµ„é‡‘ï¼Œå¹¶å°†ä»£å¸è½¬ç§»åˆ°ä¸åŒçš„é’±åŒ…åœ°å€ã€‚å®Œæˆæ­¤è¿‡ç¨‹åï¼Œåœ¨æ˜Ÿç½‘æµè§ˆå™¨ä¸­æœç´¢ä½ çš„é’±åŒ…åœ°å€ã€‚è¦æŸ¥çœ‹è¯¦æƒ…ï¼Œè¯·è¿”å›[å…¥é—¨](ch01-00-getting-"
"started.md)å¹¶æ‰¾åˆ° \"æ™ºèƒ½é’±åŒ…è®¾ç½® \"éƒ¨åˆ†ã€‚"

#: src/ch02-05-testnet-deployment.md:225
msgid "**Still doesn't work?**"
msgstr ""

#: src/ch02-05-testnet-deployment.md:227
msgid "Check if your wallet's testnet network isn't yet set with Goerli or Sepolia, try again with your blast rpc url."
msgstr ""

#: src/ch02-05-testnet-deployment.md:233
msgid "âš ï¸ And if you use Goerli, make sure you use it in subsequent commands as well."
msgstr ""

#: src/ch02-05-testnet-deployment.md:235
msgid "After this process, search your wallet address on the Starknet explorer. To see the details, go back to [Smart Wallet Setup](./ch01-00-getting-started.html#smart-wallet-setup)."
msgstr ""

#: src/ch02-05-testnet-deployment.md:237
#, fuzzy
msgid "After running the command, youâ€™ll see a message like the one below. Weâ€™re using a Braavos wallet as an example, but the steps are the same for an Argent wallet."
msgstr "è¿è¡Œè¯¥å‘½ä»¤åï¼Œä½ ä¼šçœ‹åˆ°å¦‚ä¸‹ä¿¡æ¯ã€‚æˆ‘ä»¬è¿™é‡Œä»¥Braavosé’±åŒ…ä¸ºä¾‹ï¼Œä½†Argenté’±åŒ…ä¸Šæ­¥éª¤æ˜¯ä¸€æ ·çš„ã€‚"

#: src/ch02-05-testnet-deployment.md:247
#, fuzzy
msgid "After the acount descriptor file is generated, you can see its details, run:"
msgstr "è´¦æˆ·æè¿°ç¬¦æ–‡ä»¶ç”Ÿæˆåï¼Œæ‚¨å¯ä»¥æŸ¥çœ‹å…¶è¯¦ç»†ä¿¡æ¯ï¼Œç„¶åè¿è¡Œï¼š"

#: src/ch02-05-testnet-deployment.md:253
msgid "Hereâ€™s what a typical descriptor might look like:"
msgstr "ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„æè¿°ç¬¦ï¼š"

#: src/ch02-05-testnet-deployment.md:258 src/ch04-03-01-deploy-standard-account.md:92 src/ch04-03-01-deploy-standard-account.md:140
msgid "\"variant\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:259 src/ch02-05-testnet-deployment.md:267 src/ch04-03-01-deploy-standard-account.md:93 src/ch04-03-01-deploy-standard-account.md:141
msgid "\"type\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:259 src/ch02-10-02-million-dollar-homepage.md:30
msgid "\"braavos\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:261
#, fuzzy
msgid "\"implementation\""
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch02-05-testnet-deployment.md:261
msgid "\"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:262
#, fuzzy
msgid "\"multisig\""
msgstr "å¤šç­¾ ğŸš§"

#: src/ch02-05-testnet-deployment.md:263 src/ch02-05-testnet-deployment.md:273 src/ch04-03-01-deploy-standard-account.md:99 src/ch04-03-01-deploy-standard-account.md:147
msgid "\"status\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:263
msgid "\"off\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:265
msgid "\"signers\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:267
msgid "\"stark\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:268 src/ch04-03-01-deploy-standard-account.md:95 src/ch04-03-01-deploy-standard-account.md:143
msgid "\"public_key\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:268
msgid "\"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:272 src/ch04-03-01-deploy-standard-account.md:98 src/ch04-03-01-deploy-standard-account.md:146
#, fuzzy
msgid "\"deployment\""
msgstr "æµ‹è¯•ç½‘éƒ¨ç½²"

#: src/ch02-05-testnet-deployment.md:273
msgid "\"deployed\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:274
msgid "\"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:275
msgid "\"address\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:275
msgid "\"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\""
msgstr ""

#: src/ch02-05-testnet-deployment.md:280
msgid "Note: The structure will differ if you use an Argent wallet."
msgstr "æ³¨æ„ï¼šå¦‚æœä½¿ç”¨ Argent é’±åŒ…ï¼Œç»“æ„ä¼šæœ‰æ‰€ä¸åŒã€‚"

#: src/ch02-05-testnet-deployment.md:282
#, fuzzy
msgid "Setting up Environment Variables"
msgstr "## è®¾ç½®ç¯å¢ƒå˜é‡"

#: src/ch02-05-testnet-deployment.md:284
#, fuzzy
msgid "To simplify Starkli commands, you can set environment variables. Two key variables are crucial: one for the Signerâ€™s keystore file location and another for the Account Descriptor file."
msgstr "ä¸ºäº†ç®€åŒ– Starkli å‘½ä»¤ï¼Œå¯ä»¥è®¾ç½®ç¯å¢ƒå˜é‡ã€‚æœ‰ä¸¤ä¸ªå…³é”®å˜é‡è‡³å…³é‡è¦ï¼šä¸€ä¸ªæ˜¯ç­¾åè€…çš„å¯†é’¥å­˜å‚¨æ–‡ä»¶ä½ç½®ï¼Œå¦ä¸€ä¸ªæ˜¯è´¦æˆ·æè¿°ç¬¦æ–‡ä»¶ã€‚"

#: src/ch02-05-testnet-deployment.md:289 src/ch02-06-starkli.md:130
#, fuzzy
msgid "~/.starkli-wallets/deployer/my_account_1.json"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_account_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:290 src/ch02-06-starkli.md:131
#, fuzzy
msgid "~/.starkli-wallets/deployer/my_keystore_1.json"
msgstr ""
"```bash\n"
"    cat ~/.starkli-wallets/deployer/my_keystore_1.json\n"
"```"

#: src/ch02-05-testnet-deployment.md:291
msgid "https://starknet-testnet.public.blastapi.io/rpc/v0_6"
msgstr ""

#: src/ch02-05-testnet-deployment.md:294
#, fuzzy
msgid "Setting these variables makes running Starkli commands easier and more efficient."
msgstr "è®¾ç½®è¿™äº›å˜é‡å¯ä»¥è®©è¿è¡Œ Starkli å‘½ä»¤å˜å¾—æ›´ç®€å•ã€æ›´é«˜æ•ˆã€‚"

#: src/ch02-05-testnet-deployment.md:299
msgid "Deploying a smart contract on Starknet involves two steps:"
msgstr "åœ¨ Starknet ä¸Šéƒ¨ç½²æ™ºèƒ½åˆçº¦åŒ…æ‹¬ä¸¤ä¸ªæ­¥éª¤ï¼š"

#: src/ch02-05-testnet-deployment.md:301
#, fuzzy
msgid "Declare your contractâ€™s code."
msgstr "è¦å£°æ˜æ‚¨çš„åˆçº¦ï¼Œè¯·æ‰§è¡Œï¼š"

#: src/ch02-05-testnet-deployment.md:302
#, fuzzy
msgid "Deploy an instance of the declared code."
msgstr ""
"- å£°æ˜æ‚¨çš„åˆçº¦ä»£ç ã€‚\n"
"- éƒ¨ç½²å·²å£°æ˜ä»£ç çš„å®ä¾‹ã€‚"

#: src/ch02-05-testnet-deployment.md:304
#, fuzzy
msgid ""
"To get started, navigate to the `src/` directory in the [examples/Ownable-Starknet](https://github.com/starknet-edu/starknetbook/tree/main/examples/Ownable-Starknet) directory of the Starknet Book "
"repo. The `src/lib.cairo` file contains a basic contract to practice with."
msgstr ""
"è¦å¼€å§‹å­¦ä¹ ï¼Œè¯·å¯¼èˆªåˆ°Starknetä¹‹ä¹¦ githubä»“åº“çš„ [ç¬¬ä¸€ç« ](https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/contracts) ä¸­çš„ `contracts/` ç›®å½•ã€‚`src/lib.cairo` æ–‡"
"ä»¶åŒ…å«ä¸€ä¸ªåŸºæœ¬åˆçº¦ï¼Œå¯ä¾›ç»ƒä¹ ã€‚"

#: src/ch02-05-testnet-deployment.md:308
#, fuzzy
msgid ""
"First, compile the contract using the Scarb compiler. If you havenâ€™t installed Scarb, follow the installation guide in the [basic installation](./ch02-01-basic-installation.html#scarb-package-manager-"
"installation) section."
msgstr "é¦–å…ˆï¼Œä½¿ç”¨ Scarb ç¼–è¯‘å™¨ç¼–è¯‘åˆçº¦ã€‚å¦‚æœå°šæœªå®‰è£… Scarbï¼Œè¯·æŒ‰ç…§ [è®¾ç½®ç¯å¢ƒ](https://book.starknet.io/chapter_1/environment_setup.html) éƒ¨åˆ†çš„å®‰è£…æŒ‡å—è¿›è¡Œå®‰è£…ã€‚"

#: src/ch02-05-testnet-deployment.md:316
#, fuzzy
msgid "This creates a compiled contract in `target/dev/` as `ownable_starknet_ownable.compiled_contract_class.json` (in Chapter 2 of the book we will learn more details about Scarb)."
msgstr "è¿™å°†åœ¨ `target/dev/` ä¸­åˆ›å»ºä¸€ä¸ªç¼–è¯‘å¥½çš„åˆçº¦ï¼Œåä¸º \"contracts_Ownable.sierra.json\"ï¼ˆåœ¨æœ¬ä¹¦ç¬¬ 2 ç« ä¸­ï¼Œæˆ‘ä»¬å°†äº†è§£æœ‰å…³ Scarb çš„æ›´å¤šç»†èŠ‚ï¼‰ã€‚"

#: src/ch02-05-testnet-deployment.md:320
#, fuzzy
msgid "Declaring Your Contract"
msgstr "### å£°æ˜æ‚¨çš„åˆçº¦"

#: src/ch02-05-testnet-deployment.md:322
#, fuzzy
msgid "Run this command to declare your contract using the default Starknet Sequencerâ€™s Gateway:"
msgstr "è¿è¡Œæ­¤å‘½ä»¤å¯ä½¿ç”¨é»˜è®¤çš„ Starknet æ’åºå™¨ç½‘å…³å£°æ˜æ‚¨çš„åˆçº¦ï¼š"

#: src/ch02-05-testnet-deployment.md:329
#, fuzzy
msgid "According to the `STARKNET_RPC` url, starkli can recognize the target blockchain network, in this case \"goerli\", so it is not necessary explicitly specify it."
msgstr "æ ¹æ® `STARKNET_RPC` urlï¼Œstarkli å¯ä»¥è¯†åˆ«ç›®æ ‡åŒºå—é“¾ç½‘ç»œï¼Œæœ¬ä¾‹ä¸­ä¸º \"goerli\"ï¼Œå› æ­¤æ— éœ€æ˜¾å¼æŒ‡å®šã€‚"

#: src/ch02-05-testnet-deployment.md:333
#, fuzzy
msgid ""
"Unless youâ€™re working with custom networks where itâ€™s infeasible for Starkli to detect the right compiler version, you shouldnâ€™t need to manually choose a version with `--network` and `--compiler-"
"version`."
msgstr "é™¤éä½ ä½¿ç”¨çš„æ˜¯è‡ªå®šä¹‰ç½‘ç»œï¼ŒStarkli æ— æ³•æ£€æµ‹åˆ°æ­£ç¡®çš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œå¦åˆ™ä½ åº”è¯¥ä¸éœ€è¦ä½¿ç”¨ `--network` å’Œ `--compiler-version` æ¥æ‰‹åŠ¨é€‰æ‹©ç‰ˆæœ¬ã€‚"

#: src/ch02-05-testnet-deployment.md:337
#, fuzzy
msgid ""
"If you encounter an \"Error: Invalid contract class,\" it likely means your Scarbâ€™s compiler version is incompatible with Starkli. Follow the steps above to align the versions. Starkli usually "
"supports compiler versions accepted by mainnet, even if Scarbâ€™s latest version is not yet compatible."
msgstr ""
"å¦‚æœé‡åˆ° `\"Error: Invalid contract class,\"`ï¼Œè¿™å¾ˆå¯èƒ½æ„å‘³ç€ä½ çš„ Scarb ç¼–è¯‘å™¨ç‰ˆæœ¬ä¸ Starkli ä¸å…¼å®¹ã€‚è¯·æŒ‰ç…§ä¸Šé¢çš„æ­¥éª¤è°ƒæ•´ç‰ˆæœ¬ã€‚Starkli é€šå¸¸æ”¯æŒä¸»ç½‘æ¥å—çš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œå³ä½¿ Scarb çš„æœ€æ–°ç‰ˆæœ¬è¿˜ä¸å…¼å®¹ã€‚"

#: src/ch02-05-testnet-deployment.md:343
#, fuzzy
msgid "After running the command, youâ€™ll receive a contract class hash. This unique hash serves as the identifier for your contract class within Starknet. For example:"
msgstr "è¿è¡Œè¯¥å‘½ä»¤åï¼Œæ‚¨å°†æ”¶åˆ°ä¸€ä¸ªåˆçº¦çš„class hashï¼ˆç±»å“ˆå¸Œï¼‰ã€‚è¿™ä¸ªå”¯ä¸€çš„å“ˆå¸Œå€¼æ˜¯æ‚¨çš„åˆçº¦ç±»åœ¨Starknetä¸­çš„æ ‡è¯†ç¬¦ã€‚ä¾‹å¦‚:"

#: src/ch02-05-testnet-deployment.md:351
#, fuzzy
msgid ""
"You can think of this hash as the contract classâ€™s _address._ Use a block explorer like [StarkScan](https://testnet.starkscan.co/"
"class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) to verify this hash on the blockchain."
msgstr ""
"æ‚¨å¯ä»¥å°†æ­¤æ•£åˆ—å€¼è§†ä¸ºåˆçº¦ç±»çš„ _address_  ä½¿ç”¨å¦‚ [StarkScan](https://testnet.starkscan.co/class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) ä¹‹ç±»çš„åŒºå—æµè§ˆå™¨åœ¨åŒºå—é“¾ä¸ŠéªŒè¯æ­¤hashã€‚"

#: src/ch02-05-testnet-deployment.md:356
#, fuzzy
msgid "If the contract class youâ€™re attempting to declare already exists, it is ok we can continue. Youâ€™ll receive a message like:"
msgstr "å¦‚æœæ‚¨è¯•å›¾å£°æ˜çš„åˆçº¦ç±»å·²ç»å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­ã€‚æ‚¨å°†æ”¶åˆ°å¦‚ä¸‹ä¿¡æ¯ï¼š"

#: src/ch02-05-testnet-deployment.md:364
#, fuzzy
msgid "Deploying Smart Contracts on Starknet"
msgstr "## åœ¨Starknetéƒ¨ç½²æ™ºèƒ½åˆçº¦"

#: src/ch02-05-testnet-deployment.md:366
#, fuzzy
msgid "To deploy a smart contract, youâ€™ll need to instantiate it on Starknetâ€™s testnet. This process involves executing a command that requires two main components:"
msgstr "è¦éƒ¨ç½²æ™ºèƒ½åˆçº¦ï¼Œæ‚¨éœ€è¦åœ¨ Starknet çš„æµ‹è¯•ç½‘ä¸Šå°†å…¶å®ä¾‹åŒ–ã€‚è¿™ä¸ªè¿‡ç¨‹éœ€è¦æ‰§è¡Œä¸€ä¸ªå‘½ä»¤ï¼Œè¯¥å‘½ä»¤éœ€è¦ä¸¤ä¸ªä¸»è¦ç»„ä»¶ï¼š"

#: src/ch02-05-testnet-deployment.md:370
msgid "The class hash of your smart contract."
msgstr ""

#: src/ch02-05-testnet-deployment.md:372
#, fuzzy
msgid "Any constructor arguments that the contract expects."
msgstr ""
"1.  æ™ºèƒ½åˆçº¦çš„Class Hash(ç±»å“ˆå¸Œå€¼)ã€‚\n"
"\n"
"2.  åˆçº¦æ‰€éœ€çš„æ‰€æœ‰æ„é€ å‡½æ•°å‚æ•°ã€‚"

#: src/ch02-05-testnet-deployment.md:374
#, fuzzy
msgid "In our example, the constructor expects an _owner_ address. You can learn more about constructors in [Chapter 13 of The Cairo Book](https://book.cairo-lang.org/ch13-02-contract-functions.html)."
msgstr ""
"åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œæ„é€ å‡½æ•°æœŸæœ›å¾—åˆ°ä¸€ä¸ª _owner_ åœ°å€ã€‚å…³äºæ„é€ å‡½æ•°çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [Cairoä¹‹ä¹¦ ç¬¬12ç« ](<https://book.cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-"
"constructors>)ã€‚"

#: src/ch02-05-testnet-deployment.md:378
msgid "The command would look like this:"
msgstr "å‘½ä»¤å¦‚ä¸‹ï¼š"

#: src/ch02-05-testnet-deployment.md:386
#, fuzzy
msgid "Hereâ€™s a specific example with an actual class hash and constructor inputs (as the owner address use the address of your smart wallet so you can invoke the transfer_ownership function later):"
msgstr "ä¸‹é¢æ˜¯ä¸€ä¸ªå…·ä½“ç¤ºä¾‹ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå®é™…ç±»çš„å“ˆå¸Œå€¼å’Œæ„é€ å‡½æ•°è¾“å…¥ï¼ˆä½œä¸ºæ‰€æœ‰è€…åœ°å€ï¼Œè¯·ä½¿ç”¨æ™ºèƒ½é’±åŒ…çš„åœ°å€ï¼Œä»¥ä¾¿ç¨åè°ƒç”¨ `transfer_ownership` å‡½æ•°ï¼‰ï¼š"

#: src/ch02-05-testnet-deployment.md:396
#, fuzzy
msgid "After executing the command and entering your password, you should see output like the following:"
msgstr "æ‰§è¡Œå‘½ä»¤å¹¶è¾“å…¥å¯†ç åï¼Œæ‚¨åº”è¯¥ä¼šçœ‹åˆ°å¦‚ä¸‹è¾“å‡ºï¼š"

#: src/ch02-05-testnet-deployment.md:407
#, fuzzy
msgid ""
"The contract is now live on the Starknet testnet. You can verify its status using a block explorer like [StarkScan](https://testnet.starkscan.co/"
"contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012). On the \"Read/Write Contract\" tab, youâ€™ll see the contractâ€™s external functions."
msgstr ""
"åˆçº¦ç°å·²å­˜åœ¨äºStarknetæµ‹è¯•ç½‘ä¸Šã€‚ä½ å¯ä»¥ä½¿ç”¨åƒ [StarkScan](https://testnet.starkscan.co/contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012) è¿™æ ·çš„åŒºå—æµè§ˆå™¨æ¥éªŒè¯å®ƒçš„çŠ¶æ€ã€‚åœ¨ "
"\"Read/Write Contract\" é€‰é¡¹å¡ä¸Šï¼Œä½ å¯ä»¥çœ‹åˆ°åˆçº¦çš„å¤–éƒ¨åŠŸèƒ½ã€‚"

#: src/ch02-05-testnet-deployment.md:413
#, fuzzy
msgid "Interacting with the Starknet Contract"
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-05-testnet-deployment.md:415
#, fuzzy
msgid "Starkli enables interaction with smart contracts via two primary methods: `call` for read-only functions and `invoke` for write functions that modify the state."
msgstr "Starkli é€šè¿‡ä¸¤ç§ä¸»è¦æ–¹æ³•å®ç°ä¸æ™ºèƒ½åˆçº¦çš„äº¤äº’ï¼š`call`ç”¨äºåªè¯»å‡½æ•°ï¼Œ`invoke`ç”¨äºä¿®æ”¹çŠ¶æ€çš„å†™å…¥å‡½æ•°ã€‚"

#: src/ch02-05-testnet-deployment.md:419
#, fuzzy
msgid "Calling a Read Function"
msgstr "### è°ƒç”¨åªè¯»å‡½æ•°"

#: src/ch02-05-testnet-deployment.md:421
#, fuzzy
msgid ""
"The `call` command enables you to query a smart contract function without sending a transaction. For instance, to find out who the current owner of the contract is, you can use the `get_owner` "
"function, which requires no arguments."
msgstr "`call`å‘½ä»¤ä½¿ä½ å¯ä»¥åœ¨ä¸å‘é€äº¤æ˜“çš„æƒ…å†µä¸‹æŸ¥è¯¢æ™ºèƒ½åˆçº¦å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œè¦æƒ³çŸ¥é“è°æ˜¯åˆçº¦çš„å½“å‰æ‰€æœ‰è€…ï¼Œå¯ä»¥ä½¿ç”¨`get_owner`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸éœ€è¦å‚æ•°ã€‚"

#: src/ch02-05-testnet-deployment.md:432
#, fuzzy
msgid "Replace `<CONTRACT_ADDRESS>` with the address of your recently deployed contract. The command will return the ownerâ€™s address, which was initially set during the contractâ€™s deployment:"
msgstr "è¯·å°† `<CONTRACT_ADDRESS>` æ›¿æ¢ä¸ºæ‚¨çš„åˆçº¦åœ°å€ã€‚è¯¥å‘½ä»¤å°†è¿”å›æ‰€æœ‰è€…çš„åœ°å€ï¼Œè¯¥åœ°å€æœ€åˆæ˜¯åœ¨éƒ¨ç½²åˆçº¦æ—¶è®¾ç½®çš„ï¼š"

#: src/ch02-05-testnet-deployment.md:437
#, fuzzy
msgid "\"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\""
msgstr ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"

#: src/ch02-05-testnet-deployment.md:441
#, fuzzy
msgid "Invoking a Write Function"
msgstr "## è°ƒç”¨å†™å…¥å‡½æ•°"

#: src/ch02-05-testnet-deployment.md:443
#, fuzzy
msgid "You can modify the contractâ€™s state using the `invoke` command. For example, letâ€™s transfer the contractâ€™s ownership with the `transfer_ownership` function."
msgstr "æ‚¨å¯ä»¥ä½¿ç”¨ `invoke` å‘½ä»¤ä¿®æ”¹åˆçº¦çš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ `transfer_ownership` å‡½æ•°è½¬ç§»åˆçº¦çš„æ‰€æœ‰æƒã€‚"

#: src/ch02-05-testnet-deployment.md:454
#, fuzzy
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of the contract and `<NEW_OWNER_ADDRESS>` with the address you want to transfer ownership to. If the smart wallet youâ€™re using isnâ€™t the contractâ€™s owner, "
"an error will appear. Note that the initial owner was set when deploying the contract:"
msgstr "å°† `<CONTRACT_ADDRESS>` æ›¿æ¢ä¸ºåˆçº¦åœ°å€ï¼Œå°† `<NEW_OWNER_ADDRESS>`æ›¿æ¢ä¸ºä½ æƒ³è½¬ç§»æ‰€æœ‰æƒçš„åœ°å€ã€‚å¦‚æœæ‚¨ä½¿ç”¨çš„æ™ºèƒ½é’±åŒ…ä¸æ˜¯åˆçº¦çš„æ‰€æœ‰è€…ï¼Œåˆ™ä¼šå‡ºç°é”™è¯¯ã€‚è¯·æ³¨æ„ï¼Œåˆå§‹æ‰€æœ‰è€…æ˜¯åœ¨éƒ¨ç½²åˆçº¦æ—¶è®¾ç½®çš„ï¼š"

#: src/ch02-05-testnet-deployment.md:464
#, fuzzy
msgid "The failure reason is encoded as a felt. o decode it, use the starkliâ€™s `parse-cairo-string` command."
msgstr "å¤±è´¥çš„åŸå› è¢«ç¼–ç æˆäº†`felt`ç±»å‹ã€‚è¦è§£ç å¤±è´¥åŸå› ï¼Œè¯·ä½¿ç”¨ starkli çš„ `parse-cairo-string` å‘½ä»¤ã€‚"

#: src/ch02-05-testnet-deployment.md:471
#, fuzzy
msgid "For example, if you see `0x43616c6c6572206973206e6f7420746865206f776e6572`, decoding it will yield \"Caller is not the owner.\""
msgstr "ä¾‹å¦‚ï¼Œå¦‚æœæ‚¨çœ‹åˆ° \"0x43616c6c6572206973206e6f7420746865206f776e6572\"ï¼Œå®ƒè§£ç ç»“æœå°†æ˜¯ \"Caller is not the owner.\"ã€‚"

#: src/ch02-05-testnet-deployment.md:475
#, fuzzy
msgid "After a successful transaction on L2, use a block explorer like StarkScan or Voyager to confirm the transaction status using the hash provided by the `invoke` command."
msgstr "åœ¨ L2 ä¸ŠæˆåŠŸè¿›è¡Œäº¤æ˜“åï¼Œä½¿ç”¨ StarkScan æˆ– Voyager ç­‰åŒºå—èµ„æºç®¡ç†å™¨ï¼Œä½¿ç”¨ `invoke`å‘½ä»¤æä¾›çš„å“ˆå¸Œå€¼ç¡®è®¤äº¤æ˜“çŠ¶æ€ã€‚"

#: src/ch02-05-testnet-deployment.md:479
#, fuzzy
msgid "To verify that the ownership has successfully transferred, you can call the `get_owner` function again:"
msgstr "è¦éªŒè¯æ‰€æœ‰æƒæ˜¯å¦å·²æˆåŠŸè½¬ç§»ï¼Œå¯ä»¥å†æ¬¡è°ƒç”¨ `get_owner` å‡½æ•°ï¼š"

#: src/ch02-05-testnet-deployment.md:488
#, fuzzy
msgid "If the function returns the new ownerâ€™s address, the transfer was successful."
msgstr "å¦‚æœå‡½æ•°è¿”å›æ–°æ‰€æœ‰è€…çš„åœ°å€ï¼Œåˆ™è¯´æ˜è½¬è´¦æˆåŠŸã€‚"

#: src/ch02-05-testnet-deployment.md:491
#, fuzzy
msgid "Congratulations! Youâ€™ve successfully deployed and interacted with a Starknet contract."
msgstr "æ­å–œæ‚¨ï¼æ‚¨å·²æˆåŠŸéƒ¨ç½²Starknetåˆçº¦å¹¶ä¸ä¹‹äº¤äº’ã€‚"

#: src/ch02-05-01-start-with-sepolia.md:1
msgid "Get started with Sepolia - Get ETH and deploy your wallet"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:3
msgid "Overview"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:5
msgid ""
"Currently, there are no active Sepolia faucets in Starknet. Therefore, the process of acquiring SEPOLIA tokens involves obtaining them on the **Ethereum** Sepolia testnet and then transferring them to "
"the Starknet Sepolia testnet."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:7
msgid "Step 1: Obtain SEPOLIA Tokens on the Ethereum Sepolia Testnet"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:9
msgid "To acquire $ETH on the Ethereum Sepolia testnet, you can use:"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:11
msgid "[Alchemy's Sepolia Faucet](https://sepoliafaucet.com/)."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:12
msgid "[Infura's Sepolia Faucet](https://www.infura.io/faucet/sepolia)."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:13
msgid "[LearnWeb3's Sepolia Faucet](https://learnweb3.io/faucets/sepolia)."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:15
msgid "The process is simple: log in, paste your Ethereum Sepolia testnet address, and click the \"Send me $ETH\" button."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:17
msgid "Step 2: Transfer Your $ETH to the Starknet Sepolia Testnet"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:19
msgid "This step is slightly more complex. You will need to navigate to the [Bridge Contract](https://sepolia.etherscan.io/address/0x8453FC6Cd1bCfE8D4dFC069C400B433054d47bDc#writeProxyContract)."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:23
msgid "Connect the wallet containing your $ETH and then open function number 4 `deposit (0xe2bbb158)`."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:25
#, fuzzy
msgid "Parameter Specification"
msgstr "**å»ºè®®è§„æ ¼ï¼š**"

#: src/ch02-05-01-start-with-sepolia.md:27
msgid "For the fields, specify:"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:29
msgid "`deposit`: The amount of ETH to deposit **plus** a small amount for gas. For example, `x + 0.001 ETH`. (Ex: 0.031)"
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:30
msgid "`amount`: The amount of $ETH you want to transfer to Starknet in **uint256** format. In this case, `0.03 ETH` would be `30000000000000000` (16 decimals)."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:36
msgid "`l2Recipient`: The address of your Starknet Sepolia testnet account."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:40
msgid "Click the \"Write\" button and confirm the transaction in your wallet."
msgstr ""

#: src/ch02-05-01-start-with-sepolia.md:42
#, fuzzy
msgid "\\[Optional\\] Wallet Deployment"
msgstr "æµ‹è¯•ç½‘éƒ¨ç½²"

#: src/ch02-05-01-start-with-sepolia.md:44
msgid ""
"If this is your first time using your wallet on the Starknet Sepolia testnet, go to your ArgentX or Braavos wallet and send some of the ETH you transferred to **another starknet wallet**. This will "
"automatically deploy your wallet."
msgstr ""

#: src/ch02-06-starkli.md:3
msgid ""
"[Starkli](https://book.starkli.rs/) is a Command Line Interface (CLI) tool designed for Starknet interaction, utilizing the capabilities of [starknet-rs](https://github.com/xJonathanLEI/starknet-rs). "
"This tool simplifies querying and executing transactions on Starknet."
msgstr ""

#: src/ch02-06-starkli.md:5
msgid "**NOTE:** Before continuing with this chapter, make sure you have completed the Basic Installation subchapter of Chapter 2. This includes the installation of Starkli."
msgstr ""

#: src/ch02-06-starkli.md:7
msgid ""
"In the next subchapter we will create a short Bash script using Starkli to query Starknet. It's just an example, however, creating your own Bash scripts to interact with Starknet would be very useful "
"in practice."
msgstr ""

#: src/ch02-06-starkli.md:9
#, fuzzy
msgid "Basic Setup"
msgstr "## è®¾ç½®"

#: src/ch02-06-starkli.md:11
msgid ""
"To ensure a smooth start with Starkli, execute the following command on your system. If you encounter any issues, refer to the [Basic Installation](./ch02-01-basic-installation.md) guide for "
"assistance:"
msgstr ""

#: src/ch02-06-starkli.md:14
msgid "# Verifies Starkli installation and interacts with Starknet\n"
msgstr ""

#: src/ch02-06-starkli.md:17
msgid "Connect to Starknet with Providers"
msgstr ""

#: src/ch02-06-starkli.md:19
msgid "Starkli primarily operates with a JSON-RPC provider. To access a JSON-RPC endpoint, you have several options:"
msgstr ""

#: src/ch02-06-starkli.md:21
msgid "Use services like [Infura](https://docs.infura.io/networks/starknet/how-to) or [Alchemy](https://www.alchemy.com/starknet) for an RPC client."
msgstr ""

#: src/ch02-06-starkli.md:22
msgid "Employ a temporary local node like `katana` for development and testing purposes."
msgstr ""

#: src/ch02-06-starkli.md:23
msgid "Setup your own node."
msgstr ""

#: src/ch02-06-starkli.md:25
#, fuzzy
msgid "Interacting with Katana"
msgstr "## ä¸åˆçº¦äº¤äº’"

#: src/ch02-06-starkli.md:27
#, fuzzy
msgid "To start Katana, open a terminal and execute:"
msgstr "é‡å¯ç»ˆç«¯å¹¶è¿è¡Œï¼š"

#: src/ch02-06-starkli.md:33
msgid "To retrieve the chain id from the Katana JSON-RPC endpoint, use the following command:"
msgstr ""

#: src/ch02-06-starkli.md:39
#, fuzzy
msgid "This command will output:"
msgstr "è¯¥å‘½ä»¤å°†æ˜¾ç¤ºï¼š"

#: src/ch02-06-starkli.md:45
msgid "To obtain the latest block number on Katana, run:"
msgstr ""

#: src/ch02-06-starkli.md:51
#, fuzzy
msgid "The output will be:"
msgstr "è¾“å‡ºç»“æœç±»ä¼¼äºï¼š"

#: src/ch02-06-starkli.md:57
msgid ""
"Since katana is a temporary local node and its state is ephemeral, the block number is initially 0. Refer to [Introduction to Starkli, Scarb and Katana](./ch02-02-starkli-scarb-katana.md) for further "
"details on changing the state of Katana and observing the block number after commands like starkli declare and starkli deploy."
msgstr ""

#: src/ch02-06-starkli.md:59
#, fuzzy
msgid "To declare a contract, execute:"
msgstr "è¦å£°æ˜æ‚¨çš„åˆçº¦ï¼Œè¯·æ‰§è¡Œï¼š"

#: src/ch02-06-starkli.md:65
#, fuzzy
msgid "After declaring, the output will be:"
msgstr "å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œè¾“å‡ºå°†ç±»ä¼¼äºï¼š"

#: src/ch02-06-starkli.md:71
msgid "Retrieving the latest block number on Katana again:"
msgstr ""

#: src/ch02-06-starkli.md:77
#, fuzzy
msgid "Will result in:"
msgstr "ç»“æœæ˜¯ï¼š"

#: src/ch02-06-starkli.md:83
msgid "Katana logs also reflect these changes:"
msgstr ""

#: src/ch02-06-starkli.md:86 src/ch02-06-starkli.md:88
msgid "\"starknet_chainId\""
msgstr ""

#: src/ch02-06-starkli.md:87
msgid "\"starknet_getClass\""
msgstr ""

#: src/ch02-06-starkli.md:89 src/ch02-06-starkli.md:91
msgid "\"starknet_getNonce\""
msgstr ""

#: src/ch02-06-starkli.md:90
msgid "\"starknet_estimateFee\""
msgstr ""

#: src/ch02-06-starkli.md:92
#, fuzzy
msgid "\"starknet_addDeclareTransaction\""
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch02-06-starkli.md:99
msgid "These logs indicate the receipt of a transaction, gas usage, and the mining of a new block, explaining the increment in block number to `1`."
msgstr ""

#: src/ch02-06-starkli.md:101
msgid ""
"Before deploying a contract, note that Starkli supports argument resolution, simplifying the input process. For instance, constructor inputs in felt format can be easily passed as `str:<String-value>`:"
msgstr ""

#: src/ch02-06-starkli.md:109
msgid "This command deploys the contract without requiring `to-cairo-string`, and a new block is mined as a result."
msgstr ""

#: src/ch02-06-starkli.md:111
#, fuzzy
msgid "Interacting with Testnet"
msgstr "## ä¸åˆçº¦äº¤äº’"

#: src/ch02-06-starkli.md:113
msgid "To interact with the Testnet, use a third-party JSON-RPC API provider like Infura or Alchemy. With your provider URL, execute the following command to get the latest block number:"
msgstr ""

#: src/ch02-06-starkli.md:119
msgid "This command will return a response like:"
msgstr ""

#: src/ch02-06-starkli.md:125
msgid "You can confirm this result by checking [Starkscan](https://testnet.starkscan.co/), where you'll find matching data."
msgstr ""

#: src/ch02-06-starkli.md:127
msgid "Starkli also streamlines the process of invoking commands. For instance, to transfer 1000 Wei of ETH to address 0x1234, first set up your environment variables:"
msgstr ""

#: src/ch02-06-starkli.md:134
#, fuzzy
msgid "Then, use the following command for the transfer:"
msgstr "æ‰§è¡Œä»¥ä¸‹æ“ä½œä»¥ç¼–è¯‘åˆçº¦ï¼š"

#: src/ch02-06-starkli.md:140
msgid "You can create your own script to connect to Starknet using Starkli. In the next subchapter we will create a short Bash script."
msgstr ""

#: src/ch02-06-01-connection-script.md:1
#, fuzzy
msgid "Example - Starknet Connection Script"
msgstr "ç¤ºä¾‹ - éƒ¨ç½²è„šæœ¬"

#: src/ch02-06-01-connection-script.md:3
msgid "This section provides step-by-step instructions to create and run custom bash scripts for Starknet interactions."
msgstr ""

#: src/ch02-06-01-connection-script.md:5
#, fuzzy
msgid "Katana Local Node"
msgstr "Katana: æœ¬åœ°èŠ‚ç‚¹"

#: src/ch02-06-01-connection-script.md:7
msgid "**Description:** This script connects to the local StarkNet devnet through Katana, retrieves the current chain ID, the latest block number, and the balance of a specified account."
msgstr ""

#: src/ch02-06-01-connection-script.md:9
msgid "First, ensure that Katana is running (in terminal 1):"
msgstr ""

#: src/ch02-06-01-connection-script.md:15
msgid "Then, create a file named `script_devnet` (in terminal 2):"
msgstr ""

#: src/ch02-06-01-connection-script.md:21
msgid "Edit this file with your preferred text editor and insert the following script:"
msgstr ""

#: src/ch02-06-01-connection-script.md:24 src/ch04-03-01-deploy-standard-account.md:65 src/ch04-03-01-deploy-standard-account.md:163 src/ch04-03-01-deploy-standard-account.md:194
msgid "#!/bin/bash\n"
msgstr ""

#: src/ch02-06-01-connection-script.md:25
msgid "$(starkli chain-id --rpc http://0.0.0.0:5050)"
msgstr ""

#: src/ch02-06-01-connection-script.md:26
msgid "\"Connected to the Starknet local devnet with chain id: $chain\""
msgstr ""

#: src/ch02-06-01-connection-script.md:28
msgid "$(starkli block-number --rpc http://0.0.0.0:5050)"
msgstr ""

#: src/ch02-06-01-connection-script.md:29
msgid "\"The latest block number on Katana is: $block\""
msgstr ""

#: src/ch02-06-01-connection-script.md:31
msgid "\"0x517ececd29116499f4a1b64b094da79ba08dfd54a3edaa316134c41f8160973\""
msgstr ""

#: src/ch02-06-01-connection-script.md:32
msgid "$(starkli balance $account1 --rpc http://0.0.0.0:5050)"
msgstr ""

#: src/ch02-06-01-connection-script.md:33
msgid "\"The balance of account $account1 is: $balance ETH\""
msgstr ""

#: src/ch02-06-01-connection-script.md:36
#, fuzzy
msgid "Execute the script with:"
msgstr "æ‰§è¡Œå‘½ä»¤åä¼šæ˜¾ç¤ºï¼š"

#: src/ch02-06-01-connection-script.md:42
msgid "You will see output details from the devnet."
msgstr ""

#: src/ch02-06-01-connection-script.md:44
msgid "Goerli Testnet"
msgstr ""

#: src/ch02-06-01-connection-script.md:46
msgid "**Description**: This script connects to the Goerli testnet, reads the latest block number, and retrieves the transaction receipt for a specific transaction hash."
msgstr ""

#: src/ch02-06-01-connection-script.md:48
msgid "For Goerli testnet interactions, create a file named `script_testnet`:"
msgstr ""

#: src/ch02-06-01-connection-script.md:54
msgid "Edit the file and paste in this script:"
msgstr ""

#: src/ch02-06-01-connection-script.md:57
msgid "\"Input your testnet API URL: \""
msgstr ""

#: src/ch02-06-01-connection-script.md:59
msgid "$(starkli chain-id --rpc $url)"
msgstr ""

#: src/ch02-06-01-connection-script.md:60
msgid "\"Connected to the Starknet testnet with chain id: $chain\""
msgstr ""

#: src/ch02-06-01-connection-script.md:62
msgid "$(starkli block-number --rpc $url)"
msgstr ""

#: src/ch02-06-01-connection-script.md:63
msgid "\"The latest block number on Goerli is: $block\""
msgstr ""

#: src/ch02-06-01-connection-script.md:65
msgid "\"Input your transaction hash: \""
msgstr ""

#: src/ch02-06-01-connection-script.md:67
msgid "$(starkli receipt $hash --rpc $url)"
msgstr ""

#: src/ch02-06-01-connection-script.md:68
msgid "\"The receipt of transaction $hash is: $receipt\""
msgstr ""

#: src/ch02-06-01-connection-script.md:71
msgid "Run the script:"
msgstr ""

#: src/ch02-06-01-connection-script.md:77
msgid "You will need to input a `testnet API URL` and a `transaction hash`. Example hash: 0x2dd73eb1802aef84e8d73334ce0e5856b18df6626fe1a67bb247fcaaccaac8c."
msgstr ""

#: src/ch02-06-01-connection-script.md:79
msgid "These are brief examples but you get the idea. You can create custom Bash scripts to customize your interactions with Starknet."
msgstr ""

#: src/ch02-07-starknet-devnet.md:3
msgid "Starknet Devnet is a development network (devnet) implemented in Rust, similar to the Python-based [`starknet-devnet`](https://0xspaceshard.github.io/starknet-devnet/docs/intro)."
msgstr ""

#: src/ch02-07-starknet-devnet.md:7
msgid "`starknet devnet rs` can be installed in two ways: using Docker or manually by cloning the repository and running it with Cargo."
msgstr ""

#: src/ch02-07-starknet-devnet.md:9
msgid "Using Docker"
msgstr ""

#: src/ch02-07-starknet-devnet.md:11
msgid "To install using Docker, follow the instructions provided [here](https://github.com/0xSpaceShard/starknet-devnet-rs#readme)."
msgstr ""

#: src/ch02-07-starknet-devnet.md:13
msgid "Manual Installation (Cloning the Repo)"
msgstr ""

#: src/ch02-07-starknet-devnet.md:15
msgid "Prerequisites:"
msgstr ""

#: src/ch02-07-starknet-devnet.md:17
msgid "Rust installation ([Rust Install Guide](https://www.rust-lang.org/tools/install))"
msgstr ""

#: src/ch02-07-starknet-devnet.md:19
msgid "Procedure:"
msgstr ""

#: src/ch02-07-starknet-devnet.md:21
msgid "Create a new folder for the project."
msgstr ""

#: src/ch02-07-starknet-devnet.md:22
#, fuzzy
msgid "Clone the repository:"
msgstr "é¦–å…ˆï¼Œå…‹éš†é¡¹ç›®ä»“åº“ï¼š"

#: src/ch02-07-starknet-devnet.md:24
#, fuzzy
msgid ""
"```shell\n"
"git clone https://github.com/0xSpaceShard/starknet-devnet-rs.git\n"
"```"
msgstr ""
"```bash\n"
"git clone git@github.com:starknet-edu/aa-workshop.git aa\n"
"```"

#: src/ch02-07-starknet-devnet.md:28
msgid "Running"
msgstr ""

#: src/ch02-07-starknet-devnet.md:30
#, fuzzy
msgid "After installation, run Starknet Devnet with the following command:"
msgstr "è¦åˆå§‹åŒ–æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-07-starknet-devnet.md:36
msgid "On successful execution, you'll see outputs like predeployed contract addresses, account information, and seed details."
msgstr ""

#: src/ch02-07-starknet-devnet.md:60
msgid "Running Options"
msgstr ""

#: src/ch02-07-starknet-devnet.md:62
msgid "Using a Seed"
msgstr ""

#: src/ch02-07-starknet-devnet.md:64
msgid ""
"The Starknet devnet provides a `Seed to replicate this account sequence` feature. This allows you to use a specific seed to access previously used accounts. This functionality is particularly useful "
"when employing tools like [`sncast`](https://book.starknet.io/ch02-12-foundry-cast.html) or `starkli` for contract interactions, as it eliminates the need to change account information."
msgstr ""

#: src/ch02-07-starknet-devnet.md:66
#, fuzzy
msgid "To load old accounts using a specific seed, execute the following command:"
msgstr "è¦åˆå§‹åŒ–æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-07-starknet-devnet.md:72
msgid "Example (add any number you prefer):"
msgstr ""

#: src/ch02-07-starknet-devnet.md:78
msgid "Dumping and Loading Data"
msgstr ""

#: src/ch02-07-starknet-devnet.md:80
msgid "The process of dumping and loading data facilitates resuming work from where you left off."
msgstr ""

#: src/ch02-07-starknet-devnet.md:82
msgid "**Dumping Data**:"
msgstr ""

#: src/ch02-07-starknet-devnet.md:84
msgid "Data can be dumped either on `exit` or after a `transaction`."
msgstr ""

#: src/ch02-07-starknet-devnet.md:85
msgid "In this example, dumping is done on exit into a specified directory. Ensure the directory exists, but not the file."
msgstr ""

#: src/ch02-07-starknet-devnet.md:91
msgid "**Loading Data**:"
msgstr ""

#: src/ch02-07-starknet-devnet.md:92
msgid "To load data, use the command below. Note that both the directory and the file created by the `dump` command must exist. Also, pass in the seed to avoid issues like 'low account balance'."
msgstr ""

#: src/ch02-07-starknet-devnet.md:98
#, fuzzy
msgid "Additional options"
msgstr "## å…¶ä»–èµ„æº"

#: src/ch02-07-starknet-devnet.md:133
msgid ""
"However, the main difference for the Rust version is the syntax for flags. For example, use `cargo run -- --port 5006` or `cargo run -- --dump-on exit ...` for the Rust Devnet. Other flags can be used "
"in the standard format."
msgstr ""

#: src/ch02-07-starknet-devnet.md:135
msgid "Cross-Version Disclaimer"
msgstr ""

#: src/ch02-07-starknet-devnet.md:137
msgid ""
"Be aware that the dumping and loading functionality might not be compatible across different versions of the Devnet. In other words, data dumped from one version of Devnet may not be loadable with "
"another version."
msgstr ""

#: src/ch02-07-starknet-devnet.md:139
msgid "Minting Tokens"
msgstr ""

#: src/ch02-07-starknet-devnet.md:141
#, fuzzy
msgid "To mint tokens, either to an existing address or a new one, use the following command:"
msgstr "è¦ä»æºä»£ç å®‰è£… `katana`ï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-07-starknet-devnet.md:143
#, fuzzy
msgid ""
"```shell\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://localhost:5050/mint\n"
"```"
msgstr ""
"```sh\n"
"curl -d '{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}' -H \"Content-Type: application/json\" -X POST http://127.0.0.1:5050/mint\n"
"```"

#: src/ch02-07-starknet-devnet.md:147
msgid "Commands compatible with the `sncast` and `starkli` subchapters are also applicable in the Rust Devnet."
msgstr ""

#: src/ch02-07-starknet-devnet.md:149
msgid "Next"
msgstr ""

#: src/ch02-07-starknet-devnet.md:151
msgid "In the next subchapter we will use the `sncast` tool to interact with the Starknet Devnet in a real world example."
msgstr ""

#: src/ch02-08-foundry-cast.md:1
#, fuzzy
msgid "Foundry Cast: Starknet CLI Interaction"
msgstr "# Foundry Castï¼šStarknet CLI äº¤äº’"

#: src/ch02-08-foundry-cast.md:3
msgid ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) is a tool designed for testing and developing Starknet contracts. It is an adaptation of the Ethereum Foundry for Starknet, aiming to "
"expedite the development process."
msgstr "[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) æ˜¯ä¸€ä¸ªç”¨äºæµ‹è¯•å’Œå¼€å‘Starknetåˆçº¦çš„å·¥å…·ã€‚å®ƒæ˜¯æ ¹æ®ä»¥å¤ªåŠä¸Šçš„ Foundry å·¥å…·è¿›è¡Œäº†ä¸€äº›é’ˆå¯¹ Starknet çš„æ”¹é€ ï¼Œæ—¨åœ¨åŠ å¿«å¼€å‘è¿‡ç¨‹ã€‚"

#: src/ch02-08-foundry-cast.md:5
msgid "The project consists of two primary components:"
msgstr "è¯¥é¡¹ç›®ç”±ä¸¤ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆï¼š"

#: src/ch02-08-foundry-cast.md:7
#, fuzzy
msgid ""
"**Forge**: A testing tool specifically for Cairo contracts. This tool acts as a test runner and boasts features designed to enhance your testing process. Tests are written directly in Cairo, "
"eliminating the need for other programming languages. Additionally, the Forge implementation uses Rust, mirroring Ethereum Foundry's choice of language."
msgstr ""
"- **Forge**ï¼šä¸“é—¨ç”¨äºCairoåˆçº¦çš„æµ‹è¯•å·¥å…·ã€‚è¯¥å·¥å…·å¯ç”¨ä½œæµ‹è¯•è¿è¡Œå™¨ï¼Œå¹¶å…·æœ‰æ—¨åœ¨å¢å¼ºæµ‹è¯•æµç¨‹çš„åŠŸèƒ½ã€‚æµ‹è¯•ç›´æ¥ç”¨Cairoè¯­è¨€ç¼–å†™ï¼Œæ— éœ€ä½¿ç”¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ã€‚æ­¤å¤–ï¼ŒForge çš„å®ç°ä½¿ç”¨ Rustï¼Œä¸ä»¥å¤ªåŠ Foundry çš„è¯­è¨€é€‰æ‹©å¦‚"
"å‡ºä¸€è¾™ã€‚\n"
"- **Cast**ï¼šè¿™æ˜¯ Starknet çš„ DevOps å·¥å…·ï¼Œæœ€åˆæ”¯æŒä¸€ç³»åˆ—ä¸ Starknet æ¥å£çš„å‘½ä»¤ã€‚æœªæ¥ï¼ŒCast çš„ç›®æ ‡æ˜¯ä¸ºåˆçº¦å’Œå…¶ä»– DevOps åŠŸèƒ½æä¾›éƒ¨ç½²è„šæœ¬ã€‚"

#: src/ch02-08-foundry-cast.md:8
msgid ""
"**Cast**: This serves as a DevOps tool for Starknet, initially supporting a series of commands to interface with Starknet. In the future, Cast aims to offer deployment scripts for contracts and other "
"DevOps functions."
msgstr ""

#: src/ch02-08-foundry-cast.md:10
#, fuzzy
msgid "Cast"
msgstr "## Cast"

#: src/ch02-08-foundry-cast.md:12
msgid ""
"Cast provides the Command Line Interface (CLI) for starknet, while Forge addresses testing. Written in Rust, Cast utilizes starknet Rust and integrates with Scarb. This integration allows for argument "
"specification in `Scarb.toml`, streamlining the process."
msgstr "Cast ä¸º starknet æä¾›å‘½ä»¤è¡Œç•Œé¢ï¼ˆCLIï¼‰ï¼Œè€Œ Forge åˆ™è´Ÿè´£æµ‹è¯•ã€‚Cast é‡‡ç”¨ Rust ç¼–å†™ï¼Œåˆ©ç”¨ starknet Rust å¹¶ä¸ Scarb é›†æˆã€‚è¿™ç§é›†æˆå…è®¸åœ¨ `Scarb.toml`ä¸­æŒ‡å®šå‚æ•°ï¼Œä»è€Œç®€åŒ–äº†æµç¨‹ã€‚"

#: src/ch02-08-foundry-cast.md:14
msgid "`sncast` simplifies interaction with smart contracts, reducing the number of necessary commands compared to using `starkli` alone."
msgstr "ä¸å•ç‹¬ä½¿ç”¨ `starkli` ç›¸æ¯”ï¼Œ`sncast` ç®€åŒ–äº†ä¸æ™ºèƒ½åˆçº¦çš„äº¤äº’ï¼Œå‡å°‘äº†å¿…è¦å‘½ä»¤çš„æ•°é‡ã€‚"

#: src/ch02-08-foundry-cast.md:16
msgid "In this section, we'll delve into `sncast`."
msgstr "åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥ç ”ç©¶ `sncast`ã€‚"

#: src/ch02-08-foundry-cast.md:21 src/ch02-08-01-deployment-script.md:14
#, fuzzy
msgid "# scarb --version\n"
msgstr ""
"```bash\n"
"scarb --version\n"
"```"

#: src/ch02-08-foundry-cast.md:25 src/ch02-08-01-deployment-script.md:18
#, fuzzy
msgid "# snforge --version\n"
msgstr ""
"```sh\n"
"snforge --version\n"
"```"

#: src/ch02-08-foundry-cast.md:28 src/ch02-08-01-deployment-script.md:21
#, fuzzy
msgid "# sncast --version\n"
msgstr ""
"```bash\n"
"scarb --version\n"
"```"

#: src/ch02-08-foundry-cast.md:34
#, fuzzy
msgid "Step 1: Sample Smart Contract"
msgstr "## æ­¥éª¤ 1ï¼šç¤ºä¾‹æ™ºèƒ½åˆçº¦"

#: src/ch02-08-foundry-cast.md:36
#, fuzzy
msgid ""
"The following code sample is sourced from `starknet foundry`(You can find the source of the example [here](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html)). If yo desire to get "
"the files you can do it from [Foundry Example Code](https://github.com/starknet-edu/starknetbook/tree/main/examples/foundry-example)"
msgstr "ä»¥ä¸‹ä»£ç ç¤ºä¾‹æ¥è‡ª `starknet foundry`ã€‚æ‚¨å¯ä»¥åœ¨ [æ­¤å¤„](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html) æ‰¾åˆ°åŸæ–‡ã€‚"

#: src/ch02-08-foundry-cast.md:55
msgid "// Increases the balance by the given amount.\n"
msgstr ""

#: src/ch02-08-foundry-cast.md:60
#, fuzzy
msgid "// Gets the balance.\n"
msgstr "æ£€æŸ¥ä½™é¢ï¼š"

#: src/ch02-08-foundry-cast.md:68
msgid "Before interacting with this sample smart contract, it's crucial to test its functionality using **`snforge`** to ensure its integrity."
msgstr "åœ¨ä¸æ­¤ç¤ºä¾‹æ™ºèƒ½åˆçº¦äº¤äº’ä¹‹å‰ï¼Œä½¿ç”¨ **`snforge`** æµ‹è¯•å…¶åŠŸèƒ½ä»¥ç¡®ä¿å…¶å®Œæ•´æ€§è‡³å…³é‡è¦ã€‚"

#: src/ch02-08-foundry-cast.md:70
msgid "Here are the associated tests:"
msgstr "ä»¥ä¸‹æ˜¯ç›¸å…³æµ‹è¯•ï¼š"

#: src/ch02-08-foundry-cast.md:72
msgid "Take a keen look onto the imports ie"
msgstr ""

#: src/ch02-08-foundry-cast.md:78
msgid "`casttest` from the above line is the name of the project as given in the `scarb.toml` file"
msgstr ""

#: src/ch02-08-foundry-cast.md:88
#, fuzzy
msgid "// Declare and deploy a contract\n"
msgstr "## ç¬¬ 4 æ­¥ï¼šå£°æ˜å’Œéƒ¨ç½²æˆ‘ä»¬çš„åˆçº¦"

#: src/ch02-08-foundry-cast.md:92
#, fuzzy
msgid "// Create a Dispatcher object for interaction with the deployed contract\n"
msgstr "è®©æˆ‘ä»¬æ·±å…¥äº†è§£å¦‚ä½•ä½¿ç”¨ `sncast` ä¸åˆçº¦äº¤äº’ã€‚"

#: src/ch02-08-foundry-cast.md:95
msgid "// Query a contract view function\n"
msgstr ""

#: src/ch02-08-foundry-cast.md:99
msgid "// Invoke a contract function to mutate state\n"
msgstr ""

#: src/ch02-08-foundry-cast.md:102
msgid "// Verify the transaction's effect\n"
msgstr ""

#: src/ch02-08-foundry-cast.md:109
msgid "If needed, copy the provided code snippets into the `lib.cairo` file of your new scarb project."
msgstr "å¦‚æœ‰éœ€è¦ï¼Œå°†æä¾›çš„ä»£ç ç‰‡æ®µå¤åˆ¶åˆ°æ–° scarb é¡¹ç›®çš„ `lib.cairo`æ–‡ä»¶ä¸­ã€‚"

#: src/ch02-08-foundry-cast.md:111
msgid "To execute tests, follow the steps below:"
msgstr "æ‰§è¡Œæµ‹è¯•çš„æ­¥éª¤å¦‚ä¸‹ï¼š"

#: src/ch02-08-foundry-cast.md:113
#, fuzzy
msgid ""
"Ensure `snforge` is listed as a dependency in your `Scarb.toml` file, positioned beneath the `starknet` dependency. Your dependencies section should appear as (make sure to use the latest version of "
"`snforge` and `starknet`):"
msgstr "1.ç¡®ä¿å°† `snforge` åˆ—ä¸º`Scarb.toml`æ–‡ä»¶ä¸­çš„ä¾èµ–é¡¹ï¼Œä½äº`starknet`ä¾èµ–é¡¹çš„ä¸‹æ–¹ã€‚æ‚¨çš„ä¾èµ–å…³ç³»éƒ¨åˆ†åº”æ˜¾ç¤ºä¸ºï¼ˆç¡®ä¿ä½¿ç”¨æœ€æ–°ç‰ˆæœ¬çš„ `snforge` å’Œ `starknet`ï¼‰ï¼š"

#: src/ch02-08-foundry-cast.md:120
#, fuzzy
msgid "Run the command:"
msgstr "2.è¿è¡Œå‘½ä»¤ï¼š"

#: src/ch02-08-foundry-cast.md:126
#, fuzzy
msgid "**Note:** Use `snforge` for testing instead of the `scarb test` command. The tests are set up to utilize functions from `snforge_std`. Running `scarb test` would cause errors."
msgstr "æ³¨æ„: æµ‹è¯•æ—¶ä½¿ç”¨ `snforge` è€Œä¸æ˜¯ `scarb test` å‘½ä»¤ã€‚æµ‹è¯•å°†ä½¿ç”¨ `snforge_std` ä¸­çš„å‡½æ•°ã€‚è¿è¡Œ `scarb test` ä¼šå¯¼è‡´é”™è¯¯ã€‚"

#: src/ch02-08-foundry-cast.md:128
#, fuzzy
msgid "Step 2: Setting Up Starknet Devnet"
msgstr "## ç¬¬ 2 æ­¥ï¼šè®¾ç½®Starknet Devnet"

#: src/ch02-08-foundry-cast.md:130
#, fuzzy
msgid ""
"For this guide, the focus is on using `Rust starknet devnet`. If you've been using `katana` or `pythonic devnet`, please be cautious as there might be inconsistencies. If you haven't configured "
"`devnet`, consider following the [guide](ch02-07-starknet-devnet.md) from Starknet devnet for a quick setup."
msgstr ""
"æœ¬æŒ‡å—çš„é‡ç‚¹æ˜¯ä½¿ç”¨ `starknet-devnet`ã€‚å¦‚æœæ‚¨ä¸€ç›´åœ¨ä½¿ç”¨ `katana`ï¼Œè¯·åŠ¡å¿…è°¨æ…ï¼Œå› ä¸ºå¯èƒ½ä¼šæœ‰ä¸ä¸€è‡´çš„åœ°æ–¹ã€‚å¦‚æœæ‚¨è¿˜æ²¡æœ‰é…ç½®è¿‡ `devnet`ï¼Œè¯·è€ƒè™‘æŒ‰ç…§æœ¬ [æŒ‡å—](https://livesoftwaredeveloper.com/articles/9/how-"
"to-set-up-starknet-devnet-and-frontend-for-smart-contract-development)è¿›è¡Œå¿«é€Ÿè®¾ç½®ã€‚"

#: src/ch02-08-foundry-cast.md:132
msgid "To launch `starknet devnet`, use the command:"
msgstr "è¦å¯åŠ¨ `starknet devnet`ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-08-foundry-cast.md:138
msgid "Upon successful startup, you should receive a response similar to:"
msgstr "å¯åŠ¨æˆåŠŸåï¼Œæ‚¨åº”è¯¥ä¼šæ”¶åˆ°ç±»ä¼¼çš„å›å¤ï¼š"

#: src/ch02-08-foundry-cast.md:161
msgid "(Note: The abbreviated ... is just a placeholder for the detailed response. In your actual output, you'll see the full details.)"
msgstr "(æ³¨æ„ï¼šç¼©å†™çš„...åªæ˜¯è¯¦ç»†å›å¤çš„å ä½ç¬¦ã€‚åœ¨å®é™…è¾“å‡ºä¸­ï¼Œæ‚¨å°†çœ‹åˆ°å®Œæ•´çš„è¯¦ç»†ä¿¡æ¯ã€‚ï¼‰"

#: src/ch02-08-foundry-cast.md:163
msgid "Now, you have written a smart contract, tested it, and successfully initiated starknet devnet."
msgstr "ç°åœ¨ï¼Œæ‚¨å·²ç»ç¼–å†™äº†ä¸€ä»½æ™ºèƒ½åˆçº¦ï¼Œå¯¹å…¶è¿›è¡Œäº†æµ‹è¯•ï¼Œå¹¶æˆåŠŸå¯åŠ¨äº†Starknet Devnetã€‚"

#: src/ch02-08-foundry-cast.md:165
#, fuzzy
msgid "Dive into `sncast`"
msgstr "## æ·±å…¥ `sncast`"

#: src/ch02-08-foundry-cast.md:167
msgid "Let's unpack **`sncast`**."
msgstr "è®©æˆ‘ä»¬æ¥è§£è¯»**`sncast`**ã€‚"

#: src/ch02-08-foundry-cast.md:169
msgid "As a multifunctional tool, the quickest way to discover its capabilities is via the command:"
msgstr "ä½œä¸ºä¸€æ¬¾å¤šåŠŸèƒ½å·¥å…·ï¼Œäº†è§£å…¶åŠŸèƒ½çš„æœ€å¿«æ–¹æ³•å°±æ˜¯é€šè¿‡å‘½ä»¤ï¼š"

#: src/ch02-08-foundry-cast.md:175
msgid "In the output, you'll notice distinct categories: `commands` and `options`. Each option offers both a concise (`short`) and a descriptive (`long`) variant."
msgstr "åœ¨è¾“å‡ºä¸­ï¼Œä½ ä¼šæ³¨æ„åˆ°ä¸åŒçš„ç±»åˆ«ï¼š`commands` å’Œ `options`ã€‚æ¯ä¸ªé€‰é¡¹éƒ½æœ‰ç®€çŸ­(`short`) å’Œæè¿°æ€§(`long`)ä¸¤ç§ç‰ˆæœ¬ã€‚"

#: src/ch02-08-foundry-cast.md:177
#, fuzzy
msgid "**Tip:** While both option variants are useful, we'll prioritize the long form in this guide. This choice aids clarity, especially when constructing intricate commands."
msgstr "> æç¤ºï¼šè™½ç„¶ä¸¤ç§é€‰é¡¹å˜ä½“éƒ½å¾ˆæœ‰ç”¨ï¼Œä½†åœ¨æœ¬æŒ‡å—ä¸­æˆ‘ä»¬å°†ä¼˜å…ˆä½¿ç”¨é•¿æ ¼å¼ã€‚è¿™ç§é€‰æ‹©æœ‰åŠ©äºæé«˜æ¸…æ™°åº¦ï¼Œå°¤å…¶æ˜¯åœ¨ç¼–å†™å¤æ‚çš„å‘½ä»¤æ—¶ã€‚"

#: src/ch02-08-foundry-cast.md:179
msgid "Delving deeper, to understand specific commands such as **`account`**, you can run:"
msgstr "è¦æ·±å…¥äº†è§£**`account`**ç­‰ç‰¹å®šå‘½ä»¤ï¼Œå¯ä»¥è¿è¡Œï¼š"

#: src/ch02-08-foundry-cast.md:185
msgid "Each account subcommand like `add`, `create`, and `deploy` can be further explored. For instance:"
msgstr "æ¯ä¸ªè´¦æˆ·å­å‘½ä»¤ï¼Œå¦‚ `add`, `create`, å’Œ `deploy` ï¼Œéƒ½å¯ä»¥è¿›ä¸€æ­¥æ¢ç´¢ã€‚ä¾‹å¦‚ï¼š"

#: src/ch02-08-foundry-cast.md:191
msgid "The layered structure of `sncast` provides a wealth of information right at your fingertips. It's like having dynamic documentation. Make it a habit to explore, and you'll always stay informed."
msgstr "`sncast` çš„åˆ†å±‚ç»“æ„ä¸ºæ‚¨æä¾›äº†ä¸°å¯Œçš„ä¿¡æ¯ã€‚è¿™å°±åƒæ‹¥æœ‰åŠ¨æ€æ–‡æ¡£ä¸€æ ·ã€‚å…»æˆæ¢ç´¢çš„ä¹ æƒ¯ï¼Œæ‚¨å°±èƒ½å§‹ç»ˆæŒæ¡æœ€æ–°ä¿¡æ¯ã€‚"

#: src/ch02-08-foundry-cast.md:193
#, fuzzy
msgid "Step 3: Using `sncast` for Account Management"
msgstr "## ç¬¬ 3 æ­¥ï¼šä½¿ç”¨ `sncast` è¿›è¡Œè´¦æˆ·ç®¡ç†"

#: src/ch02-08-foundry-cast.md:195
msgid "Let's delve into how to use `sncast` for interacting with the contract."
msgstr "è®©æˆ‘ä»¬æ·±å…¥äº†è§£å¦‚ä½•ä½¿ç”¨ `sncast` ä¸åˆçº¦äº¤äº’ã€‚"

#: src/ch02-08-foundry-cast.md:197
msgid ""
"By default, `starknet devnet` offers several `predeployed accounts`. These are accounts already registered with the node, loaded with test tokens (for gas fees and various transactions). Developers "
"can use them directly with any `contract` on the `local node` (i.e., starknet devnet)."
msgstr "é»˜è®¤æƒ…å†µä¸‹ï¼Œ`starknet devnet`æä¾›å¤šä¸ª `predeployed accounts`ï¼ˆé¢„éƒ¨ç½²è´¦æˆ·ï¼‰ã€‚è¿™äº›è´¦æˆ·å·²ç»åœ¨èŠ‚ç‚¹ä¸Šæ³¨å†Œï¼Œå¹¶è£…è½½äº†æµ‹è¯•ä»£å¸ï¼ˆç”¨äºgaså’Œå„ç§äº¤æ˜“ï¼‰ã€‚å¼€å‘è€…å¯ä»¥ç›´æ¥åœ¨æœ¬åœ°èŠ‚ç‚¹ä¸Šä½¿ç”¨å®ƒä»¬ã€‚"

#: src/ch02-08-foundry-cast.md:199
#, fuzzy
msgid "How to Utilize Predeployed Accounts"
msgstr "### å¦‚ä½•åˆ©ç”¨é¢„å…ˆéƒ¨ç½²çš„è´¦æˆ·"

#: src/ch02-08-foundry-cast.md:201
msgid "To employ a predeployed account with the smart contract, execute the `account add` command as shown below:"
msgstr "è¦åœ¨æ™ºèƒ½åˆçº¦ä¸­ä½¿ç”¨é¢„å…ˆéƒ¨ç½²çš„è´¦æˆ·ï¼Œè¯·æ‰§è¡Œ`account add`å‘½ä»¤ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š"

#: src/ch02-08-foundry-cast.md:207
msgid ""
"Although several options can accompany the `add` command (e.g., `--name, --address, --class-hash, --deployed, --private-key, --public-key, --salt, --add-profile`), we'll focus on a select few for this "
"illustration."
msgstr "è™½ç„¶ `add` å‘½ä»¤å¯ä»¥åŒ…å«å¤šä¸ªé€‰é¡¹ï¼ˆä¾‹å¦‚ï¼Œ`--name, --address, --class-hash, --deployed, --private-key, --public-key, -salt, --add-profile` ï¼‰ï¼Œä½†æˆ‘ä»¬åœ¨æœ¬ä¾‹ä¸­å°†é‡ç‚¹ä»‹ç»å…¶ä¸­çš„å‡ ä¸ªé€‰é¡¹ã€‚"

#: src/ch02-08-foundry-cast.md:209
msgid "Choose an account from the **`starknet-devnet`**, for demonstration, we'll select account **`#0`**, and execute:"
msgstr "ä»**`starknet-devnet`**ä¸­é€‰æ‹©ä¸€ä¸ªè´¦æˆ·ï¼Œä½œä¸ºæ¼”ç¤ºï¼Œæˆ‘ä»¬å°†é€‰æ‹©è´¦æˆ·**`#0`**ï¼Œç„¶åæ‰§è¡Œï¼š"

#: src/ch02-08-foundry-cast.md:215
msgid "Points to remember:"
msgstr "éœ€è¦è®°ä½çš„è¦ç‚¹ï¼š"

#: src/ch02-08-foundry-cast.md:217
msgid "**`-name`** - Mandatory field."
msgstr ""

#: src/ch02-08-foundry-cast.md:218
msgid "**`-address`** - Necessary account address."
msgstr ""

#: src/ch02-08-foundry-cast.md:219
msgid "**`-private-key`** - Private key of the account."
msgstr ""

#: src/ch02-08-foundry-cast.md:220
#, fuzzy
msgid ""
"**`-add-profile`** - Though optional, it's pivotal. By enabling **`sncast`** to include the account in your **`Scarb.toml`** file, you can manage multiple accounts, facilitating transactions among "
"them when working with your smart contract using sncast."
msgstr ""
"1. **`-name`** - å¿…å¡«å­—æ®µã€‚\n"
"2. **`-address`** - å¿…è¦çš„è´¦æˆ·åœ°å€ã€‚\n"
"3. **`-private-key`** - è´¦æˆ·çš„ç§äººå¯†é’¥ã€‚\n"
"4. **`-add-profile`** - è™½ç„¶æ˜¯å¯é€‰é¡¹ï¼Œä½†éå¸¸é‡è¦ã€‚é€šè¿‡å¯ç”¨**`sncast`**ï¼Œå°†è´¦æˆ·åŒ…å«åœ¨**`Scarb.toml`**æ–‡ä»¶ä¸­ï¼Œæ‚¨å¯ä»¥ç®¡ç†å¤šä¸ªè´¦æˆ·ï¼Œåœ¨ä½¿ç”¨sncastå¤„ç†æ™ºèƒ½åˆçº¦æ—¶ï¼Œæ–¹ä¾¿å®ƒä»¬ä¹‹é—´çš„äº¤æ˜“ã€‚"

#: src/ch02-08-foundry-cast.md:222
#, fuzzy
msgid "Now that we have familiarized ourselves with using a predeployed account, let's proceed to add a new account."
msgstr "ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»ç†Ÿæ‚‰äº†å¦‚ä½•ä½¿ç”¨é¢„å…ˆéƒ¨ç½²çš„è´¦æˆ·ï¼Œè®©æˆ‘ä»¬ç»§ç»­æ·»åŠ ä¸€ä¸ªæ–°è´¦æˆ·ã€‚"

#: src/ch02-08-foundry-cast.md:224
#, fuzzy
msgid "Creating and Deploying a New Account to Starknet Devnet"
msgstr "### åœ¨Starknet Devnet åˆ›å»ºå’Œéƒ¨ç½²æ–°è´¦æˆ·"

#: src/ch02-08-foundry-cast.md:226
msgid "Creating a new account involves a few more steps than using an existing one, but it's straightforward when broken down. Here are the steps:"
msgstr "åˆ›å»ºæ–°è´¦æˆ·è¦æ¯”ä½¿ç”¨ç°æœ‰è´¦æˆ·å¤šå‡ ä¸ªæ­¥éª¤ï¼Œä½†ç»†åˆ†èµ·æ¥ä¹Ÿå¾ˆç®€å•ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š"

#: src/ch02-08-foundry-cast.md:228
#, fuzzy
msgid "Account Creation"
msgstr "1.åˆ›å»ºè´¦æˆ·"

#: src/ch02-08-foundry-cast.md:230
msgid "To create a new account, use (you can use `sncast account create --help` to see the available options):"
msgstr "è¦åˆ›å»ºæ–°è´¦æˆ·ï¼Œè¯·ä½¿ç”¨ï¼ˆå¯ä»¥ä½¿ç”¨ `sncast account create --help` æŸ¥çœ‹å¯ç”¨é€‰é¡¹ï¼‰ï¼š"

#: src/ch02-08-foundry-cast.md:236
msgid "Wondering where the `--class-hash` comes from? It's visible in the output from the `starknet-devnet` command under the Predeclared Starknet CLI account section. For example:"
msgstr "æƒ³çŸ¥é“ `--class-hash` ä»ä½•è€Œæ¥ï¼Ÿåœ¨é¢„è®¾ Starknet CLI è´¦æˆ·éƒ¨åˆ†çš„ `starknet-devnet` å‘½ä»¤è¾“å‡ºä¸­å¯ä»¥çœ‹åˆ°å®ƒã€‚ä¾‹å¦‚ï¼š"

#: src/ch02-08-foundry-cast.md:245
#, fuzzy
msgid "Funding the Account"
msgstr "2.ä¸ºè´¦æˆ·æä¾›èµ„é‡‘"

#: src/ch02-08-foundry-cast.md:247
msgid "To fund the new account, replace the address in the following command with your new one:"
msgstr "è¦ä¸ºæ–°è´¦æˆ·æ³¨èµ„ï¼Œè¯·å°†ä»¥ä¸‹å‘½ä»¤ä¸­çš„åœ°å€æ›¿æ¢ä¸ºæ–°åœ°å€ï¼š"

#: src/ch02-08-foundry-cast.md:250
msgid "'{\"amount\":8646000000000, \"address\":\"0x6e...eadf\"}'"
msgstr ""

#: src/ch02-08-foundry-cast.md:250
msgid "\"Content-Type: application/json\""
msgstr ""

#: src/ch02-08-foundry-cast.md:253
msgid "Note: The **amount** is specified in the previous command's output."
msgstr "æ³¨æ„ï¼š**amount**å·²åœ¨ä¸Šä¸€æ¡å‘½ä»¤çš„è¾“å‡ºä¸­æŒ‡å®šã€‚"

#: src/ch02-08-foundry-cast.md:255
msgid "A successful fund addition will return:"
msgstr "æˆåŠŸå¢èµ„åå°†è¿”å›ï¼š"

#: src/ch02-08-foundry-cast.md:258
msgid "\"new_balance\""
msgstr ""

#: src/ch02-08-foundry-cast.md:258
msgid "\"tx_hash\""
msgstr ""

#: src/ch02-08-foundry-cast.md:258
msgid "\"0x48...1919\""
msgstr ""

#: src/ch02-08-foundry-cast.md:258
msgid "\"unit\""
msgstr ""

#: src/ch02-08-foundry-cast.md:258
msgid "\"wei\""
msgstr ""

#: src/ch02-08-foundry-cast.md:261
#, fuzzy
msgid "Account Deployment"
msgstr "3.è´¦æˆ·éƒ¨ç½²"

#: src/ch02-08-foundry-cast.md:263
msgid "Deploy the account to the **`starknet devnet`** local node to register it with the chain:"
msgstr "å°†è´¦æˆ·éƒ¨ç½²åˆ° **`starknet devnet`** æœ¬åœ°èŠ‚ç‚¹ï¼Œä»¥ä¾¿åœ¨é“¾ä¸Šæ³¨å†Œï¼š"

#: src/ch02-08-foundry-cast.md:269
msgid "A successful deployment provides a transaction hash. If it doesn't work, revisit your previous steps."
msgstr "æˆåŠŸéƒ¨ç½²ä¼šæä¾›ä¸€ä¸ªäº‹åŠ¡å“ˆå¸Œå€¼ã€‚å¦‚æœä¸æˆåŠŸï¼Œè¯·é‡æ–°æ£€æŸ¥ä¹‹å‰çš„æ­¥éª¤ã€‚"

#: src/ch02-08-foundry-cast.md:271
#, fuzzy
msgid "Setting a Default Profile"
msgstr "4.è®¾ç½®é»˜è®¤é…ç½®æ–‡ä»¶"

#: src/ch02-08-foundry-cast.md:273
msgid ""
"You can define a default profile for your **`sncast`** actions. To set one, edit the **`Scarb.toml`** file. To make the **`new_account`** the default profile, find the section **`[tool.sncast."
"new_account]`** and change it to **`[tool.sncast]`**. This means **`sncast`** will default to using this profile unless instructed otherwise."
msgstr ""
"æ‚¨å¯ä»¥ä¸º**`sncast`**æ“ä½œå®šä¹‰é»˜è®¤é…ç½®æ–‡ä»¶ã€‚è¦è®¾ç½®é»˜è®¤é…ç½®æ–‡ä»¶ï¼Œè¯·ç¼–è¾‘**`Scarb.toml`**æ–‡ä»¶ã€‚è¦å°†**`new_account`**è®¾ä¸ºé»˜è®¤é…ç½®æ–‡ä»¶ï¼Œè¯·æ‰¾åˆ°**`[tool.sncast.new_account]`**éƒ¨åˆ†å¹¶å°†å…¶æ›´æ”¹ä¸º**`[tool."
"sncast]`**ã€‚è¿™æ„å‘³ç€é™¤éå¦æœ‰æŒ‡ç¤ºï¼Œ**`sncast`** å°†é»˜è®¤ä½¿ç”¨æ­¤é…ç½®æ–‡ä»¶ã€‚"

#: src/ch02-08-foundry-cast.md:275
#, fuzzy
msgid "Step 4: Declaring and Deploying our Contract"
msgstr "## ç¬¬ 4 æ­¥ï¼šå£°æ˜å’Œéƒ¨ç½²æˆ‘ä»¬çš„åˆçº¦"

#: src/ch02-08-foundry-cast.md:277
msgid "By now, we've arrived at the crucial step of using `sncast` to declare and deploy our smart contracts."
msgstr "ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»åˆ°äº†ä½¿ç”¨ `sncast` æ¥å£°æ˜å’Œéƒ¨ç½²æ™ºèƒ½åˆçº¦çš„å…³é”®æ­¥éª¤ã€‚"

#: src/ch02-08-foundry-cast.md:279
#, fuzzy
msgid "Declaring the Contract"
msgstr "2.å£°æ˜åˆçº¦"

#: src/ch02-08-foundry-cast.md:281
msgid "Recall that we drafted and tested the contract in **Step 1**. Here, we'll focus on two actions: building and declaring."
msgstr "å›é¡¾ä¸€ä¸‹ï¼Œæˆ‘ä»¬åœ¨**æ­¥éª¤ 1** ä¸­èµ·è‰å¹¶æµ‹è¯•äº†åˆçº¦ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨ä¸¤ä¸ªæ“ä½œï¼šç¼–è¯‘å’Œå£°æ˜ã€‚"

#: src/ch02-08-foundry-cast.md:283
#, fuzzy
msgid "**Building the Contract**"
msgstr "1. **ç¼–è¯‘åˆçº¦**"

#: src/ch02-08-foundry-cast.md:285
msgid "Execute the following to build the contract:"
msgstr "æ‰§è¡Œä»¥ä¸‹æ“ä½œä»¥ç¼–è¯‘åˆçº¦ï¼š"

#: src/ch02-08-foundry-cast.md:291
msgid ""
"If you've successfully run tests using **`snforge`**, the **`scarb build`** should operate without issues. After the build completes, a new **`target`** folder will appear at the root of your project."
msgstr "å¦‚æœæ‚¨å·²æˆåŠŸä½¿ç”¨**`snforge`**è¿›è¡Œäº†æµ‹è¯•ï¼Œé‚£ä¹ˆ**`scarb build`**åº”è¯¥å¯ä»¥é¡ºåˆ©è¿è¡Œã€‚æ„å»ºå®Œæˆåï¼Œé¡¹ç›®æ ¹ç›®å½•ä¸‹ä¼šå‡ºç°ä¸€ä¸ªæ–°çš„ **`target`** æ–‡ä»¶å¤¹ã€‚"

#: src/ch02-08-foundry-cast.md:293
msgid "Within the **`target`** folder, you'll find a **`dev`** sub-folder containing three files: **`*.casm.json`**, **`*.sierra.json`**, and **`*.starknet_artifacts.json`**."
msgstr "åœ¨**`target`**æ–‡ä»¶å¤¹ä¸­ï¼Œä½ ä¼šå‘ç°ä¸€ä¸ª**`dev`**å­æ–‡ä»¶å¤¹ï¼Œå…¶ä¸­åŒ…å«ä¸‰ä¸ªæ–‡ä»¶ï¼š ***`*.casm.json`**ã€**`*.sierra.json`**å’Œ**`*.starknet_artifacts.json`**ã€‚"

#: src/ch02-08-foundry-cast.md:295
msgid "If these files aren't present, it's likely due to missing configurations in your **`Scarb.toml`** file. To address this, append the following lines after **`dependencies`**:"
msgstr "å¦‚æœæ²¡æœ‰è¿™äº›æ–‡ä»¶ï¼Œå¾ˆå¯èƒ½æ˜¯ç”±äº**`Scarb.toml`**æ–‡ä»¶ä¸­ç¼ºå°‘é…ç½®ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¯·åœ¨ **`dependencies`** åæ·»åŠ ä»¥ä¸‹å‡ è¡Œï¼š"

#: src/ch02-08-foundry-cast.md:303
msgid "These lines instruct the compiler to produce both `sierra` and `casm` outputs."
msgstr "è¿™äº›è¡ŒæŒ‡ç¤ºç¼–è¯‘å™¨åŒæ—¶ç”Ÿæˆ `sierra` å’Œ `casm` è¾“å‡ºã€‚"

#: src/ch02-08-foundry-cast.md:305
#, fuzzy
msgid "**Declaring the Contract**"
msgstr "2.å£°æ˜åˆçº¦"

#: src/ch02-08-foundry-cast.md:307
msgid "We will use the `sncast declare` command to declare the contract. Here's the format:"
msgstr "æˆ‘ä»¬å°†ä½¿ç”¨ `sncast declare` å‘½ä»¤æ¥å£°æ˜åˆçº¦ã€‚æ ¼å¼å¦‚ä¸‹ï¼š"

#: src/ch02-08-foundry-cast.md:313
msgid "Given this, the correct command would be:"
msgstr "å› æ­¤ï¼Œæ­£ç¡®çš„æŒ‡ä»¤åº”è¯¥æ˜¯ï¼š"

#: src/ch02-08-foundry-cast.md:319
#, fuzzy
msgid ""
"**Note:-** that we've omitted the **`--url`** option. Why? When using **`--profile`**, as seen here with **`account1`**, it's not necessary. Remember, earlier in this guide, we discussed adding and "
"creating new accounts. You can use either **`account1`** or **`new_account`** and achieve the desired result."
msgstr ""
"è¯·æ³¨æ„ï¼Œæˆ‘ä»¬çœç•¥äº† **`--url`** é€‰é¡¹ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿåœ¨ä½¿ç”¨ **`--profile`**ï¼ˆå¦‚è¿™é‡Œçš„ **`account1`**ï¼‰æ—¶ï¼Œå®ƒä¸æ˜¯å¿…éœ€çš„ã€‚è¯·è®°ä½ï¼Œåœ¨æœ¬æŒ‡å—çš„å‰é¢éƒ¨åˆ†ï¼Œæˆ‘ä»¬è®¨è®ºäº†æ·»åŠ å’Œåˆ›å»ºæ–°è´¦æˆ·ã€‚ä½ å¯ä»¥ä½¿ç”¨**`account1`**æˆ–"
"**`new_account`**æ¥è¾¾åˆ°é¢„æœŸæ•ˆæœã€‚"

#: src/ch02-08-foundry-cast.md:321
#, fuzzy
msgid ""
"**Hint:** You can define a default profile for sncast actions. Modify the `Scarb.toml` file to set a default. For example, to make `new_account` the default, find `[tool.sncast.new_account]` and "
"change it to `[tool.sncast]`. Then, there's no need to specify the profile for each call, simplifying your command to:"
msgstr ""
"> æç¤ºï¼šæ‚¨å¯ä»¥ä¸º sncast æ“ä½œå®šä¹‰é»˜è®¤é…ç½®æ–‡ä»¶ã€‚ä¿®æ”¹ `Scarb.toml` æ–‡ä»¶ä»¥è®¾ç½®é»˜è®¤å€¼ã€‚ä¾‹å¦‚ï¼Œè¦å°† `new_account` è®¾ç½®ä¸ºé»˜è®¤å€¼ï¼Œè¯·æ‰¾åˆ° `[tool.sncast.new_account]`ï¼Œå¹¶å°†å…¶æ›´æ”¹ä¸º `[tool.sncast]`ã€‚è¿™æ ·ï¼Œå°±æ— éœ€ä¸º"
"æ¯æ¬¡è°ƒç”¨æŒ‡å®šé…ç½®æ–‡ä»¶ï¼Œä»è€Œç®€åŒ–äº†å‘½ä»¤ï¼š"

#: src/ch02-08-foundry-cast.md:327
msgid "The output will resemble:"
msgstr "è¾“å‡ºç»“æœç±»ä¼¼äºï¼š"

#: src/ch02-08-foundry-cast.md:335
msgid "Make sure to note the \\*\\*`class hash` as it will be essential in the subsequent step."
msgstr "è¯·åŠ¡å¿…è®°ä¸‹ \\*\\*`class hash`ï¼Œå› ä¸ºå®ƒåœ¨åç»­æ­¥éª¤ä¸­è‡³å…³é‡è¦ã€‚"

#: src/ch02-08-foundry-cast.md:337
#, fuzzy
msgid ""
"**Note:** If you encounter an error stating Class hash already declared, simply move to the next step. Redeclaring an already-declared contract isn't permissible. Use the mentioned class hash for "
"deployment."
msgstr "> æ³¨æ„ï¼šå¦‚æœé‡åˆ° \"Class hash already declared \"çš„é”™è¯¯æç¤ºï¼Œè¯·ç›´æ¥è¿›å…¥ä¸‹ä¸€æ­¥ã€‚ä¸å…è®¸é‡æ–°å£°æ˜å·²å£°æ˜çš„åˆçº¦ã€‚è¯·ä½¿ç”¨ä¸Šè¿°ç±»æ•£åˆ—è¿›è¡Œéƒ¨ç½²ã€‚"

#: src/ch02-08-foundry-cast.md:339 src/ch04-02-hello-account.md:180
#, fuzzy
msgid "Deploying the Contract"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch02-08-foundry-cast.md:341
msgid ""
"With the contract successfully declared and a `class hash` obtained, we're ready to proceed to contract deployment. This step is straightforward. Replace `<class-hash>` in the command below with your "
"obtained class hash:"
msgstr "æˆåŠŸå£°æ˜äº†åˆçº¦å¹¶è·å¾—äº† `class hash`åï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹éƒ¨ç½²åˆçº¦äº†ã€‚è¿™ä¸€æ­¥å¾ˆç®€å•ã€‚å°†ä¸‹é¢å‘½ä»¤ä¸­çš„ `<class-hash>` æ›¿æ¢ä¸ºè·å¾—çš„ç±»æ•£åˆ—ï¼š"

#: src/ch02-08-foundry-cast.md:347
msgid "Executing this will likely yield:"
msgstr "è¿™æ ·åšçš„ç»“æœå¯èƒ½æ˜¯ï¼š"

#: src/ch02-08-foundry-cast.md:355
msgid "However, you may encounter some issues, such as:"
msgstr "ä¸è¿‡ï¼Œæ‚¨å¯èƒ½ä¼šé‡åˆ°ä¸€äº›é—®é¢˜ï¼Œä¾‹å¦‚ï¼š"

#: src/ch02-08-foundry-cast.md:357
msgid "**Error: RPC url not passed nor found in Scarb.toml**. This indicates the absence of a default profile in the **`Scarb.toml`** file. To remedy this:"
msgstr "**Error: RPC url not passed nor found in Scarb.toml**ã€‚è¿™è¡¨æ˜ **`Scarb.toml`** æ–‡ä»¶ä¸­æ²¡æœ‰é»˜è®¤é…ç½®æ–‡ä»¶ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼š"

#: src/ch02-08-foundry-cast.md:359
msgid "Add the **`--profile`** option, followed by the desired profile name, as per the ones you've established."
msgstr ""

#: src/ch02-08-foundry-cast.md:360
#, fuzzy
msgid "Alternatively, set a default profile as previously discussed in the \"Declaring the Contract\" section under \"Hint\" or as detailed in the \"Adding, Creating, and Deploying Account\" subsection."
msgstr ""
"- æ·»åŠ **`-profile`***é€‰é¡¹ï¼Œä¹‹åæ˜¯æ‰€éœ€çš„é…ç½®æ–‡ä»¶åç§°ï¼Œä¸å·²å»ºç«‹çš„é…ç½®æ–‡ä»¶åç§°ä¸€è‡´ã€‚\n"
"- æˆ–è€…ï¼ŒæŒ‰ç…§ä¹‹å‰åœ¨ \"Hint \"ä¸‹çš„ \"å£°æ˜åˆçº¦ \"ä¸€èŠ‚ä¸­è®¨è®ºçš„æ–¹æ³•æˆ– \"æ·»åŠ ã€åˆ›å»ºå’Œéƒ¨ç½²è´¦æˆ· \"å°èŠ‚ä¸­çš„è¯¦ç»†è¯´æ˜ï¼Œè®¾ç½®é»˜è®¤é…ç½®æ–‡ä»¶ã€‚"

#: src/ch02-08-foundry-cast.md:362
msgid "You've successfully deployed your contract with `sncast`! Now, let's explore how to interact with it."
msgstr "æ‚¨å·²ç»æˆåŠŸåœ°ç”¨ `sncast` éƒ¨ç½²äº†æ‚¨çš„åˆçº¦ï¼ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥æ¢è®¨ä¸€ä¸‹å¦‚ä½•ä¸ä¹‹äº¤äº’ã€‚"

#: src/ch02-08-foundry-cast.md:364
#, fuzzy
msgid "Interacting with the Contract"
msgstr "## ä¸åˆçº¦äº¤äº’"

#: src/ch02-08-foundry-cast.md:366
msgid "This section explains how to read and write information to the contract."
msgstr "æœ¬èŠ‚ä»‹ç»å¦‚ä½•è¯»å–å’Œå†™å…¥åˆçº¦ä¿¡æ¯ã€‚"

#: src/ch02-08-foundry-cast.md:368
#, fuzzy
msgid "Invoking Contract Functions"
msgstr "### è°ƒç”¨åˆçº¦å‡½æ•°"

#: src/ch02-08-foundry-cast.md:370
msgid "To write to the contract, invoke its functions. Here's a basic overview of the command:"
msgstr "è¦å†™å…¥åˆçº¦ï¼Œè¯·è°ƒç”¨å…¶å‡½æ•°ã€‚ä¸‹é¢æ˜¯è¯¥å‘½ä»¤çš„åŸºæœ¬æ¦‚è¿°ï¼š"

#: src/ch02-08-foundry-cast.md:383
msgid ""
"To demonstrate, let's invoke the `increase_balance` method of our smart contract with a preset default profile. Not every option is always necessary; for instance, sometimes, including the `--max-fee` "
"might be essential."
msgstr "ä¸ºäº†æ¼”ç¤ºï¼Œè®©æˆ‘ä»¬è°ƒç”¨æ™ºèƒ½åˆçº¦çš„ `increase_balance`æ–¹æ³•ï¼Œå¹¶é¢„è®¾ä¸€ä¸ªé»˜è®¤é…ç½®æ–‡ä»¶ã€‚å¹¶éæ¯ä¸ªé€‰é¡¹éƒ½æ˜¯å¿…è¦çš„ï¼›ä¾‹å¦‚ï¼Œæœ‰æ—¶å¯èƒ½å¿…é¡»åŒ…å«\"-max-fee\"ã€‚"

#: src/ch02-08-foundry-cast.md:389
msgid "If successful, you'll receive a transaction hash like this:"
msgstr "å¦‚æœæˆåŠŸï¼Œæ‚¨å°†æ”¶åˆ°è¿™æ ·çš„äº¤æ˜“å“ˆå¸Œå€¼ï¼š"

#: src/ch02-08-foundry-cast.md:396
#, fuzzy
msgid "Reading from the Contract"
msgstr "### ä»åˆçº¦è¯»å–æ•°æ®"

#: src/ch02-08-foundry-cast.md:398
msgid "To retrieve data from the contract, use the `sncast call` command. Here's how it works:"
msgstr "è¦ä»åˆçº¦ä¸­è·å–æ•°æ®ï¼Œè¯·ä½¿ç”¨ `sncast call` å‘½ä»¤ã€‚å…·ä½“æ“ä½œå¦‚ä¸‹ï¼š"

#: src/ch02-08-foundry-cast.md:404
msgid "Executing the command displays:"
msgstr "æ‰§è¡Œå‘½ä»¤åä¼šæ˜¾ç¤ºï¼š"

#: src/ch02-08-foundry-cast.md:413
msgid "'pending'"
msgstr ""

#: src/ch02-08-foundry-cast.md:417 src/ch03-01-02-fee-mechanism.md:58
msgid "For instance:"
msgstr "ä¾‹å¦‚ï¼š"

#: src/ch02-08-foundry-cast.md:423
msgid "While not all options are used in the example, you might need to include options like `--calldata`, specifying it as a list or array."
msgstr "è™½ç„¶ç¤ºä¾‹ä¸­å¹¶æœªä½¿ç”¨æ‰€æœ‰é€‰é¡¹ï¼Œä½†æ‚¨å¯èƒ½éœ€è¦åŒ…å«ç±»ä¼¼ `--calldata` è¿™æ ·çš„é€‰é¡¹ï¼Œå¹¶å°†å…¶æŒ‡å®šä¸ºåˆ—è¡¨æˆ–æ•°ç»„ã€‚"

#: src/ch02-08-foundry-cast.md:425
msgid "A successful call returns:"
msgstr "è°ƒç”¨æˆåŠŸè¿”å›ï¼š"

#: src/ch02-08-foundry-cast.md:432
msgid "This indicates successful read and write operations on the contract."
msgstr "è¿™è¡¨ç¤ºå¯¹åˆçº¦çš„è¯»å†™æ“ä½œæˆåŠŸã€‚"

#: src/ch02-08-foundry-cast.md:434
#, fuzzy
msgid "sncast Multicall Guide"
msgstr "### sncast å¤šé‡è°ƒç”¨æŒ‡å—"

#: src/ch02-08-foundry-cast.md:436
msgid "Use `sncast multicall` to simultaneously read and write to the contract. Let's explore how to effectively use this feature."
msgstr "ä½¿ç”¨ `sncast multicall`å¯åŒæ—¶è¯»å†™åˆçº¦ã€‚è®©æˆ‘ä»¬æ¥æ¢è®¨å¦‚ä½•æœ‰æ•ˆä½¿ç”¨è¿™ä¸€åŠŸèƒ½ã€‚"

#: src/ch02-08-foundry-cast.md:438
msgid "First, understand its basic usage:"
msgstr "é¦–å…ˆï¼Œäº†è§£å…¶åŸºæœ¬ç”¨æ³•ï¼š"

#: src/ch02-08-foundry-cast.md:444
msgid "This command displays:"
msgstr "è¯¥å‘½ä»¤å°†æ˜¾ç¤ºï¼š"

#: src/ch02-08-foundry-cast.md:460
msgid "To delve deeper, initiate the `new` subcommand:"
msgstr "è¦æ·±å…¥ç ”ç©¶ï¼Œè¯·æ‰§è¡Œ `new` å­å‘½ä»¤ï¼š"

#: src/ch02-08-foundry-cast.md:473
msgid "Generate a template called `call1.toml`:"
msgstr "ç”Ÿæˆåä¸º `call1.toml` çš„æ¨¡æ¿ï¼š"

#: src/ch02-08-foundry-cast.md:479
msgid "This provides a basic template:"
msgstr "è¿™æä¾›äº†ä¸€ä¸ªåŸºæœ¬æ¨¡æ¿ï¼š"

#: src/ch02-08-foundry-cast.md:481
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"deploy\"\n"
"class_hash = \"\"\n"
"inputs = []\n"
"id = \"\"\n"
"unique = false\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"\"\n"
"function = \"\"\n"
"inputs = []\n"
"```"

#: src/ch02-08-foundry-cast.md:496
msgid "Modify `call1.toml` to:"
msgstr "ä¿®æ”¹ `call1.toml` ä¸ºï¼š"

#: src/ch02-08-foundry-cast.md:498
msgid ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"

#: src/ch02-08-foundry-cast.md:512
msgid "In multicalls, only `deploy` and `invoke` actions are allowed. For a detailed guide on these, refer to the earlier section."
msgstr "åœ¨å¤šé‡è°ƒç”¨ä¸­ï¼Œåªå…è®¸æ‰§è¡Œ`deploy` å’Œ `invoke`æ“ä½œã€‚æœ‰å…³è¿™äº›æ“ä½œçš„è¯¦ç»†æŒ‡å—ï¼Œè¯·å‚é˜…å‰é¢çš„ç« èŠ‚ã€‚"

#: src/ch02-08-foundry-cast.md:514
#, fuzzy
msgid "**Note:** Ensure inputs are in hexadecimal format. Strings work normally, but numbers require this format for accurate results."
msgstr "> æ³¨æ„ï¼šç¡®ä¿è¾“å…¥ä¸ºåå…­è¿›åˆ¶æ ¼å¼ã€‚å­—ç¬¦ä¸²å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œä½†æ•°å­—éœ€è¦è¿™ç§æ ¼å¼æ‰èƒ½è·å¾—å‡†ç¡®ç»“æœã€‚"

#: src/ch02-08-foundry-cast.md:516
msgid "To execute the multicall, use:"
msgstr "è¦æ‰§è¡Œå¤šé‡è°ƒç”¨ï¼Œè¯·ä½¿ç”¨ï¼š"

#: src/ch02-08-foundry-cast.md:522
msgid "Upon success:"
msgstr "æˆåŠŸåï¼š"

#: src/ch02-08-foundry-cast.md:529
msgid "Check the balance:"
msgstr "æ£€æŸ¥ä½™é¢ï¼š"

#: src/ch02-08-foundry-cast.md:535
msgid "The response:"
msgstr "è¿”å›æ˜¯ï¼š"

#: src/ch02-08-foundry-cast.md:542
msgid "The expected balance, `0x9`, is confirmed."
msgstr "æˆ‘ä»¬ç¡®è®¤äº†ä½™é¢ `0x9`æ˜¯æˆ‘ä»¬æ‰€é¢„æœŸçš„ ã€‚"

#: src/ch02-08-foundry-cast.md:544 src/ch02-09-starknet-js.md:570 src/ch02-10-starknet-react.md:319 src/ch02-13-foundry-forge.md:900 src/ch02-16-apibara.md:454 src/ch03-00-architecture.md:249
#: src/ch03-01-transactions.md:63 src/ch03-01-01-transactions-lifecycle.md:175 src/ch03-02-sequencers.md:214 src/ch03-03-provers.md:233 src/ch03-06-solidity-verifier.md:139
#: src/ch04-00-account-abstraction.md:117 src/ch04-05-01-multicaller.md:589 src/ch04-05-02-multisig.md:881
#, fuzzy
msgid "Conclusion"
msgstr "## æ€»ç»“"

#: src/ch02-08-foundry-cast.md:546
msgid ""
"This guide detailed the use of `sncast`, a robust command-line tool tailored for starknet smart contracts. Its purpose is to make interactions with starknet's smart contracts effortless. Key "
"functionalities include contract deployment, function invocation, and function calling."
msgstr "æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº† `sncast`çš„ä½¿ç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸“ä¸ºStarknetæ™ºèƒ½åˆçº¦å®šåˆ¶çš„å¼ºå¤§çš„å‘½ä»¤è¡Œå·¥å…·ã€‚å…¶ç›®çš„æ˜¯è®©ä¸ starknet æ™ºèƒ½åˆçº¦çš„äº¤äº’å˜å¾—éå¸¸è½»æ¾ã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬åˆçº¦éƒ¨ç½²ã€å†™å‡½æ•°è°ƒç”¨å’Œè¯»å‡½æ•°è°ƒç”¨ã€‚"

#: src/ch02-08-01-deployment-script.md:1
#, fuzzy
msgid "Deployment Script Example"
msgstr "# éƒ¨ç½²è„šæœ¬ç¤ºä¾‹"

#: src/ch02-08-01-deployment-script.md:3
msgid "**IMPORTANT:** Ensure you have completed the Starknet Devnet subchapter before proceeding with this guide."
msgstr ""

#: src/ch02-08-01-deployment-script.md:5
#, fuzzy
msgid ""
"This guide provides a step-by-step process to set up a testing and deployment environment for Starknet smart contracts. The script provided here will initialize accounts, execute tests, and perform "
"multicalls."
msgstr "æœ¬æ•™ç¨‹ä»‹ç»å¦‚ä½•ä¸ºæ™ºèƒ½åˆçº¦å»ºç«‹æµ‹è¯•å’Œéƒ¨ç½²ç¯å¢ƒã€‚ç»™å‡ºçš„è„šæœ¬ä¼šåˆå§‹åŒ–è´¦æˆ·ã€è¿è¡Œæµ‹è¯•å¹¶æ‰§è¡Œå¤šé‡è°ƒç”¨ã€‚"

#: src/ch02-08-01-deployment-script.md:7
msgid "Please note that this is a basic example. You should adapt it to suit your specific needs and requirements."
msgstr ""

#: src/ch02-08-01-deployment-script.md:11
msgid "The script is compatible with the following versions or higher"
msgstr ""

#: src/ch02-08-01-deployment-script.md:27
#, fuzzy
msgid "Additional Tools"
msgstr "## å…¶ä»–èµ„æº"

#: src/ch02-08-01-deployment-script.md:29
msgid "The script requires `jq` to run. You can install it with `sudo apt install jq` on Ubuntu or `brew install jq` on macOS. For more information, refer to the [JQ Docs](https://jqlang.github.io/jq/)."
msgstr ""

#: src/ch02-08-01-deployment-script.md:31
#, fuzzy
msgid "Script Preparation"
msgstr "### æµ‹è¯•å‡†å¤‡"

#: src/ch02-08-01-deployment-script.md:33
#, fuzzy
msgid "1. Create the Script File"
msgstr "### 1.å‡†å¤‡è„šæœ¬æ–‡ä»¶"

#: src/ch02-08-01-deployment-script.md:35
msgid "In the root directory of your project, create a file named **`script.sh`**. This file will contain the deployment script."
msgstr ""

#: src/ch02-08-01-deployment-script.md:36
#, fuzzy
msgid "Modify the file permissions to make it executable:"
msgstr "è¦æŸ¥æ‰¾ Starkli æ”¯æŒçš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œè¯·æ‰§è¡Œï¼š"

#: src/ch02-08-01-deployment-script.md:42
msgid "âš ï¸ **NOTE:** The script file must be executable to run. The `chmod +x` command changes the file permissions to allow execution."
msgstr ""

#: src/ch02-08-01-deployment-script.md:44
#, fuzzy
msgid "2. Insert the Script"
msgstr "### 2.æ’å…¥è„šæœ¬"

#: src/ch02-08-01-deployment-script.md:46
msgid "Below is the content for `script.sh`. It adheres to best practices for clarity, error management, and long-term support."
msgstr "ä»¥ä¸‹æ˜¯ `script.sh` çš„å†…å®¹ã€‚å®ƒéµå¾ªä»£ç æ¸…æ™°åº¦ã€é”™è¯¯ç®¡ç†å’Œé•¿æœŸæ”¯æŒæ–¹é¢çš„æœ€ä½³å®è·µã€‚"

#: src/ch02-08-01-deployment-script.md:48
msgid ""
"**Security Note**: Using environment variables is safer than hardcoding private keys in your scripts, but they're still accessible to any process on your machine and could potentially be leaked in "
"logs or error messages."
msgstr "**å®‰å…¨æç¤º**ï¼šè™½ç„¶ä½¿ç”¨ç¯å¢ƒå˜é‡æ¯”åœ¨è„šæœ¬ä¸­ç¡¬ç¼–ç ç§é’¥æ›´å®‰å…¨ï¼Œä½†ä½ çš„ç”µè„‘ä¸Šçš„ä»»ä½•è¿›ç¨‹ä»å¯è®¿é—®å®ƒä»¬ï¼Œå¹¶æœ‰å¯èƒ½åœ¨æ—¥å¿—æˆ–é”™è¯¯ä¿¡æ¯ä¸­æ³„éœ²å‡ºæ¥ã€‚"

#: src/ch02-08-01-deployment-script.md:50
msgid "On step 5 _declaring_, Uncomment according to local devnet you are using either the rust node or python node for declaration to work as expected."
msgstr ""

#: src/ch02-08-01-deployment-script.md:53
msgid "#!/usr/bin/env bash\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:54
msgid "# Ensure the script stops on first error\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:57
msgid "# Global variables\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:59
msgid "\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:60
msgid "\"HelloStarknet\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:61
#, fuzzy
msgid "\"account1\""
msgstr "è´¦æˆ·"

#: src/ch02-08-01-deployment-script.md:62
msgid "\"multicall.toml\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:63
msgid "false"
msgstr ""

#: src/ch02-08-01-deployment-script.md:64
msgid "# Addresses and Private keys as environment variables\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:66
msgid "${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}"
msgstr ""

#: src/ch02-08-01-deployment-script.md:67
msgid "${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}"
msgstr ""

#: src/ch02-08-01-deployment-script.md:68
msgid "${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}"
msgstr ""

#: src/ch02-08-01-deployment-script.md:69
msgid "${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}"
msgstr ""

#: src/ch02-08-01-deployment-script.md:70
msgid "# Utility function to log messages\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:73
msgid "\"\\n$1\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:75
msgid "# Step 1: Clean previous environment\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:77 src/ch02-08-01-deployment-script.md:79
msgid "\"$file_path\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:78
msgid "\"Removing existing accounts file...\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:81
msgid "# Step 2: Define accounts for the smart contract\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:83
msgid ""
"<<EOF\n"
"[\n"
"    {\n"
"        \"name\": \"account1\",\n"
"        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
"    },\n"
"    {\n"
"        \"name\": \"account2\",\n"
"        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
"        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
"    }\n"
"]\n"
"EOF"
msgstr ""

#: src/ch02-08-01-deployment-script.md:98
msgid "# Step 3: Run contract tests\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:100
#, fuzzy
msgid "\"\\nTesting the contract...\""
msgstr "2.å£°æ˜åˆçº¦"

#: src/ch02-08-01-deployment-script.md:101
msgid "$(snforge test 2>&1)"
msgstr ""

#: src/ch02-08-01-deployment-script.md:102
msgid "\"$testing_result\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:102
msgid "\"Failure\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:103
msgid "\"Tests failed!\\n\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:105
msgid "\"\\nEnsure that your tests are passing before proceeding.\\n\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:106
msgid "true"
msgstr ""

#: src/ch02-08-01-deployment-script.md:109
msgid "\"$FAILED_TESTS\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:109
msgid "\"true\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:110
msgid "\"Tests passed successfully.\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:112
msgid "# Step 4: Create new account(s)\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:113
msgid "\"\\nCreating account(s)...\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:114
msgid "\"${accounts_json}\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:114
msgid "'.[]'"
msgstr ""

#: src/ch02-08-01-deployment-script.md:115
msgid "$(echo \"${row}\" | jq -r '.name')"
msgstr ""

#: src/ch02-08-01-deployment-script.md:116
msgid "$(echo \"${row}\" | jq -r '.address')"
msgstr ""

#: src/ch02-08-01-deployment-script.md:117
msgid "$(echo \"${row}\" | jq -r '.private_key')"
msgstr ""

#: src/ch02-08-01-deployment-script.md:119
#, fuzzy
msgid "$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)"
msgstr ""
"```sh\n"
"sncast --url http://localhost:5050/rpc account add  --name account1 --address 0x5f...60ba --private-key 0xc...0acc --add-profile\n"
"```"

#: src/ch02-08-01-deployment-script.md:120
msgid "\"$account_creation_result\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:120
msgid "\"error:\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:121
msgid "\"Account $name already exists.\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:123
msgid "\"Account $name created successfully.\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:127
#, fuzzy
msgid "# Step 5: Build, declare, and deploy the contract\n"
msgstr "## ç¬¬ 4 æ­¥ï¼šå£°æ˜å’Œéƒ¨ç½²æˆ‘ä»¬çš„åˆçº¦"

#: src/ch02-08-01-deployment-script.md:128
#, fuzzy
msgid "\"\\nBuilding the contract...\""
msgstr "1. **ç¼–è¯‘åˆçº¦**"

#: src/ch02-08-01-deployment-script.md:131
#, fuzzy
msgid "\"\\nDeclaring the contract...\""
msgstr "2.å£°æ˜åˆçº¦"

#: src/ch02-08-01-deployment-script.md:132
msgid "$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)"
msgstr ""

#: src/ch02-08-01-deployment-script.md:134 src/ch02-08-01-deployment-script.md:137
msgid "\"$declaration_output\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:134
msgid "\"error: Class with hash\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:135
msgid "\"Class hash already declared.\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:136
msgid "# CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p') ## Uncomment this for pythonic devnet\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:137
msgid "'s/.*\\(0x[0-9a-fA-F]*\\).*/\\1/p'"
msgstr ""

#: src/ch02-08-01-deployment-script.md:137
msgid "## Uncomment this for rust devnet\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:139
msgid "\"New class hash declaration.\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:140
msgid "$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')"
msgstr ""

#: src/ch02-08-01-deployment-script.md:143
msgid "\"Class Hash: $CLASS_HASH\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:145
#, fuzzy
msgid "\"\\nDeploying the contract...\""
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch02-08-01-deployment-script.md:146
msgid "$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")"
msgstr ""

#: src/ch02-08-01-deployment-script.md:147
msgid "$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')"
msgstr ""

#: src/ch02-08-01-deployment-script.md:148
msgid "\"Contract address: $CONTRACT_ADDRESS\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:150
msgid "# Step 6: Create and execute multicalls\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:151
msgid "\"\\nSetting up multicall...\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:152
#, fuzzy
msgid ""
"\"$MULTICALL_FILE\" <<-EOM\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x1']\n"
"\n"
"[[call]]\n"
"call_type = 'invoke'\n"
"contract_address = '$CONTRACT_ADDRESS'\n"
"function = 'increase_balance'\n"
"inputs = ['0x2']\n"
"EOM\n"
"\n"
msgstr ""
"```toml\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x4']\n"
"\n"
"[[call]]\n"
"call_type = \"invoke\"\n"
"contract_address = \"0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\"\n"
"function = \"increase_balance\"\n"
"inputs = ['0x1']\n"
"```"

#: src/ch02-08-01-deployment-script.md:166
msgid "\"Executing multicall...\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:167 src/ch02-08-01-deployment-script.md:171
msgid "\"$PROFILE_NAME\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:167 src/ch02-08-01-deployment-script.md:175
msgid "\"$MULTICALL_FILE\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:169
msgid "# Step 7: Query the contract state\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:170
#, fuzzy
msgid "\"\\nChecking balance...\""
msgstr "- æŸ¥çœ‹ä½™é¢ï¼š"

#: src/ch02-08-01-deployment-script.md:171
msgid "\"$CONTRACT_ADDRESS\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:173
msgid "# Step 8: Clean up temporary files\n"
msgstr ""

#: src/ch02-08-01-deployment-script.md:174
msgid "\"\\nCleaning up...\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:177
msgid "\"\\nScript completed successfully.\\n\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:181
#, fuzzy
msgid "3. \\[Optional\\]Adjust the Bash Path"
msgstr "### 3.è°ƒæ•´ Bash è·¯å¾„"

#: src/ch02-08-01-deployment-script.md:183
msgid "The line `#!/usr/bin/env bash` indicates the path to the bash interpreter. If you require a different version or location of bash, determine its path using:"
msgstr "è¡Œ `#!/usr/bin/env bash` è¡¨ç¤º bash è§£é‡Šå™¨çš„è·¯å¾„ã€‚å¦‚æœéœ€è¦ä¸åŒç‰ˆæœ¬æˆ–ä¸åŒä½ç½®çš„ bashï¼Œè¯·ä½¿ç”¨ï¼š"

#: src/ch02-08-01-deployment-script.md:189
msgid "Then replace `#!/usr/bin/env` bash in the script with the resulting path, such as `#!/path/to/your/bash`."
msgstr "ç„¶åå°†è„šæœ¬ä¸­çš„ `#!/usr/bin/env` bash æ›¿æ¢ä¸ºç”Ÿæˆçš„è·¯å¾„ï¼Œå¦‚ `#!/path/to/your/bash`ã€‚"

#: src/ch02-08-01-deployment-script.md:191
#, fuzzy
msgid "Execution"
msgstr "## æ‰§è¡Œ"

#: src/ch02-08-01-deployment-script.md:193
msgid "When running the script, you'll need to provide the environment variables `ACCOUNT1_PRIVATE_KEY` and `ACCOUNT2_PRIVATE_KEY`."
msgstr "è¿è¡Œè„šæœ¬æ—¶ï¼Œéœ€è¦æä¾›ç¯å¢ƒå˜é‡ `ACCOUNT1_PRIVATE_KEY` å’Œ `ACCOUNT2_PRIVATE_KEY`ã€‚"

#: src/ch02-08-01-deployment-script.md:195 src/ch03-05-layer-3.md:9
msgid "Example:"
msgstr "ä¾‹å­:"

#: src/ch02-08-01-deployment-script.md:198
msgid "\"0x259f4329e6f4590b\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:198
msgid "\"0xb4862b21fb97d\""
msgstr ""

#: src/ch02-08-01-deployment-script.md:201 src/ch04-05-01-multicaller.md:597
#, fuzzy
msgid "Considerations"
msgstr "## è€ƒé‡"

#: src/ch02-08-01-deployment-script.md:203
msgid "The **`set -e`** directive in the script ensures it exits if any command fails, enhancing the reliability of the deployment and testing process."
msgstr ""

#: src/ch02-08-01-deployment-script.md:204
msgid "Always secure private keys and sensitive information. Keep them away from logs and visible outputs."
msgstr ""

#: src/ch02-08-01-deployment-script.md:205
msgid "For greater flexibility, consider moving hardcoded values like accounts or contract names to a configuration file. This approach simplifies updates and overall management."
msgstr ""

#: src/ch02-09-starknet-js.md:3
#, fuzzy
msgid ""
"Starknet.js is a JavaScript/TypeScript library designed to connect your website or decentralized application (D-App) to Starknet. It aims to mimic the architecture of [ethers.js](https://docs.ethers."
"org/v5/), so if you are familiar with ethers, you should find Starknet.js easy to work with."
msgstr ""
"Starknet.js æ˜¯ä¸€ä¸ª JavaScript/TypeScript åº“ï¼Œç”¨äºå°†æ‚¨çš„ç½‘ç«™æˆ–å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºï¼ˆD-Appï¼‰è¿æ¥åˆ°Starknetã€‚å®ƒæ—¨åœ¨æ¨¡ä»¿ [ethers.js](https://docs.ethers.org/v5/) çš„æ¶æ„ï¼Œæ‰€ä»¥å¦‚æœä½ ç†Ÿæ‚‰ ethersï¼Œä½ ä¼šå‘ç° "
"Starknet.js å¾ˆå®¹æ˜“ä½¿ç”¨ã€‚"

#: src/ch02-09-starknet-js.md:11
#, fuzzy
msgid "Starknet-js in your dapp"
msgstr "<span class=\"caption\">Starknet-js in your dapp</span>"

#: src/ch02-09-starknet-js.md:15
msgid "To install Starknet.js, follow these steps:"
msgstr "æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤å®‰è£… Starknet.jsï¼š"

#: src/ch02-09-starknet-js.md:17
#, fuzzy
msgid "For the latest official release (main branch):"
msgstr "æœ€æ–°æ­£å¼ç‰ˆæœ¬ï¼ˆä¸»åˆ†æ”¯ï¼‰ï¼š"

#: src/ch02-09-starknet-js.md:23
#, fuzzy
msgid "To use the latest features (merges in develop branch):"
msgstr "ä½¿ç”¨æœ€æ–°åŠŸèƒ½ï¼ˆå¼€å‘åˆ†æ”¯å·²åˆå¹¶çš„åŠŸèƒ½ï¼‰ï¼š"

#: src/ch02-09-starknet-js.md:31
#, fuzzy
msgid ""
"To build an app that users are able to connect to and interact with Starknet, we recommend adding the [get-starknet](https://github.com/starknet-io/get-starknet) library, which allows you to manage "
"wallet connections."
msgstr "è¦æ„å»ºä¸€ä¸ªç”¨æˆ·èƒ½å¤Ÿè¿æ¥åˆ°Starknetå¹¶ä¸ä¹‹äº¤äº’çš„åº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å»ºè®®æ·»åŠ [get-starknet](https://github.com/starknet-io/get-starknet)åº“ï¼Œè¯¥åº“å…è®¸æ‚¨ç®¡ç†é’±åŒ…è¿æ¥ã€‚"

#: src/ch02-09-starknet-js.md:36
#, fuzzy
msgid "With these tools ready, there are basically 3 main concepts to know on the frontend: Account, Provider, and Contracts."
msgstr "å‡†å¤‡å¥½è¿™äº›å·¥å…·åï¼Œåœ¨å‰ç«¯åŸºæœ¬ä¸Šéœ€è¦äº†è§£ 3 ä¸ªä¸»è¦æ¦‚å¿µï¼šè´¦æˆ·ã€æä¾›å•†å’Œåˆçº¦ã€‚"

#: src/ch02-09-starknet-js.md:39
#, fuzzy
msgid "Account"
msgstr "è´¦æˆ·"

#: src/ch02-09-starknet-js.md:41
#, fuzzy
msgid "We can generally think of the account as the \"end user\" of a dapp, and some user interaction will be involved to gain access to it."
msgstr "ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè´¦æˆ·çœ‹ä½œæ˜¯ dapp çš„ \"æœ€ç»ˆç”¨æˆ·\"ï¼Œè¦è®¿é—®è¯¥è´¦æˆ·ï¼Œéœ€è¦ä¸ç”¨æˆ·è¿›è¡Œä¸€äº›äº¤äº’ã€‚"

#: src/ch02-09-starknet-js.md:44
#, fuzzy
msgid ""
"Think of a dapp where the user connects their browser extension wallet (such as ArgentX or Braavos) - if the user accepts the connection, that gives us access to the account and signer, which can sign "
"transactions and messages."
msgstr "æƒ³è±¡ä¸€ä¸‹ç”¨æˆ·è¿æ¥æµè§ˆå™¨æ‰©å±•é’±åŒ…ï¼ˆå¦‚ ArgentX æˆ– Braavosï¼‰çš„ dappï¼Œå¦‚æœç”¨æˆ·æ¥å—è¿æ¥ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¿é—®è´¦æˆ·å’Œç­¾åè€…ï¼Œä»è€Œç­¾ç½²äº¤æ˜“å’Œä¿¡æ¯ã€‚"

#: src/ch02-09-starknet-js.md:49
#, fuzzy
msgid ""
"Unlike Ethereum, where user accounts are Externally Owned Accounts, Starknet **accounts are contracts**. This might not necessarily impact your dappâ€™s frontend, but you should definitely be aware of "
"this difference."
msgstr "ä»¥å¤ªåŠçš„ç”¨æˆ·è´¦æˆ·æ˜¯EOAï¼ˆå¤–éƒ¨æ‹¥æœ‰è´¦æˆ·ï¼‰ï¼Œè€ŒStarknetçš„**è´¦æˆ·æ˜¯åˆçº¦**ã€‚è¿™å¯èƒ½ä¸ä¸€å®šä¼šå½±å“ä½ çš„ dapp å‰ç«¯ï¼Œä½†ä½ ä¸€å®šè¦æ„è¯†åˆ°è¿™ç§å·®å¼‚ã€‚"

#: src/ch02-09-starknet-js.md:64
msgid ""
"The snippet above uses the `connect` function provided by `get-starknet` to establish a connection to the user wallet. Once connected, we are able to access account methods, such as `signMessage` or "
"`execute`."
msgstr "ä¸Šé¢çš„ä»£ç æ®µä½¿ç”¨`get-starknet`æä¾›çš„`connect`å‡½æ•°ä¸ç”¨æˆ·é’±åŒ…å»ºç«‹è¿æ¥ã€‚è¿æ¥åï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¿é—®è´¦æˆ·æ–¹æ³•ï¼Œå¦‚ `signMessage` æˆ– `execute`ã€‚"

#: src/ch02-09-starknet-js.md:66 src/ch02-09-01-counter-ui.md:145
#, fuzzy
msgid "Provider"
msgstr "### æä¾›å•†"

#: src/ch02-09-starknet-js.md:68
#, fuzzy
msgid ""
"The provider allows you to interact with the Starknet network. You can think of it as a \"read\" connection to the blockchain, as it doesnâ€™t allow signing transactions or messages. Just like in "
"Ethereum, you can use a default provider, or use services such as Infura or Alchemy, both of which support Starknet, to create an RPC provider."
msgstr ""
"æä¾›å•†å…è®¸æ‚¨ä¸Starknetç½‘ç»œè¿›è¡Œäº¤äº’ã€‚ä½ å¯ä»¥æŠŠå®ƒçœ‹ä½œæ˜¯ä¸åŒºå—é“¾çš„ \"åªè¯» \"è¿æ¥ï¼Œå› ä¸ºå®ƒä¸å…è®¸ç­¾ç½²äº¤æ˜“æˆ–æ¶ˆæ¯ã€‚å°±åƒåœ¨ä»¥å¤ªåŠä¸­ä¸€æ ·ï¼Œä½ å¯ä»¥ä½¿ç”¨é»˜è®¤çš„æä¾›è€…ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ Infura æˆ– Alchemyï¼ˆä¸¤è€…éƒ½æ”¯æŒ Starknetï¼‰"
"ç­‰æœåŠ¡æ¥åˆ›å»º RPC æä¾›è€…ã€‚"

#: src/ch02-09-starknet-js.md:74
msgid "By default, the Provider is a sequencer provider."
msgstr "é»˜è®¤æƒ…å†µä¸‹ï¼Œæä¾›å•†æŒ‡çš„æ˜¯æ’åºå™¨æä¾›å•†ã€‚"

#: src/ch02-09-starknet-js.md:76
msgid ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"
msgstr ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"

#: src/ch02-09-starknet-js.md:90
#, fuzzy
msgid "Contracts"
msgstr "## åˆçº¦"

#: src/ch02-09-starknet-js.md:92
#, fuzzy
msgid ""
"Your frontend will likely be interacting with deployed contracts. For each contract, there should be a counterpart on the frontend. To create these instances, you will need the contractâ€™s address and "
"ABI, and either a provider or signer."
msgstr "æ‚¨çš„å‰ç«¯å¯èƒ½éœ€è¦ä¸å·²éƒ¨ç½²çš„åˆçº¦è¿›è¡Œäº¤äº’ã€‚å¯¹äºæ¯ä¸ªåˆçº¦ï¼Œå‰ç«¯éƒ½åº”è¯¥æœ‰ä¸€ä¸ªå¯¹åº”çš„å®ä¾‹ã€‚è¦åˆ›å»ºè¿™äº›å®ä¾‹ï¼Œä½ éœ€è¦åˆçº¦çš„åœ°å€å’Œ ABIï¼Œä»¥åŠæä¾›è€…æˆ–ç­¾ç½²è€…ã€‚"

#: src/ch02-09-starknet-js.md:97
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"

#: src/ch02-09-starknet-js.md:107
#, fuzzy
msgid ""
"If you create a contract instance with a provider, youâ€™ll be limited to calling read functions on the contract - only with a signer can you change the state of the blockchain. However, you are able to "
"connect a previously created `Contract` instance with a new account:"
msgstr "å¦‚æœä½¿ç”¨æä¾›è€…åˆ›å»ºåˆçº¦å®ä¾‹ï¼Œåˆ™åªèƒ½è°ƒç”¨åˆçº¦ä¸Šçš„åªè¯»å‡½æ•°ï¼Œåªæœ‰ä½¿ç”¨ç­¾åè€…æ‰èƒ½æ”¹å˜åŒºå—é“¾çš„çŠ¶æ€ã€‚ä¸è¿‡ï¼Œæ‚¨å¯ä»¥å°†ä»¥å‰åˆ›å»ºçš„ \"åˆçº¦ \"å®ä¾‹ä¸æ–°è´¦æˆ·è¿æ¥èµ·æ¥ï¼š"

#: src/ch02-09-starknet-js.md:118
#, fuzzy
msgid "In the snippet above, after calling the `connect` method, it would be possible to call read functions on the contract, but not before."
msgstr "åœ¨ä¸Šé¢çš„ä»£ç æ®µä¸­ï¼Œåœ¨è°ƒç”¨ `connect` æ–¹æ³•åï¼Œå¯ä»¥è°ƒç”¨åˆçº¦ä¸Šçš„åªè¯»å‡½æ•°ï¼Œä½†åœ¨æ­¤ä¹‹å‰åˆ™ä¸è¡Œã€‚"

#: src/ch02-09-starknet-js.md:122
#, fuzzy
msgid "Units"
msgstr "### å•ä½"

#: src/ch02-09-starknet-js.md:124
#, fuzzy
msgid ""
"If you have previous experience with web3, you know dealing with units requires care, and Starknet is no exception. Once again, the docs are very useful here, in particular [this section on data "
"transformation](https://www.starknetjs.com/docs/guides/define_call_message/)."
msgstr ""
"å¦‚æœä½ ä»¥å‰æœ‰è¿‡ web3å¼€å‘ç»éªŒï¼Œå°±ä¼šçŸ¥é“å¤„ç†å•ä½éœ€è¦å°å¿ƒè°¨æ…ï¼ŒStarknet ä¹Ÿä¸ä¾‹å¤–ã€‚é‡ä¸Šè¿™ç§æƒ…å†µæ—¶ï¼Œæ–‡æ¡£æ€»æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œå°¤å…¶æ˜¯[å…³äºæ•°æ®è½¬æ¢çš„è¿™ä¸€éƒ¨åˆ†](https://www.starknetjs.com/docs/guides/"
"define_call_message/)ã€‚"

#: src/ch02-09-starknet-js.md:129
#, fuzzy
msgid "Very often you will need to convert Cairo structs (such as Uint256) that are returned from contracts into numbers:"
msgstr "æ‚¨ç»å¸¸éœ€è¦å°†ä»åˆçº¦è¿”å›çš„ Cairo ç»“æ„ä½“ï¼ˆå¦‚ Uint256ï¼‰è½¬æ¢ä¸ºæ•°å­—ï¼š"

#: src/ch02-09-starknet-js.md:132
msgid ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"
msgstr ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"

#: src/ch02-09-starknet-js.md:145
msgid "And vice versa:"
msgstr "åä¹‹äº¦ç„¶ï¼š"

#: src/ch02-09-starknet-js.md:147
msgid ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"
msgstr ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"

#: src/ch02-09-starknet-js.md:156
#, fuzzy
msgid "There are other helpful utils, besides `bnToUint256` and `uint256ToBN`, provided by Starknet.js."
msgstr "é™¤äº† `bnToUint256` å’Œ `uint256ToBN` ä¹‹å¤–ï¼ŒStarknet.js è¿˜æä¾›äº†å…¶ä»–æœ‰ç”¨çš„å·¥å…·ã€‚"

#: src/ch02-09-starknet-js.md:159
#, fuzzy
msgid "We now have a solid foundation to build a Starknet dapp. However, there are framework specific tools that help us build Starknet dapps, which are covered in chapter 5."
msgstr "æˆ‘ä»¬ç°åœ¨æœ‰äº†æ„å»ºStarknetåº”ç”¨ç¨‹åºçš„åšå®åŸºç¡€ã€‚ä¸è¿‡ï¼Œè¿˜æœ‰ä¸€äº›ç‰¹å®šçš„æ¡†æ¶å·¥å…·å¯ä»¥å¸®åŠ©æˆ‘ä»¬æ„å»ºStarknetåº”ç”¨ç¨‹åºï¼Œè¿™å°†åœ¨ç¬¬ 5 ç« ä¸­ä»‹ç»ã€‚"

#: src/ch02-09-starknet-js.md:163
msgid "With Starknet.js, you can also automate the process of deploying a smart contract to Starknet testnet / mainnet."
msgstr ""

#: src/ch02-09-starknet-js.md:165
#, fuzzy
msgid "Deployment of Smart Contracts using Starknet.js"
msgstr "## åœ¨Starknetéƒ¨ç½²æ™ºèƒ½åˆçº¦"

#: src/ch02-09-starknet-js.md:167
msgid ""
"Starknet.js offers capabilities for deploying smart contracts. In this tutorial, we demonstrate this by deploying an account contract, which we previously developed in [Chapter 4](./ch04-03-standard-"
"account.html), through a scripted approach."
msgstr ""

#: src/ch02-09-starknet-js.md:169
msgid "STEP 1: Initial Setup and Dependency Installation"
msgstr ""

#: src/ch02-09-starknet-js.md:171
msgid "To begin, set up your project environment for the account contract deployment. Within your project'sroot directory, start by initializing a Node.js environment:"
msgstr ""

#: src/ch02-09-starknet-js.md:177
msgid "This command generates a package.json file. Next, update this file to include the latest versions of the necessary dependencies:"
msgstr ""

#: src/ch02-09-starknet-js.md:180
msgid "\"@tsconfig/node20\""
msgstr ""

#: src/ch02-09-starknet-js.md:180
msgid "\"^20.1.2\""
msgstr ""

#: src/ch02-09-starknet-js.md:180
msgid "\"axios\""
msgstr ""

#: src/ch02-09-starknet-js.md:181
msgid "\"^1.6.0\""
msgstr ""

#: src/ch02-09-starknet-js.md:181
msgid "\"chalk\""
msgstr ""

#: src/ch02-09-starknet-js.md:182
msgid "\"^5.3.0\""
msgstr ""

#: src/ch02-09-starknet-js.md:182
msgid "\"dotenv\""
msgstr ""

#: src/ch02-09-starknet-js.md:183
msgid "\"^16.3.1\""
msgstr ""

#: src/ch02-09-starknet-js.md:183 src/ch02-14-security-considerations.md:342
msgid "\"starknet\""
msgstr ""

#: src/ch02-09-starknet-js.md:184
msgid "\"^5.19.5\""
msgstr ""

#: src/ch02-09-starknet-js.md:184
msgid "\"ts-node\""
msgstr ""

#: src/ch02-09-starknet-js.md:185
msgid "\"^10.9.1\""
msgstr ""

#: src/ch02-09-starknet-js.md:185
msgid "\"typescript\""
msgstr ""

#: src/ch02-09-starknet-js.md:186
msgid "\"^5.2.2\""
msgstr ""

#: src/ch02-09-starknet-js.md:189
msgid "With the dependencies specified, install them using:"
msgstr ""

#: src/ch02-09-starknet-js.md:195
msgid "Configuration of TypeScript Environment"
msgstr ""

#: src/ch02-09-starknet-js.md:197
msgid "Create a `tsconfig.json` file in your project directory:"
msgstr ""

#: src/ch02-09-starknet-js.md:201
msgid "\"extends\""
msgstr ""

#: src/ch02-09-starknet-js.md:201
msgid "\"./node_modules/@tsconfig/node20/tsconfig.json\""
msgstr ""

#: src/ch02-09-starknet-js.md:202
msgid "\"include\""
msgstr ""

#: src/ch02-09-starknet-js.md:202
msgid "\"scripts/**/*\""
msgstr ""

#: src/ch02-09-starknet-js.md:206
msgid "Ensure your Node.js version aligns with v20 to match this configuration."
msgstr ""

#: src/ch02-09-starknet-js.md:208
msgid "Furthermore, establish a `.env` file at the root of your project. This file should contain your RPC endpoint and the private key of your deployer account:"
msgstr ""

#: src/ch02-09-starknet-js.md:211
msgid "<YOUR_WALLET_ADDRESS_PRIVATE_KEY>"
msgstr ""

#: src/ch02-09-starknet-js.md:212
msgid "\"<INFURA_STARKNET_GOERLI_API_KEY>\""
msgstr ""

#: src/ch02-09-starknet-js.md:215
msgid "Your environment is successfully set up."
msgstr ""

#: src/ch02-09-starknet-js.md:217
#, fuzzy
msgid "Preparation of Deployment Scripts"
msgstr "ç¤ºä¾‹ - éƒ¨ç½²è„šæœ¬"

#: src/ch02-09-starknet-js.md:219
msgid "To facilitate the deployment of the account contract, three key files are necessary:"
msgstr ""

#: src/ch02-09-starknet-js.md:221
msgid "`utils.ts`: This file will contain the functions and logic for deployment."
msgstr ""

#: src/ch02-09-starknet-js.md:222
msgid "`deploy.ts`: This is the main deployment script."
msgstr ""

#: src/ch02-09-starknet-js.md:223
msgid "`l2-eth-abi.json`: This file will hold the ABI (Application Binary Interface) for the account contract."
msgstr ""

#: src/ch02-09-starknet-js.md:225
msgid "STEP 2: Import Required Modules and Functions"
msgstr ""

#: src/ch02-09-starknet-js.md:227
msgid ""
"In the `utils.ts` file, import the necessary modules and functions from various packages. This includes functionality from Starknet, filesystem operations, path handling, and environment variable "
"configuration:"
msgstr ""

#: src/ch02-09-starknet-js.md:229
msgid ""
"```ts\n"
"import {\n"
"  Account,\n"
"  stark,\n"
"  ec,\n"
"  hash,\n"
"  CallData,\n"
"  RpcProvider,\n"
"  Contract,\n"
"  cairo,\n"
"} from \"starknet\";\n"
"import { promises as fs } from \"fs\";\n"
"import path from \"path\";\n"
"import readline from \"readline\";\n"
"import \"dotenv/config\";\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:246
#, fuzzy
msgid "STEP 3: Implementing the `waitForEnter` Function"
msgstr "## è°ƒç”¨ `increment` å‡½æ•°"

#: src/ch02-09-starknet-js.md:248
msgid "To enhance user interaction during the deployment process, implement the `waitForEnter` function. This function prompts the user to press 'Enter' to proceed, ensuring an interactive session:"
msgstr ""

#: src/ch02-09-starknet-js.md:266
msgid "STEP 4: Styling Terminal Output Messages"
msgstr ""

#: src/ch02-09-starknet-js.md:268
msgid "Integrate the `chalk` module for styling terminal output messages. This enhances the readability and user experience in the command line interface:"
msgstr ""

#: src/ch02-09-starknet-js.md:270
msgid ""
"```ts\n"
"export async function importChalk() {\n"
"  return import(\"chalk\").then((m) => m.default);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:276
msgid "STEP 5: Establishing Connection to the Starknet Network"
msgstr ""

#: src/ch02-09-starknet-js.md:278
msgid "Configure the `RpcProvider` object to connect to the Starknet network. This connection uses the RPC endpoint specified in the `.env` file, facilitating communication through the Infura client:"
msgstr ""

#: src/ch02-09-starknet-js.md:288
msgid "STEP 6: Preparing the Deployer Account"
msgstr ""

#: src/ch02-09-starknet-js.md:290
msgid "Set up the deployer account for contract deployment. Utilize the private key from the `.env` file and its respective pre-deployed address to create a new `Account` object:"
msgstr ""

#: src/ch02-09-starknet-js.md:293
msgid ""
"```ts\n"
"export function getDeployerWallet(provider: RpcProvider) {\n"
"  const privateKey = process.env.DEPLOYER_PRIVATE_KEY as string;\n"
"  const address =\n"
"    \"0x070a0122733c00716cb9f4ab5a77b8bcfc04b707756bbc27dc90973844a752d1\";\n"
"  return new Account(provider, address, privateKey);\n"
"}\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:302
#, fuzzy
msgid "STEP 7: Generating a Key Pair for the Account Contract"
msgstr "### å£°æ˜åˆçº¦"

#: src/ch02-09-starknet-js.md:304
msgid "The next step involves generating a key pair for the account contract using the `stark` object from Starknet.js. The key pair consists of a private key and a corresponding public key:"
msgstr ""

#: src/ch02-09-starknet-js.md:317
msgid "Note: If a specific private key is required, replace `stark.randomAddress()` with the desired private key."
msgstr ""

#: src/ch02-09-starknet-js.md:319
#, fuzzy
msgid "STEP 8: Importing Compiled Account Contract Files"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch02-09-starknet-js.md:321
msgid "After compiling the account contract with `scarb build`, Sierra and Casm files are generated in the `target/dev/`directory:"
msgstr ""

#: src/ch02-09-starknet-js.md:323
msgid "Sierra File: `<Project_File_Name>.contract_class.json`"
msgstr ""

#: src/ch02-09-starknet-js.md:324
msgid "Casm File: `<Project_File_Name>.compiled_contract_class.json`"
msgstr ""

#: src/ch02-09-starknet-js.md:326
msgid "To import these files into the deployment script, specify their absolute paths:"
msgstr ""

#: src/ch02-09-starknet-js.md:328
msgid ""
"```ts\n"
"export async function getCompiledCode(filename: string) {\n"
"  const sierraFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.contract_class.json`,\n"
"  );\n"
"  const casmFilePath = path.join(\n"
"    __dirname,\n"
"    `../target/dev/${filename}.compiled_contract_class.json`,\n"
"  );\n"
"\n"
"  const code = [sierraFilePath, casmFilePath].map(async (filePath) => {\n"
"    const file = await fs.readFile(filePath);\n"
"    return JSON.parse(file.toString(\"ascii\"));\n"
"  });\n"
"\n"
"  const [sierraCode, casmCode] = await Promise.all(code);\n"
"\n"
"  return {\n"
"    sierraCode,\n"
"    casmCode,\n"
"  };\n"
"}\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:353
msgid "We use `fs` method to read the file contents."
msgstr ""

#: src/ch02-09-starknet-js.md:355
#, fuzzy
msgid "STEP 9: Declaration of the Account Contract"
msgstr "### å£°æ˜åˆçº¦"

#: src/ch02-09-starknet-js.md:357
msgid "To declare the account contract's class, define an `interface` containing all necessary fields for the declaration, then use the `declare()` method:"
msgstr ""

#: src/ch02-09-starknet-js.md:381
#, fuzzy
msgid "STEP 10: Deploying the Account Contract"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch02-09-starknet-js.md:383
msgid ""
"To deploy the account contract, calculate its address using the contract's class hash. After determining the address, fund it using the [Starknet Faucet](https://faucet.goerli.starknet.io/) to cover "
"gas fees during deployment:"
msgstr ""

#: src/ch02-09-starknet-js.md:385
msgid ""
"```ts\n"
"interface DeployAccountConfig {\n"
"  privateKey: string;\n"
"  publicKey: string;\n"
"  classHash: string;\n"
"  provider: RpcProvider;\n"
"}\n"
"\n"
"export async function deployAccount({\n"
"  privateKey,\n"
"  publicKey,\n"
"  classHash,\n"
"  provider,\n"
"}: DeployAccountConfig) {\n"
"  const chalk = await importChalk();\n"
"\n"
"  const constructorArgs = CallData.compile({\n"
"    public_key: publicKey,\n"
"  });\n"
"\n"
"  const myAccountAddress = hash.calculateContractAddressFromHash(\n"
"    publicKey,\n"
"    classHash,\n"
"    constructorArgs,\n"
"    0,\n"
"  );\n"
"\n"
"  console.log(`Send ETH to contract address ${chalk.bold(myAccountAddress)}`);\n"
"  const message = \"Press [Enter] when ready...\";\n"
"  await waitForEnter(message);\n"
"\n"
"  const account = new Account(provider, myAccountAddress, privateKey, \"1\");\n"
"\n"
"  const deploy = await account.deployAccount({\n"
"    classHash: classHash,\n"
"    constructorCalldata: constructorArgs,\n"
"    addressSalt: publicKey,\n"
"  });\n"
"\n"
"  await provider.waitForTransaction(deploy.transaction_hash);\n"
"  return deploy.contract_address;\n"
"}\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:429
#, fuzzy
msgid "STEP 11: Interacting with the Deployed Account Contract"
msgstr "## ä¸åˆçº¦äº¤äº’"

#: src/ch02-09-starknet-js.md:431
msgid "Once the account contract is successfully deployed, we can test it by sending test Ethereum (ETH) to another address:"
msgstr ""

#: src/ch02-09-starknet-js.md:433
msgid ""
"```ts\n"
"interface TransferEthConfig {\n"
"  provider: RpcProvider;\n"
"  account: Account;\n"
"}\n"
"\n"
"export async function transferEth({ provider, account }: TransferEthConfig) {\n"
"  const L2EthAddress =\n"
"    \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\";\n"
"\n"
"  const L2EthAbiPath = path.join(__dirname, \"./l2-eth-abi.json\");\n"
"  const L2EthAbiFile = await fs.readFile(L2EthAbiPath);\n"
"  const L2ETHAbi = JSON.parse(L2EthAbiFile.toString(\"ascii\"));\n"
"\n"
"  const contract = new Contract(L2ETHAbi, L2EthAddress, provider);\n"
"\n"
"  contract.connect(account);\n"
"\n"
"  const recipient =\n"
"    \"0x05feeb3a0611b8f1f602db065d36c0f70bb01032fc1f218bf9614f96c8f546a9\";\n"
"  const amountInGwei = cairo.uint256(100);\n"
"\n"
"  await contract.transfer(recipient, amountInGwei);\n"
"}\n"
"\n"
"export async function isContractAlreadyDeclared(\n"
"  classHash: string,\n"
"  provider: RpcProvider,\n"
") {\n"
"  try {\n"
"    await provider.getClassByHash(classHash);\n"
"    return true;\n"
"  } catch (error) {\n"
"    return false;\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:471
msgid "With the necessary functions in place, we can now write the deployment script in `deploy.ts`, which orchestrates the deployment and verification process:"
msgstr ""

#: src/ch02-09-starknet-js.md:473
msgid ""
"```ts\n"
"import { hash, LibraryError, Account } from \"starknet\";\n"
"\n"
"import {\n"
"  importChalk,\n"
"  connectToStarknet,\n"
"  getDeployerWallet,\n"
"  createKeyPair,\n"
"  getCompiledCode,\n"
"  declareContract,\n"
"  deployAccount,\n"
"  transferEth,\n"
"  isContractAlreadyDeclared,\n"
"} from \"./utils\";\n"
"\n"
"async function main() {\n"
"  const chalk = await importChalk();\n"
"  const provider = connectToStarknet();\n"
"  const deployer = getDeployerWallet(provider);\n"
"  const { privateKey, publicKey } = createKeyPair();\n"
"\n"
"  console.log(chalk.yellow(\"Account Contract:\"));\n"
"  console.log(`Private Key = ${privateKey}`);\n"
"  console.log(`Public Key = ${publicKey}`);\n"
"\n"
"  let sierraCode, casmCode;\n"
"  try {\n"
"    ({ sierraCode, casmCode } = await getCompiledCode(\"aa_Account\"));\n"
"  } catch (error: any) {\n"
"    console.log(chalk.red(\"Failed to read contract files\"));\n"
"    process.exit(1);\n"
"  }\n"
"\n"
"  const classHash = hash.computeContractClassHash(sierraCode);\n"
"  const isAlreadyDeclared = await isContractAlreadyDeclared(\n"
"    classHash,\n"
"    provider,\n"
"  );\n"
"\n"
"  if (isAlreadyDeclared) {\n"
"    console.log(chalk.yellow(\"Contract class already declared\"));\n"
"  } else {\n"
"    try {\n"
"      console.log(\"Declaring account contract...\");\n"
"      await declareContract({ provider, deployer, sierraCode, casmCode });\n"
"      console.log(chalk.green(\"Account contract successfully declared\"));\n"
"    } catch (error: any) {\n"
"      console.log(chalk.red(\"Declare transaction failed\"));\n"
"      console.log(error);\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  console.log(`Class Hash = ${classHash}`);\n"
"\n"
"  let address: string;\n"
"  try {\n"
"    console.log(\"Deploying account contract...\");\n"
"    address = await deployAccount({\n"
"      privateKey,\n"
"      publicKey,\n"
"      classHash,\n"
"      provider,\n"
"    });\n"
"    console.log(\n"
"      chalk.green(`Account contract successfully deployed to Starknet testnet`),\n"
"    );\n"
"  } catch (error: any) {\n"
"    if (\n"
"      error instanceof LibraryError &&\n"
"      error.message.includes(\"balance is smaller\")\n"
"    ) {\n"
"      console.log(chalk.red(\"Insufficient account balance for deployment\"));\n"
"      process.exit(1);\n"
"    } else {\n"
"      console.log(chalk.red(\"Deploy account transaction failed\"));\n"
"      process.exit(1);\n"
"    }\n"
"  }\n"
"\n"
"  const account = new Account(provider, address, privateKey, \"1\");\n"
"\n"
"  try {\n"
"    console.log(\"Testing account by transferring ETH...\");\n"
"    await transferEth({ provider, account });\n"
"    console.log(chalk.green(`Account works!`));\n"
"  } catch (error) {\n"
"    console.log(chalk.red(\"Failed to transfer ETH\"));\n"
"    process.exit(1);\n"
"  }\n"
"}\n"
"\n"
"main();\n"
"```"
msgstr ""

#: src/ch02-09-starknet-js.md:568
msgid ""
"The `main` function orchestrates the entire deployment process, from creating a key pair to declaring and deploying the account contract, and finally testing its functionality by executing a transfer "
"transaction."
msgstr ""

#: src/ch02-09-starknet-js.md:572
msgid ""
"We have walked through the process of deploying an account contract using Starknet.js. Starting from setting up the environment, compiling the contract, and preparing the deployment scripts, to the "
"final steps of declaring, deploying, and interacting with the contract, each phase has been covered in detail. This approach ensures that developers can easily deploy their account contracts on the "
"Starknet network."
msgstr ""

#: src/ch02-09-01-counter-ui.md:1
#, fuzzy
msgid "Counter Smart Contract UI Integration"
msgstr "# è®¡æ•°å™¨æ™ºèƒ½åˆçº¦ç”¨æˆ·ç•Œé¢é›†æˆ"

#: src/ch02-09-01-counter-ui.md:3
msgid "This guide walks readers through integrating a simple counter smart contract with a frontend. By the end of this guide, readers will understand how to:"
msgstr "æœ¬æŒ‡å—æŒ‡å¯¼è¯»è€…å¦‚ä½•å°†ç®€å•çš„è®¡æ•°å™¨æ™ºèƒ½åˆçº¦ä¸å‰ç«¯é›†æˆã€‚åœ¨æœ¬æŒ‡å—ç»“æŸæ—¶ï¼Œè¯»è€…å°†äº†è§£å¦‚ä½•ï¼š"

#: src/ch02-09-01-counter-ui.md:5
#, fuzzy
msgid "Connect the frontend to a smart contract."
msgstr "æ‰§è¡Œä»¥ä¸‹æ“ä½œä»¥ç¼–è¯‘åˆçº¦ï¼š"

#: src/ch02-09-01-counter-ui.md:6
msgid "Initiate transactions, such as incrementing or decrementing the counter."
msgstr ""

#: src/ch02-09-01-counter-ui.md:7
msgid "Read and display data, such as showing the counter value on the frontend."
msgstr ""

#: src/ch02-09-01-counter-ui.md:9
msgid ""
"For a visual walkthrough, do check out the [Basecamp frontend session](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). This comprehensive session delves deeper into the "
"nuances of the concepts we've touched upon, presenting a mix of theoretical explanations and hands-on demonstrations."
msgstr "è¦è·å¾—ç›´è§‚çš„æ¼”ç¤ºï¼Œè¯·æŸ¥çœ‹ [Basecamp å‰ç«¯è¯¾ç¨‹](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view)ã€‚è¿™èŠ‚ç»¼åˆè¯¾ç¨‹æ·±å…¥æ¢è®¨äº†æˆ‘ä»¬æ‰€æ¶‰åŠæ¦‚å¿µçš„ç»†å¾®å·®åˆ«ï¼Œæ—¢æœ‰ç†è®ºè§£é‡Šï¼Œä¹Ÿæœ‰å®è·µæ¼”ç¤ºã€‚"

#: src/ch02-09-01-counter-ui.md:11
#, fuzzy
msgid "Tools Used"
msgstr "## ä½¿ç”¨çš„å·¥å…·"

#: src/ch02-09-01-counter-ui.md:13
msgid "[Reactjs](https://react.dev/learn/start-a-new-react-project): A frontend building framework."
msgstr ""

#: src/ch02-09-01-counter-ui.md:14
#, fuzzy
msgid "[@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet): A wrapper for **[starknet.js](https://github.com/0xs34n/starknet.js)**, aiding interaction with wallet extensions."
msgstr ""
"- [Reactjs](https://react.dev/learn/start-a-new-react-project)ï¼šå‰ç«¯æ„å»ºæ¡†æ¶ã€‚\n"
"- [@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet)ï¼šæ˜¯**[starknet.js](https://github.com/0xs34n/starknet.js)**çš„ä¸€ä¸ªå°è£…ï¼Œå¯å¸®åŠ©ä¸é’±åŒ…æ‰©å±•è¿›è¡Œäº¤äº’ã€‚\n"
"- [starknet](https://www.npmjs.com/package/starknet)ï¼šStarknetçš„ JavaScript åº“ã€‚"

#: src/ch02-09-01-counter-ui.md:15
msgid "[Starknet](https://www.npmjs.com/package/starknet): A JavaScript library for Starknet."
msgstr ""

#: src/ch02-09-01-counter-ui.md:17
#, fuzzy
msgid "Setting Up the Environment"
msgstr "## é…ç½®ç¯å¢ƒ"

#: src/ch02-09-01-counter-ui.md:19
msgid "To begin, clone the project repository:"
msgstr "é¦–å…ˆï¼Œå…‹éš†é¡¹ç›®ä»“åº“ï¼š"

#: src/ch02-09-01-counter-ui.md:25
msgid "Then, navigate to the project directory and install necessary packages:"
msgstr "ç„¶åï¼Œå¯¼èˆªè‡³é¡¹ç›®ç›®å½•å¹¶å®‰è£…å¿…è¦çš„è½¯ä»¶åŒ…ï¼š"

#: src/ch02-09-01-counter-ui.md:32
msgid "To launch the project, run:"
msgstr "è¦å¯åŠ¨è¯¥é¡¹ç›®ï¼Œè¯·è¿è¡Œï¼š"

#: src/ch02-09-01-counter-ui.md:38
msgid "In `index.js`, several key functions are provided:"
msgstr "åœ¨ `index.js` ä¸­ï¼Œæä¾›äº†å‡ ä¸ªå…³é”®å‡½æ•°ï¼š"

#: src/ch02-09-01-counter-ui.md:41
msgid "// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
msgstr ""

#: src/ch02-09-01-counter-ui.md:43
msgid "// Terminate the connection\n"
msgstr ""

#: src/ch02-09-01-counter-ui.md:46
msgid "// Trigger increment\n"
msgstr ""

#: src/ch02-09-01-counter-ui.md:49
msgid "// Trigger decrement\n"
msgstr ""

#: src/ch02-09-01-counter-ui.md:52
msgid "// Retrieve current count\n"
msgstr ""

#: src/ch02-09-01-counter-ui.md:57
#, fuzzy
msgid "Managing Connection"
msgstr "## ç®¡ç†è¿æ¥"

#: src/ch02-09-01-counter-ui.md:59
#, fuzzy
msgid "`connectWallet`"
msgstr "### `connectWallet` ï¼ˆè¿æ¥é’±åŒ…ï¼‰"

#: src/ch02-09-01-counter-ui.md:61
msgid ""
"The `connectWallet` function serves as the mechanism to establish a connection to the blockchain through specific wallet providers such as ArgentX or Braavos. It is asynchronous, allowing the use of "
"`await` for handling asynchronous tasks."
msgstr "`connectWallet` å‡½æ•°æ˜¯é€šè¿‡ ArgentX æˆ– Braavos ç­‰ç‰¹å®šé’±åŒ…æä¾›å•†ä¸åŒºå—é“¾å»ºç«‹è¿æ¥çš„æœºåˆ¶ã€‚å®ƒæ˜¯å¼‚æ­¥çš„ï¼Œå…è®¸ä½¿ç”¨ `await` æ¥å¤„ç†å¼‚æ­¥ä»»åŠ¡ã€‚"

#: src/ch02-09-01-counter-ui.md:65 src/ch02-09-01-counter-ui.md:105 src/ch04-05-06-web-wallet.md:28 src/ch04-05-06-web-wallet.md:35
msgid "\"https://web.argent.xyz\""
msgstr ""

#: src/ch02-09-01-counter-ui.md:74
#, fuzzy
msgid "Initiates the connection using the **`connect`** method from the **`@argent/get-starknet`** library, targeting Starknet."
msgstr ""
"- ä½¿ç”¨**`@argent/get-starknet`**åº“ä¸­çš„**`connect`**æ–¹æ³•å¯åŠ¨è¿æ¥ï¼Œç›®æ ‡ä¸ºStarknetã€‚\n"
"- è¿æ¥æˆåŠŸåï¼Œç”¨**`connection`**ã€**`account`**å’Œ**`selectedAddress`**çš„è¯¦ç»†ä¿¡æ¯æ›´æ–° React ç»„ä»¶çš„çŠ¶æ€ã€‚"

#: src/ch02-09-01-counter-ui.md:75
#, fuzzy
msgid "Upon a successful connection, updates the React component's state with details of the **`connection`**, **`account`**, and **`selectedAddress`**."
msgstr ""
"- ä½¿ç”¨**`@argent/get-starknet`**åº“ä¸­çš„**`connect`**æ–¹æ³•å¯åŠ¨è¿æ¥ï¼Œç›®æ ‡ä¸ºStarknetã€‚\n"
"- è¿æ¥æˆåŠŸåï¼Œç”¨**`connection`**ã€**`account`**å’Œ**`selectedAddress`**çš„è¯¦ç»†ä¿¡æ¯æ›´æ–° React ç»„ä»¶çš„çŠ¶æ€ã€‚"

#: src/ch02-09-01-counter-ui.md:77
#, fuzzy
msgid "`disconnectWallet`"
msgstr "###`disconnectWallet` ï¼ˆæ–­å¼€é’±åŒ…è¿æ¥ï¼‰"

#: src/ch02-09-01-counter-ui.md:79
msgid "The `disconnectWallet` function is designed to sever the connection with the web wallet asynchronously. After disconnection, it updates the component's state, resetting connection details."
msgstr "`disconnectWallet`å‡½æ•°æ—¨åœ¨å¼‚æ­¥æ–­å¼€ä¸ç½‘ç»œé’±åŒ…çš„è¿æ¥ã€‚æ–­å¼€è¿æ¥åï¼Œå®ƒä¼šæ›´æ–°ç»„ä»¶çš„çŠ¶æ€ï¼Œé‡ç½®è¿æ¥è¯¦æƒ…ã€‚"

#: src/ch02-09-01-counter-ui.md:82
msgid ">"
msgstr ""

#: src/ch02-09-01-counter-ui.md:86
msgid "''"
msgstr ""

#: src/ch02-09-01-counter-ui.md:90
msgid "It utilizes the **`disconnect`** function, possibly from an external library, and handles the operation asynchronously with **`await`**."
msgstr ""

#: src/ch02-09-01-counter-ui.md:91
msgid "Post-disconnection, the state of the React component is updated:"
msgstr ""

#: src/ch02-09-01-counter-ui.md:92
msgid "**`setConnection`** is set to **`undefined`**."
msgstr ""

#: src/ch02-09-01-counter-ui.md:93
msgid "**`setAccount`** is set to **`undefined`**."
msgstr ""

#: src/ch02-09-01-counter-ui.md:94
msgid "**`setAddress`** is cleared with an empty string."
msgstr ""

#: src/ch02-09-01-counter-ui.md:96
#, fuzzy
msgid "`EagerlyConnect`"
msgstr "### `EagerlyConnect`"

#: src/ch02-09-01-counter-ui.md:98
msgid "The `EagerlyConnect` mechanism leverages React's `useEffect` hook to initiate a connection to Starknet upon the component's mounting or initial rendering."
msgstr "`EagerlyConnect`æœºåˆ¶åˆ©ç”¨ React çš„ `useEffect` é’©å­ï¼Œåœ¨ç»„ä»¶æŒ‚è½½æˆ–åˆå§‹æ¸²æŸ“æ—¶å¯åŠ¨ä¸Starknetçš„è¿æ¥ã€‚"

#: src/ch02-09-01-counter-ui.md:104
msgid "\"neverAsk\""
msgstr ""

#: src/ch02-09-01-counter-ui.md:118
#, fuzzy
msgid ""
"Inside the **`useEffect`**, the **`connectToStarknet`** function is defined, aiming to establish an asynchronous connection using the **`connect`** function. Parameters like **`modalMode`** and "
"**`webWalletUrl`** are passed to guide the connection process."
msgstr ""
"- åœ¨**`useEffect`**å†…éƒ¨ï¼Œå®šä¹‰äº†**`connectToStarknet`**å‡½æ•°ï¼Œæ—¨åœ¨ä½¿ç”¨**`connect`**å‡½æ•°å»ºç«‹å¼‚æ­¥è¿æ¥ã€‚ä¼ é€’**`modalMode`**å’Œ**`webWalletUrl`**ç­‰å‚æ•°æ˜¯ä¸ºäº†æŒ‡å¯¼è¿æ¥è¿‡ç¨‹ã€‚\n"
"- å¦‚æœè¿æ¥æˆåŠŸï¼ˆ**`connection && connection.isConnected`**ï¼‰ï¼Œåˆ™ä½¿ç”¨**`setConnection`**ã€**`setAccount`**å’Œ**`setAddress`**æ›´æ–°çŠ¶æ€ï¼ŒåŒ…æ‹¬è¿æ¥ã€è´¦æˆ·å’Œæ‰€é€‰åœ°å€çš„è¯¦ç»†ä¿¡æ¯ã€‚\n"
"- **`connectToStarknet`**å‡½æ•°åœ¨å®šä¹‰åç«‹å³æ‰§è¡Œã€‚"

#: src/ch02-09-01-counter-ui.md:119
msgid ""
"If successful in connecting (**`connection && connection.isConnected`**), the state updates with details of the connection, the account, and the selected address using **`setConnection`**, "
"**`setAccount`**, and **`setAddress`**."
msgstr ""

#: src/ch02-09-01-counter-ui.md:120
msgid "The **`connectToStarknet`** function is executed immediately after its definition."
msgstr ""

#: src/ch02-09-01-counter-ui.md:122
#, fuzzy
msgid "Important Refresher on Smart Contract Interactions"
msgstr "## æ™ºèƒ½åˆçº¦äº¤äº’çš„è¦ç‚¹å›é¡¾"

#: src/ch02-09-01-counter-ui.md:124
msgid ""
"For effective interaction with a smart contract on the network, it's crucial to understand key components after establishing a connection. Among these are the `contract address`, `ABI`, `Signer`, and "
"`Provider`."
msgstr "è¦ä¸ç½‘ç»œä¸Šçš„æ™ºèƒ½åˆçº¦è¿›è¡Œæœ‰æ•ˆäº¤äº’ï¼Œå…³é”®æ˜¯è¦äº†è§£å»ºç«‹è¿æ¥åçš„å…³é”®ç»„ä»¶ã€‚å…¶ä¸­åŒ…æ‹¬ `contract address`, `ABI`, `Signer`, å’Œ `Provider`.ã€‚"

#: src/ch02-09-01-counter-ui.md:126
#, fuzzy
msgid "ABI (Application Binary Interface)"
msgstr "### ABI - åº”ç”¨äºŒè¿›åˆ¶æ¥å£"

#: src/ch02-09-01-counter-ui.md:128
msgid "ABI is a standardized bridge between two binary program modules. It is essential for:"
msgstr "ABI æ˜¯ä¸¤ä¸ªäºŒè¿›åˆ¶ç¨‹åºæ¨¡å—ä¹‹é—´çš„æ ‡å‡†åŒ–æ¡¥æ¢ã€‚å®ƒå¯¹ä»¥ä¸‹æ–¹é¢è‡³å…³é‡è¦ï¼š"

#: src/ch02-09-01-counter-ui.md:130
#, fuzzy
msgid "Interacting with smart contracts on the blockchain."
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-09-01-counter-ui.md:131
msgid "Specifying the structure of functions, events, and variables for software applications."
msgstr ""

#: src/ch02-09-01-counter-ui.md:132
msgid "Enabling smooth communication with the smart contract, detailing function signatures, input/output types, event formats, and variable types."
msgstr ""

#: src/ch02-09-01-counter-ui.md:133
msgid "Facilitating invocation of functions and data retrieval from the contract."
msgstr ""

#: src/ch02-09-01-counter-ui.md:135
#, fuzzy
msgid "Signer"
msgstr "### ç­¾åè€…"

#: src/ch02-09-01-counter-ui.md:137
msgid "The Signer plays a pivotal role in:"
msgstr "ç­¾åè€…åœ¨ä»¥ä¸‹æ–¹é¢å‘æŒ¥ç€å…³é”®ä½œç”¨ï¼š"

#: src/ch02-09-01-counter-ui.md:139
#, fuzzy
msgid "Signing transactions."
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch02-09-01-counter-ui.md:140
msgid "Authorizing actions on the blockchain."
msgstr ""

#: src/ch02-09-01-counter-ui.md:141
#, fuzzy
msgid "Bearing the fees associated with blockchain operations."
msgstr ""
"- ç­¾ç½²äº¤æ˜“ã€‚\n"
"- æˆæƒåŒºå—é“¾ä¸Šçš„æ“ä½œã€‚\n"
"- æ‰¿æ‹…ä¸åŒºå—é“¾æ“ä½œç›¸å…³çš„è´¹ç”¨ã€‚"

#: src/ch02-09-01-counter-ui.md:143
msgid "Signers are especially linked to write operations that change the state of the blockchain. These operations need cryptographic signing for security and validity."
msgstr "ç­¾åè€…ä¸æ”¹å˜åŒºå—é“¾çŠ¶æ€çš„å†™å…¥æ“ä½œå°¤å…¶ç›¸å…³ã€‚è¿™äº›æ“ä½œéœ€è¦åŠ å¯†ç­¾åæ¥ä¿è¯å®‰å…¨æ€§å’Œæœ‰æ•ˆæ€§ã€‚"

#: src/ch02-09-01-counter-ui.md:147
msgid "The Provider acts as the medium for:"
msgstr "æä¾›è€…å……å½“ä»¥ä¸‹æ´»åŠ¨çš„åª’ä»‹ï¼š"

#: src/ch02-09-01-counter-ui.md:149
msgid "Communication with the blockchain."
msgstr ""

#: src/ch02-09-01-counter-ui.md:150
#, fuzzy
msgid "Creating transactions."
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch02-09-01-counter-ui.md:151
msgid "Fetching data from the blockchain."
msgstr ""

#: src/ch02-09-01-counter-ui.md:153
msgid "To initiate a write transaction, the connected account (signer) must be provided. This signer then signs the transaction, bearing the necessary fee for execution."
msgstr "è¦å¯åŠ¨å†™å…¥äº¤æ˜“ï¼Œå¿…é¡»æä¾›è¿æ¥è´¦æˆ·ï¼ˆç­¾åè€…ï¼‰ã€‚ç­¾åè€…éšåç­¾ç½²äº¤æ˜“ï¼Œå¹¶æ‰¿æ‹…æ‰§è¡Œæ‰€éœ€çš„è´¹ç”¨ã€‚"

#: src/ch02-09-01-counter-ui.md:155
#, fuzzy
msgid "Invoking the `increment` Function"
msgstr "## è°ƒç”¨ `increment` å‡½æ•°"

#: src/ch02-09-01-counter-ui.md:162
msgid "\"You successfully incremented the counter!\""
msgstr ""

#: src/ch02-09-01-counter-ui.md:169
msgid "The **`increaseCounter`** function is crafted to interact with a smart contract and increment a specific counter. Here's a step-by-step breakdown:"
msgstr "**`increaseCounter`**å‡½æ•°ç”¨äºä¸æ™ºèƒ½åˆçº¦äº¤äº’å¹¶é€’å¢ç‰¹å®šè®¡æ•°å™¨ã€‚ä¸‹é¢æ˜¯æŒ‰ç…§æ­¥éª¤çš„åˆ†è§£è®²è§£ï¼š"

#: src/ch02-09-01-counter-ui.md:171
msgid "Establishes a new contract instance using the provided contract's ABI, its address, and the connected account. The account is essential since this write transaction alters the contract's state."
msgstr ""

#: src/ch02-09-01-counter-ui.md:172
msgid "Executes the contract's **`increment`** method. The **`await`** keyword ensures the program pauses until this action completes."
msgstr ""

#: src/ch02-09-01-counter-ui.md:173
#, fuzzy
msgid "On successful execution, the user receives a confirmation alert indicating the counter's increment."
msgstr "éªŒè¯æˆåŠŸåï¼Œæ‚¨å°†åœ¨æ§åˆ¶å°ä¸­æ”¶åˆ°ç¡®è®¤ä¿¡æ¯ã€‚"

#: src/ch02-09-01-counter-ui.md:174
msgid "In case of any errors during the process, an alert displays the corresponding error message to the user."
msgstr ""

#: src/ch02-09-01-counter-ui.md:176
#, fuzzy
msgid "Invoking the `decrement` Function"
msgstr "## è°ƒç”¨ `decrement` å‡½æ•°"

#: src/ch02-09-01-counter-ui.md:183
msgid "\"You successfully decremented the counter!\""
msgstr ""

#: src/ch02-09-01-counter-ui.md:190
msgid "The **`decreaseCounter`** function is designed to interact with a smart contract and decrement a specific counter. Here's a succinct breakdown of its operation:"
msgstr "é€’å‡è®¡æ•°å™¨ï¼ˆ**`decreaseCounter`** ï¼‰å‡½æ•°æ—¨åœ¨ä¸æ™ºèƒ½åˆçº¦äº¤äº’ï¼Œè®©ä¸€ä¸ªç‰¹å®šçš„è®¡æ•°å™¨é€’å‡ã€‚ä¸‹é¢æ˜¯å…¶æ“ä½œçš„ç®€è¦è¯´æ˜ï¼š"

#: src/ch02-09-01-counter-ui.md:192
msgid "Creates a new contract instance by utilizing the provided contract's ABI, its address, and the connected account. The account is vital as this write transaction modifies the contract's state."
msgstr ""

#: src/ch02-09-01-counter-ui.md:193
msgid "Initiates the contract's **`decrement`** method. With the use of the **`await`** keyword, the program ensures it waits for the decrement action to finalize."
msgstr ""

#: src/ch02-09-01-counter-ui.md:194
msgid "Upon successful execution, the user is notified with an alert indicating the counter's decrement."
msgstr ""

#: src/ch02-09-01-counter-ui.md:195
msgid "Should any errors arise during the interaction, the user is promptly alerted with the pertinent error message."
msgstr ""

#: src/ch02-09-01-counter-ui.md:197
#, fuzzy
msgid "Fetching the Current Count with `get_current_count` Function"
msgstr "## ä½¿ç”¨`get_current_count`å‡½æ•°è·å–å½“å‰è®¡æ•°"

#: src/ch02-09-01-counter-ui.md:214
msgid "The **`getCounter`** function is designed to retrieve the current count from a smart contract. Here's a breakdown of its operation:"
msgstr "**`getCounter`**å‡½æ•°æ—¨åœ¨ä»æ™ºèƒ½åˆçº¦ä¸­è·å–å½“å‰è®¡æ•°ã€‚ä¸‹é¢æ˜¯è¯¥å‡½æ•°çš„å…·ä½“æ“ä½œï¼š"

#: src/ch02-09-01-counter-ui.md:216
msgid "Establishes a provider instance, specifying the sequencer network â€“ in this instance, it's set to the **`mainnet`** through **`constants.NetworkName.SN_MAIN`**."
msgstr ""

#: src/ch02-09-01-counter-ui.md:217
msgid "With this provider, it then initiates a contract instance using the provided contract's ABI, its address, and the aforementioned provider."
msgstr ""

#: src/ch02-09-01-counter-ui.md:218
msgid ""
"The function then invokes the **`get_current_count`** method of the contract to fetch the current count. This is an asynchronous action, and the program waits for its completion with the **`await`** "
"keyword."
msgstr ""

#: src/ch02-09-01-counter-ui.md:219
msgid "Once successfully retrieved, the count, which is presumably a number, is converted to a string and stored using the **`setRetrievedValue`** function."
msgstr ""

#: src/ch02-09-01-counter-ui.md:220
msgid "In the event of any errors during the process, an alert provides the user with the relevant error message."
msgstr ""

#: src/ch02-09-01-counter-ui.md:222
msgid ""
"It's essential to emphasize that while performing read operations, like fetching data from a blockchain network, the function uses the provider. Unlike write operations, which typically require a "
"signer (or an account) for transaction signing, read operations don't mandate such authentication. Thus, in this function, only the provider is specified, and not the signer."
msgstr ""
"å¿…é¡»å¼ºè°ƒçš„æ˜¯ï¼Œåœ¨æ‰§è¡Œè¯»å–æ“ä½œï¼ˆå¦‚ä»åŒºå—é“¾ç½‘ç»œä¸­è·å–æ•°æ®ï¼‰æ—¶ï¼Œè¯¥åŠŸèƒ½ä½¿ç”¨çš„æ˜¯æä¾›å•†ã€‚ä¸é€šå¸¸éœ€è¦ç­¾åè€…ï¼ˆæˆ–è´¦æˆ·ï¼‰è¿›è¡Œäº¤æ˜“ç­¾åçš„å†™å…¥æ“ä½œä¸åŒï¼Œè¯»å–æ“ä½œå¹¶ä¸å¼ºåˆ¶è¦æ±‚è¿›è¡Œæ­¤ç±»èº«ä»½éªŒè¯ã€‚å› æ­¤ï¼Œåœ¨è¯¥å‡½æ•°ä¸­ï¼ŒåªæŒ‡å®šäº†"
"æä¾›å•†ï¼Œè€Œæ²¡æœ‰æŒ‡å®šç­¾åè€…ã€‚"

#: src/ch02-09-01-counter-ui.md:224
#, fuzzy
msgid "Wrapping It Up: Integrating a Frontend with a Counter Smart Contract"
msgstr "## åˆè€Œä¸ºä¸€ï¼šå°†å‰ç«¯ä¸è®¡æ•°å™¨æ™ºèƒ½åˆçº¦æ•´åˆåœ¨ä¸€èµ·"

#: src/ch02-09-01-counter-ui.md:226
msgid "In this tutorial, we review the process of integrating a basic counter smart contract with a frontend application."
msgstr "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†å›é¡¾å°†åŸºæœ¬è®¡æ•°å™¨æ™ºèƒ½åˆçº¦ä¸å‰ç«¯åº”ç”¨ç¨‹åºé›†æˆçš„è¿‡ç¨‹ã€‚"

#: src/ch02-09-01-counter-ui.md:228
msgid "Here's a quick recap:"
msgstr "ä¸‹é¢æ˜¯ç®€è¦å›é¡¾ï¼š"

#: src/ch02-09-01-counter-ui.md:230
msgid "**Establishing Connection**: With the **`connectWallet`** function, we made seamless connections to the blockchain, paving the way for interactions with our smart contract."
msgstr ""

#: src/ch02-09-01-counter-ui.md:231
msgid "**Terminating Connection**: The **`disconnectWallet`** function ensures that users can safely terminate their active connections to the blockchain, maintaining security and control."
msgstr ""

#: src/ch02-09-01-counter-ui.md:232
msgid "**Interacting with the Smart Contract**: Using the **`increaseCounter`**, **`decreaseCounter`**, and **`getCounter`** functions, we explored how to:"
msgstr ""

#: src/ch02-09-01-counter-ui.md:233
#, fuzzy
msgid "Initiate transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch02-09-01-counter-ui.md:234
msgid "Adjust the counter value (increment or decrement)"
msgstr ""

#: src/ch02-09-01-counter-ui.md:235
msgid "Fetch data from the blockchain"
msgstr ""

#: src/ch02-09-01-counter-ui.md:237
#, fuzzy
msgid ""
"For a visual walkthrough, do check out the [Basecamp VII: S5 Frontend](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). This comprehensive session delves deeper into the "
"nuances of the concepts we've touched upon, presenting a mix of theoretical explanations and hands-on demonstrations."
msgstr "è¦è·å¾—ç›´è§‚çš„æ¼”ç¤ºï¼Œè¯·æŸ¥çœ‹ [Basecamp å‰ç«¯è¯¾ç¨‹](https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view)ã€‚è¿™èŠ‚ç»¼åˆè¯¾ç¨‹æ·±å…¥æ¢è®¨äº†æˆ‘ä»¬æ‰€æ¶‰åŠæ¦‚å¿µçš„ç»†å¾®å·®åˆ«ï¼Œæ—¢æœ‰ç†è®ºè§£é‡Šï¼Œä¹Ÿæœ‰å®è·µæ¼”ç¤ºã€‚"

#: src/ch02-09-02-erc20-ui.md:1 src/ch02-10-01-erc20-ui.md:1
#, fuzzy
msgid "ERC-20 UI"
msgstr "# ERC-20 UI"

#: src/ch02-09-02-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with StarknetJS. Readers will:"
msgstr "æœ¬æŒ‡å—æä¾›äº†ä½¿ç”¨ Cairo æ„å»º ERC20 æ™ºèƒ½åˆçº¦çš„æ­¥éª¤ï¼Œå¹¶å°†å…¶çº³å…¥ä½¿ç”¨ StarknetJS çš„ React Web åº”ç”¨ç¨‹åºä¸­ã€‚è¯»è€…å°†ï¼š"

#: src/ch02-09-02-erc20-ui.md:5 src/ch02-10-01-erc20-ui.md:5
msgid "Understand how to implement the ERC20 interface"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:6 src/ch02-10-01-erc20-ui.md:6
#, fuzzy
msgid "Learn how to deploy contracts on the Starknet network"
msgstr "å½“è®¾ç½®å®Œæˆåï¼Œæ‚¨å°±å¯ä»¥å°†æ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°Starknetæµ‹è¯•ç½‘ç»œäº†ã€‚"

#: src/ch02-09-02-erc20-ui.md:7 src/ch02-10-01-erc20-ui.md:7
msgid "Discover ways to engage with contracts within a React application"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:8 src/ch02-10-01-erc20-ui.md:8
msgid "Design their own ERC20 token and initiate it on Starknet"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and StarknetJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr "æœ¬æŒ‡å—çš„å‰ææ¡ä»¶æ˜¯å¯¹ Cairo ç¼–ç¨‹è¯­è¨€å’Œ StarknetJS æœ‰åŸºæœ¬çš„äº†è§£ã€‚æ­¤å¤–ï¼Œç¡®ä¿ç³»ç»Ÿä¸Šå·²å®‰è£… Node.js å’Œ NPMã€‚"

#: src/ch02-09-02-erc20-ui.md:12 src/ch02-10-01-erc20-ui.md:12
msgid "The example will walk through creating an ERC20 token named MKT and crafting a web3 interface for functionalities such as balance verification and token transfer."
msgstr "è¯¥ç¤ºä¾‹å°†ä»‹ç»å¦‚ä½•åˆ›å»ºä¸€ä¸ªåä¸º MKT çš„ ERC20 ä»£å¸ï¼Œå¹¶ä¸ºä½™é¢éªŒè¯å’Œä»£å¸è½¬ç§»ç­‰åŠŸèƒ½åˆ›å»ºä¸€ä¸ª web3 ç•Œé¢ã€‚"

#: src/ch02-09-02-erc20-ui.md:16 src/ch02-10-01-erc20-ui.md:16
msgid "Throughout this guide, the following tools and libraries will be utilized:"
msgstr "æœ¬æŒ‡å—å°†ä½¿ç”¨ä»¥ä¸‹å·¥å…·å’Œåº“ï¼š"

#: src/ch02-09-02-erc20-ui.md:18 src/ch02-10-01-erc20-ui.md:18
msgid "Scarb 0.7.0 with Cairo 2.2.0"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:19 src/ch02-10-01-erc20-ui.md:19
msgid "Starkli 0.1.9"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:20 src/ch02-10-01-erc20-ui.md:20
msgid "Oppenzeppelin libraries v0.7.0"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:21
msgid "StarknetJS v5.19.5"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:22
msgid "get-starknet v3.0.1"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:23 src/ch02-10-01-erc20-ui.md:22
msgid "NodeJS v19.6.1"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:24
msgid "Next.js 13.5.5"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:25 src/ch02-10-01-erc20-ui.md:24
msgid "Visual Studio Code"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:26 src/ch02-10-01-erc20-ui.md:25
msgid "Vercel"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:28 src/ch02-10-01-erc20-ui.md:27
#, fuzzy
msgid "Initiating a New Starknet Project"
msgstr "## å¯åŠ¨æ–°çš„Starkneté¡¹ç›®"

#: src/ch02-09-02-erc20-ui.md:30 src/ch02-10-01-erc20-ui.md:29
msgid "Begin by establishing a new Starknet project named \"erc20\" using Scarb:"
msgstr "é¦–å…ˆä½¿ç”¨ Scarb å»ºç«‹ä¸€ä¸ªåä¸º \"erc20 \"çš„æ–°Starkneté¡¹ç›®ï¼š"

#: src/ch02-09-02-erc20-ui.md:38 src/ch02-10-01-erc20-ui.md:37
msgid "Subsequently, update the Scarb.toml to include the essential OpenZeppelin libraries. Post edits, the Scarb.toml should appear as:"
msgstr "éšåï¼Œæ›´æ–° Scarb.tomlï¼Œä½¿å…¶åŒ…å« OpenZeppelin çš„åŸºæœ¬åº“ã€‚ç¼–è¾‘å®Œæˆåï¼ŒScarb.toml åº”æ˜¾ç¤ºä¸ºï¼š"

#: src/ch02-09-02-erc20-ui.md:40
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-09-02-erc20-ui.md:54 src/ch02-10-01-erc20-ui.md:53
#, fuzzy
msgid "Implementing the ERC20 Token"
msgstr "## å®ç° ERC20 token"

#: src/ch02-09-02-erc20-ui.md:56 src/ch02-10-01-erc20-ui.md:55
msgid "Begin by creating a new file named `src/erc20.cairo`. In this file, the ERC20 token named MKT, along with its associated functions, will be defined:"
msgstr "é¦–å…ˆåˆ›å»ºä¸€ä¸ªåä¸º`src/erc20.cairo`çš„æ–°æ–‡ä»¶ã€‚åœ¨è¯¥æ–‡ä»¶ä¸­ï¼Œå°†å®šä¹‰åä¸º MKT çš„ ERC20 ä»£å¸åŠå…¶ç›¸å…³å‡½æ•°ï¼š"

#: src/ch02-09-02-erc20-ui.md:99 src/ch02-10-01-erc20-ui.md:98
msgid "Now edit `src/lib.cairo` and replace the content with:"
msgstr "ç°åœ¨ç¼–è¾‘ `src/lib.cairo`ï¼Œå°†å†…å®¹æ›¿æ¢ä¸º"

#: src/ch02-09-02-erc20-ui.md:107 src/ch02-10-01-erc20-ui.md:106
msgid "Upon completing your contract, proceed to compile it using Scarb:"
msgstr "å®Œæˆåˆçº¦åï¼Œä½¿ç”¨ Scarb è¿›è¡Œç¼–è¯‘ï¼š"

#: src/ch02-09-02-erc20-ui.md:113
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet (using your own account and keystore):"
msgstr "ç¼–è¯‘å®Œæˆåï¼Œåœ¨Starknetæµ‹è¯•ç½‘ä¸Šå£°æ˜æ™ºèƒ½åˆçº¦ï¼ˆä½¿ç”¨ä½ è‡ªå·±çš„è´¦æˆ·å’Œkeystoreï¼‰ï¼š"

#: src/ch02-09-02-erc20-ui.md:119 src/ch02-09-02-erc20-ui.md:146 src/ch02-10-01-erc20-ui.md:118 src/ch02-10-01-erc20-ui.md:145
msgid "The output should appear similar to:"
msgstr "è¾“å‡ºç»“æœåº”ç±»ä¼¼äºï¼š"

#: src/ch02-09-02-erc20-ui.md:128 src/ch02-10-01-erc20-ui.md:127
msgid "In cases where no modifications have been made to the provided contract, a notification will indicate that the contract has previously been declared on Starknet:"
msgstr "å¦‚æœä½ æ²¡æœ‰å¯¹æ‰€æä¾›çš„åˆçº¦è¿›è¡Œä¿®æ”¹ï¼Œåˆ™ä¼šæœ‰ä¸€ä¸ªæ˜¾ç¤ºè¯¥åˆçº¦ä¹‹å‰å·²åœ¨Starknetå£°æ˜çš„é€šçŸ¥å‡ºç°ï¼š"

#: src/ch02-09-02-erc20-ui.md:132 src/ch02-10-01-erc20-ui.md:131
#, fuzzy
msgid "'s already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
msgstr ""
"```bash\n"
"Enter keystore password:\n"
"Not declaring class as it's already declared. Class hash: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
"```"

#: src/ch02-09-02-erc20-ui.md:135 src/ch02-10-01-erc20-ui.md:134
#, fuzzy
msgid "Deploying the ERC20 Contract"
msgstr "## éƒ¨ç½² ERC20 åˆçº¦"

#: src/ch02-09-02-erc20-ui.md:137 src/ch02-10-01-erc20-ui.md:136
msgid "Proceed to deploy the MKT Token using Starkli. Provide these arguments for successful deployment:"
msgstr "ç»§ç»­ä½¿ç”¨ Starkli éƒ¨ç½² MKT ä»£å¸ã€‚æƒ³è¦æˆåŠŸéƒ¨ç½²éœ€æä¾›è¿™äº›å‚æ•°ï¼š"

#: src/ch02-09-02-erc20-ui.md:139 src/ch02-10-01-erc20-ui.md:138
#, fuzzy
msgid ""
"`Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
"contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively."
msgstr ""
"- `Initial mint`ï¼šé“¸é€  1,000,000 ä¸ªä»£å¸ã€‚é‰´äº MKT ä»£å¸åŒ…å« 18 ä½å°æ•°ï¼ˆOpenZeppelin çš„æ ‡å‡†ï¼‰ï¼Œæ‰€éœ€çš„è¾“å…¥ä¸º 1,000,000 \\* 10^18 æˆ– 0xd3c21bcecceda1000000ã€‚ç”±äºåˆçº¦æœŸæœ›çš„æ˜¯ u256 é“¸å¸å€¼ï¼Œå› æ­¤éœ€è¦åŒæ—¶æä¾›ä½"
"å€¼å’Œé«˜å€¼ï¼šåˆ†åˆ«ä¸º 0xd3c21bcecceda1000000 å’Œ 0ã€‚\n"
"- `Receiver address`ï¼šæ¥æ”¶è€…åœ°å€å¯ä»¥ä½¿ç”¨ä»»ä½•ä½ æŒæ§çš„åœ°å€ã€‚ä¾‹å¦‚ï¼š0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-09-02-erc20-ui.md:140
msgid "`Receiver address`: Use a preferred address who wiil be the initial recipient of 1,000,000 MKT. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""

#: src/ch02-09-02-erc20-ui.md:154 src/ch02-10-01-erc20-ui.md:153
msgid "NOTE: The deployed address received will differ for every user. Retain this address, as it will replace instances in subsequent TypeScript files to match the specific contract address."
msgstr "æ³¨æ„ï¼šæ¯ä¸ªç”¨æˆ·æ”¶åˆ°çš„éƒ¨ç½²åœ°å€éƒ½ä¸åŒã€‚è¯·ä¿ç•™æ­¤åœ°å€ï¼Œå› ä¸ºå®ƒå°†æ›¿æ¢åç»­ TypeScript æ–‡ä»¶ä¸­çš„å®ä¾‹ï¼Œä»¥åŒ¹é…ç‰¹å®šçš„åˆçº¦åœ°å€ã€‚"

#: src/ch02-09-02-erc20-ui.md:156 src/ch02-10-01-erc20-ui.md:155
msgid "Well done! The Cairo ERC20 smart contract has been deployed successfully on Starknet."
msgstr "å¹²å¾—æ¼‚äº®ï¼Cairo ERC20 æ™ºèƒ½åˆçº¦å·²åœ¨StarknetæˆåŠŸéƒ¨ç½²ã€‚"

#: src/ch02-09-02-erc20-ui.md:158
#, fuzzy
msgid "Setting Up a New React Project"
msgstr "## è®¾ç½®æ–°çš„ React é¡¹ç›®"

#: src/ch02-09-02-erc20-ui.md:160
#, fuzzy
msgid ""
"With the contract in place, initiate the development of the web application. Begin by setting up our react project. To do this, Nextjs framework provides the `create-next-app` script that streamlines "
"the setup of a Nextjs application:"
msgstr "åˆçº¦éƒ¨ç½²å®Œæˆååï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å¼€å‘ç½‘ç»œåº”ç”¨ç¨‹åºã€‚é¦–å…ˆè®¾ç½®æˆ‘ä»¬çš„ react é¡¹ç›®ã€‚ä¸ºæ­¤ï¼ŒNextjs æ¡†æ¶æä¾›äº† \"create-next-app \"è„šæœ¬ï¼Œå¯ç®€åŒ– Nextjs åº”ç”¨ç¨‹åºçš„è®¾ç½®ï¼š"

#: src/ch02-09-02-erc20-ui.md:173
msgid "Then, you should see something like this:"
msgstr "ç„¶åï¼Œä½ åº”è¯¥ä¼šçœ‹åˆ°ç±»ä¼¼è¿™æ ·çš„å†…å®¹ï¼š"

#: src/ch02-09-02-erc20-ui.md:190
#, fuzzy
msgid "Installing the Starknet.js Library"
msgstr "## å®‰è£… Starknet.js åº“"

#: src/ch02-09-02-erc20-ui.md:192
msgid "Now, let's install the starknet.js and recommended get-starknet (manage wallet connections) libraries:"
msgstr "ç°åœ¨ï¼Œè®©æˆ‘ä»¬å®‰è£… starknet.js å’Œæ¨èçš„ get-starknetï¼ˆç®¡ç†é’±åŒ…è¿æ¥ï¼‰åº“ï¼š"

#: src/ch02-09-02-erc20-ui.md:199 src/ch02-09-02-erc20-ui.md:213
msgid "You should see something like this:"
msgstr "ä½ åº”è¯¥çœ‹åˆ°è¿™æ ·çš„å†…å®¹ï¼š"

#: src/ch02-09-02-erc20-ui.md:207
msgid "Install starknetJS:"
msgstr "å®‰è£… starknetJSï¼š"

#: src/ch02-09-02-erc20-ui.md:221
msgid "Post-installation, confirm the version of the Starknet.js library:"
msgstr "å®‰è£…åï¼Œç¡®è®¤ Starknet.js åº“çš„ç‰ˆæœ¬ï¼š"

#: src/ch02-09-02-erc20-ui.md:229
msgid "The output should display the installed version, such as `starknet@5.19.5` and `get-starknet@3.0.1`."
msgstr "è¾“å‡ºç»“æœåº”æ˜¾ç¤ºå·²å®‰è£…çš„ç‰ˆæœ¬ï¼Œå¦‚ `starknet@5.19.5` å’Œ `get-starknet@3.0.1`ã€‚"

#: src/ch02-09-02-erc20-ui.md:231
#, fuzzy
msgid "Building our Project"
msgstr "## ç¼–è¯‘æˆ‘ä»¬çš„é¡¹ç›®"

#: src/ch02-09-02-erc20-ui.md:233
msgid "Once set up, make modifications to `erc20_web/src/app/layout.tsx` by replacing its content with the following code:"
msgstr "è®¾ç½®å®Œæˆåï¼Œç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢ `erc20_web/src/app/layout.tsx` ä¸­çš„å†…å®¹ï¼Œå¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼š"

#: src/ch02-09-02-erc20-ui.md:235
msgid ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"
msgstr ""
"```typescript\n"
"import type { Metadata } from 'next'\n"
"\n"
"export const metadata: Metadata = {\n"
"  title: 'Create Next App',\n"
"  description: 'Generated by create next app',\n"
"}\n"
"\n"
"export default function RootLayout({\n"
"  children,\n"
"}: {\n"
"  children: React.ReactNode\n"
"}) {\n"
"  return (\n"
"    <html lang=\"en\">\n"
"      <body>{children}</body>\n"
"    </html>\n"
"  )\n"
"}\n"
"\n"
"```"

#: src/ch02-09-02-erc20-ui.md:257
msgid "Now, edit `erc20_web/src/app/page.tsx` and replace its content with the following code:"
msgstr "ç°åœ¨ï¼Œç¼–è¾‘ `erc20_web/src/app/page.tsx` å¹¶ç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢å…¶å†…å®¹ï¼š"

#: src/ch02-09-02-erc20-ui.md:259
msgid ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import Head from \"next/head\";\n"
"import App from \"../components/App\";\n"
"\n"
"export default function Home() {\n"
"\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Homepage</title>\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"      <p>A basic web3 example with StarknetJS</p>\n"
"          <App />\n"
"      </main>\n"
"    </>\n"
"  );\n"
"}\n"
"```"

#: src/ch02-09-02-erc20-ui.md:280 src/ch02-10-01-erc20-ui.md:234
#, fuzzy
msgid "Enhancing Your React Application with Additional Features"
msgstr "## åˆ©ç”¨é™„åŠ åŠŸèƒ½æ”¹è¿›ä½ çš„ React åº”ç”¨ç¨‹åº"

#: src/ch02-09-02-erc20-ui.md:282
msgid "To enhance the app's functionality, create one component (`erc20_web/src/components/App.tsx`) for balance and transfer with the following code."
msgstr "ä¸ºå¢å¼ºåº”ç”¨ç¨‹åºçš„åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹ä»£ç ä¸ºä½™é¢å’Œè½¬è´¦åˆ›å»ºä¸€ä¸ªç»„ä»¶ï¼ˆ`erc20_web/src/components/App.tsx`ï¼‰ã€‚"

#: src/ch02-09-02-erc20-ui.md:284
msgid ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"
msgstr ""
"```typescript\n"
"'use client';\n"
"import { useState, useMemo } from \"react\"\n"
"import { connect, disconnect } from \"get-starknet\"\n"
"import { Contract, Provider, SequencerProvider, constants } from \"starknet\"\n"
"\n"
"const contractAddress = \"0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\"\n"
"\n"
"function App() {\n"
"  const [provider, setProvider] = useState({} as Provider)\n"
"  const [address, setAddress] = useState('')\n"
"  const [currentBlockHash, setCurrentBlockHash] = useState('')\n"
"  const [balance, setBalance] = useState('')\n"
"  const [isConnected, setIsConnected] = useState(false)\n"
"  const [recipient, setRecipient] = useState('0x');\n"
"  const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"  const disconnectWallet = async () => {\n"
"    try {\n"
"      await disconnect({ clearLastWallet: true })\n"
"      setProvider({} as Provider)\n"
"      setAddress('')\n"
"      setIsConnected(false)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const connectWallet = async () => {\n"
"    try {\n"
"      const starknet = await connect()\n"
"      if (!starknet) throw new Error(\"Failed to connect to wallet.\")\n"
"      await starknet.enable({ starknetVersion: \"v5\" })\n"
"      setProvider(starknet.account)\n"
"      setAddress(starknet.selectedAddress || '')\n"
"      setIsConnected(true)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const checkBalance = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      const data = await contract.balance_of(address)\n"
"      setBalance(data.toString())\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const transfer = async () => {\n"
"    try {\n"
"      // initialize contract using abi, address and provider\n"
"      const { abi: testAbi } = await provider.getClassAt(contractAddress);\n"
"      if (testAbi === undefined) { throw new Error(\"no abi.\") };\n"
"      const contract = new Contract(testAbi, contractAddress, provider)\n"
"      // make contract call\n"
"      await contract.transfer(recipient, amount)\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  const current_block_hash = async () => {\n"
"    try {\n"
"      const provider1 = new SequencerProvider({ baseUrl: constants.BaseUrl.SN_GOERLI });\n"
"\n"
"      const block = await provider1.getBlock(\"latest\"); // <- Get latest block\n"
"      setCurrentBlockHash(block.block_hash);\n"
"    }\n"
"    catch (error: any) {\n"
"      alert(error.message)\n"
"    }\n"
"  }\n"
"\n"
"  current_block_hash()\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!isConnected) return ''\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`\n"
"  }, [isConnected, address])\n"
"\n"
"  const handleRecipientChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"    setRecipient(event.target.value);\n"
"  };\n"
"\n"
"  const handleAmountChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n"
"      setAmount(event.target.value);\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Latest block hash: {currentBlockHash}</p>\n"
"      {isConnected ?\n"
"        <div>\n"
"          <span>Connected: {shortenedAddress}</span>\n"
"          <p><button onClick={()=> {disconnectWallet()}}>Disconnect</button></p>\n"
"          <hr />\n"
"          <p>Balance.</p>\n"
"          <p>{balance}</p>\n"
"          <p><button onClick={() => checkBalance()}>Check Balance</button></p>\n"
"          <hr />\n"
"          <p>Transfer.</p>\n"
"          <p>Recipient:\n"
"              <input\n"
"              type=\"text\"\n"
"              value={recipient}\n"
"              onChange={handleRecipientChange}\n"
"              />\n"
"          </p>\n"
"          <p>Amount (default 1 MKT with 18 decimals):\n"
"            <input\n"
"            type=\"number\"\n"
"            value={amount}\n"
"            onChange={handleAmountChange}\n"
"            />\n"
"          </p>\n"
"          <p>\n"
"            <button onClick={() => transfer()}>Transfer</button>\n"
"          </p>\n"
"          <hr/>\n"
"        </div> :\n"
"        <div>\n"
"          <span>Choose a wallet:</span>\n"
"          <p>\n"
"            <button onClick={() => connectWallet()}>Connect a Wallet</button>\n"
"          </p>\n"
"        </div>\n"
"      }\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default App;\n"
"```"

#: src/ch02-09-02-erc20-ui.md:429
msgid "Finally, launch the web3 application:"
msgstr "æœ€åï¼Œå¯åŠ¨ web3 åº”ç”¨ç¨‹åºï¼š"

#: src/ch02-09-02-erc20-ui.md:436
msgid "Congratulations, you have your starknetjs web3 application. Now connect your wallet in goerli testnet, check your balance and transfer MKT tokens to your friends:"
msgstr "æ­å–œæ‚¨ï¼Œæ‚¨å·²ç»æ‹¥æœ‰äº†è‡ªå·±çš„ starknetjs web3 åº”ç”¨ç¨‹åºã€‚ç°åœ¨åœ¨ goerli testnet ä¸­è¿æ¥æ‚¨çš„é’±åŒ…ï¼ŒæŸ¥çœ‹ä½™é¢å¹¶å°† MKT ä»£å¸è½¬ç»™æ‚¨çš„æœ‹å‹ï¼š"

#: src/ch02-09-02-erc20-ui.md:440 src/ch02-10-01-erc20-ui.md:410
#, fuzzy
msgid "Deploying Your Project Online"
msgstr "## åœ¨çº¿éƒ¨ç½²é¡¹ç›®"

#: src/ch02-09-02-erc20-ui.md:442 src/ch02-10-01-erc20-ui.md:412
msgid "To share your application with friends and allow them to check their balances and transfer tokens, publish your app online. Vercel offers a straightforward way to do this:"
msgstr "è¦ä¸æœ‹å‹åˆ†äº«æ‚¨çš„åº”ç”¨ç¨‹åºï¼Œå¹¶å…è®¸ä»–ä»¬æŸ¥çœ‹ä½™é¢å’Œè½¬ç§»ä»£å¸ï¼Œè¯·åœ¨çº¿å‘å¸ƒæ‚¨çš„åº”ç”¨ç¨‹åºã€‚Vercel æä¾›äº†ä¸€ç§ç®€å•æ˜“è¡Œçš„æ–¹æ³•ï¼š"

#: src/ch02-09-02-erc20-ui.md:444 src/ch02-10-01-erc20-ui.md:414
#, fuzzy
msgid "Set Up Vercel"
msgstr "### è®¾ç½® Vercel"

#: src/ch02-09-02-erc20-ui.md:446 src/ch02-10-01-erc20-ui.md:416
#, fuzzy
msgid "Register for an account at [Vercel Signup](https://vercel.com/signup)."
msgstr ""
"1.åœ¨ [Vercel Signup](https://vercel.com/signup) ä¸Šæ³¨å†Œè´¦æˆ·ã€‚\n"
"2.åœ¨ç½‘ç»œåº”ç”¨ç¨‹åºæ–‡ä»¶å¤¹ (`erc20_web`) ä¸­å®‰è£… Vercelï¼š"

#: src/ch02-09-02-erc20-ui.md:447 src/ch02-10-01-erc20-ui.md:417
#, fuzzy
msgid "Install Vercel in your web application folder (`erc20_web`):"
msgstr ""
"1.åœ¨ [Vercel Signup](https://vercel.com/signup) ä¸Šæ³¨å†Œè´¦æˆ·ã€‚\n"
"2.åœ¨ç½‘ç»œåº”ç”¨ç¨‹åºæ–‡ä»¶å¤¹ (`erc20_web`) ä¸­å®‰è£… Vercelï¼š"

#: src/ch02-09-02-erc20-ui.md:454 src/ch02-10-01-erc20-ui.md:425
#, fuzzy
msgid "Authenticate your Vercel account:"
msgstr "3.éªŒè¯æ‚¨çš„ Vercel è´¦æˆ·ï¼š"

#: src/ch02-09-02-erc20-ui.md:461 src/ch02-10-01-erc20-ui.md:431
msgid "After entering your email, check your inbox and click on the \"Verify\" button."
msgstr "è¾“å…¥ç”µå­é‚®ä»¶åï¼Œæ£€æŸ¥æ”¶ä»¶ç®±å¹¶ç‚¹å‡» \"Verify\"æŒ‰é’®ã€‚"

#: src/ch02-09-02-erc20-ui.md:467 src/ch02-10-01-erc20-ui.md:437
msgid "On successful verification, you'll receive a confirmation in the console."
msgstr "éªŒè¯æˆåŠŸåï¼Œæ‚¨å°†åœ¨æ§åˆ¶å°ä¸­æ”¶åˆ°ç¡®è®¤ä¿¡æ¯ã€‚"

#: src/ch02-09-02-erc20-ui.md:469 src/ch02-10-01-erc20-ui.md:439
#, fuzzy
msgid "Link your project to Vercel:"
msgstr "4.å°†æ‚¨çš„é¡¹ç›®é“¾æ¥åˆ° Vercelï¼š"

#: src/ch02-09-02-erc20-ui.md:482 src/ch02-10-01-erc20-ui.md:445
#, fuzzy
msgid "Upload it:"
msgstr "5.ä¸Šä¼ ï¼š"

#: src/ch02-09-02-erc20-ui.md:488 src/ch02-10-01-erc20-ui.md:451
#, fuzzy
msgid "Publish your project:"
msgstr "6.å‘å¸ƒæ‚¨çš„é¡¹ç›®ï¼š"

#: src/ch02-09-02-erc20-ui.md:495
msgid "Check your production URL and congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "æ£€æŸ¥æ‚¨çš„ç”Ÿäº§ URLï¼Œç„¶åæ­å–œæ‚¨ï¼ç°åœ¨æ‰€æœ‰äººéƒ½å¯ä»¥è®¿é—®æ‚¨çš„ MKT ä»£å¸çš„ web3 åº”ç”¨ç¨‹åºäº†ã€‚"

#: src/ch02-09-02-erc20-ui.md:499 src/ch02-10-01-erc20-ui.md:461
msgid "Engage with your app by:"
msgstr "é€šè¿‡ä»¥ä¸‹æ–¹å¼ä¸æ‚¨çš„åº”ç”¨ç¨‹åºäº¤äº’ï¼š"

#: src/ch02-09-02-erc20-ui.md:501 src/ch02-10-01-erc20-ui.md:463
#, fuzzy
msgid "Connecting your wallet:"
msgstr "- è¿æ¥æ‚¨çš„é’±åŒ…ï¼š"

#: src/ch02-09-02-erc20-ui.md:505 src/ch02-10-01-erc20-ui.md:467
#, fuzzy
msgid "Checking your balance:"
msgstr "- æŸ¥çœ‹ä½™é¢ï¼š"

#: src/ch02-09-02-erc20-ui.md:509 src/ch02-10-01-erc20-ui.md:471
#, fuzzy
msgid "Transferring tokens:"
msgstr "- è½¬è®©ä»£å¸ï¼š"

#: src/ch02-09-02-erc20-ui.md:513 src/ch02-10-01-erc20-ui.md:475
#, fuzzy
msgid "Wrapping Up"
msgstr "## æ€»ç»“"

#: src/ch02-09-02-erc20-ui.md:515
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React, StarknetJS and Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†å­¦ä¹ ä½¿ç”¨ Reactã€StarknetJS å’Œ Cairo åˆ¶ä½œ Web3 åº”ç”¨ç¨‹åºçš„æ­¥éª¤ã€‚è¿™ä¸ªåº”ç”¨ç¨‹åºåŒ…å«ä¸€ä¸ª ERC20 æ™ºèƒ½åˆçº¦ï¼Œä¸ºç”¨æˆ·äº¤äº’æä¾›äº†ä¸€ä¸ªç°ä»£åŒ–çš„ Web ç•Œé¢ã€‚ä¸‹é¢æ˜¯æ‚¨çš„æˆæœå¿«ç…§ï¼š"

#: src/ch02-09-02-erc20-ui.md:517 src/ch02-10-01-erc20-ui.md:479
msgid "**Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries."
msgstr ""

#: src/ch02-09-02-erc20-ui.md:519 src/ch02-10-01-erc20-ui.md:480
msgid ""
"**Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
"network."
msgstr ""

#: src/ch02-09-02-erc20-ui.md:521
msgid "**React Application**: Built a React application powered by StarknetJS, featuring components dedicated to balance inquiries and token transactions."
msgstr ""

#: src/ch02-09-02-erc20-ui.md:523 src/ch02-10-01-erc20-ui.md:486
msgid ""
"**Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token transactions."
msgstr ""

#: src/ch02-09-02-erc20-ui.md:525 src/ch02-10-01-erc20-ui.md:488
msgid ""
"The insights you've gathered from this tutorial lay a solid groundwork for creating intricate web3 applications. You're now equipped with the prowess to craft more intricate decentralized applications "
"and smart contracts. The vast expanse of decentralized finance and blockchain is ripe for your innovative inputs. Dive in and happy coding!"
msgstr ""
"é€šè¿‡æœ¬æ•™ç¨‹çš„å­¦ä¹ ï¼Œæ‚¨å°†ä¸ºåˆ›å»ºå¤æ‚çš„ Web3 åº”ç”¨ç¨‹åºæ‰“ä¸‹åšå®çš„åŸºç¡€ã€‚ç°åœ¨ï¼Œæ‚¨å·²ç»å…·å¤‡äº†åˆ¶ä½œæ›´å¤æ‚çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºå’Œæ™ºèƒ½åˆçº¦çš„èƒ½åŠ›ã€‚å»ä¸­å¿ƒåŒ–é‡‘èå’ŒåŒºå—é“¾çš„å¹¿é˜”å¤©åœ°æ­£ç­‰ç€ä½ çš„åˆ›æ–°æŠ•å…¥ã€‚æŠ•å…¥å…¶ä¸­ï¼Œå¿«ä¹ç¼–ç ï¼"

#: src/ch02-10-starknet-react.md:3
msgid "In the starknet ecosystem, several tools are available for front-end development. The most notable are:"
msgstr ""

#: src/ch02-10-starknet-react.md:5
#, fuzzy
msgid ""
"[starknet-react](https://github.com/apibara/starknet-react) ([documentation](https://starknet-react.com/docs/getting-started)): A collection of React hooks tailored for Starknet, inspired by [wagmi]"
"(https://github.com/tmm/wagmi) and powered by [starknet.js](https://github.com/0xs34n/starknet.js)."
msgstr ""
"- [starknet-react](https://github.com/apibara/starknet-react)\n"
"  ([æ–‡æ¡£](https://apibara.github.io/starknet-react))ï¼š\n"
"  ç”¨äº Starknet çš„ React é’©å­é›†ã€‚å…¶çµæ„Ÿæ¥æºäº\n"
"  [wagmi](https://github.com/tmm/wagmi)ï¼Œç”±\n"
"  [starknet.js](https://github.com/0xs34n/starknet.js) å¼€å‘.\n"
"\n"
"- [starknet.js](https://github.com/0xs34n/starknet.js)ï¼šä¸€ä¸ª JavaScriptåº“ã€‚\n"
"  å®ƒç›¸å½“äºä»¥å¤ªåŠçš„ [web3.js](https://web3js.org/)ã€‚"

#: src/ch02-10-starknet-react.md:7
msgid "[starknet.js](https://github.com/0xs34n/starknet.js): This JavaScript library facilitates interactions with Starknet contracts, akin to [web3.js](https://web3js.org/) for Ethereum."
msgstr ""

#: src/ch02-10-starknet-react.md:9
#, fuzzy
msgid ""
"Developed by the [Apibara](https://github.com/apibara/) team, [Starknet React](https://github.com/apibara/starknet-react/) is an open-source suite of React providers and hooks specifically for "
"Starknet."
msgstr ""
"ç”±[Apibara](https://github.com/apibara/)å›¢é˜Ÿç¼–å†™çš„[Starknet React](https://github.com/apibara/starknet-react/)æ˜¯ä¸€ä¸ªå¼€æºçš„\n"
"ï¼Œä¸ºStarknetè®¾è®¡çš„çš„React providerå’Œé’©å­çš„é›†åˆã€‚"

#: src/ch02-10-starknet-react.md:11
#, fuzzy
msgid "Integrating Starknet React"
msgstr "## ä¸Starknet React é›†æˆ"

#: src/ch02-10-starknet-react.md:13
msgid "The fastest way to get started using Starknet React is by using the `create-starknet` Command Line Interface (CLI). The tool will guide you through setting up your Starknet application:"
msgstr ""

#: src/ch02-10-starknet-react.md:19
msgid "Or, if you want to do it manually you will need to add the following dependencies to your project:"
msgstr ""

#: src/ch02-10-starknet-react.md:25
#, fuzzy
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is an SDK designed to simplify interactions with Starknet. Conversely, [get-starknet](https://github.com/starknet-io/get-starknet/) specializes in wallet "
"connection management."
msgstr ""
"[Starknet.js](https://www.starknetjs.com/)æ˜¯ä¸€ä¸ª\n"
"ç”¨äºä¸ Starknet äº¤äº’çš„é‡è¦ SDKã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ[get-starknet]()\n"
"[get-starknet](https://github.com/starknet-io/get-starknet/)æ˜¯ä¸€ä¸ª\n"
"æ˜¯ä¸€ä¸ªæ“…é•¿ç®¡ç†é’±åŒ…è¿æ¥çš„è½¯ä»¶åŒ…ã€‚"

#: src/ch02-10-starknet-react.md:27
msgid "Wrap your app in the `StarknetConfig` component to configure and provide a React Context. This component lets you specify wallet connection options for users through its connectors prop."
msgstr ""

#: src/ch02-10-starknet-react.md:34
msgid "// Show these connectors if the user has no connector installed.\n"
msgstr ""

#: src/ch02-10-starknet-react.md:36
msgid "// Hide recommended connectors if the user has any connector installed.\n"
msgstr ""

#: src/ch02-10-starknet-react.md:37
msgid "\"onlyIfNoConnectors\""
msgstr ""

#: src/ch02-10-starknet-react.md:38
msgid "// Randomize the order of the connectors.\n"
msgstr ""

#: src/ch02-10-starknet-react.md:39
msgid "\"random\""
msgstr ""

#: src/ch02-10-starknet-react.md:45
msgid ""
"/StarknetConfig>\n"
"  );\n"
"}\n"
msgstr ""

#: src/ch02-10-starknet-react.md:50
#, fuzzy
msgid "Establishing Connection and Managing Account"
msgstr "## å»ºç«‹è¿æ¥å’Œç®¡ç†è´¦æˆ·"

#: src/ch02-10-starknet-react.md:52
#, fuzzy
msgid "After defining the connectors in the `config`, you can use a hook to access them. This enables users to connect their wallets."
msgstr ""
"ä¸€æ—¦åœ¨é…ç½®ä¸­å®šä¹‰äº†è¿æ¥å™¨ï¼Œåº”ç”¨å°±ä¼šè¢«è®¾ç½®ä¸ºä½¿ç”¨\n"
"é’©å­æ¥è®¿é—®è¿™äº›è¿æ¥å™¨ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿè¿æ¥ä»–ä»¬çš„\n"
"é’±åŒ…ï¼š"

#: src/ch02-10-starknet-react.md:63
msgid ""
"/button>\n"
"        </"
msgstr ""

#: src/ch02-10-starknet-react.md:66
msgid ""
"/ul>\n"
"  );\n"
"}\n"
msgstr ""

#: src/ch02-10-starknet-react.md:71
msgid "Now, observe the `disconnect` function that terminates the connection when invoked:"
msgstr ""

#: src/ch02-10-starknet-react.md:79
msgid "Once connected, the `useAccount` hook provides access to the connected account, giving insights into the connection's current state."
msgstr ""

#: src/ch02-10-starknet-react.md:84
msgid "/p> : <Connect /"
msgstr ""

#: src/ch02-10-starknet-react.md:84 src/ch02-10-starknet-react.md:314
msgid "/div>;\n"
msgstr ""

#: src/ch02-10-starknet-react.md:87
#, fuzzy
msgid ""
"State values like `isConnected` and `isReconnecting` update automatically, easing UI updates. This is particularly useful for asynchronous processes, removing the need for manual state management in "
"your components."
msgstr ""
"`isConnected`å’Œ `isReconnecting`ç­‰çŠ¶æ€å€¼ä¼šè‡ªåŠ¨æ›´æ–°ï¼Œ\n"
"ä»è€Œç®€åŒ–äº†ç”¨æˆ·ç•Œé¢çš„æ¡ä»¶æ›´æ–°ã€‚è¿™ç§æ–¹ä¾¿çš„\n"
"æ¨¡å¼åœ¨å¤„ç†å¼‚æ­¥è¿›ç¨‹æ—¶å¤§æ˜¾èº«æ‰‹ï¼Œå› ä¸ºå®ƒ\n"
"æ— éœ€åœ¨ç»„ä»¶ä¸­æ‰‹åŠ¨ç®¡ç†çŠ¶æ€ã€‚"

#: src/ch02-10-starknet-react.md:89
#, fuzzy
msgid "Once connected, signing messages is easy with the account value from the `useAccount` hook. For a smoother experience, you can also use the `useSignTypedData` hook."
msgstr ""
"å»ºç«‹è¿æ¥åï¼Œä½¿ç”¨`useAccount`é’©å­è¿”å›çš„è´¦æˆ·å€¼ç­¾ç½²ä¿¡æ¯å°±å˜å¾—è½»è€Œæ˜“ä¸¾äº†ã€‚\n"
"è¦è·å¾—æ›´é¡ºæ»‘çš„ä½“éªŒï¼Œè¯·ä½¿ç”¨`useSignTypedData` é’©å­ã€‚"

#: src/ch02-10-starknet-react.md:100
msgid ""
"/button>\n"
"    );\n"
msgstr ""

#: src/ch02-10-starknet-react.md:104
#, fuzzy
msgid ""
"Starknet React supports signing an array of `BigNumberish` values or an object. When signing an object, ensure the data adheres to the EIP712 type. For detailed guidance on signing, see the Starknet."
"js documentation: [here](https://www.starknetjs.com/docs/guides/signature/)."
msgstr ""
"Starknet React æ”¯æŒç­¾ç½²ä¸€ä¸ª`BigNumberish`å€¼æ•°ç»„æˆ–ä¸€ä¸ªå¯¹è±¡ã€‚\n"
"ç­¾ç½²å¯¹è±¡æ—¶ï¼Œå¿…é¡»ç¡®ä¿æ•°æ®ç¬¦åˆ EIP712 ç±»å‹ã€‚\n"
"æœ‰å…³ç­¾åçš„æ›´å…¨é¢æŒ‡å—ï¼Œè¯·å‚é˜… Starknet.js æ–‡æ¡£ï¼š\n"
"[æ­¤å¤„](https://www.starknetjs.com/docs/guides/signature/)."

#: src/ch02-10-starknet-react.md:106
#, fuzzy
msgid "Displaying StarkName"
msgstr "## æ˜¾ç¤ºStarkName"

#: src/ch02-10-starknet-react.md:108
#, fuzzy
msgid ""
"Once an account is connected, the `useStarkName` hook retrieves the `StarkName` of the account. Linked to [Starknet.id](https://www.starknet.id/), it allows for displaying the user address in a user-"
"friendly manner."
msgstr ""
"è¿æ¥è´¦æˆ·åï¼Œå¯ä½¿ç”¨ `useStarkName` é’©å­æ¥è·å–å·²è¿æ¥è´¦æˆ·çš„ StarkNameã€‚\n"
"StarkNameä¸[Starknet.id](https://www.starknet.id/)æœ‰å…³ï¼Œå®ƒå…è®¸ä»¥æ›´æ–¹ä¾¿ç”¨æˆ·çš„æ–¹å¼æ˜¾ç¤ºç”¨æˆ·åœ°å€ã€‚"

#: src/ch02-10-starknet-react.md:114
msgid ""
"/span>;\n"
"    if (isError)\n"
"        return <span>Error fetching name...</"
msgstr ""

#: src/ch02-10-starknet-react.md:118 src/ch02-10-starknet-react.md:137 src/ch02-10-starknet-react.md:158
msgid "/span>;\n"
msgstr ""

#: src/ch02-10-starknet-react.md:121
msgid ""
"This hook provides additional information: **error**, **status**, **fetchStatus**, **isSuccess**, **isError**, **isPending**, **isFetching**, **isLoading**. These details offer precise insights into "
"the current process."
msgstr ""

#: src/ch02-10-starknet-react.md:123
#, fuzzy
msgid "Fetching Address from `StarkName`"
msgstr "## ä» StarkName è·å–åœ°å€"

#: src/ch02-10-starknet-react.md:125
#, fuzzy
msgid "To retrieve an `address` from a `StarkName`, use the `useAddressFromStarkName` hook."
msgstr ""
"æ‚¨å¯èƒ½è¿˜æƒ³è·å–ä¸ StarkName ç›¸å¯¹åº”çš„åœ°å€ã€‚\n"
"ä¸ºæ­¤ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `useAddressFromStarkName` é’©å­ã€‚"

#: src/ch02-10-starknet-react.md:129
msgid "\"vitalik.stark\""
msgstr ""

#: src/ch02-10-starknet-react.md:133
msgid ""
"/span>;\n"
"    if (isError)\n"
"        return <span>Error fetching address...</"
msgstr ""

#: src/ch02-10-starknet-react.md:140
#, fuzzy
msgid "If the provided name does not have an associated address, it will return `0x0`"
msgstr "å¦‚æœæ‰€æä¾›çš„åç§°æ²¡æœ‰ç›¸å…³åœ°å€ï¼Œå®ƒå°†è¿”å›**\"0x0\"**"

#: src/ch02-10-starknet-react.md:143
#, fuzzy
msgid "Navigating the Network"
msgstr "## ç½‘ç»œå¯¼èˆª"

#: src/ch02-10-starknet-react.md:145
#, fuzzy
msgid "Starknet React provides developers with tools for network interactions, including hooks like useBlock for retrieving the latest block:"
msgstr ""
"é™¤äº†é’±åŒ…å’Œè´¦æˆ·ç®¡ç†ï¼ŒStarknet React è¿˜ä¸ºå¼€å‘äººå‘˜æä¾›äº†ç½‘ç»œäº¤äº’é’©å­ã€‚\n"
"ä¾‹å¦‚ï¼Œ`useBlock` å¯ä»¥æ£€ç´¢æœ€æ–°çš„åŒºå—ï¼š"

#: src/ch02-10-starknet-react.md:150
msgid "\"latest\""
msgstr ""

#: src/ch02-10-starknet-react.md:154
msgid ""
"/span>;\n"
"        if (isError || !data)\n"
"            return <span>Error...</"
msgstr ""

#: src/ch02-10-starknet-react.md:161
#, fuzzy
msgid ""
"Here, `refetchInterval` sets the data refresh rate. Starknet React uses [react-query](https://github.com/TanStack/query/) for state and query management. Other hooks like `useContractRead` and "
"`useWaitForTransaction` are also available for interval-based updates."
msgstr ""
"åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼ŒrefetchInterval æ§åˆ¶æ•°æ®é‡å–çš„é¢‘ç‡ã€‚\n"
"åœ¨å¹•åï¼ŒStarknet React åˆ©ç”¨[react-query](https://github.com/TanStack/query/)æ¥ç®¡ç†çŠ¶æ€å’ŒæŸ¥è¯¢ã€‚\n"
"é™¤äº† `useBlock`ï¼ŒStarknet React è¿˜æä¾›äº†å…¶ä»–é’©å­ï¼Œå¦‚\n"
"`useContractRead` å’Œ `useWaitForTransaction` ç­‰é’©å­ï¼Œè¿™äº›é’©å­å¯é…ç½®ä¸ºå®šæœŸæ›´æ–°ã€‚"

#: src/ch02-10-starknet-react.md:163
#, fuzzy
msgid "The useStarknet hook gives direct access to the ProviderInterface:"
msgstr "`useStarknet` é’©å­å¯ç›´æ¥è®¿é—® `ProviderInterface`ï¼š"

#: src/ch02-10-starknet-react.md:168
#, fuzzy
msgid ""
"// library.getClassByHash(...)\n"
"    // library.getTransaction(...)\n"
msgstr ""
"const { library } = useStarknet();\n"
"\n"
"    // library.getClassByHash(...)\n"
"    // library.getTransaction(...)"

#: src/ch02-10-starknet-react.md:172
#, fuzzy
msgid "Tracking Wallet changes"
msgstr "## è·Ÿè¸ªé’±åŒ…å˜åŒ–"

#: src/ch02-10-starknet-react.md:174
msgid ""
"For a better dApp user experience, tracking wallet changes is crucial. This includes account changes, connections, disconnections, and network switches. Reload balances on account changes, or reset "
"your dApp's state on network changes. Use `useAccount` and `useNetwork` for this."
msgstr ""

#: src/ch02-10-starknet-react.md:176
#, fuzzy
msgid "`useNetwork` provides the current network chain:"
msgstr "`useNetwork` é’©å­å¯æä¾›å½“å‰ä½¿ç”¨çš„é“¾çš„ä¿¡æ¯ã€‚"

#: src/ch02-10-starknet-react.md:183
msgid ""
"/p>\n"
"            <p>Connected chain id: {id}</"
msgstr ""

#: src/ch02-10-starknet-react.md:185
msgid ""
"/>\n"
"    )\n"
msgstr ""

#: src/ch02-10-starknet-react.md:189
msgid "This hook also offers **blockExplorer**, **testnet** for detailed network information."
msgstr ""

#: src/ch02-10-starknet-react.md:191
msgid "Monitor user interactions with account and network using the `useEffect` hook:"
msgstr ""

#: src/ch02-10-starknet-react.md:199
msgid ""
"// Do some work when the user changes the account on the wallet\n"
"            // Like reloading the balances\n"
msgstr ""

#: src/ch02-10-starknet-react.md:202
msgid ""
"// Do some work when the user disconnects the wallet\n"
"            // Like reseting the state of your dApp\n"
msgstr ""

#: src/ch02-10-starknet-react.md:208
msgid ""
"// Do some work when the user changes the network on the wallet\n"
"        // Like reseting the state of your dApp\n"
msgstr ""

#: src/ch02-10-starknet-react.md:213
#, fuzzy
msgid "Contract Interactions"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch02-10-starknet-react.md:215
#, fuzzy
msgid "Read Functions"
msgstr "### è¯»å–å‡½æ•°"

#: src/ch02-10-starknet-react.md:217
#, fuzzy
msgid "Starknet React introduces `useContractRead`, similar to wagmi, for read operations on contracts. These operations are independent of the user's connection status and don't require a signer."
msgstr ""
"Starknet React æä¾›äº† useContractReadï¼Œè¿™æ˜¯ä¸€ä¸ªä¸“é—¨çš„é’©å­ï¼Œç”¨äºè°ƒç”¨\n"
"è¯»å–åˆçº¦å‡½æ•°çš„ä¸“é—¨é’©å­ï¼Œç±»ä¼¼äº wagmiã€‚\n"
"è¯¥é’©å­çš„åŠŸèƒ½ä¸ç”¨æˆ·çš„è¿æ¥çŠ¶æ€æ— å…³ï¼Œå› ä¸ºè¯»å–æ“ä½œå¹¶ä¸éœ€è¦ç­¾åè€…ã€‚"

#: src/ch02-10-starknet-react.md:221
msgid "\"balanceOf\""
msgstr ""

#: src/ch02-10-starknet-react.md:229
msgid ""
"/div>;\n"
"    if (isError || !data)\n"
"        return <div>{error?.message}</"
msgstr ""

#: src/ch02-10-starknet-react.md:236
msgid "For ERC20 operations, the `useBalance` hook simplifies retrieving balances without needing an ABI."
msgstr ""

#: src/ch02-10-starknet-react.md:244 src/ch02-10-starknet-react.md:311
msgid ""
"/div>;\n"
"if (isError || !data) return <div>{error?.message}</"
msgstr ""

#: src/ch02-10-starknet-react.md:251
msgid ""
"/div>\n"
");\n"
msgstr ""

#: src/ch02-10-starknet-react.md:255
#, fuzzy
msgid "Write Functions"
msgstr "### å†™å…¥å‡½æ•°"

#: src/ch02-10-starknet-react.md:257
msgid ""
"The `useContractWrite` hook, unlike wagmi, benefits from Starknet's native support for multicall transactions. This improves user experience by facilitating multiple transactions without individual "
"approvals."
msgstr ""

#: src/ch02-10-starknet-react.md:262
msgid ""
"// return a single object for single transaction,\n"
"      // or an array of objects for multicall**\n"
msgstr ""

#: src/ch02-10-starknet-react.md:264 src/ch04-05-06-web-wallet.md:55
msgid "\"transfer\""
msgstr ""

#: src/ch02-10-starknet-react.md:278
msgid ""
"/p>\n"
"        <p>hash: {data?.transaction_hash}</"
msgstr ""

#: src/ch02-10-starknet-react.md:284
msgid "This setup starts with the `populateTransaction` utility, followed by executing the transaction through `writeAsync`. The hook also provides transaction status and hash."
msgstr ""

#: src/ch02-10-starknet-react.md:286
#, fuzzy
msgid "A Single Contract Instance"
msgstr "### å•åˆçº¦å®ä¾‹"

#: src/ch02-10-starknet-react.md:288
#, fuzzy
msgid "For cases where a single contract instance is more than apecifying the contract address and ABI in each hook., use the `useContract` hook:"
msgstr ""
"åœ¨æŸäº›ç”¨ä¾‹ä¸­ï¼Œä½¿ç”¨å•ä¸ªåˆçº¦å®ä¾‹å¯èƒ½æ¯”åœ¨æ¯ä¸ªé’©å­ä¸­æŒ‡å®šåˆçº¦åœ°å€å’Œ ABIæ›´å¯å–ã€‚\n"
"Starknet React ä½¿ç”¨ `useContract` é’©å­æ»¡è¶³äº†è¿™ä¸€è¦æ±‚ï¼š"

#: src/ch02-10-starknet-react.md:295
#, fuzzy
msgid ""
"// Call functions directly on contract\n"
"// contract.transfer(...);\n"
"// contract.balanceOf(...);\n"
msgstr ""
"const { contract } = useContract({\n"
"        address: CONTRACT_ADDRESS,\n"
"        abi: abi_erc20,\n"
"    });\n"
"\n"
"    // Call functions directly on contract\n"
"    // contract.transfer(...);\n"
"    // contract.balanceOf(...);"

#: src/ch02-10-starknet-react.md:301
#, fuzzy
msgid "Tracking Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch02-10-starknet-react.md:303
msgid "`UseWaitForTransaction` tracks transaction states with a transaction hash, reducing network requests through caching."
msgstr ""

#: src/ch02-10-starknet-react.md:317
#, fuzzy
msgid "Explore all available hooks in Starknet React's documentation: <https://starknet-react.com/hooks/>."
msgstr ""
"æ‰€æœ‰å¯ç”¨é’©å­çš„åˆ—è¡¨ï¼Œå¯åœ¨ Starknet React æ–‡æ¡£é‡ŒæŸ¥é˜…ï¼š\n"
"<https://apibara.github.io/starknet-react/>ã€‚"

#: src/ch02-10-starknet-react.md:321
#, fuzzy
msgid ""
"The Starknet React library provides a range of React hooks and providers specifically designed for Starknet and the Starknet.js SDK. These tools enable developers to create applications on the "
"Starknet network."
msgstr ""
"Starknet React åº“æä¾›äº†ä¸€æ•´å¥— React é’©å­å’Œproviderï¼Œä¸“ä¸º Starknet å’Œ Starknet.js SDK è€Œè®¾è®¡ã€‚\n"
"é€šè¿‡è¿™äº›ç²¾å¿ƒè®¾è®¡çš„å·¥å…·ï¼Œå¼€å‘äººå‘˜å¯ä»¥æ„å»ºå»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºæ¥é©¾é©­Starknetç½‘ç»œçš„å¼ºå¤§åŠŸèƒ½ã€‚"

#: src/ch02-10-01-erc20-ui.md:3
msgid "This guide offers steps to build an ERC20 smart contract using Cairo and to incorporate it within a React web application with Starknet React. Readers will:"
msgstr "æœ¬æŒ‡å—æä¾›äº†ä½¿ç”¨ Cairo æ„å»º ERC20 æ™ºèƒ½åˆçº¦çš„æ­¥éª¤ï¼Œå¹¶å°†å…¶çº³å…¥ä½¿ç”¨ Starknet React çš„ React Web åº”ç”¨ç¨‹åºä¸­ã€‚è¯»è€…å°†ï¼š"

#: src/ch02-10-01-erc20-ui.md:10
msgid "A prerequisite for this guide is a foundational understanding of both the Cairo programming language and ReactJS. Additionally, ensure Node.js and NPM are installed on the system."
msgstr "æœ¬æŒ‡å—çš„å‰ææ¡ä»¶æ˜¯å¯¹ Cairo ç¼–ç¨‹è¯­è¨€å’Œ ReactJS æœ‰åŸºæœ¬çš„äº†è§£ã€‚æ­¤å¤–ï¼Œç¡®ä¿ç³»ç»Ÿä¸Šå·²å®‰è£… Node.js å’Œ NPMã€‚"

#: src/ch02-10-01-erc20-ui.md:21
msgid "Starknet React v2.1.1"
msgstr ""

#: src/ch02-10-01-erc20-ui.md:23
msgid "Next.js 13.1.6"
msgstr ""

#: src/ch02-10-01-erc20-ui.md:39
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.0-beta.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-10-01-erc20-ui.md:112
msgid "Subsequent to the compilation, declare the smart contract on the Starknet testnet:"
msgstr "ç¼–è¯‘å®Œæˆåï¼Œåœ¨Starknetæµ‹è¯•ç½‘ä¸Šå£°æ˜æ™ºèƒ½åˆçº¦ï¼š"

#: src/ch02-10-01-erc20-ui.md:139
msgid "`Receiver address`: Use a preferred address. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""

#: src/ch02-10-01-erc20-ui.md:157
#, fuzzy
msgid "Installing the Starknet React Library"
msgstr "## å®‰è£… Starknet React åº“"

#: src/ch02-10-01-erc20-ui.md:159
#, fuzzy
msgid "With the contract in place, initiate the development of the web application. Begin by incorporating the Starknet React library and setting up a new React Project called 'erc20':"
msgstr "åˆçº¦éƒ¨ç½²å®Œæˆåï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹å¼€å‘ç½‘ç»œåº”ç”¨ç¨‹åºäº†ã€‚é¦–å…ˆå¯¼å…¥ Starknet React åº“ï¼š"

#: src/ch02-10-01-erc20-ui.md:177
msgid "Post-installation, confirm the version of the Starknet React library:"
msgstr "å®‰è£…åï¼Œç¡®è®¤ Starknet React åº“çš„ç‰ˆæœ¬ï¼š"

#: src/ch02-10-01-erc20-ui.md:183
#, fuzzy
msgid "The output should display the installed version, such as `@starknet-react/core@2.1.1`."
msgstr "è¾“å‡ºç»“æœåº”æ˜¾ç¤ºå·²å®‰è£…çš„ç‰ˆæœ¬ï¼Œå¦‚ `@starknet-react/core@1.0.4`ã€‚"

#: src/ch02-10-01-erc20-ui.md:185
#, fuzzy
msgid "Once set up, make modifications to `erc20_web/page.tsx` by replacing its content with the following code:"
msgstr "è®¾ç½®å®Œæˆåï¼Œç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢ `erc20_web/index.tsx` ä¸­çš„å†…å®¹ï¼Œå¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼š"

#: src/ch02-10-01-erc20-ui.md:187
#, fuzzy
msgid ""
"```typescript\n"
"'use client';\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from \"@/components/WalletBar\";\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from '../components/WalletBar'\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" />\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"

#: src/ch02-10-01-erc20-ui.md:225
msgid "To launch the web3 application:"
msgstr "å¯åŠ¨ web3 åº”ç”¨ç¨‹åºï¼š"

#: src/ch02-10-01-erc20-ui.md:232
msgid "NOTE: Observe the server port that appears during launch. This will be useful for subsequent testing."
msgstr "æ³¨æ„ï¼šè§‚å¯Ÿå¯åŠ¨è¿‡ç¨‹ä¸­å‡ºç°çš„æœåŠ¡å™¨ç«¯å£ã€‚è¿™å°†æœ‰åŠ©äºåç»­æµ‹è¯•ã€‚"

#: src/ch02-10-01-erc20-ui.md:236
msgid "To enhance the app's functionality, create two components for balance and transfer. Subsequently, update the `Wallet.tsx` file to incorporate the new features:"
msgstr "ä¸ºå¢å¼ºåº”ç”¨ç¨‹åºçš„åŠŸèƒ½ï¼Œåˆ›å»ºä½™é¢å’Œè½¬è´¦ä¸¤ä¸ªç»„ä»¶ã€‚éšåï¼Œæ›´æ–° `Wallet.tsx` æ–‡ä»¶ä»¥çº³å…¥æ–°åŠŸèƒ½ï¼š"

#: src/ch02-10-01-erc20-ui.md:240
#, fuzzy
msgid "Balance Component"
msgstr "### ä½™é¢ç»„ä»¶"

#: src/ch02-10-01-erc20-ui.md:242
msgid "Design a balance component inside `components/Balance.tsx` and integrate the following code:"
msgstr "åœ¨ `components/Balance.tsx` ä¸­è®¾è®¡ä¸€ä¸ªä½™é¢ç»„ä»¶ï¼Œå¹¶æ•´åˆä»¥ä¸‹ä»£ç ï¼š"

#: src/ch02-10-01-erc20-ui.md:244
#, fuzzy
msgid ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../../assets/erc20.json';\n"
"import { MouseEventHandler } from \"react\";\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address || ''], // Provide a default value if address is undefined\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  const handleClick: MouseEventHandler<HTMLButtonElement> = async (event) => {\n"
"    event.preventDefault();\n"
"    await refetch();\n"
"  };\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={handleClick}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../assets/erc20.json';\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address],\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={refetch}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default Balance;\n"
"```"

#: src/ch02-10-01-erc20-ui.md:280
msgid "NOTE: Replace the address with the address of your deployed contract."
msgstr "æ³¨æ„ï¼šè¯·å°†åœ°å€æ›¿æ¢ä¸ºå·²éƒ¨ç½²åˆçº¦çš„åœ°å€ã€‚"

#: src/ch02-10-01-erc20-ui.md:282
#, fuzzy
msgid "Transfer Component"
msgstr "### è½¬è´¦ç»„ä»¶"

#: src/ch02-10-01-erc20-ui.md:284
msgid "Craft a transfer component in `components/Transfer.tsx` and embed the subsequent code:"
msgstr "åœ¨ `components/Transfer.tsx` ä¸­åˆ¶ä½œä¸€ä¸ªè½¬è´¦ç»„ä»¶ï¼Œå¹¶åµŒå…¥åç»­ä»£ç ï¼š"

#: src/ch02-10-01-erc20-ui.md:286
msgid ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"\n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: '0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"\n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e.target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"

#: src/ch02-10-01-erc20-ui.md:327
msgid "NOTE: Replace contractAddress with the address of your deployed contract."
msgstr "æ³¨æ„ï¼šå°† contractAddress æ›¿æ¢ä¸ºå·²éƒ¨ç½²åˆçº¦çš„åœ°å€ã€‚"

#: src/ch02-10-01-erc20-ui.md:329
#, fuzzy
msgid "Updating the Wallet Component"
msgstr "### æ›´æ–°é’±åŒ…ç»„ä»¶"

#: src/ch02-10-01-erc20-ui.md:331
msgid "Proceed to modify the `components/Wallet.tsx` file. Replace any existing content with the following enhanced code:"
msgstr "ç»§ç»­ä¿®æ”¹ `components/Wallet.tsx` æ–‡ä»¶ã€‚ç”¨ä»¥ä¸‹æ–°ä»£ç æ›¿æ¢ä»»ä½•ç°æœ‰å†…å®¹ï¼š"

#: src/ch02-10-01-erc20-ui.md:333
#, fuzzy
msgid ""
"```typescript\n"
"\"use client\";\n"
"import { useAccount, useConnect, useDisconnect } from \"@starknet-react/core\";\n"
"import { useMemo } from \"react\";\n"
"import { Button } from \"./ui/Button\";\n"
"import Balance from './Balance'\n"
"import Transfer from './Transfer'\n"
"\n"
"function WalletConnected() {\n"
"  const { address } = useAccount();\n"
"  const { disconnect } = useDisconnect();\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Connected: {shortenedAddress}</span>\n"
"      <p><button onClick={() => disconnect()}>Disconnect</button></p>\n"
"      <hr/>\n"
"      <Balance />\n"
"      <Transfer />\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnect();\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Choose a wallet: </span>\n"
"      <p>\n"
"      {connectors.map((connector) => {\n"
"        return (\n"
"          <Button\n"
"            key={connector.id}\n"
"            onClick={() => connect({ connector })}\n"
"          >\n"
"            {connector.id}\n"
"          </Button>\n"
"        );\n"
"      })}\n"
"      </p>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar() {\n"
"  const { address } = useAccount();\n"
"\n"
"  return address ? <WalletConnected /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"import { useAccount, useConnectors } from '@starknet-react/core'\n"
"import { useMemo } from 'react'\n"
"import Balance from '../components/Balance'\n"
"import Transfer from '../components/Transfer'\n"
"\n"
"function WalletConnected() {\n"
"  const { address } = useAccount();\n"
"  const { disconnect } = useConnectors();\n"
"\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return '';\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Connected: {shortenedAddress}</span>\n"
"      <p><button onClick={disconnect}>Disconnect</button></p>\n"
"      <hr/>\n"
"      <Balance />\n"
"      <Transfer />\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"\n"
"  return (\n"
"    <div>\n"
"      <span>Select a wallet:</span>\n"
"      <p>\n"
"      {connectors.map((connector) => (\n"
"        <button key={connector.id} onClick={() => connect(connector)}>\n"
"          {connector.id}\n"
"        </button>\n"
"      ))}\n"
"      </p>\n"
"    </div>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar() {\n"
"  const { address } = useAccount();\n"
"\n"
"  return address ? <WalletConnected /> : <ConnectWallet />;\n"
"}\n"
"```"

#: src/ch02-10-01-erc20-ui.md:390
msgid "This updated code refines the Wallet component to offer a more interactive experience for users intending to connect or manage their wallets."
msgstr "æ›´æ–°åçš„ä»£ç å®Œå–„äº†é’±åŒ…ç»„ä»¶ï¼Œä¸ºæ‰“ç®—è¿æ¥æˆ–ç®¡ç†é’±åŒ…çš„ç”¨æˆ·æä¾›äº†äº¤äº’æ€§æ›´å¼ºçš„ä½“éªŒã€‚"

#: src/ch02-10-01-erc20-ui.md:392
#, fuzzy
msgid "Finalizing the MKT Token Application"
msgstr "## å®Œæˆ MKT ä»£å¸åº”ç”¨"

#: src/ch02-10-01-erc20-ui.md:394
msgid "To finalize the application setup, we need the ABI file for the MKT token. Follow the steps below to generate and integrate it:"
msgstr "è¦å®Œæˆåº”ç”¨ç¨‹åºè®¾ç½®ï¼Œæˆ‘ä»¬éœ€è¦ MKT ä»£å¸çš„ ABI æ–‡ä»¶ã€‚è¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤ç”Ÿæˆå¹¶é›†æˆè¯¥æ–‡ä»¶ï¼š"

#: src/ch02-10-01-erc20-ui.md:396
msgid "At the root of your project, create a new directory named `assets/`."
msgstr ""

#: src/ch02-10-01-erc20-ui.md:397
#, fuzzy
msgid "Inside the `assets/` directory, create an empty JSON file named `erc20.json`."
msgstr "åœ¨ `src/` ç›®å½•ä¸­ï¼Œåˆ›å»ºåŒ…å«ä»¥ä¸‹å†…å®¹çš„ `.env` æ–‡ä»¶ï¼š"

#: src/ch02-10-01-erc20-ui.md:398
msgid "Go back to your ERC20 Cairo project folder and locate the `erc20/target/erc20_erc20_sierra.json` file."
msgstr ""

#: src/ch02-10-01-erc20-ui.md:402
#, fuzzy
msgid "Extract the ABI definition (ensuring you include the square brackets) and integrate it into the previously created `assets/erc20.json` file."
msgstr "4.æå– ABI å®šä¹‰ï¼ˆç¡®ä¿åŒ…å«æ–¹æ‹¬å·ï¼‰å¹¶å°†å…¶æ•´åˆåˆ°ä¹‹å‰åˆ›å»ºçš„ `assets/erc20.json` æ–‡ä»¶ä¸­ã€‚"

#: src/ch02-10-01-erc20-ui.md:406
msgid ""
"Well done! The basic MKT token application is now operational locally. Access it via `http://localhost:3000` or the port noted from earlier server setup. The app allows users to connect their wallets, "
"review their balances, and perform token transfers."
msgstr "åšå¾—å¥½ï¼åŸºæœ¬çš„ MKT ä»£å¸åº”ç”¨ç¨‹åºç°å·²åœ¨æœ¬åœ°è¿è¡Œã€‚è¯·é€šè¿‡ `http://localhost:3000`æˆ–å…ˆå‰æœåŠ¡å™¨è®¾ç½®ä¸­æŒ‡å‡ºçš„ç«¯å£è®¿é—®è¯¥åº”ç”¨ç¨‹åºã€‚è¯¥åº”ç”¨ç¨‹åºå…è®¸ç”¨æˆ·è¿æ¥è‡ªå·±çš„é’±åŒ…ã€æŸ¥çœ‹ä½™é¢å’Œæ‰§è¡Œä»£å¸è½¬è´¦ã€‚"

#: src/ch02-10-01-erc20-ui.md:457
msgid "Congratulations! Your MKT token web3 application is now accessible to everyone."
msgstr "æ­å–œæ‚¨ï¼ç°åœ¨æ‰€æœ‰äººéƒ½å¯ä»¥è®¿é—®æ‚¨çš„ MKT ä»£å¸ web3 åº”ç”¨äº†ã€‚"

#: src/ch02-10-01-erc20-ui.md:477
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 application using React and Starknet Cairo. This application, complete with an ERC20 smart contract, offers a modern web "
"interface for user interaction. Here's a snapshot of your achievements:"
msgstr "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨ä¸€æ­¥æ­¥çš„å­¦ä¹ äº†å¦‚ä½•ä½¿ç”¨ React å’Œ Starknet Cairo åˆ¶ä½œ Web3 åº”ç”¨ã€‚è¿™ä¸ªåº”ç”¨ç¨‹åºåŒ…å«ä¸€ä¸ª ERC20 æ™ºèƒ½åˆçº¦ï¼Œä¸ºç”¨æˆ·äº¤äº’æä¾›äº†ä¸€ä¸ªç°ä»£åŒ–çš„ Web ç•Œé¢ã€‚ä¸‹é¢æ˜¯æ‚¨çš„æˆæœå¿«ç…§ï¼š"

#: src/ch02-10-01-erc20-ui.md:482
msgid "**React Application**: Built a React application powered by Starknet React, featuring components dedicated to balance inquiries and token transactions."
msgstr ""

#: src/ch02-10-01-erc20-ui.md:484
msgid "**ABI Creation**: Produced the ABI for the MKT token, a critical component to liaise with the contract."
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:1
#, fuzzy
msgid "Million Dollar Homepage"
msgstr "# ç™¾ä¸‡ç¾å…ƒçº§åˆ«çš„ä¸»é¡µ"

#: src/ch02-10-02-million-dollar-homepage.md:3
msgid ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) is a decentralized application on the Starknet blockchain. It provides a virtual space where users can claim and personalize "
"sections of a 100x100 grid, known as \"Starknet Homepage\". Each section is a 10x10 pixel area. Users can acquire these sections by minting non-fungible tokens (NFTs) and then personalizing them with "
"images and other content."
msgstr ""
"[Starknetä¸»é¡µ](https://github.com/dbejarano820/starknet_homepage) æ˜¯StarknetåŒºå—é“¾ä¸Šçš„ä¸€ä¸ªå»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºã€‚å®ƒä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªè™šæ‹Ÿç©ºé—´ï¼Œç”¨æˆ·å¯ä»¥åœ¨è¿™ä¸ª 100x100 ç½‘æ ¼ï¼ˆå³ \"Starknetä¸»é¡µ\"ï¼‰ä¸Šç”³è¯·å¹¶ä¸ªæ€§åŒ–"
"è‡ªå·±çš„éƒ¨åˆ†ã€‚æ¯ä¸ªåŒºåŸŸä¸º 10x10 åƒç´ ã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡é“¸é€ ä¸å¯å…‘æ¢ä»£å¸ï¼ˆNFTï¼‰è·å¾—è¿™äº›åŒºåŸŸï¼Œç„¶åç”¨å›¾ç‰‡å’Œå…¶ä»–å†…å®¹å¯¹å…¶è¿›è¡Œä¸ªæ€§åŒ–è®¾ç½®ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:5
msgid "View the live app on testnet [here](https://starknet-homepage-kappa.vercel.app/)."
msgstr "åœ¨[æ­¤å¤„](https://starknet-homepage-kappa.vercel.app/) å¯ä»¥ä»testnetä¸ŠæŸ¥çœ‹å®æ—¶åº”ç”¨ç¨‹åºã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:9
msgid ""
"This initiative is an adaptation of the renowned Million Dollar Homepage and was conceived at the Starknet Summit 2023 Hacker House in Palo Alto, California. The following is a guide to understanding "
"how this project was developed using the available tools in the ecosystem."
msgstr ""
"è¯¥é¡¹ç›®æ˜¯å¯¹è‘—åçš„ \"ç™¾ä¸‡ç¾å…ƒä¸»é¡µ\"ï¼ˆMillion Dollar Homepageï¼‰çš„æ”¹ç¼–ï¼Œæ˜¯åœ¨åŠ åˆ©ç¦å°¼äºšå·å¸•æ´›é˜¿å°”æ‰˜çš„ \"Starknetå³°ä¼š 2023 åˆ›å®¢ä¹‹å®¶\"ï¼ˆStarknet Summit 2023 Hacker Houseï¼‰ä¸Šæ„æ€çš„ã€‚ä¸‹é¢çš„å†…å®¹å°†å¸®åŠ©ä½ äº†è§£è¿™ä¸ª"
"é¡¹ç›®æ˜¯å¦‚ä½•åˆ©ç”¨ç”Ÿæ€ç³»ç»Ÿä¸­çš„å¯ç”¨å·¥å…·å¼€å‘å‡ºæ¥çš„ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:11
#, fuzzy
msgid "Tools Utilized:"
msgstr "### ä½¿ç”¨çš„å·¥å…·ï¼š"

#: src/ch02-10-02-million-dollar-homepage.md:13
msgid "[Starknet-react](https://github.com/apibara/starknet-react)"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:14
msgid "[Starknet.js](https://github.com/0xs34n/starknet.js)"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:15
#, fuzzy
msgid "[OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)"
msgstr ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:16
msgid "[MaterialUI](https://mui.com/material-ui/)"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:18
#, fuzzy
msgid "Initial Setup"
msgstr "## åˆå§‹è®¾ç½®"

#: src/ch02-10-02-million-dollar-homepage.md:20
msgid "The `Starknet-react` app offers a command to initialize a Starknet app. This command sets up the foundational structure needed for a NextJS application."
msgstr "`Starknet-react` åº”ç”¨ç¨‹åºæä¾›äº†ä¸€ä¸ªç”¨äºåˆå§‹åŒ– Starknet åº”ç”¨ç¨‹åºçš„å‘½ä»¤ã€‚è¯¥å‘½ä»¤è®¾ç½®äº† NextJS åº”ç”¨ç¨‹åºæ‰€éœ€çš„åŸºç¡€ç»“æ„ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:26
msgid ""
"The `StarknetConfig` component accepts a `connectors` prop, which defines wallet connection options for the user. Additionally, it can take a `defaultProvider` to set the network the application "
"should connect to by default."
msgstr "`StarknetConfig` ç»„ä»¶æ¥å—ä¸€ä¸ªåä¸º `connectors`çš„propï¼Œä¸ºç”¨æˆ·å®šä¹‰é’±åŒ…è¿æ¥é€‰é¡¹ã€‚æ­¤å¤–ï¼Œå®ƒè¿˜å¯ä»¥æ¥å—ä¸€ä¸ª `defaultProvider` æ¥è®¾ç½®åº”ç”¨ç¨‹åºé»˜è®¤åº”è¿æ¥çš„ç½‘ç»œã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:31
msgid "\"argentX\""
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:45
msgid ""
"/ThemeProvider>\n"
"    </"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:47
msgid ""
"/StarknetConfig>\n"
");\n"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:51
msgid ""
"Both `CacheProvider` and `ThemeProvider` are components that facilitate the seamless integration of MaterialUI with NextJS. For a comprehensive setup guide on these components, please refer to [this "
"link](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)."
msgstr "`CacheProvider` å’Œ `ThemeProvider` éƒ½æ˜¯å¸®åŠ© MaterialUI ä¸ NextJS æ— ç¼é›†æˆçš„ç»„ä»¶ã€‚æœ‰å…³è¿™äº›ç»„ä»¶çš„å…¨é¢è®¾ç½®æŒ‡å—ï¼Œè¯·å‚é˜… [æ­¤é“¾æ¥](https://blog.logrocket.com/getting-started-with-mui-and-next-js/)ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:53
#, fuzzy
msgid "Main Functionality"
msgstr "## ä¸»è¦åŠŸèƒ½"

#: src/ch02-10-02-million-dollar-homepage.md:55
msgid ""
"The core functionality of the Starknet Homepage centers around selecting a 4-sided region on a matrix, representing the desired 10x10 cells, and minting a token based on those cells. The "
"responsibility of the smart contract is to validate whether the selected cells are available for minting. If a user owns Starknet Homepage tokens, they can access a dropdown to modify the token's "
"content, including the associated image and link on the grid."
msgstr ""
"Starknet Homepage çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯åœ¨çŸ©é˜µä¸Šé€‰æ‹©ä¸€ä¸ªå››è¾¹å½¢åŒºåŸŸï¼ˆä»£è¡¨æ‰€éœ€çš„ 10x10 å•å…ƒï¼‰ï¼Œå¹¶æ ¹æ®è¿™äº›å•å…ƒé“¸é€ ä»£å¸ã€‚æ™ºèƒ½åˆçº¦çš„èŒè´£æ˜¯éªŒè¯æ‰€é€‰å•å…ƒæ ¼æ˜¯å¦å¯ç”¨äºé“¸å¸ã€‚å¦‚æœç”¨æˆ·æ‹¥æœ‰Starknetä¸»é¡µä»£å¸ï¼Œå°±å¯ä»¥è®¿é—®ä¸‹æ‹‰èœå•"
"æ¥ä¿®æ”¹ä»£å¸çš„å†…å®¹ï¼ŒåŒ…æ‹¬ç½‘æ ¼ä¸Šçš„ç›¸å…³å›¾ç‰‡å’Œé“¾æ¥ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:57
msgid "The app's primary requirements are:"
msgstr "è¯¥åº”ç”¨ç¨‹åºçš„ä¸»è¦è¦æ±‚æ˜¯ï¼š"

#: src/ch02-10-02-million-dollar-homepage.md:59
msgid "Wallet connectivity"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:60
msgid "Grid for displaying existing tokens"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:61
msgid "Cell selection capability"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:62
msgid "Multicall function for token approval and minting"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:63
msgid "Dropdown to view owned tokens"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:64
msgid "On-chain representation of the entire 1 million pixel grid"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:66
msgid ""
"A significant aspect to consider is the string limitation in Cairo contracts. To store links of varying sizes, they are stored as arrays of `felt252`s. The contract uses the following logic for this "
"purpose:"
msgstr "éœ€è¦è€ƒè™‘çš„ä¸€ä¸ªé‡è¦æ–¹é¢æ˜¯ Cairo åˆçº¦ä¸­çš„å­—ç¬¦ä¸²é™åˆ¶ã€‚ä¸ºäº†å­˜å‚¨ä¸åŒå¤§å°çš„é“¾æ¥ï¼Œå®ƒä»¬è¢«å­˜å‚¨ä¸º `felt252`æ•°ç»„ã€‚ä¸ºæ­¤ï¼Œåˆçº¦ä½¿ç”¨äº†ä»¥ä¸‹é€»è¾‘ï¼š"

#: src/ch02-10-02-million-dollar-homepage.md:82
msgid "// Read the stored array's length. If the length is superior to 255, the read will fail.\n"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:88
msgid "// Sequentially read all stored elements and append them to the array.\n"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:103
msgid "// // Store the length of the array in the first storage slot. 255 of elements is max\n"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:107
msgid "// Store the array elements sequentially\n"
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:126
msgid "The storage method for links in the contract state is structured as:"
msgstr "åˆçº¦çŠ¶æ€ä¸‹é“¾æ¥çš„å­˜å‚¨æ–¹æ³•ç»“æ„å¦‚ä¸‹ï¼š"

#: src/ch02-10-02-million-dollar-homepage.md:140
msgid ""
"The OpenZeppelin Cairo Contracts library played a crucial role in speeding up the development of the ERC721 contract for Starknet Homepage. You can find the contract for review [here](https://github."
"com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). Once you have installed the library, you can refer to the following example for typical usage:"
msgstr ""
"OpenZeppelin Cairo Contracts åº“åœ¨åŠ é€Ÿå¼€å‘Starkneté¦–é¡µçš„ ERC721 åˆçº¦æ–¹é¢å‘æŒ¥äº†è‡³å…³é‡è¦çš„ä½œç”¨ã€‚æ‚¨å¯ä»¥åœ¨ [æ­¤å¤„](https://github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721."
"cairo) æ‰¾åˆ°è¯¥åˆçº¦ä»¥ä¾›æŸ¥é˜…ã€‚å®‰è£…è¯¥åº“åï¼Œæ‚¨å¯ä»¥å‚è€ƒä»¥ä¸‹ç¤ºä¾‹äº†è§£å…¶å…¸å‹ç”¨æ³•ï¼š"

#: src/ch02-10-02-million-dollar-homepage.md:170
#, fuzzy
msgid "Component Logic"
msgstr "### ç»„ä»¶é€»è¾‘"

#: src/ch02-10-02-million-dollar-homepage.md:172
#, fuzzy
msgid "Grid"
msgstr "#### ç½‘æ ¼"

#: src/ch02-10-02-million-dollar-homepage.md:174
msgid ""
"The Grid component represents a 100x100 matrix, with each cell being 100 pixels. This layout corresponds to the data structure found in the smart contract. To showcase the tokens already minted on the "
"Homepage, the app employs a React Hook from `starknet-react` to invoke the `getAllTokens` function from the contract."
msgstr ""
"ç½‘æ ¼ç»„ä»¶è¡¨ç¤ºä¸€ä¸ª 100x100 çš„çŸ©é˜µï¼Œæ¯ä¸ªå•å…ƒæ ¼ä¸º 100 ä¸ªåƒç´ ã€‚è¿™ç§å¸ƒå±€ä¸æ™ºèƒ½åˆçº¦ä¸­çš„æ•°æ®ç»“æ„ç›¸å¯¹åº”ã€‚ä¸ºäº†å±•ç¤ºä¸»é¡µä¸Šå·²ç»é“¸é€ çš„ä»£å¸ï¼Œè¯¥åº”ç”¨ç¨‹åºä½¿ç”¨äº†æ¥è‡ª `starknet-react` çš„ React Hook æ¥è°ƒç”¨åˆçº¦ä¸­çš„ "
"`getAllTokens` å‡½æ•°ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:176
msgid ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"
msgstr ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:194
msgid "Deserialization ensures the data from the Starknet contract is aptly transformed for frontend use. This process involves decoding the array of `felt252`s into extensive strings."
msgstr "ååºåˆ—åŒ–å¯ç¡®ä¿Starknetåˆçº¦ä¸­çš„æ•°æ®ç»è¿‡é€‚å½“è½¬æ¢åä¾›å‰ç«¯ä½¿ç”¨ã€‚è¿™ä¸€è¿‡ç¨‹åŒ…æ‹¬å°† `felt252` æ•°ç»„è§£ç ä¸ºå­—ç¬¦ä¸²ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:196
msgid ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"
msgstr ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:211
msgid ""
"Furthermore, the Grid component manages the cell selection process, leading to the minting of a corresponding token. Once an area is chosen, a modal appears displaying the mint details and other "
"necessary inputs for the call data. The intricacies of the multicall will be addressed subsequently."
msgstr "æ­¤å¤–ï¼Œç½‘æ ¼ç»„ä»¶è¿˜è´Ÿè´£ç®¡ç†å•å…ƒæ ¼çš„é€‰æ‹©è¿‡ç¨‹ï¼Œä»è€Œé“¸é€ ç›¸åº”çš„ä»£å¸ã€‚ä¸€æ—¦é€‰æ‹©äº†ä¸€ä¸ªåŒºåŸŸï¼Œå°±ä¼šå‡ºç°ä¸€ä¸ªæ¨¡æ€ï¼Œæ˜¾ç¤ºé“¸å¸ç»†èŠ‚å’Œå…¶ä»–å¿…è¦çš„å‘¼å«æ•°æ®è¾“å…¥ã€‚å¤šé‡å‘¼å«çš„å¤æ‚æ€§å°†åœ¨éšåè®¨è®ºã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:215
#, fuzzy
msgid "Modals"
msgstr "#### æ¨¡æ€çª—"

#: src/ch02-10-02-million-dollar-homepage.md:217
msgid "Modals offer a convenient means to present varied functionalities within the app, such as wallet connection, token minting, and token editing."
msgstr "æ¨¡æ€çª—æä¾›äº†ä¸€ç§ä¾¿æ·çš„æ–¹å¼ï¼Œå¯åœ¨åº”ç”¨ç¨‹åºä¸­å±•ç¤ºå„ç§åŠŸèƒ½ï¼Œå¦‚é’±åŒ…è¿æ¥ã€ä»£å¸é“¸é€ å’Œä»£å¸ç¼–è¾‘ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:221
msgid "A recognized best practice is to invoke the React hook for shared information at a top-level, ensuring components like the `WalletBar` remain streamlined and focused."
msgstr "å…¬è®¤çš„æœ€ä½³åšæ³•æ˜¯åœ¨é¡¶å±‚è°ƒç”¨ React é’©å­æ¥å…±äº«ä¿¡æ¯ï¼Œä»è€Œç¡®ä¿ `WalletBar` ç­‰ç»„ä»¶ä¿æŒç²¾ç®€å’Œé›†ä¸­ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:233
msgid ""
"Below, the `WalletConnected` function displays the connected wallet's address, while the `ConnectWallet` function allows users to select and connect their wallet. The `WalletBar` function renders the "
"appropriate modal based on the connection status."
msgstr "ä¸‹é¢ï¼Œ`WalletConnected` å‡½æ•°æ˜¾ç¤ºè¿æ¥çš„é’±åŒ…åœ°å€ï¼Œè€Œ `ConnectWallet`å‡½æ•°å…è®¸ç”¨æˆ·é€‰æ‹©å¹¶è¿æ¥ä»–ä»¬çš„é’±åŒ…ã€‚é’±åŒ…æ  \"å‡½æ•°ä¼šæ ¹æ®è¿æ¥çŠ¶æ€æ¸²æŸ“ç›¸åº”çš„æ¨¡æ€ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:235
msgid ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet />;\n"
"}\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:317
#, fuzzy
msgid "Token Dropdown"
msgstr "#### ä»£å¸ä¸‹æ‹‰èœå•"

#: src/ch02-10-02-million-dollar-homepage.md:319
msgid ""
"The dropdown component is dedicated to showcasing the tokens associated with the currently connected wallet. To retrieve these tokens, a transaction like the one shown below can be executed. The sole "
"argument for this function is the contract address of the intended owner."
msgstr "ä¸‹æ‹‰ç»„ä»¶ç”¨äºæ˜¾ç¤ºä¸å½“å‰è¿æ¥çš„é’±åŒ…ç›¸å…³çš„ä»£å¸ã€‚è¦æ£€ç´¢è¿™äº›ä»£å¸ï¼Œå¯ä»¥æ‰§è¡Œä¸‹å›¾æ‰€ç¤ºçš„äº¤æ˜“ã€‚è¯¥åŠŸèƒ½çš„å”¯ä¸€å‚æ•°æ˜¯ç›®æ ‡æ‰€æœ‰è€…çš„åˆçº¦åœ°å€ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:321
msgid ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"
msgstr ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:335
#, fuzzy
msgid "Multicall Contract Interaction"
msgstr "### å¤šé‡è°ƒç”¨åˆçº¦äº¤äº’"

#: src/ch02-10-02-million-dollar-homepage.md:337
msgid ""
"The provided code offers an illustration of a multicall, specifically to approve a transaction for the mint price transfer followed by the actual minting action. Notably, the `shortString` module from "
"`starknet.js` plays a pivotal role; it encodes and segments a lengthy string into an array of `felt252`s, the expected argument type for the contract on Starknet."
msgstr ""
"æ‰€æä¾›çš„ä»£ç æä¾›äº†å¤šé‡è°ƒç”¨çš„ç¤ºä¾‹ï¼Œç‰¹åˆ«æ˜¯æ‰¹å‡†ä»¥é“¸å¸ä»·æ ¼è¿›è¡Œè½¬è®©äº¤æ˜“ï¼Œç„¶åè¿›è¡Œå®é™…çš„é“¸å¸æ“ä½œã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œ`starknet.js`ä¸­çš„ `shortString`æ¨¡å—å‘æŒ¥äº†å…³é”®ä½œç”¨ï¼›å®ƒå°†å†—é•¿çš„å­—ç¬¦ä¸²ç¼–ç å¹¶åˆ†å‰²æˆ \"felt252 \"æ•°"
"ç»„ï¼Œè¿™æ˜¯Starknetåˆçº¦çš„é¢„æœŸå‚æ•°ç±»å‹ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:339
msgid "The `useContractWrite` is a Hook dedicated to executing a Starknet multicall, which can be employed for a singular transaction or multiple ones."
msgstr "`useContractWrite` æ˜¯ä¸€ä¸ªä¸“é—¨ç”¨äºæ‰§è¡ŒStarknetå¤šé‡è°ƒç”¨çš„é’©å­ï¼Œå¯ç”¨äºå•ä¸ªæˆ–å¤šä¸ªäº‹åŠ¡ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:341
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:372
msgid ""
"Another crucial aspect to point out is the `calldata` of the approve function for the ether transfer: calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`. The amount argument is split "
"into two parts because it's a `u256`, which is composed of two separate `felt252` values."
msgstr ""
"éœ€è¦æŒ‡å‡ºçš„å¦ä¸€ä¸ªé‡è¦æ–¹é¢æ˜¯ä»¥å¤ªç½‘ä¼ è¾“æ‰¹å‡†å‡½æ•°çš„ `calldata`ï¼š calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', \"0\"],`ã€‚é‡‘é¢å‚æ•°è¢«åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ª `u256`ï¼Œç”±ä¸¤ä¸ªç‹¬ç«‹çš„ `felt252` å€¼ç»„"
"æˆã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:374
msgid "Once the multicall is prepared, the next step is to initiate the function and sign the transaction using the connected wallet."
msgstr "å‡†å¤‡å¥½å¤šé‡è°ƒç”¨åï¼Œä¸‹ä¸€æ­¥å°±æ˜¯ä½¿ç”¨è¿æ¥çš„é’±åŒ…å¯åŠ¨åŠŸèƒ½å¹¶ç­¾ç½²äº¤æ˜“ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:376
msgid ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:394
#, fuzzy
msgid "Conditional Multicall for Token Editing"
msgstr "### ç”¨äºä»£å¸ç¼–è¾‘çš„æ¡ä»¶å¤šé‡è°ƒç”¨"

#: src/ch02-10-02-million-dollar-homepage.md:396
msgid "Another instructive illustration of a conditional multicall setup is the modal used to modify the data associated with a token."
msgstr "è®¾ç½®æ¡ä»¶å¤šé‡è°ƒç”¨çš„å¦ä¸€ä¸ªæœ‰å¯å‘æ€§çš„ä¾‹å­æ˜¯ç”¨äºä¿®æ”¹æ ‡è®°ç›¸å…³æ•°æ®çš„æ¨¡æ€çª—ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:400
msgid ""
"There are scenarios where the user may wish to alter just one attribute of the token, rather than both. Consequently, a conditional multicall configuration becomes necessary. It's essential to recall "
"that the token id in the Cairo contract is defined as a `u256`, implying it comprises two `felt252` values."
msgstr "åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç”¨æˆ·å¯èƒ½åªæƒ³æ›´æ”¹ä»£å¸çš„ä¸€ä¸ªå±æ€§ï¼Œè€Œä¸æ˜¯ä¸¤ä¸ªéƒ½æ”¹ã€‚å› æ­¤ï¼Œæœ‰æ¡ä»¶çš„å¤šé‡è°ƒç”¨é…ç½®å°±å˜å¾—å¾ˆæœ‰å¿…è¦ã€‚å¿…é¡»è®°ä½ï¼ŒCairoåˆçº¦ä¸­çš„ä»£å¸ id è¢«å®šä¹‰ä¸º `u256`ï¼Œè¿™æ„å‘³ç€å®ƒç”±ä¸¤ä¸ª`felt252`å€¼ç»„æˆã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:402
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"
msgstr ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"

#: src/ch02-10-02-million-dollar-homepage.md:430
#, fuzzy
msgid "Starknet Homepage Overview"
msgstr "## Starknetä¸»é¡µæ¦‚è§ˆ"

#: src/ch02-10-02-million-dollar-homepage.md:432
msgid ""
"**Grid Component**: Represents a 100x100 matrix, allowing users to select cells and mint corresponding tokens. It fetches existing tokens using the `getAllTokens` function from the contract and "
"displays them."
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:433
#, fuzzy
msgid "**Modals**: Serve as the user interface for actions like wallet connection, token minting, and token editing."
msgstr "æ¨¡æ€çª—æä¾›äº†ä¸€ç§ä¾¿æ·çš„æ–¹å¼ï¼Œå¯åœ¨åº”ç”¨ç¨‹åºä¸­å±•ç¤ºå„ç§åŠŸèƒ½ï¼Œå¦‚é’±åŒ…è¿æ¥ã€ä»£å¸é“¸é€ å’Œä»£å¸ç¼–è¾‘ã€‚"

#: src/ch02-10-02-million-dollar-homepage.md:434
msgid "**Token Dropdown**: Displays tokens associated with a connected wallet. It retrieves these tokens using the `getTokensByOwner` function."
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:435
msgid "**Multicall Contract Interaction**: Enables token minting and editing. This process utilizes conditional multicalls based on user preferences, especially for editing token attributes."
msgstr ""

#: src/ch02-10-02-million-dollar-homepage.md:437
msgid ""
"Throughout the platform, string limitations in Cairo contracts require encoding lengthy strings into arrays of `felt252`s. The OpenZeppelin Cairo Contracts library significantly expedites the "
"development of the ERC721 contract for the Starknet Homepage."
msgstr "åœ¨æ•´ä¸ªå¹³å°ä¸­ï¼ŒCairoåˆçº¦ä¸­çš„å­—ç¬¦ä¸²é™åˆ¶è¦æ±‚å°†å†—é•¿çš„å­—ç¬¦ä¸²ç¼–ç ä¸º `felt252`æ•°ç»„ã€‚OpenZeppelin Cairoåˆçº¦åº“å¤§å¤§åŠ å¿«äº†Starknetä¸»é¡µ ERC721 åˆçº¦çš„å¼€å‘ã€‚"

#: src/ch02-11-starknet-py.md:3
msgid ""
"Starknet.py is a Python SDK designed for integrating websites, decentralized applications, backends, and more, with Starknet. It serves as a bridge, enabling smooth interaction between your "
"application and the Starknet blockchain."
msgstr ""

#: src/ch02-11-starknet-py.md:5
msgid "For detailed information, documentation, and getting started guides, visit the [Starknet.py documentation](https://starknetpy.readthedocs.io/en/latest/)."
msgstr ""

#: src/ch02-11-starknet-py.md:6
msgid "To access the source code, contribute, or view the latest updates, check out the [Starknet.py GitHub repository](https://github.com/software-mansion/starknet.py)."
msgstr ""

#: src/ch02-11-starknet-py.md:7
msgid ""
"For community support, discussions, and staying connected with other developers, join the Starknet Discord community. Look for the `ğŸstarknet-py` channel in [Starknet Discord](https://discord.gg/"
"qypnmzkhbc)."
msgstr ""

#: src/ch02-13-foundry-forge.md:3
msgid ""
"Merely deploying contracts is not the end game. Many tools have offered this capability in the past. Forge sets itself apart by hosting a Cairo VM instance, enabling the sequential execution of tests. "
"It employs Scarb for contract compilation."
msgstr "ä»…ä»…éƒ¨ç½²åˆçº¦å¹¶ä¸æ˜¯æœ€ç»ˆç›®çš„ã€‚è¿‡å»ï¼Œè®¸å¤šå·¥å…·éƒ½æä¾›äº†è¿™ç§åŠŸèƒ½ã€‚Forge é€šè¿‡æ‰˜ç®¡ Cairo è™šæ‹Ÿæœºå®ä¾‹ï¼Œå®ç°äº†æµ‹è¯•çš„é¡ºåºæ‰§è¡Œï¼Œä»è€Œä¸ä¼—ä¸åŒã€‚å®ƒé‡‡ç”¨ Scarb è¿›è¡Œåˆçº¦ç¼–è¯‘ã€‚"

#: src/ch02-13-foundry-forge.md:5
msgid ""
"To utilize Forge, define test functions and label them with test attributes. Users can either test standalone Cairo functions or integrate contracts, dispatchers, and test contract interactions on-"
"chain."
msgstr "è¦ä½¿ç”¨ Forgeï¼Œåªéœ€å®šä¹‰æµ‹è¯•åŠŸèƒ½å¹¶æ ‡æ³¨æµ‹è¯•å±æ€§å³å¯ã€‚ç”¨æˆ·æ—¢å¯ä»¥æµ‹è¯•ç‹¬ç«‹çš„ Cairo å‡½æ•°ï¼Œä¹Ÿå¯ä»¥é›†æˆåˆçº¦ã€è°ƒåº¦ç¨‹åºï¼Œå¹¶æµ‹è¯•é“¾ä¸Šçš„åˆçº¦äº¤äº’ã€‚"

#: src/ch02-13-foundry-forge.md:7
#, fuzzy
msgid "`snForge` Command-Line Usage"
msgstr "## ä½¿ç”¨ `snForge` å‘½ä»¤è¡Œ"

#: src/ch02-13-foundry-forge.md:9
msgid "This section guides you through the Starknet Foundry `snforge` command-line tool. Learn how to set up a new project, compile the code, and execute tests."
msgstr "æœ¬èŠ‚å°†æŒ‡å¯¼æ‚¨ä½¿ç”¨ Starknet Foundry `snforge` å‘½ä»¤è¡Œå·¥å…·ã€‚äº†è§£å¦‚ä½•å»ºç«‹æ–°é¡¹ç›®ã€ç¼–è¯‘ä»£ç å’Œæ‰§è¡Œæµ‹è¯•ã€‚"

#: src/ch02-13-foundry-forge.md:11
#, fuzzy
msgid "To start a new project with Starknet Foundry, use the `snforge init` command and replace `project_name` with your project's name."
msgstr "è¦ä½¿ç”¨ Starknet Foundry å¯åŠ¨ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œå¯ä»¥ä½¿ç”¨ `--init` å‘½ä»¤ã€‚å°† `project_name` æ›¿æ¢ä¸ºä½ çš„é¡¹ç›®åç§°ã€‚"

#: src/ch02-13-foundry-forge.md:17
msgid "Once you've set up the project, inspect its layout:"
msgstr "è®¾ç½®å¥½é¡¹ç›®åï¼Œæ£€æŸ¥å…¶ç»“æ„ï¼š"

#: src/ch02-13-foundry-forge.md:24
msgid "The project structure is as follows:"
msgstr "åˆ›å»ºé¡¹ç›®åï¼Œæ‚¨å¯ä»¥å‘ç°å…¶ç»“æ„å¦‚ä¸‹ï¼š"

#: src/ch02-13-foundry-forge.md:34
msgid "`src/` holds your contract source code."
msgstr ""

#: src/ch02-13-foundry-forge.md:35
msgid "`tests/` is the location of your test files."
msgstr ""

#: src/ch02-13-foundry-forge.md:36
msgid "`Scarb.toml` is for project and **`snforge`** configurations."
msgstr ""

#: src/ch02-13-foundry-forge.md:38
#, fuzzy
msgid "Ensure the CASM and SIERRA code generation is active in the `Scarb.toml` file:"
msgstr "ç¡®ä¿åœ¨ `Scarb.toml` æ–‡ä»¶ä¸­æ¿€æ´» CASM ä»£ç ç”Ÿæˆï¼š"

#: src/ch02-13-foundry-forge.md:48
msgid "Requirements for snforge"
msgstr ""

#: src/ch02-13-foundry-forge.md:50
msgid "Before you run `snforge test` certain prerequisites must be addressed:"
msgstr ""

#: src/ch02-13-foundry-forge.md:52
#, fuzzy
msgid "Install the latest [scarb version](#https://docs.swmansion.com/scarb/docs.html)."
msgstr "å¯¹äº Windowsï¼Œè¯·æŒ‰ç…§ [Scarb æ–‡æ¡£](https://docs.swmansion.com/scarb/download.html#windows)ä¸­çš„æ‰‹å†Œè¿›è¡Œè®¾ç½®ã€‚"

#: src/ch02-13-foundry-forge.md:53
msgid "Install [starknet-foundry](#https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html) by running this command:"
msgstr ""

#: src/ch02-13-foundry-forge.md:55
msgid "`curl -L https://raw.githubusercontent.com/foundry-rs/starknet-foundry/master/scripts/install.sh | sh `"
msgstr ""

#: src/ch02-13-foundry-forge.md:58
msgid "Follow the instructions and then run: `snfoundryup`"
msgstr ""

#: src/ch02-13-foundry-forge.md:61
#, fuzzy
msgid "Check your `snforge` version, run : `snforge version`"
msgstr "ç¡®ä¿æ ‡ç­¾ç‰ˆæœ¬ä¸æ‚¨çš„ `snforge` ç‰ˆæœ¬ä¸€è‡´ã€‚éªŒè¯æ‚¨çš„ `snforge` ç‰ˆæœ¬ï¼š"

#: src/ch02-13-foundry-forge.md:64
msgid "As athe time of this tutorial, we used `snforge` version `snforge 0.16.0` which is the latest at this time."
msgstr ""

#: src/ch02-13-foundry-forge.md:66
msgid "Test"
msgstr ""

#: src/ch02-13-foundry-forge.md:68
#, fuzzy
msgid "Run tests using `snforge test`:"
msgstr "æ‚¨å¯ä»¥ä½¿ç”¨ `snforge` è¿è¡Œæµ‹è¯•ï¼š"

#: src/ch02-13-foundry-forge.md:81
#, fuzzy
msgid "Integrating `snforge` with Existing Scarb Projects"
msgstr "## åœ¨ç°æœ‰ Scarb é¡¹ç›®ä¸­ä½¿ç”¨ `snforge`"

#: src/ch02-13-foundry-forge.md:83
#, fuzzy
msgid ""
"For those with an established Scarb project who wish to incorporate `snforge`, ensure the `snforge_std package` is declared as a dependency. Insert the line below in the \\[dependencies\\] section of "
"your `Scarb.toml`:"
msgstr "å¯¹äºé‚£äº›å·²å»ºç«‹ Scarb é¡¹ç›®å¹¶å¸Œæœ›å°† `snforge` çº³å…¥å…¶ä¸­çš„ç”¨æˆ·ï¼Œè¯·ç¡®ä¿å·²å°† `snforge_std package` å£°æ˜ä¸ºä¾èµ–é¡¹ã€‚åœ¨æ‚¨çš„ `Scarb.toml` çš„ [dependencies] éƒ¨åˆ†æ’å…¥ä¸‹é¢ä¸€è¡Œï¼š"

#: src/ch02-13-foundry-forge.md:85
#, fuzzy
msgid ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry\", tag = \"v0.16.0\" }\n"
"```"
msgstr ""
"```shell\n"
"# ...\n"
"[dependencies]\n"
"snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"[VERSION]\" }\n"
"```"

#: src/ch02-13-foundry-forge.md:91
msgid "Ensure the tag version corresponds with your `snforge` version. To verify your `snforge` version:"
msgstr "ç¡®ä¿æ ‡ç­¾ç‰ˆæœ¬ä¸æ‚¨çš„ `snforge` ç‰ˆæœ¬ä¸€è‡´ã€‚éªŒè¯æ‚¨çš„ `snforge` ç‰ˆæœ¬ï¼š"

#: src/ch02-13-foundry-forge.md:97
msgid "Or, add this dependency using the `scarb` command:"
msgstr "æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ `scarb` å‘½ä»¤æ·»åŠ è¯¥ä¾èµ–å…³ç³»ï¼š"

#: src/ch02-13-foundry-forge.md:99
#, fuzzy
msgid ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag v0.16.0\n"
"```"
msgstr ""
"```shell\n"
"scarb add snforge_std --git https://github.com/foundry-rs/starknet-foundry.git --tag VERSION\n"
"```"

#: src/ch02-13-foundry-forge.md:103
#, fuzzy
msgid "With these steps, your existing Scarb project is now **`snforge`**\\-ready."
msgstr "å®Œæˆè¿™äº›æ­¥éª¤åï¼Œæ‚¨ç°æœ‰çš„ Scarb é¡¹ç›®å°±å¯ä»¥**`snforge`**äº†ã€‚"

#: src/ch02-13-foundry-forge.md:105
#, fuzzy
msgid "Testing with `snforge`"
msgstr "## ä½¿ç”¨ snforge è¿è¡Œæµ‹è¯•"

#: src/ch02-13-foundry-forge.md:107
#, fuzzy
msgid "Utilize Starknet Foundry's `snforge test` command to efficiently run tests."
msgstr "åˆ©ç”¨ Starknet Foundry çš„ `snforge` å‘½ä»¤å¯é«˜æ•ˆçš„è¿è¡Œæµ‹è¯•ã€‚"

#: src/ch02-13-foundry-forge.md:109
#, fuzzy
msgid "Executing Tests"
msgstr "### è¿è¡Œæµ‹è¯•"

#: src/ch02-13-foundry-forge.md:111
msgid "Navigate to the package directory and issue this command to run tests:"
msgstr "å¯¼èˆªè‡³è½¯ä»¶åŒ…ç›®å½•ï¼Œç„¶åä½¿ç”¨æ­¤å‘½ä»¤è¿è¡Œæµ‹è¯•ï¼š"

#: src/ch02-13-foundry-forge.md:117
msgid "Sample output might resemble:"
msgstr "è¾“å‡ºç¤ºä¾‹å¯èƒ½ç±»ä¼¼äº"

#: src/ch02-13-foundry-forge.md:129
#, fuzzy
msgid "Example: Testing a Simple Contract"
msgstr "## ç¤ºä¾‹ï¼šæµ‹è¯•ç®€å•åˆçº¦"

#: src/ch02-13-foundry-forge.md:131
msgid "The example provided below demonstrates how to test a Starknet contract using `snforge`."
msgstr "ä¸‹é¢çš„ç¤ºä¾‹æ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `snforge` æµ‹è¯•æ˜Ÿç½‘åˆåŒã€‚"

#: src/ch02-13-foundry-forge.md:162
msgid "Remember, the identifier following `mod` signifies the contract name. Here, the contract name is `HelloStarknet`."
msgstr "è¯·è®°ä½ï¼Œ`mod`åé¢çš„æ ‡è¯†ç¬¦è¡¨ç¤ºåˆçº¦åç§°ã€‚è¿™é‡Œï¼Œåˆçº¦åç§°æ˜¯ `HelloStarknet`ã€‚"

#: src/ch02-13-foundry-forge.md:164
#, fuzzy
msgid "Craft the Test"
msgstr "### è®¾è®¡æµ‹è¯•"

#: src/ch02-13-foundry-forge.md:166
msgid "Below is a test for the **`HelloStarknet`** contract. This test deploys **`HelloStarknet`** and interacts with its functions:"
msgstr "ä¸‹é¢æ˜¯ **`HelloStarknet`** åˆçº¦çš„æµ‹è¯•ã€‚è¯¥æµ‹è¯•éƒ¨ç½² **`HelloStarknet`**ï¼Œå¹¶ä¸å…¶åŠŸèƒ½äº¤äº’ï¼š"

#: src/ch02-13-foundry-forge.md:168
msgid ""
"```\n"
"use starknet::ContractAddress;\n"
"\n"
"use snforge_std::{declare, ContractClassTrait};\n"
"\n"
"use tesingg::IHelloStarknetSafeDispatcher;\n"
"use tesingg::IHelloStarknetSafeDispatcherTrait;\n"
"use tesingg::IHelloStarknetDispatcher;\n"
"use tesingg::IHelloStarknetDispatcherTrait;\n"
"\n"
"fn deploy_contract(name: felt252) -> ContractAddress {\n"
"    let contract = declare(name);\n"
"    contract.deploy(@ArrayTrait::new()).unwrap()\n"
"}\n"
"\n"
"#[test]\n"
"fn test_increase_balance() {\n"
"    let contract_address = deploy_contract('HelloStarknet');\n"
"\n"
"    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
"\n"
"    let balance_before = dispatcher.get_balance();\n"
"    assert(balance_before == 0, 'Invalid balance');\n"
"\n"
"    dispatcher.increase_balance(42);\n"
"\n"
"    let balance_after = dispatcher.get_balance();\n"
"    assert(balance_after == 42, 'Invalid balance');\n"
"}\n"
"\n"
"#[test]\n"
"fn test_cannot_increase_balance_with_zero_value() {\n"
"    let contract_address = deploy_contract('HelloStarknet');\n"
"\n"
"    let safe_dispatcher = IHelloStarknetSafeDispatcher { contract_address };\n"
"\n"
"    #[feature(\"safe_dispatcher\")]\n"
"    let balance_before = safe_dispatcher.get_balance().unwrap();\n"
"    assert(balance_before == 0, 'Invalid balance');\n"
"\n"
"    #[feature(\"safe_dispatcher\")]\n"
"    match safe_dispatcher.increase_balance(0) {\n"
"        Result::Ok(_) => panic_with_felt252('Should have panicked'),\n"
"        Result::Err(panic_data) => {\n"
"            assert(*panic_data.at(0) == 'Amount cannot be 0', *panic_data.at(0));\n"
"        }\n"
"    };\n"
"}\n"
"```"
msgstr ""

#: src/ch02-13-foundry-forge.md:218
msgid "To run the test, execute the `snforge` command. The expected output is:"
msgstr "è¦è¿è¡Œæµ‹è¯•ï¼Œè¯·æ‰§è¡Œ `snforge` å‘½ä»¤ã€‚é¢„æœŸè¾“å‡ºä¸º"

#: src/ch02-13-foundry-forge.md:229
#, fuzzy
msgid "Example: Testing ERC20 Contract"
msgstr "## ç¤ºä¾‹ï¼šæµ‹è¯• ERC20 åˆçº¦"

#: src/ch02-13-foundry-forge.md:231
msgid ""
"There are several methods to test smart contracts, such as unit tests, integration tests, fuzz tests, fork tests, E2E tests, and using foundry cheatcodes. This section discusses testing an ERC20 "
"example contract from the `starknet-js` subchapter examples using unit and integration tests, filtering, foundry cheatcodes, and fuzz tests through the `snforge` CLI."
msgstr ""
"æµ‹è¯•æ™ºèƒ½åˆçº¦æœ‰å¤šç§æ–¹æ³•ï¼Œå¦‚å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€æ¨¡ç³Šæµ‹è¯•ã€åˆ†å‰æµ‹è¯•ã€E2E æµ‹è¯•å’Œä½¿ç”¨foundryä½œå¼Šç ã€‚æœ¬èŠ‚å°†è®¨è®ºé€šè¿‡ `snforge` CLI ä½¿ç”¨å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ã€è¿‡æ»¤ã€foundryä½œå¼Šç å’Œæ¨¡ç³Šæµ‹è¯•æ¥æµ‹è¯• `starknet-js` å­"
"ç« èŠ‚ç¤ºä¾‹ä¸­çš„ ERC20 ç¤ºä¾‹åˆçº¦ã€‚"

#: src/ch02-13-foundry-forge.md:233
#, fuzzy
msgid "ERC20 Contract Example"
msgstr "## ERC20 åˆçº¦ç¤ºä¾‹"

#: src/ch02-13-foundry-forge.md:235
#, fuzzy
msgid ""
"After setting up your foundry project, add the following dependency to your `Scarb.toml` (in this case we are using version 0.8.0 of the OpenZeppelin Cairo contracts, due to the fact that it uses "
"components):"
msgstr "è®¾ç½®å¥½æ‚¨çš„ foundry é¡¹ç›®åï¼Œå°†ä»¥ä¸‹ä¾èµ–é¡¹æ·»åŠ åˆ°æ‚¨çš„ `Scarb.toml`ï¼ˆåœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ 0.7.0 ç‰ˆ OpenZeppelin Cairo åˆçº¦ï¼Œä½†æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ä»»æ„ç‰ˆæœ¬ï¼‰ï¼š"

#: src/ch02-13-foundry-forge.md:237
#, fuzzy
msgid ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.8.1\" }\n"
"```"
msgstr ""
"```shell\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"```"

#: src/ch02-13-foundry-forge.md:241
msgid "Here's a basic ERC20 contract:"
msgstr "è¿™æ˜¯ä¸€ä»½åŸºæœ¬çš„ ERC20 åˆçº¦ï¼š"

#: src/ch02-13-foundry-forge.md:243
msgid ""
"```\n"
"use starknet::ContractAddress;\n"
"#[starknet::interface]\n"
"trait IERC20<TContractState> {\n"
"    fn get_name(self: @TContractState) -> felt252;\n"
"    fn get_symbol(self: @TContractState) -> felt252;\n"
"    fn get_decimals(self: @TContractState) -> u8;\n"
"    fn get_total_supply(self: @TContractState) -> u256;\n"
"    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
"    fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -> u256;\n"
"    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256);\n"
"    fn transfer_from(\n"
"        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256\n"
"    );\n"
"    fn approve(ref self: TContractState, spender: ContractAddress, amount: u256);\n"
"    fn increase_allowance(ref self: TContractState, spender: ContractAddress, added_value: u256);\n"
"    fn decrease_allowance(\n"
"        ref self: TContractState, spender: ContractAddress, subtracted_value: u256\n"
"    );\n"
"\n"
"\n"
"    fn mint(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
"}\n"
"\n"
"#[starknet::contract]\n"
"mod ERC20Token {\n"
"\n"
"Importing necessary libraries\n"
"\n"
"    use starknet::ContractAddress;\n"
"    use starknet::get_caller_address;\n"
"    use starknet::contract_address_const;\n"
"\n"
"Similar to address(0) in Solidity\n"
"\n"
"    use core::zeroable::Zeroable;\n"
"    use super::IERC20;\n"
"\n"
"    //Stroge Variables\n"
"    #[storage]\n"
"    struct Storage {\n"
"        name: felt252,\n"
"        symbol: felt252,\n"
"        decimals: u8,\n"
"        total_supply: u256,\n"
"        balances: LegacyMap<ContractAddress, u256>,\n"
"        allowances: LegacyMap<\n"
"            (ContractAddress, ContractAddress), u256\n"
"        >, //similar to mapping(address => mapping(address => uint256))\n"
"    }\n"
"    //  Event\n"
"    #[event]\n"
"    #[derive(Drop, starknet::Event)]\n"
"    enum Event {\n"
"        Approval: Approval,\n"
"        Transfer: Transfer\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Transfer {\n"
"        from: ContractAddress,\n"
"        to: ContractAddress,\n"
"        value: u256\n"
"    }\n"
"\n"
"    #[derive(Drop, starknet::Event)]\n"
"    struct Approval {\n"
"        owner: ContractAddress,\n"
"        spender: ContractAddress,\n"
"        value: u256,\n"
"    }\n"
"\n"
"The contract constructor is not part of the interface. Nor are internal functions part of the interface.\n"
"\n"
"Constructor\n"
"\n"
"    #[constructor]\n"
"    fn constructor(ref self: ContractState, // _name: felt252,\n"
"\n"
"    recipient: ContractAddress) {\n"
"        // The .is_zero() method here is used to determine whether the address type recipient is a 0 address, similar to recipient == address(0) in Solidity.\n"
"        assert(!recipient.is_zero(), 'transfer to zero address');\n"
"\n"
"        self.name.write('ERC20Token');\n"
"        self.symbol.write('ECT');\n"
"        self.decimals.write(18);\n"
"        self.total_supply.write(1000000);\n"
"        self.balances.write(recipient, 1000000);\n"
"\n"
"        self\n"
"            .emit(\n"
"                Transfer { //Here, `contract_address_const::<0>()` is similar to address(0) in Solidity\n"
"                    from: contract_address_const::<0>(), to: recipient, value: 1000000\n"
"                }\n"
"            );\n"
"    }\n"
"\n"
"    #[abi(embed_v0)]\n"
"    impl IERC20Impl of IERC20<ContractState> {\n"
"        fn get_name(self: @ContractState) -> felt252 {\n"
"            self.name.read()\n"
"        }\n"
"        fn get_symbol(self: @ContractState) -> felt252 {\n"
"            self.symbol.read()\n"
"        }\n"
"\n"
"        fn get_decimals(self: @ContractState) -> u8 {\n"
"            self.decimals.read()\n"
"        }\n"
"\n"
"        fn get_total_supply(self: @ContractState) -> u256 {\n"
"            self.total_supply.read()\n"
"        }\n"
"\n"
"\n"
"        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
"            self.balances.read(account)\n"
"        }\n"
"\n"
"        fn allowance(\n"
"            self: @ContractState, owner: ContractAddress, spender: ContractAddress\n"
"        ) -> u256 {\n"
"            self.allowances.read((owner, spender))\n"
"        }\n"
"\n"
"     fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
"            let owner = self.owner.read();\n"
"            let caller = get_caller_address();\n"
"            assert(owner == caller, Errors::CALLER_NOT_OWNER);\n"
"            assert(!recipient.is_zero(), Errors::ADDRESS_ZERO);\n"
"            assert(self.balances.read(recipient) >= amount, Errors::INSUFFICIENT_FUND);\n"
"            self.balances.write(recipient, self.balances.read(recipient) + amount);\n"
"            self.total_supply.write(self.total_supply.read() - amount);\n"
"            // call transfer\n"
"            // Transfer(Zeroable::zero(), recipient, amount);\n"
"\n"
"            true\n"
"        }\n"
"\n"
"\n"
"        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) {\n"
"            let caller = get_caller_address();\n"
"            self.transfer_helper(caller, recipient, amount);\n"
"        }\n"
"\n"
"        fn transfer_from(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            let my_allowance = self.allowances.read((sender, caller));\n"
"\n"
"            assert(my_allowance > 0, 'You have no token approved');\n"
"            assert(amount <= my_allowance, 'Amount Not Allowed');\n"
"            // assert(my_allowance <= amount, 'Amount Not Allowed');\n"
"\n"
"            self\n"
"                .spend_allowance(\n"
"                    sender, caller, amount\n"
"                ); //responsible for deduction of the amount allowed to spend\n"
"            self.transfer_helper(sender, recipient, amount);\n"
"        }\n"
"\n"
"        fn approve(ref self: ContractState, spender: ContractAddress, amount: u256) {\n"
"            let caller = get_caller_address();\n"
"            self.approve_helper(caller, spender, amount);\n"
"        }\n"
"\n"
"        fn increase_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, added_value: u256\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) + added_value\n"
"                );\n"
"        }\n"
"\n"
"        fn decrease_allowance(\n"
"            ref self: ContractState, spender: ContractAddress, subtracted_value: u256\n"
"        ) {\n"
"            let caller = get_caller_address();\n"
"            self\n"
"                .approve_helper(\n"
"                    caller, spender, self.allowances.read((caller, spender)) - subtracted_value\n"
"                );\n"
"        }\n"
"    }\n"
"\n"
"    #[generate_trait]\n"
"    impl HelperImpl of HelperTrait {\n"
"        fn transfer_helper(\n"
"            ref self: ContractState,\n"
"            sender: ContractAddress,\n"
"            recipient: ContractAddress,\n"
"            amount: u256\n"
"        ) {\n"
"            let sender_balance = self.balance_of(sender);\n"
"\n"
"            assert(!sender.is_zero(), 'transfer from 0');\n"
"            assert(!recipient.is_zero(), 'transfer to 0');\n"
"            assert(sender_balance >= amount, 'Insufficient fund');\n"
"            self.balances.write(sender, self.balances.read(sender) - amount);\n"
"            self.balances.write(recipient, self.balances.read(recipient) + amount);\n"
"            true;\n"
"\n"
"            self.emit(Transfer { from: sender, to: recipient, value: amount, });\n"
"        }\n"
"\n"
"        fn approve_helper(\n"
"            ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256\n"
"        ) {\n"
"            assert(!owner.is_zero(), 'approve from 0');\n"
"            assert(!spender.is_zero(), 'approve to 0');\n"
"\n"
"            self.allowances.write((owner, spender), amount);\n"
"\n"
"            self.emit(Approval { owner, spender, value: amount, })\n"
"        }\n"
"\n"
"        fn spend_allowance(\n"
"            ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256\n"
"        ) {\n"
"            // First, read the amount authorized by owner to spender\n"
"            let current_allowance = self.allowances.read((owner, spender));\n"
"\n"
"            // define a variable ONES_MASK of type u128\n"
"            let ONES_MASK = 0xfffffffffffffffffffffffffffffff_u128;\n"
"\n"
"            // to determine whether the authorization is unlimited,\n"
"\n"
"            let is_unlimited_allowance = current_allowance.low == ONES_MASK\n"
"                && current_allowance\n"
"                    .high == ONES_MASK; //equivalent to type(uint256).max in Solidity.\n"
"\n"
"            // This is also a way to save gas, because if the authorized amount is the maximum value of u256, theoretically, this amount cannot be spent.\n"
"            if !is_unlimited_allowance {\n"
"                self.approve_helper(owner, spender, current_allowance - amount);\n"
"            }\n"
"        }\n"
"    }\n"
"```"
msgstr ""

#: src/ch02-13-foundry-forge.md:488
msgid "This contract allows minting tokens to a recipient during deployment, checking balances, and transferring tokens, relying on the openzeppelin ERC20 library."
msgstr "è¯¥åˆçº¦å…è®¸åœ¨éƒ¨ç½²è¿‡ç¨‹ä¸­å‘æ¥æ”¶è€…é“¸é€ ä»£å¸ã€æ£€æŸ¥ä½™é¢å’Œè½¬ç§»ä»£å¸ï¼Œå¹¶ä¾èµ–äº openzeppelin ERC20 åº“ã€‚"

#: src/ch02-13-foundry-forge.md:490
#, fuzzy
msgid "Test Preparation"
msgstr "### æµ‹è¯•å‡†å¤‡"

#: src/ch02-13-foundry-forge.md:492
msgid "Organize your test file and include the required imports:"
msgstr "æ•´ç†æµ‹è¯•æ–‡ä»¶å¹¶åŒ…å«æ‰€éœ€çš„å¯¼å…¥ï¼š"

#: src/ch02-13-foundry-forge.md:509
#, fuzzy
msgid "For testing, you'll need a helper function to deploy the contract instance."
msgstr "æµ‹è¯•æ—¶ï¼Œæ‚¨éœ€è¦ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥éƒ¨ç½²åˆåŒå®ä¾‹ã€‚è¯¥å‡½æ•°éœ€è¦ä¸€ä¸ª `supply` é‡‘é¢å’Œ `recipient` åœ°å€ï¼š"

#: src/ch02-13-foundry-forge.md:511
#, fuzzy
msgid "This function requires a `supply` amount and `recipient` address:"
msgstr "æµ‹è¯•æ—¶ï¼Œæ‚¨éœ€è¦ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥éƒ¨ç½²åˆåŒå®ä¾‹ã€‚è¯¥å‡½æ•°éœ€è¦ä¸€ä¸ª `supply` é‡‘é¢å’Œ `recipient` åœ°å€ï¼š"

#: src/ch02-13-foundry-forge.md:513
msgid "Before deploying a starknet contract, we need a contract_class."
msgstr ""

#: src/ch02-13-foundry-forge.md:515
#, fuzzy
msgid "Get it using the declare function from [starknet Foundry](#https://foundry-rs.github.io/starknet-foundry/)"
msgstr "ä»¥ä¸‹ä»£ç ç¤ºä¾‹æ¥è‡ª `starknet foundry`ã€‚æ‚¨å¯ä»¥åœ¨ [æ­¤å¤„](https://foundry-rs.github.io/starknet-foundry/testing/contracts.html) æ‰¾åˆ°åŸæ–‡ã€‚"

#: src/ch02-13-foundry-forge.md:517
msgid "Supply values the constructor arguments when deploying"
msgstr ""

#: src/ch02-13-foundry-forge.md:532
msgid "Generate an address"
msgstr ""

#: src/ch02-13-foundry-forge.md:554
msgid "Use `declare` and `ContractClassTrait` from `snforge_std`. Then, initialize the `supply` and `recipient`, declare the contract, compute the calldata, and deploy."
msgstr "ä½¿ç”¨ `snforge_std` ä¸­çš„ `declare` å’Œ `ContractClassTrait`ã€‚ç„¶åï¼Œåˆå§‹åŒ– `supply` å’Œ `recipient`ï¼Œå£°æ˜åˆçº¦ï¼Œè®¡ç®— calldata å¹¶éƒ¨ç½²ã€‚"

#: src/ch02-13-foundry-forge.md:556
#, fuzzy
msgid "Writing the Test Cases"
msgstr "### ç¼–å†™æµ‹è¯•ç”¨ä¾‹"

#: src/ch02-13-foundry-forge.md:558
#, fuzzy
msgid "Verifying the contract details After Deployment using Fuzz testing"
msgstr "#### éƒ¨ç½²åæ ¸æŸ¥ä½™é¢"

#: src/ch02-13-foundry-forge.md:560
#, fuzzy
msgid "To begin, test the deployment helper function to confirm the details provided:"
msgstr "é¦–å…ˆï¼Œæµ‹è¯•éƒ¨ç½²åŠ©æ‰‹åŠŸèƒ½ï¼Œç¡®è®¤æ”¶ä»¶äººçš„ä½™é¢ï¼š"

#: src/ch02-13-foundry-forge.md:562
msgid ""
"```\n"
"#[test]\n"
"    fn test_constructor() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        // let name = dispatcher.get_name();\n"
"        let name = dispatcher.get_name();\n"
"\n"
"        assert(name == 'ERC20Token', 'name is not correct');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_decimal_is_correct() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        let decimal = dispatcher.get_decimals();\n"
"\n"
"        assert(decimal == 18, 'Decimal is not correct');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_total_supply() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        let total_supply = dispatcher.get_total_supply();\n"
"\n"
"        assert(total_supply == 1000000, 'Total supply is wrong');\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_address_balance() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        let balance = dispatcher.get_total_supply();\n"
"        let admin_balance = dispatcher.balance_of(Account::admin());\n"
"        assert(admin_balance == balance, Errors::INVALID_BALANCE);\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"\n"
"        dispatcher.transfer(Account::user1(), 10);\n"
"        let new_admin_balance = dispatcher.balance_of(Account::admin());\n"
"        assert(new_admin_balance == balance - 10, Errors::INVALID_BALANCE);\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"\n"
"        let user1_balance = dispatcher.balance_of(Account::user1());\n"
"        assert(user1_balance == 10, Errors::INVALID_BALANCE);\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[fuzzer(runs: 22, seed: 38)]\n"
"    fn test_allowance(amount: u256) {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(contract_address, 20);\n"
"\n"
"        let currentAllowance = dispatcher.allowance(Account::admin(), contract_address);\n"
"\n"
"        assert(currentAllowance == 20, Errors::NOT_ALLOWED);\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_transfer() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        // Get original balances\n"
"        let original_sender_balance = dispatcher.balance_of(Account::admin());\n"
"        let original_recipient_balance = dispatcher.balance_of(Account::user1());\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"\n"
"        dispatcher.transfer(Account::user1(), 50);\n"
"\n"
"        // Confirm that the funds have been sent!\n"
"        assert(\n"
"            dispatcher.balance_of(Account::admin()) == original_sender_balance - 50,\n"
"            Errors::FUNDS_NOT_SENT\n"
"        );\n"
"\n"
"        // Confirm that the funds have been recieved!\n"
"        assert(\n"
"            dispatcher.balance_of(Account::user1()) == original_recipient_balance + 50,\n"
"            Errors::FUNDS_NOT_RECIEVED\n"
"        );\n"
"\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"    }\n"
"\n"
"\n"
"    #[test]\n"
"    fn test_transfer_from() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(Account::user1(), 20);\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"\n"
"        assert(dispatcher.allowance(Account::admin(), Account::user1()) == 20, Errors::NOT_ALLOWED);\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::user1());\n"
"        dispatcher.transfer_from(Account::admin(), Account::user2(), 10);\n"
"        assert(\n"
"            dispatcher.allowance(Account::admin(), Account::user1()) == 10, Errors::FUNDS_NOT_SENT\n"
"        );\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('Amount Not Allowed',))]\n"
"    fn test_transfer_from_should_fail() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(Account::user1(), 20);\n"
"        stop_prank(CheatTarget::One(contract_address));\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::user1());\n"
"        dispatcher.transfer_from(Account::admin(), Account::user2(), 40);\n"
"    }\n"
"\n"
"    #[test]\n"
"    #[should_panic(expected: ('You have no token approved',))]\n"
"    fn test_transfer_from_failed_when_not_approved() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"        start_prank(CheatTarget::One(contract_address), Account::user1());\n"
"        dispatcher.transfer_from(Account::admin(), Account::user2(), 5);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_approve() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(Account::user1(), 50);\n"
"        assert(dispatcher.allowance(Account::admin(), Account::user1()) == 50, Errors::NOT_ALLOWED);\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_increase_allowance() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(Account::user1(), 30);\n"
"        assert(dispatcher.allowance(Account::admin(), Account::user1()) == 30, Errors::NOT_ALLOWED);\n"
"\n"
"        dispatcher.increase_allowance(Account::user1(), 20);\n"
"\n"
"        assert(\n"
"            dispatcher.allowance(Account::admin(), Account::user1()) == 50,\n"
"            Errors::ERROR_INCREASING_ALLOWANCE\n"
"        );\n"
"    }\n"
"\n"
"    #[test]\n"
"    fn test_decrease_allowance() {\n"
"        let contract_address = deploy_contract();\n"
"        let dispatcher = IERC20Dispatcher { contract_address };\n"
"\n"
"        start_prank(CheatTarget::One(contract_address), Account::admin());\n"
"        dispatcher.approve(Account::user1(), 30);\n"
"        assert(dispatcher.allowance(Account::admin(), Account::user1()) == 30, Errors::NOT_ALLOWED);\n"
"\n"
"        dispatcher.decrease_allowance(Account::user1(), 5);\n"
"\n"
"        assert(\n"
"            dispatcher.allowance(Account::admin(), Account::user1()) == 25,\n"
"            Errors::ERROR_DECREASING_ALLOWANCE\n"
"        );\n"
"    }\n"
"```"
msgstr ""

#: src/ch02-13-foundry-forge.md:740
#, fuzzy
msgid "Running `snforge test` produces:"
msgstr "è¿è¡Œ `snforge` ä¼šäº§ç”Ÿï¼š"

#: src/ch02-13-foundry-forge.md:760
#, fuzzy
msgid "Fuzz Testing"
msgstr "## æ¨¡ç³Šæµ‹è¯•"

#: src/ch02-13-foundry-forge.md:762
#, fuzzy
msgid ""
"Fuzz testing introduces random inputs to the code to identify vulnerabilities, security issues, and unforeseen behaviors. While you can manually provide these inputs, automation is preferable when "
"testing a broad set of values."
msgstr "æ¨¡ç³Šæµ‹è¯•å°†éšæœºè¾“å…¥å¼•å…¥ä»£ç ï¼Œä»¥è¯†åˆ«æ¼æ´ã€å®‰å…¨é—®é¢˜å’Œä¸å¯é¢„è§çš„è¡Œä¸ºã€‚è™½ç„¶æ‚¨å¯ä»¥æ‰‹åŠ¨æä¾›è¿™äº›è¾“å…¥ï¼Œä½†åœ¨æµ‹è¯•ä¸€ç»„å¹¿æ³›çš„å€¼æ—¶ï¼Œæœ€å¥½ä½¿ç”¨è‡ªåŠ¨åŒ–ã€‚è¯·å‚é˜…ä¸‹é¢ `test_fuzz.cairo` ä¸­çš„ç¤ºä¾‹ï¼š"

#: src/ch02-13-foundry-forge.md:764
msgid "Let discuss Random Fuzz Testing as a type of Fuzz testing:"
msgstr ""

#: src/ch02-13-foundry-forge.md:766
#, fuzzy
msgid "Random Fuzz testing"
msgstr "## æ¨¡ç³Šæµ‹è¯•"

#: src/ch02-13-foundry-forge.md:768
msgid ""
"To convert a test to a random fuzz test, simply add arguments to the test function. These arguments can then be used in the test body. The test will be run many times against different randomly "
"generated values. See the example below in `test_fuzz.cairo`:"
msgstr ""

#: src/ch02-13-foundry-forge.md:782
#, fuzzy
msgid "Then run `snforge test`"
msgstr ""
"```shell\n"
"snforge test_\n"
"```"

#: src/ch02-13-foundry-forge.md:797
#, fuzzy
msgid "The fuzzer supports these types by February 2024:"
msgstr "ç›´åˆ° 2023 å¹´ 11 æœˆï¼Œæ¨¡ç³Šå™¨æ”¯æŒè¿™äº›ç±»å‹ï¼š"

#: src/ch02-13-foundry-forge.md:799
msgid "u8"
msgstr ""

#: src/ch02-13-foundry-forge.md:800
msgid "u16"
msgstr ""

#: src/ch02-13-foundry-forge.md:801
msgid "u32"
msgstr ""

#: src/ch02-13-foundry-forge.md:802
msgid "u64"
msgstr ""

#: src/ch02-13-foundry-forge.md:803
msgid "u128"
msgstr ""

#: src/ch02-13-foundry-forge.md:804
msgid "u256"
msgstr ""

#: src/ch02-13-foundry-forge.md:805
msgid "felt252"
msgstr ""

#: src/ch02-13-foundry-forge.md:807
#, fuzzy
msgid "Fuzzer Configuration"
msgstr "`Fuzzer Configuration`"

#: src/ch02-13-foundry-forge.md:809
msgid "It is possible to configure the number of runs of the random fuzzer as well as its seed for a specific test case:"
msgstr ""

#: src/ch02-13-foundry-forge.md:819
msgid "It can also be configured globally, via command line arguments:"
msgstr ""

#: src/ch02-13-foundry-forge.md:825
msgid "Or in `scarb.toml`:"
msgstr "æˆ–åœ¨ `scarb.toml`ä¸­ï¼š"

#: src/ch02-13-foundry-forge.md:836
#, fuzzy
msgid "For more insight on fuzz tests, you can view it [here](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html)"
msgstr "æœ‰å…³æ¨¡ç³Šæµ‹è¯•çš„æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜… [æ­¤å¤„](https://foundry-rs.github.io/starknet-foundry/testing/fuzz-testing.html#fuzz-testing)"

#: src/ch02-13-foundry-forge.md:838
#, fuzzy
msgid "Filter Tests"
msgstr "## è¿‡æ»¤æµ‹è¯•"

#: src/ch02-13-foundry-forge.md:840
msgid "To execute specific tests, use a filter string with the `snforge` command. Tests matching the filter based on their absolute module tree path will be executed."
msgstr "è¦æ‰§è¡Œç‰¹å®šæµ‹è¯•ï¼Œå¯åœ¨ `snforge` å‘½ä»¤ä¸­ä½¿ç”¨è¿‡æ»¤å™¨å­—ç¬¦ä¸²ã€‚æ ¹æ®æ¨¡å—æ ‘çš„ç»å¯¹è·¯å¾„ä¸è¿‡æ»¤å™¨åŒ¹é…çš„æµ‹è¯•å°†è¢«æ‰§è¡Œã€‚"

#: src/ch02-13-foundry-forge.md:842
msgid "For instance, to run all tests with the string 'test\\_' in their name:"
msgstr "ä¾‹å¦‚ï¼Œè¿è¡Œåç§°ä¸­åŒ…å« 'test\\_'å­—ç¬¦ä¸²çš„æ‰€æœ‰æµ‹è¯•ï¼š"

#: src/ch02-13-foundry-forge.md:848
msgid "Expected output:"
msgstr "é¢„æœŸè¾“å‡ºï¼š"

#: src/ch02-13-foundry-forge.md:861
msgid "All the tests with the string 'test\\_' in their test name went through."
msgstr "æ‰€æœ‰æµ‹è¯•åç§°ä¸­åŒ…å« 'test\\_'å­—ç¬¦ä¸²çš„æµ‹è¯•éƒ½é€šè¿‡äº†ã€‚"

#: src/ch02-13-foundry-forge.md:863
msgid "Another example: To filter and run `test_fuzz_sum` we can partially match the test name with the string 'fuzz_sum' like this:"
msgstr "å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼šè¦è¿‡æ»¤å¹¶è¿è¡Œ `test_fuzz_sum` æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†æµ‹è¯•åç§°ä¸å­—ç¬¦ä¸² \"fuzz_sum \"éƒ¨åˆ†åŒ¹é…ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š"

#: src/ch02-13-foundry-forge.md:869
msgid "To execute an exact test, combine the `--exact` flag with a fully qualified test name:"
msgstr "è¦æ‰§è¡Œç²¾ç¡®æµ‹è¯•ï¼Œè¯·å°† `--exact` æ ‡å¿—ä¸å®Œæ•´çš„æµ‹è¯•åç§°ç›¸ç»“åˆï¼š"

#: src/ch02-13-foundry-forge.md:875
msgid "To halt the test suite upon the first test failure, use the `--exit-first` flag:"
msgstr "è¦åœ¨ç¬¬ä¸€æ¬¡æµ‹è¯•å¤±è´¥ååœæ­¢æ‰§è¡Œæµ‹è¯•ï¼Œè¯·åœ¨ `snforge` å‘½ä»¤ä¸­åŠ å…¥ `--exit-first` æ ‡å¿—ï¼š"

#: src/ch02-13-foundry-forge.md:881
msgid "If a test fails, the output will resemble:"
msgstr "å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œè¾“å‡ºå°†ç±»ä¼¼äºï¼š"

#: src/ch02-13-foundry-forge.md:902
msgid ""
"Starknet Foundry offers a notable step forward in Starknet contract development and testing. This toolset sharpens the process of creating, deploying, and testing Cairo contracts. Its main components, "
"Forge and Cast, provide developers with robust tools for Cairo contract work."
msgstr "Starknet Foundryåœ¨Starknetåˆçº¦å¼€å‘å’Œæµ‹è¯•æ–¹é¢è¿ˆå‡ºäº†æ˜¾è‘—çš„ä¸€æ­¥ã€‚è¯¥å·¥å…·é›†å¼ºåŒ–äº†Cairoåˆçº¦çš„åˆ›å»ºã€éƒ¨ç½²å’Œæµ‹è¯•è¿‡ç¨‹ã€‚å…¶ä¸»è¦ç»„ä»¶ Forge å’Œ Cast ä¸ºå¼€å‘äººå‘˜æä¾›äº†å¼ºå¤§çš„Cairoåˆçº¦å·¥ä½œå·¥å…·ã€‚"

#: src/ch02-13-foundry-forge.md:904
msgid ""
"Forge shines with its dual functionality: deploying and thoroughly testing Cairo contracts. It directly supports test writing in Cairo, removing the need for other languages and simplifying the task. "
"Moreover, Forge seamlessly integrates with Scarb, emphasizing its adaptability, especially with existing Scarb projects."
msgstr "Forge å…·æœ‰åŒé‡åŠŸèƒ½ï¼šéƒ¨ç½²å’Œå…¨é¢æµ‹è¯• Cairo åˆçº¦ã€‚å®ƒç›´æ¥æ”¯æŒ Cairo æµ‹è¯•ç¼–å†™ï¼Œæ— éœ€ä½¿ç”¨å…¶ä»–è¯­è¨€ï¼Œç®€åŒ–äº†ä»»åŠ¡ã€‚æ­¤å¤–ï¼ŒForge è¿˜å¯ä»¥ä¸ Scarb æ— ç¼é›†æˆï¼Œè¿™å¼ºè°ƒäº†å…¶é€‚åº”æ€§ï¼Œå°¤å…¶æ˜¯ä¸ç°æœ‰ Scarb é¡¹ç›®çš„é€‚åº”æ€§ã€‚"

#: src/ch02-13-foundry-forge.md:906
msgid "The `snforge` command-line tool makes initializing, setting up, and testing Starknet contracts straightforward."
msgstr "`snforge` å‘½ä»¤è¡Œå·¥å…·å¯ç›´æ¥åˆå§‹åŒ–ã€è®¾ç½®å’Œæµ‹è¯•Starknetåˆçº¦ã€‚"

#: src/ch02-14-security-considerations.md:3
msgid "In blockchain programming, understanding and mitigating smart contract vulnerabilities is vital to maintain user trust. This is as true for Cairo as any other language."
msgstr ""

#: src/ch02-14-security-considerations.md:5
msgid "We'll cover common security issues and Starknet-specific vulnerabilities in Cairo, along with strategies to safeguard your contracts."
msgstr ""

#: src/ch02-14-security-considerations.md:7
msgid "Your insights can enhance this chapter. To contribute, submit a pull request to the [Book repo](https://github.com/starknet-edu/starknetbook)."
msgstr ""

#: src/ch02-14-security-considerations.md:9
msgid "Note: Some code examples here are simplified pseudo-code, meant for concept explanation, not for production use."
msgstr ""

#: src/ch02-14-security-considerations.md:11
#, fuzzy
msgid "1. Access Control"
msgstr "1.åˆ›å»ºè´¦æˆ·"

#: src/ch02-14-security-considerations.md:13
msgid "Access control vulnerabilities occur when a smart contract's functions are insufficiently protected, allowing unauthorized actions. This can result in unexpected behavior and data manipulation."
msgstr ""

#: src/ch02-14-security-considerations.md:15
msgid "Take, for instance, a smart contract for token minting without proper access control:"
msgstr ""

#: src/ch02-14-security-considerations.md:22
msgid "// Stores the total supply of tokens.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:28
msgid ""
"// The mint_tokens function updates the total supply.\n"
"            // Without access control, any user can call this function, posing a risk.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:36
msgid ""
"In this code, the `mint_tokens` function is vulnerable because any user can call it, leading to potential token supply exploitation. Implementing access controls would restrict this function to "
"authorized users only."
msgstr ""

#: src/ch02-14-security-considerations.md:38
#, fuzzy
msgid "Recommendation"
msgstr "**å»ºè®®è§„æ ¼ï¼š**"

#: src/ch02-14-security-considerations.md:40
msgid ""
"To prevent access control vulnerabilities, integrate authorization mechanisms like role-based access control (RBAC) or ownership checks. You can develop a custom solution or use templates from sources "
"like [OpenZeppelin](https://docs.openzeppelin.com/contracts-cairo/access)."
msgstr ""

#: src/ch02-14-security-considerations.md:42
msgid ""
"In our earlier example, we can enhance security by adding an owner variable, initializing the owner in the constructor, and including a verification in the `mint_tokens` function to allow only the "
"owner to mint tokens."
msgstr ""

#: src/ch02-14-security-considerations.md:50
msgid "// New variable to store the contract owner's address.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:56
msgid "// Get the address of the contract creator.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:57
msgid "// Set the creator as the owner.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:63
msgid "// Check if the caller is the owner before minting tokens.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:65
msgid "// Assert ensures only the owner can mint.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:73
msgid "By establishing robust access control, you ensure that only authorized entities execute your smart contract functions, significantly reducing the risk of unauthorized interference."
msgstr ""

#: src/ch02-14-security-considerations.md:75
msgid "2. Reentrancy"
msgstr ""

#: src/ch02-14-security-considerations.md:77
msgid ""
"Reentrancy vulnerabilities arise when a smart contract calls an external contract before updating its state. This allows the external contract to recursively call the original function, potentially "
"leading to unintended behavior."
msgstr ""

#: src/ch02-14-security-considerations.md:79
msgid ""
"Consider a game contract where whitelisted addresses can mint an NFT sword and then execute an `on_receive_sword()` function before returning it. This NFT contract is at risk of a reentrancy attack, "
"where an attacker can mint multiple swords."
msgstr ""

#: src/ch02-14-security-considerations.md:84
msgid "// Stores available swords.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:85
msgid "// Maps swords to addresses.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:86
msgid "// Tracks whitelisted addresses.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:93
msgid "// Initializes the sword count.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:101
msgid "// Update the sword count before minting.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:104
msgid "// Mint a sword.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:106
msgid "// Callback to sender's contract.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:108
msgid "// Remove sender from whitelist after callback to prevent reentrancy.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:114
msgid ""
"An attacker's contract can implement the `on_receive_sword` function to exploit the reentry vulnerability and mint multiple swords by calling `mint_one_sword` again before removing the sender from the "
"`whitelist`:"
msgstr ""

#: src/ch02-14-security-considerations.md:122
msgid "// Attempt to mint a sword again.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:128
msgid ""
"Reentrancy protections are critical in many ERC standards with `safeTransfer` functions (like ERC721, ERC777, ERC1155, ERC223) and in flash loans, where borrower contracts need to safely use and "
"return funds."
msgstr ""

#: src/ch02-14-security-considerations.md:130 src/ch02-14-security-considerations.md:202 src/ch02-14-security-considerations.md:261 src/ch02-14-security-considerations.md:369
#: src/ch02-14-security-considerations.md:400
#, fuzzy
msgid "Recommendation:"
msgstr "**å»ºè®®è§„æ ¼ï¼š**"

#: src/ch02-14-security-considerations.md:132
msgid ""
"To prevent reentrancy attacks, use the check-effects-interactions pattern. This means updating your contract's internal state before interacting with external contracts. In the previous example, "
"remove the sender from the whitelist before making the external call."
msgstr ""

#: src/ch02-14-security-considerations.md:136
msgid "// Update the sword count first.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:139
msgid "// Mint a sword to the caller.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:141
msgid "// Crucially, remove the sender from the whitelist before the external call.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:143
msgid "// Only then, make the callback to the sender.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:148
msgid "Adhering to this pattern enhances the security of your smart contract by minimizing the risk of reentrancy attacks and preserving the integrity of its internal state."
msgstr ""

#: src/ch02-14-security-considerations.md:150
msgid "3. Tx.Origin Authentication"
msgstr ""

#: src/ch02-14-security-considerations.md:152
msgid ""
"In Solidity, `tx.origin` is a global variable that stores the address of the transaction initiator, while `msg.sender` stores the address of the transaction caller. In Cairo, we have the "
"`account_contract_address` global variable and `get_caller_address` function, which serve the same purpose."
msgstr ""

#: src/ch02-14-security-considerations.md:154
msgid ""
"Using `account_contract_address` (the equivalent of `tx.origin`) for authentication in your smart contract functions can lead to phishing attacks. Attackers can create custom smart contracts and trick "
"users into placing them as intermediaries in a transaction call, effectively impersonating the contract owner."
msgstr ""

#: src/ch02-14-security-considerations.md:156
msgid "For example, consider a Cairo smart contract that allows transferring funds to the owner and uses `account_contract_address` for authentication:"
msgstr ""

#: src/ch02-14-security-considerations.md:163 src/ch02-14-security-considerations.md:210
msgid "// Stores the owner's address.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:168 src/ch02-14-security-considerations.md:215
msgid "// Initialize the owner as the contract deployer.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:178
msgid "// Verifies the transaction initiator as the owner.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:180
msgid "// Processes the fund transfer.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:186
msgid "An attacker can trick the owner into using a malicious contract, allowing the attacker to call the `transferTo` function and impersonate the contract owner:"
msgstr ""

#: src/ch02-14-security-considerations.md:196
msgid "// Malicious callback to transfer funds.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:204
msgid "To guard against phishing attacks, replace `account_contract_address` (origin) authentication with `get_caller_address` (sender) in the `transferTo` function:"
msgstr ""

#: src/ch02-14-security-considerations.md:224
msgid "// Verify that the caller is the owner.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:226
msgid "// Execute the fund transfer.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:232
msgid "This change ensures secure authentication, preventing unauthorized users from executing critical functions and safeguarding against phishing attempts."
msgstr ""

#: src/ch02-14-security-considerations.md:234
msgid "4. Handling Overflow and Underflow in Smart Contracts"
msgstr ""

#: src/ch02-14-security-considerations.md:236
msgid "Overflow and underflow vulnerabilities arise from assigning values too large (overflow) or too small (underflow) for a specific data type."
msgstr ""

#: src/ch02-14-security-considerations.md:238
msgid "Consider the `felt252` data type: adding or subtracting values beyond its range can yield incorrect results:"
msgstr ""

#: src/ch02-14-security-considerations.md:242
msgid "// Assigns the maximum felt252 value: 2^251 + 17 * 2^192\n"
msgstr ""

#: src/ch02-14-security-considerations.md:244
msgid "// Attempting to add beyond the maximum value.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:250
msgid "// Same maximum value as in overflow.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:252
msgid "// Subtracting more than the minimum, leading to underflow.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:257
msgid "Executing these functions will result in incorrect values due to overflow and underflow, as illustrated in the following image:"
msgstr ""

#: src/ch02-14-security-considerations.md:263
msgid "To prevent incorrect results, use protected data types like `u128` or `u256`, which are designed to manage overflows and underflows."
msgstr ""

#: src/ch02-14-security-considerations.md:265
msgid "Here's how you can use the `u256` data type to handle these issues:"
msgstr ""

#: src/ch02-14-security-considerations.md:269 src/ch02-14-security-considerations.md:296
msgid "// Maximum u128 value.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:270
msgid "// Maximum u256 value.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:271 src/ch02-14-security-considerations.md:277
msgid "// Value of 3.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:272
msgid "// Attempting to add beyond max, will trigger overflow protection.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:276
msgid "// Zero value for u256.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:278
msgid "// Attempting to subtract from zero, will trigger underflow protection.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:282
msgid "When these functions encounter overflows or underflows, the transaction will revert, as shown in these images:"
msgstr ""

#: src/ch02-14-security-considerations.md:287
msgid "Failure reasons for `u256`:"
msgstr ""

#: src/ch02-14-security-considerations.md:289
msgid "Overflow: `0x753235365f616464204f766572666c6f77=u256_add Overflow`"
msgstr ""

#: src/ch02-14-security-considerations.md:290
msgid "Underflow: `0x753235365f737562204f766572666c6f77=u256_sub Overflow`"
msgstr ""

#: src/ch02-14-security-considerations.md:292
msgid "Similarly, the `u128` data type can be used to handle overflow and underflow:"
msgstr ""

#: src/ch02-14-security-considerations.md:297
msgid "// Adding to max, overflow protection triggers if necessary.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:301
msgid "// Zero value for u128.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:302
msgid "// Subtracting from zero, underflow protection activates if needed.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:306
msgid "Overflow or underflow in u128 will similarly revert the transaction, with corresponding failure reasons:"
msgstr ""

#: src/ch02-14-security-considerations.md:311
msgid "Failure reasons for u128:"
msgstr ""

#: src/ch02-14-security-considerations.md:313
msgid "Overflow: `0x753132385f616464204f766572666c6f77=u128_add Overflow`"
msgstr ""

#: src/ch02-14-security-considerations.md:314
msgid "Underflow: `0x753132385f737562204f766572666c6f77=u128_sub Overflow`"
msgstr ""

#: src/ch02-14-security-considerations.md:316
msgid "Using these data types, you can ensure safer arithmetic operations in your smart contracts, avoiding unintended consequences of overflows and underflows."
msgstr ""

#: src/ch02-14-security-considerations.md:318
msgid "5. Private Data On-Chain."
msgstr ""

#: src/ch02-14-security-considerations.md:320
msgid ""
"Storing secret values in smart contracts presents a challenge because all on-chain data is publicly accessible, even if the code isn't published. For example, consider a smart contract storing a "
"password (12345678) using a constructor parameter:"
msgstr ""

#: src/ch02-14-security-considerations.md:326
msgid "// Field to store the password.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:331
msgid "// Writing the password to the storage.\n"
msgstr ""

#: src/ch02-14-security-considerations.md:339
msgid "However, understanding Cairo's [storage layout](https://book.cairo-lang.org/ch13-01-contract-storage.html), we can create a script to read the stored variable:"
msgstr ""

#: src/ch02-14-security-considerations.md:346
msgid "\"goerli-alpha\""
msgstr ""

#: src/ch02-14-security-considerations.md:350
msgid "\"password\""
msgstr ""

#: src/ch02-14-security-considerations.md:352
msgid "\"getStor=\""
msgstr ""

#: src/ch02-14-security-considerations.md:354
msgid "\"0x032d0392eae7440063ea0f3f50a75dbe664aaa1df76b4662223430851a113369\""
msgstr ""

#: src/ch02-14-security-considerations.md:361
msgid "Executing this script reveals the stored password value (hex value of 12345678):"
msgstr ""

#: src/ch02-14-security-considerations.md:365
msgid "Moreover, using a block explorer, we can view the deployed parameters in the transaction:"
msgstr ""

#: src/ch02-14-security-considerations.md:371
msgid ""
"If your smart contract requires storing private data on-chain, consider off-chain encryption before sending data to the blockchain. Alternatively, explore options like hashes, merkle trees, or commit-"
"reveal patterns to maintain data privacy."
msgstr ""

#: src/ch02-14-security-considerations.md:373
msgid "6. Denial of Service."
msgstr ""

#: src/ch02-14-security-considerations.md:375
msgid ""
"Denial of Service (DoS), also called griefing attack, entails a situation where the atacker causes grief for other users of the protocol. A DoS attacker cripples the functionality of a Smart Contract "
"even if they gain no economic value from doing so. A major attack vector when it comes to Denial of Service is the gas exhaustion attack. In this attack, a malicious user can call a function that "
"needs an excessive amount of gas for execution. The consequent exhaustion of gas can cause the smart contract to stop, thus denying services to legitimate users."
msgstr ""

#: src/ch02-14-security-considerations.md:382
msgid "// Stored variables\n"
msgstr ""

#: src/ch02-14-security-considerations.md:391
msgid "// very expensive computation\n"
msgstr ""

#: src/ch02-14-security-considerations.md:398
msgid ""
"The minimalist contract above shows a transaction that would need intensive computation. The occurrence could result from an attacker calling the `transaction` function many times, leading to gas "
"exhaustion."
msgstr ""

#: src/ch02-14-security-considerations.md:402
msgid ""
"The smart contract has to be minimized as much as possible to reduce gas consumption. Gas limits could also be incorporated when designing functions. The developer should also try to estimate gas "
"usage every step, to ensure that all aspects are carefully accounted for."
msgstr ""

#: src/ch02-14-security-considerations.md:404
msgid "Call for Contributions: Additional Vulnerabilities"
msgstr ""

#: src/ch02-14-security-considerations.md:406
msgid ""
"We've discussed several common vulnerabilities in Cairo smart contracts, but many other security risks need attention. We invite community contributions to expand this chapter with more "
"vulnerabilities:"
msgstr ""

#: src/ch02-14-security-considerations.md:408
msgid "Storage Collision"
msgstr ""

#: src/ch02-14-security-considerations.md:409
msgid "Flash Loan Attacks"
msgstr ""

#: src/ch02-14-security-considerations.md:410
msgid "Oracle Manipulation"
msgstr ""

#: src/ch02-14-security-considerations.md:411
msgid "Bad Randomness"
msgstr ""

#: src/ch02-14-security-considerations.md:412
msgid "Untrusted Delegate Calls"
msgstr ""

#: src/ch02-14-security-considerations.md:413
msgid "Public Burn"
msgstr ""

#: src/ch02-14-security-considerations.md:415
msgid ""
"If you have expertise in these areas, please consider contributing your knowledge, including explanations and examples of these vulnerabilities. Your input will greatly benefit the Starknet and Cairo "
"developer community, aiding in the development of more secure and resilient smart contracts."
msgstr ""

#: src/ch02-14-security-considerations.md:417
msgid "We appreciate your support in enhancing the safety and security of the Starknet ecosystem for developers and users alike."
msgstr ""

#: src/ch02-15-security-tools.md:1
#, fuzzy
msgid "Starknet Security Tools"
msgstr "# Starknetå·¥å…·"

#: src/ch02-15-security-tools.md:3
msgid "Starknet offers a range of tools for testing the security of smart contracts. We invite developers to improve existing tools or create new ones."
msgstr ""

#: src/ch02-15-security-tools.md:5
msgid "This section covers:"
msgstr ""

#: src/ch02-15-security-tools.md:7
msgid "Tools for security testing."
msgstr ""

#: src/ch02-15-security-tools.md:8
msgid "Security considerations for smart contracts."
msgstr ""

#: src/ch02-15-security-tools.md:10
msgid "Below is an overview of the tools for Starknet security testing discussed in this chapter:"
msgstr ""

#: src/ch02-15-security-tools.md:12
msgid "**Cairo-fuzzer**: A tool for smart contract developers to test security. It functions both as a standalone tool and as a library."
msgstr ""

#: src/ch02-15-security-tools.md:13
msgid "**Caracal**: A static analysis tool for Starknet smart contracts, utilizing the SIERRA representation."
msgstr ""

#: src/ch02-15-security-tools.md:14
msgid "**Thoth**: A comprehensive Cairo/Starknet security toolkit. It includes analyzers, disassemblers, and decompilers."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:1
msgid "Cairo-Fuzzer"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:3
msgid "[Cairo-Fuzzer](https://github.com/FuzzingLabs/cairo-fuzzer) is a tool designed for smart contract developers to assess security. It operates both independently and as a library."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:5 src/ch02-15-02-caracal.md:5 src/ch02-15-03-thoth.md:5
#, fuzzy
msgid "Features"
msgstr "## å…³é”®ç‰¹æ€§"

#: src/ch02-15-01-cairo-fuzzer.md:9
msgid "Execute Cairo contracts."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:10
#, fuzzy
msgid "Execute Starknet contracts."
msgstr "## ä¸Starknetåˆçº¦äº¤äº’"

#: src/ch02-15-01-cairo-fuzzer.md:11
msgid "Replay fuzzing corpus."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:12
msgid "Minimize fuzzing corpus."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:13
msgid "Load previous corpus."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:14
msgid "Manage multiple arguments."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:15
msgid "Utilize workspace architecture."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:16
msgid "Import dictionaries."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:17
msgid "Integrate Cairo-fuzzer as a library."
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:19
msgid "Usage"
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:21
#, fuzzy
msgid "To use Cairo-fuzzer, run the following command:"
msgstr "è¦ä»æºä»£ç å®‰è£… `katana`ï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-15-01-cairo-fuzzer.md:24
msgid "\"Fuzz_symbolic_execution\""
msgstr ""

#: src/ch02-15-01-cairo-fuzzer.md:27
#, fuzzy
msgid "This outputs:"
msgstr "è¾“å‡ºç»“æœï¼š"

#: src/ch02-15-02-caracal.md:3
msgid "[Caracal](https://github.com/crytic/caracal) is a static analysis tool for Starknet smart contracts, specifically analyzing their SIERRA representation."
msgstr ""

#: src/ch02-15-02-caracal.md:7
msgid "Vulnerability detectors for Cairo code."
msgstr ""

#: src/ch02-15-02-caracal.md:8
msgid "Report printers."
msgstr ""

#: src/ch02-15-02-caracal.md:9
msgid "Taint analysis."
msgstr ""

#: src/ch02-15-02-caracal.md:10
msgid "Data flow analysis framework."
msgstr ""

#: src/ch02-15-02-caracal.md:11
#, fuzzy
msgid "Compatibility with Scarb projects."
msgstr "é¦–å…ˆå¯åŠ¨ä¸€ä¸ª Scarb é¡¹ç›®ï¼š"

#: src/ch02-15-02-caracal.md:15
msgid "Precompiled Binaries"
msgstr ""

#: src/ch02-15-02-caracal.md:17
msgid "Download precompiled binaries from the [releases page](https://github.com/crytic/caracal/releases). Use binary version v0.1.x for Cairo compiler 1.x.x, and v0.2.x for Cairo compiler 2.x.x."
msgstr ""

#: src/ch02-15-02-caracal.md:19
#, fuzzy
msgid "Building from Source"
msgstr "## ç¼–è¯‘æˆ‘ä»¬çš„é¡¹ç›®"

#: src/ch02-15-02-caracal.md:23
msgid "Rust compiler"
msgstr ""

#: src/ch02-15-02-caracal.md:24
msgid "Cargo"
msgstr ""

#: src/ch02-15-02-caracal.md:26
#, fuzzy
msgid "Installation Steps"
msgstr "# å®‰è£…"

#: src/ch02-15-02-caracal.md:28
msgid "Clone and build from the repository:"
msgstr ""

#: src/ch02-15-02-caracal.md:34
msgid "Building from a Local Copy:"
msgstr ""

#: src/ch02-15-02-caracal.md:36
msgid "If you prefer to build from a local copy:"
msgstr ""

#: src/ch02-15-03-thoth.md:3
msgid ""
"[Thoth](https://github.com/FuzzingLabs/thoth) (pronounced \"taut\" or \"toss\") is a security toolkit for Cairo/Starknet. Written in Python 3, it includes analyzers, disassemblers, and decompilers. "
"Thoth is capable of generating call graphs, control-flow graphs (CFG), and data-flow graphs for Sierra files or Cairo/Starknet compilation artifacts. It also features tools like a symbolic execution "
"engine and a symbolic bounded model checker."
msgstr ""

#: src/ch02-15-03-thoth.md:7
msgid "**Remote & Local Analysis**: Works with contracts on Mainnet/Goerli and local compilations."
msgstr ""

#: src/ch02-15-03-thoth.md:8
msgid "**Decompiler**: Transforms assembly into decompiled code using SSA (Static Single Assignment)."
msgstr ""

#: src/ch02-15-03-thoth.md:9
msgid "**Call Flow Analysis**: Generates Call Flow Graphs."
msgstr ""

#: src/ch02-15-03-thoth.md:10
msgid "**Static Analysis**: Conducts various types of analyses (security/optimization/analytics) on contracts."
msgstr ""

#: src/ch02-15-03-thoth.md:11
msgid "**Symbolic Execution**: Finds variable values for specific paths in functions and generates test cases."
msgstr ""

#: src/ch02-15-03-thoth.md:12
msgid "**Data Flow Analysis**: Produces Data Flow Graphs (DFG) for each function."
msgstr ""

#: src/ch02-15-03-thoth.md:13
msgid "**Disassembler**: Converts bytecode to assembly."
msgstr ""

#: src/ch02-15-03-thoth.md:14
msgid "**Control Flow Analysis**: Creates Control Flow Graphs (CFG)."
msgstr ""

#: src/ch02-15-03-thoth.md:15
msgid "**Cairo Fuzzer Inputs**: Generates inputs for Cairo fuzzer."
msgstr ""

#: src/ch02-15-03-thoth.md:16
msgid "**Sierra Files Analysis**: Analyzes Sierra files."
msgstr ""

#: src/ch02-15-03-thoth.md:17
msgid "**Sierra Files Symbolic Execution**: Performs symbolic execution on Sierra files."
msgstr ""

#: src/ch02-15-03-thoth.md:18
msgid "**Symbolic Bounded Model Checker**: Functions as a symbolic bounded model checker."
msgstr ""

#: src/ch02-15-03-thoth.md:24
#, fuzzy
msgid "Install Thoth using the following commands:"
msgstr "è¦ä»æºä»£ç å®‰è£… `katana`ï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-16-apibara.md:3
msgid ""
"Apibara is the fastest platform to build production-grade indexers that connect onchain data to web2 services, like for example Postrgres, MongoDB, or any other database of your choice. More [here]"
"(https://apibara.com/)."
msgstr ""

#: src/ch02-16-apibara.md:7
msgid "What is an indexer?"
msgstr ""

#: src/ch02-16-apibara.md:9
msgid "An indexer is a service that listens to the blockchain and indexes the data you are interested in. It makes it easy to query the blockchain data and build applications on top of it."
msgstr ""

#: src/ch02-16-apibara.md:12
msgid "What can you build with Apibara?"
msgstr ""

#: src/ch02-16-apibara.md:14
msgid "Some examples of what you can build with Apibara are:"
msgstr ""

#: src/ch02-16-apibara.md:16
msgid "Real-time NFT collections dashboard"
msgstr ""

#: src/ch02-16-apibara.md:17
msgid "Real-time swaps dashboard"
msgstr ""

#: src/ch02-16-apibara.md:19
msgid "Building an exmaple"
msgstr ""

#: src/ch02-16-apibara.md:21
msgid ""
"In this example, we will build a small app similar to the concept [Starkscan](https://starkscan.io/) but that will solely listen to swaps happening on AVNU in real-time. For the fronted we will use "
"react."
msgstr ""

#: src/ch02-16-apibara.md:24
msgid "Apibara offers his [direct access node](https://github.com/apibara/dna) that we will use to listen to the swaps."
msgstr ""

#: src/ch02-16-apibara.md:28
msgid "Get an Apibara API Key"
msgstr ""

#: src/ch02-16-apibara.md:30
msgid "Head to [Apibara](https://app.apibara.com/), sign up and create a new indexer. You can choose between:"
msgstr ""

#: src/ch02-16-apibara.md:33
msgid "DNA (Direct Node Access) Key. You can use Python SDK or Typescript SDK."
msgstr ""

#: src/ch02-16-apibara.md:34
msgid "Webhook"
msgstr ""

#: src/ch02-16-apibara.md:36
msgid "We will use the DNA key to listen to the swaps happening on AVNU. You will get a key something like:"
msgstr ""

#: src/ch02-16-apibara.md:43
msgid "Save it, we will use it later."
msgstr ""

#: src/ch02-16-apibara.md:45
msgid "Set the server"
msgstr ""

#: src/ch02-16-apibara.md:47
msgid "We will use Apibara's [TypeScript SDK](https://github.com/apibara/typescript-sdk/tree/main) to set a server script that will listen to the swaps happening on AVNU."
msgstr ""

#: src/ch02-16-apibara.md:49
msgid ""
"Apibara itself offers and example of usage [TypeScript Example](https://github.com/apibara/typescript-sdk/tree/main/examples/starknet-client). First, ensure you have Node.js and npm installed on your "
"machine. You can check by running `node -v` and `npm -v` in your terminal. If you don't have them installed, download and install from [Node.js official website](https://nodejs.org/)."
msgstr ""

#: src/ch02-16-apibara.md:52
msgid "Next, create a new directory for your project and navigate into it:"
msgstr ""

#: src/ch02-16-apibara.md:63
msgid "Install apibara's dependencies and some other dependencies we will use:"
msgstr ""

#: src/ch02-16-apibara.md:69
#, fuzzy
msgid "Create a file called `index.ts` and add the following code:"
msgstr "æ¥ä¸‹æ¥ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `src/hello_scarb.cairo` çš„æ–°æ–‡ä»¶ï¼Œå¹¶æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š"

#: src/ch02-16-apibara.md:71
msgid ""
"```typescript\n"
"import { StreamClient } from \"@apibara/protocol\";\n"
"import {\n"
"  Filter,\n"
"  StarkNetCursor,\n"
"  v1alpha2,\n"
"  FieldElement,\n"
"} from \"@apibara/starknet\";\n"
"import { RpcProvider, constants, provider, uint256 } from \"starknet\";\n"
"import { formatUnits } from \"ethers\";\n"
"import * as dotenv from \"dotenv\";\n"
"import { MongoDBService } from \"./MongoDBService\";\n"
"import { BlockNumber } from \"starknet\";\n"
"dotenv.config();\n"
"\n"
"const tokensDecimals = [\n"
"  {\n"
"    //ETH\n"
"    ticker: \"ETH\",\n"
"    decimals: 18,\n"
"    address:\n"
"      \"0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"  },\n"
"  {\n"
"    //USDT\n"
"    ticker: \"USDT\",\n"
"    decimals: 6,\n"
"    address:\n"
"      \"0x068f5c6a61780768455de69077e07e89787839bf8166decfbf92b645209c0fb8\",\n"
"  },\n"
"  {\n"
"    //USDC\n"
"    ticker: \"USDC\",\n"
"    decimals: 6,\n"
"    address:\n"
"      \"0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8\",\n"
"  },\n"
"  {\n"
"    //STRK\n"
"    ticker: \"STRK\",\n"
"    decimals: 18,\n"
"    address:\n"
"      \"0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d\",\n"
"  },\n"
"];\n"
"\n"
"async function main() {\n"
"  try {\n"
"    // Apibara streaming\n"
"    const client = new StreamClient({\n"
"      url: \"mainnet.starknet.a5a.ch\",\n"
"      token: process.env.APIBARA_TOKEN,\n"
"      async onReconnect(err, retryCount) {\n"
"        console.log(\"reconnect\", err, retryCount);\n"
"        // Sleep for 1 second before retrying.\n"
"        await new Promise((resolve) => setTimeout(resolve, 1000));\n"
"\n"
"        return { reconnect: true };\n"
"      },\n"
"    });\n"
"\n"
"    const provider = new RpcProvider({\n"
"      nodeUrl: constants.NetworkName.SN_MAIN,\n"
"      chainId: constants.StarknetChainId.SN_MAIN,\n"
"    });\n"
"    const hashAndBlockNumber = await provider.getBlockLatestAccepted();\n"
"    const block_number = hashAndBlockNumber.block_number;\n"
"    // The address of the swap event\n"
"    const key = FieldElement.fromBigInt(\n"
"      BigInt(\n"
"        \"0xe316f0d9d2a3affa97de1d99bb2aac0538e2666d0d8545545ead241ef0ccab\",\n"
"      ),\n"
"    );\n"
"    // The contract that emits the event. The AVNU swap contract\n"
"    const address = FieldElement.fromBigInt(\n"
"      BigInt(\n"
"        \"0x04270219d365d6b017231b52e92b3fb5d7c8378b05e9abc97724537a80e93b0f\",\n"
"      ),\n"
"    );\n"
"\n"
"    //Initialize the filter\n"
"    const filter_test = Filter.create()\n"
"      .withHeader({ weak: false })\n"
"      .addEvent((ev) => ev.withFromAddress(address).withKeys([key]))\n"
"      .encode();\n"
"\n"
"    // Configure the apibara client\n"
"    client.configure({\n"
"      filter: filter_test,\n"
"      batchSize: 1,\n"
"      cursor: StarkNetCursor.createWithBlockNumber(block_number),\n"
"    });\n"
"\n"
"    // Start listening to messages\n"
"    for await (const message of client) {\n"
"      switch (message.message) {\n"
"        case \"data\": {\n"
"          if (!message.data?.data) {\n"
"            continue;\n"
"          }\n"
"          for (const data of message.data.data) {\n"
"            const block = v1alpha2.Block.decode(data);\n"
"            const { header, events, transactions } = block;\n"
"            if (!header || !transactions) {\n"
"              continue;\n"
"            }\n"
"            console.log(\"Block \" + header.blockNumber);\n"
"            console.log(\"Events\", events.length);\n"
"\n"
"            for (const event of events) {\n"
"              console.log(event);\n"
"              if (event.event && event.receipt) {\n"
"                handleEventAvnuSwap(header, event.event, event.receipt);\n"
"              }\n"
"            }\n"
"          }\n"
"          break;\n"
"        }\n"
"        case \"invalidate\": {\n"
"          break;\n"
"        }\n"
"        case \"heartbeat\": {\n"
"          console.log(\"Received heartbeat\");\n"
"          break;\n"
"        }\n"
"      }\n"
"    }\n"
"  } catch (error) {\n"
"    console.error(\"Initialization failed\", error);\n"
"    process.exit(1);\n"
"  }\n"
"}\n"
"\n"
"main()\n"
"  .then(() => process.exit(0))\n"
"  .catch((error) => {\n"
"    console.error(error);\n"
"    process.exit(1);\n"
"  });\n"
"\n"
"async function handleEventAvnuSwap(\n"
"  header: v1alpha2.IBlockHeader,\n"
"  event: v1alpha2.IEvent,\n"
"  receipt: v1alpha2.ITransactionReceipt,\n"
") {\n"
"  console.log(\"STARTING TO HANDLE AVNUSWAP EVENT\");\n"
"  if (!event.data) return null;\n"
"\n"
"  const takerAddress = FieldElement.toHex(event.data[0]);\n"
"  const sellAddress = FieldElement.toHex(event.data[1]);\n"
"\n"
"  const sellToken = tokensDecimals.find(\n"
"    (token) => token.address === sellAddress,\n"
"  );\n"
"  const sellAddressDecimals = sellToken?.decimals;\n"
"  if (!sellAddressDecimals) return null; // Skip if sell token is not supported\n"
"\n"
"  const sellAmount = +formatUnits(\n"
"    uint256.uint256ToBN({\n"
"      low: FieldElement.toBigInt(event.data[2]),\n"
"      high: FieldElement.toBigInt(event.data[3]),\n"
"    }),\n"
"    sellAddressDecimals,\n"
"  );\n"
"\n"
"  const buyAddress = FieldElement.toHex(event.data[4]);\n"
"  const buyToken = tokensDecimals.find((token) => token.address === buyAddress);\n"
"  const buyAddressDecimals = buyToken?.decimals;\n"
"  if (!buyAddressDecimals) return null; // Skip if buy token is not supported\n"
"\n"
"  const buyAmount = +formatUnits(\n"
"    uint256.uint256ToBN({\n"
"      low: FieldElement.toBigInt(event.data[5]),\n"
"      high: FieldElement.toBigInt(event.data[6]),\n"
"    }),\n"
"    buyAddressDecimals,\n"
"  );\n"
"\n"
"  const beneficiary = FieldElement.toHex(event.data[7]);\n"
"\n"
"  if (header.blockNumber == null) {\n"
"    return null;\n"
"  }\n"
"  console.log(\"FINISHED HANDLING AVNUSWAP EVENT\");\n"
"  const swapData = {\n"
"    exchange: \"avnu-swap\",\n"
"    sell_token: sellAddress,\n"
"    buy_token: buyAddress,\n"
"    pair: `${sellToken?.ticker}-${buyToken?.ticker}`,\n"
"    block_number: +header.blockNumber,\n"
"    block_time: header.timestamp?.seconds?.toString(),\n"
"    timestamp: new Date().toISOString(),\n"
"    transaction_hash: FieldElement.toHex(\n"
"      receipt.transactionHash ?? FieldElement.fromBigInt(BigInt(0)),\n"
"    ),\n"
"    taker_address: takerAddress,\n"
"    sell_amount: sellAmount,\n"
"    buy_amount: buyAmount,\n"
"    beneficiary_address: beneficiary,\n"
"  };\n"
"  try {\n"
"    await MongoDBService.insertSwapData(\"swaps\", swapData);\n"
"    console.log(\"AvnuSwap data saved to MongoDB\");\n"
"  } catch (error) {\n"
"    console.error(\"Failed to save AvnuSwap data to MongoDB\", error);\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-16-apibara.md:280
msgid "Now let's explain the core parts of the code:"
msgstr ""

#: src/ch02-16-apibara.md:282
msgid "Set the apibara streaming client. Here we create an apibara client with the url and the token we got from the apibara dashboard."
msgstr ""

#: src/ch02-16-apibara.md:284
msgid ""
"```typescript\n"
"async function main() {\n"
"  try {\n"
"    // Apibara streaming\n"
"    const client = new StreamClient({\n"
"      url: 'mainnet.starknet.a5a.ch',\n"
"      token: process.env.APIBARA_TOKEN,\n"
"      async onReconnect(err, retryCount) {\n"
"        console.log('reconnect', err, retryCount)\n"
"        // Sleep for 1 second before retrying.\n"
"        await new Promise((resolve) => setTimeout(resolve, 1000))\n"
"\n"
"        return { reconnect: true }\n"
"      },\n"
"    })\n"
"\n"
"```"
msgstr ""

#: src/ch02-16-apibara.md:302
msgid "Have in mind that the url is the mainnet url, but you can also use the testnet url."
msgstr ""

#: src/ch02-16-apibara.md:310
msgid "Get the latest block number. We will use the latest block number to set the cursor of the apibara client."
msgstr ""

#: src/ch02-16-apibara.md:321
msgid "Set the filter. This is the key part where we indicate to the apibara client what we want to listen to. In this case, we want to listen to the swaps events happening on the AVNU swap contract."
msgstr ""

#: src/ch02-16-apibara.md:324
msgid ""
"```typescript\n"
"const key = FieldElement.fromBigInt(\n"
"  BigInt(\"0xe316f0d9d2a3affa97de1d99bb2aac0538e2666d0d8545545ead241ef0ccab\"),\n"
");\n"
"const address = FieldElement.fromBigInt(\n"
"  BigInt(\"0x04270219d365d6b017231b52e92b3fb5d7c8378b05e9abc97724537a80e93b0f\"),\n"
");\n"
"const filter_test = Filter.create()\n"
"  .withHeader({ weak: false })\n"
"  .addEvent((ev) => ev.withFromAddress(address).withKeys([key]))\n"
"  .encode();\n"
"```"
msgstr ""

#: src/ch02-16-apibara.md:337
msgid "Configure the apibara client. Here we set the filter, the batch size, and the cursor."
msgstr ""

#: src/ch02-16-apibara.md:347
msgid "Start listening to the messages. Here we listen to the messages and handle the events."
msgstr ""

#: src/ch02-16-apibara.md:349
msgid ""
"```typescript\n"
"for await (const message of client) {\n"
"  switch (message.message) {\n"
"    case \"data\": {\n"
"      if (!message.data?.data) {\n"
"        continue;\n"
"      }\n"
"      for (const data of message.data.data) {\n"
"        const block = v1alpha2.Block.decode(data);\n"
"        const { header, events, transactions } = block;\n"
"        if (!header || !transactions) {\n"
"          continue;\n"
"        }\n"
"        for (const event of events) {\n"
"          console.log(event);\n"
"          if (event.event && event.receipt) {\n"
"            handleEventAvnuSwap(header, event.event, event.receipt);\n"
"          }\n"
"        }\n"
"      }\n"
"      break;\n"
"    }\n"
"    case \"invalidate\": {\n"
"      break;\n"
"    }\n"
"    case \"heartbeat\": {\n"
"      console.log(\"Received heartbeat\");\n"
"      break;\n"
"    }\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-16-apibara.md:382
msgid "Handling the events. Here we handle the events and save the swaps data to a MongoDB."
msgstr ""

#: src/ch02-16-apibara.md:384
msgid ""
"```typescript\n"
"async function handleEventAvnuSwap(\n"
"  header: v1alpha2.IBlockHeader,\n"
"  event: v1alpha2.IEvent,\n"
"  receipt: v1alpha2.ITransactionReceipt,\n"
") {\n"
"  console.log(\"STARTING TO HANDLE AVNUSWAP EVENT\");\n"
"  if (!event.data) return null;\n"
"\n"
"  const takerAddress = FieldElement.toHex(event.data[0]);\n"
"  const sellAddress = FieldElement.toHex(event.data[1]);\n"
"\n"
"  //...\n"
"  //Parse the data\n"
"  //...\n"
"\n"
"  console.log(\"FINISHED HANDLING AVNUSWAP EVENT\");\n"
"  const swapData = {\n"
"    exchange: \"avnu-swap\",\n"
"    sell_token: sellAddress,\n"
"    buy_token: buyAddress,\n"
"    pair: `${sellToken?.ticker}-${buyToken?.ticker}`,\n"
"    block_number: +header.blockNumber,\n"
"    block_time: header.timestamp?.seconds?.toString(),\n"
"    timestamp: new Date().toISOString(),\n"
"    transaction_hash: FieldElement.toHex(\n"
"      receipt.transactionHash ?? FieldElement.fromBigInt(BigInt(0)),\n"
"    ),\n"
"    taker_address: takerAddress,\n"
"    sell_amount: sellAmount,\n"
"    buy_amount: buyAmount,\n"
"    beneficiary_address: beneficiary,\n"
"  };\n"
"  try {\n"
"    await MongoDBService.insertSwapData(\"swaps\", swapData);\n"
"    console.log(\"AvnuSwap data saved to MongoDB\");\n"
"  } catch (error) {\n"
"    console.error(\"Failed to save AvnuSwap data to MongoDB\", error);\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/ch02-16-apibara.md:426
msgid "If you want to get the full code, you can find it [here](https://github.com/starknet-edu/starknetbook/tree/main/examples/apibara-example/apibara-server)."
msgstr ""

#: src/ch02-16-apibara.md:428
msgid "Run the server"
msgstr ""

#: src/ch02-16-apibara.md:430
msgid ""
"To run the server, you will need to have a MongoDB running. You can use a local MongoDB or a cloud MongoDB like [MongoDB Atlas](https://www.mongodb.com/cloud/atlas). Remember to replace the "
"`MONGODB_URI` with your MongoDB URI."
msgstr ""

#: src/ch02-16-apibara.md:434
msgid "\"mongodb:xxx\""
msgstr ""

#: src/ch02-16-apibara.md:437
#, fuzzy
msgid "To run the server, you can use the following command:"
msgstr "è¦åˆå§‹åŒ–æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch02-16-apibara.md:443
msgid "Lets see it in action"
msgstr ""

#: src/ch02-16-apibara.md:445
msgid ""
"No that we have apibara streaming the swap objects into our MongoDB, we can build a frontend to display the swaps in real-time. Please see the example in [here](https://github.com/starknet-edu/"
"starknetbook/tree/main/examples/apibara-example/apibara-frontend)"
msgstr ""

#: src/ch02-16-apibara.md:448
msgid "Since, this go out of the scope of this book, we will not cover the frontend part."
msgstr ""

#: src/ch02-16-apibara.md:450
msgid "Deployed real-time swaps dashboard"
msgstr ""

#: src/ch02-16-apibara.md:452
msgid "This example is deployed [here](https://miniswapscan.vercel.app/)."
msgstr ""

#: src/ch02-16-apibara.md:456
msgid ""
"This is a simple example of how to use apibara to listen to swaps happening on AVNU in real-time. You can index your NFT collection, listen to swaps, or any other event you are interested in and build "
"a frontend to display the data in real-time."
msgstr ""

#: src/ch02-16-apibara.md:459 src/ch03-02-01-madara.md:468 src/ch03-02-01-madara.md:586 src/ch03-02-01-madara.md:597 src/ch03-02-01-madara.md:626
#, fuzzy
msgid "Resources"
msgstr "## å­¦ä¹ èµ„æ–™"

#: src/ch02-16-apibara.md:461
msgid "[Apibara Example Workshop](https://www.youtube.com/watch?v=XCxAvuutks4&t=428s&ab_channel=StarkWare)"
msgstr ""

#: src/ch03-00-architecture.md:3
msgid "This is an introduction to Starknetâ€™s Layer 2 architecture,"
msgstr ""

#: src/ch03-00-architecture.md:5
#, fuzzy
msgid ""
"Starknet is a coordinated system, with each componentâ€”Sequencers, Provers, and nodesâ€”playing a specific yet interconnected role. Although Starknet hasnâ€™t fully decentralized yet, itâ€™s actively moving "
"toward that goal. This understanding of the roles and interactions within the system will help you better grasp the intricacies of the Starknet ecosystem."
msgstr ""
"Starknetæ˜¯ä¸€ä¸ªåè°ƒçš„ç³»ç»Ÿï¼Œæ¯ä¸ªç»„æˆéƒ¨åˆ†--åºåˆ—å™¨ã€ä¼ æ’­è€…å’ŒèŠ‚ç‚¹--éƒ½æ‰®æ¼”ç€ç‰¹å®šè€Œåˆç›¸äº’å…³è”çš„è§’è‰²ã€\n"
"è¯æ˜è€…å’ŒèŠ‚ç‚¹éƒ½æ‰®æ¼”ç€ç‰¹å®šä½†åˆç›¸äº’å…³è”çš„è§’è‰²ã€‚è™½ç„¶\n"
"Starknet è¿˜æ²¡æœ‰å®Œå…¨å»ä¸­å¿ƒåŒ–ï¼Œä½†å®ƒæ­£ç§¯æåœ°å‘è¿™ä¸ªç›®æ ‡è¿ˆè¿›ã€‚\n"
"è¿™ä¸€ç›®æ ‡ã€‚é€šè¿‡äº†è§£ç³»ç»Ÿå†…çš„è§’è‰²å’Œäº¤äº’å…³ç³»\n"
"ç³»ç»Ÿå†…çš„è§’è‰²å’Œäº¤äº’çš„äº†è§£ï¼Œå°†æœ‰åŠ©äºæ‚¨æ›´å¥½åœ°æŒæ¡Starkneté”™ç»¼å¤æ‚çš„\n"
"ç”Ÿæ€ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚"

#: src/ch03-00-architecture.md:12
#, fuzzy
msgid "High-Level Overview"
msgstr "## é«˜çº§æ¦‚è¿°"

#: src/ch03-00-architecture.md:14
#, fuzzy
msgid ""
"Starknetâ€™s operation begins when a transaction is received by a gateway, which serves as the Mempool. This stage could also be managed by the Sequencer. The transaction is initially marked as "
"\"RECEIVED.\" The Sequencer then incorporates the transaction into the network state and tags it as \"ACCEPTED_ON_L2.\" The final step involves the Prover, which executes the operating system on the "
"new block, calculates its proof, and submits it to the Layer 1 (L1) for verification."
msgstr ""
"å½“ç½‘å…³æ¥æ”¶åˆ°ä¸€ç¬”äº¤æ˜“æ—¶ï¼ŒStarknetçš„è¿è¡Œå°±å¼€å§‹äº†ã€\n"
"ç½‘å…³å……å½“ Mempoolã€‚è¿™ä¸ªé˜¶æ®µä¹Ÿå¯ä»¥ç”±\n"
"åºåˆ—å™¨ç®¡ç†ã€‚äº‹åŠ¡æœ€åˆè¢«æ ‡è®°ä¸º \"å·²æ¥æ”¶\"ã€‚ç„¶å\n"
"ç„¶åï¼Œå®šåºå™¨å°†äº‹åŠ¡çº³å…¥ç½‘ç»œçŠ¶æ€ï¼Œå¹¶æ ‡è®°ä¸º \"ACCEPTED_ON_L2\"ã€‚\n"
"æ ‡è®°ä¸º \"ACCEPTED_ON_L2\"ã€‚æœ€åä¸€æ­¥æ¶‰åŠéªŒè¯å™¨ï¼Œå®ƒ\n"
"åœ¨æ–°åŒºå—ä¸Šæ‰§è¡Œæ“ä½œç³»ç»Ÿï¼Œè®¡ç®—å…¶è¯æ˜ã€\n"
"å¹¶æäº¤ç»™ç¬¬ä¸€å±‚ (L1) è¿›è¡ŒéªŒè¯ã€‚"

#: src/ch03-00-architecture.md:24
#, fuzzy
msgid "Starknet architecture"
msgstr "# æ¶æ„"

#: src/ch03-00-architecture.md:26
#, fuzzy
msgid "In essence, Starknetâ€™s architecture involves multiple components:"
msgstr "ä»æœ¬è´¨ä¸Šè®²ï¼ŒStarknetçš„æ¶æ„æ¶‰åŠå¤šä¸ªç»„æˆéƒ¨åˆ†ï¼š"

#: src/ch03-00-architecture.md:28
msgid "The Sequencer is responsible for receiving transactions, ordering them, and producing blocks. It operates similarly to validators in Ethereum or Bitcoin."
msgstr ""

#: src/ch03-00-architecture.md:32
msgid ""
"The Prover is tasked with generating proofs for the created blocks and transactions. It uses Cairoâ€™s Virtual Machine to run provable programs, thereby creating execution traces necessary for "
"generating STARK proofs."
msgstr ""

#: src/ch03-00-architecture.md:37
msgid "Layer 1 (L1), in this case Ethereum, hosts a smart contract capable of verifying these STARK proofs. If the proofs are valid, Starknetâ€™s state root on L1 is updated."
msgstr ""

#: src/ch03-00-architecture.md:41
#, fuzzy
msgid "Starknetâ€™s state is a comprehensive snapshot maintained through Merkle trees, much like in Ethereum. This establishes the architecture of the validity roll-up and the roles of each component."
msgstr ""
"Starknetçš„çŠ¶æ€æ˜¯é€šè¿‡ Merkle\n"
"æ ‘ç»´æŠ¤çš„ç»¼åˆå¿«ç…§ï¼Œè¿™ä¸ä»¥å¤ªåŠéå¸¸ç›¸ä¼¼ã€‚è¿™å°±ç¡®ç«‹äº†\n"
"çš„æ¶æ„ä»¥åŠæ¯ä¸ªç»„ä»¶çš„ä½œç”¨ã€‚"

#: src/ch03-00-architecture.md:45
#, fuzzy
msgid "For a more in-depth look at each component, read on."
msgstr "å¦‚éœ€æ›´æ·±å…¥åœ°äº†è§£æ¯ä¸ªç»„ä»¶ï¼Œè¯·ç»§ç»­é˜…è¯»ã€‚"

#: src/ch03-00-architecture.md:47
#, fuzzy
msgid "After exploring the introductory overview of the different components, delve deeper into their specific roles by referring to their dedicated subchapters in this Chapter."
msgstr ""
"åœ¨äº†è§£äº†ä¸åŒç»„ä»¶çš„ä»‹ç»æ€§æ¦‚è¿°ä¹‹åã€\n"
"æ·±å…¥äº†è§£å®ƒä»¬çš„å…·ä½“ä½œç”¨åï¼Œè¯·å‚é˜…æœ¬ç« ä¸­çš„ä¸“\n"
"ç« ï¼Œæ·±å…¥äº†è§£å®ƒä»¬çš„å…·ä½“ä½œç”¨ã€‚"

#: src/ch03-00-architecture.md:53
#, fuzzy
msgid "Sequencers are the backbone of the Starknet network, akin to Ethereumâ€™s validators. They usher transactions into the system."
msgstr ""
"åºåˆ—å™¨æ˜¯ Starknet ç½‘ç»œçš„æ”¯æŸ±ï¼Œç±»ä¼¼äºä»¥å¤ªåŠçš„\n"
"éªŒè¯å™¨ã€‚å®ƒä»¬å°†äº¤æ˜“å¼•å…¥ç³»ç»Ÿã€‚"

#: src/ch03-00-architecture.md:56
#, fuzzy
msgid ""
"Validity rollups excel at offloading some network chores, like bundling and processing transactions, to specialized players. This setup is somewhat like how Ethereum and Bitcoin delegate security to "
"miners. Sequencing, like mining, demands hefty resources."
msgstr ""
"æœ‰æ•ˆæœŸæ»šåŠ¨åŠŸèƒ½æ“…é•¿äºå¸è½½ä¸€äº›ç½‘ç»œæ‚åŠ¡ï¼Œå¦‚æ†ç»‘å’Œå¤„ç†äº¤æ˜“ã€‚\n"
"å’Œå¤„ç†äº¤æ˜“ç­‰å·¥ä½œã€‚è¿™ç§è®¾ç½®\n"
"æœ‰ç‚¹åƒä»¥å¤ªåŠå’Œæ¯”ç‰¹å¸å°†å®‰å…¨æ€§å§”æ‰˜ç»™çŸ¿å·¥çš„æ–¹å¼ã€‚\n"
"æ’åºå’ŒæŒ–çŸ¿ä¸€æ ·ï¼Œéƒ½éœ€è¦å¤§é‡èµ„æºã€‚"

#: src/ch03-00-architecture.md:61
#, fuzzy
msgid ""
"For networks like Starknet and other platforms utilizing Validity rollups, a similar parallel is drawn. These networks outsource transaction processing to specialized entities and then verify their "
"work. These specialized entities in the context of Validity rollups are known as \"Sequencers.\""
msgstr ""
"å¯¹äºåƒ Starknet è¿™æ ·çš„ç½‘ç»œå’Œå…¶ä»–åˆ©ç”¨ Validity\n"
"rollupsçš„ç½‘ç»œä¹Ÿæœ‰ç±»ä¼¼çš„æƒ…å†µã€‚è¿™äº›ç½‘ç»œå°†\n"
"è¿™äº›ç½‘ç»œå°†äº¤æ˜“å¤„ç†å¤–åŒ…ç»™ä¸“é—¨çš„å®ä½“ï¼Œç„¶åå¯¹å…¶å·¥ä½œè¿›è¡ŒéªŒè¯ã€‚\n"
"å·¥ä½œã€‚åœ¨æœ‰æ•ˆæœŸæ»šåŠ¨çš„èƒŒæ™¯ä¸‹ï¼Œè¿™äº›ä¸“ä¸šå®ä½“è¢«ç§°ä¸º \"åºåˆ—å™¨\"ã€‚\n"
"ç§°ä¸º \"æ’åºå™¨\"ã€‚"

#: src/ch03-00-architecture.md:67
#, fuzzy
msgid ""
"Instead of providing security, as miners do, Sequencers provide transaction capacity. They order (sequence) multiple transactions into a single batch, executes them, and produce a block that will "
"later be proved by the Prover and submmited to the Layer 1 network as a single, compact proof, known as a \"rollup.\" In other words, just as validators in Ethereum and miners in Bitcoin are "
"specialized actors securing the network, Sequencers in Validity rollup-based networks are specialized actors that provide transaction capacity."
msgstr ""
"åºåˆ—å™¨å¹¶ä¸åƒçŸ¿å·¥é‚£æ ·æä¾›å®‰å…¨æ€§ï¼Œè€Œæ˜¯æä¾›\n"
"äº¤æ˜“å®¹é‡ã€‚å®ƒä»¬å°†å¤šä¸ªäº¤æ˜“æ’åº\n"
"æ‰§è¡Œï¼Œå¹¶äº§ç”Ÿä¸€ä¸ªåŒºå—ï¼Œè¯¥åŒºå—éšåå°†è¢«è¯æ˜è€…è¯æ˜ï¼Œå¹¶ä½œä¸ºä¸€ä¸ªå•ä¸€çš„ã€å­æäº¤ç»™ç¬¬ä¸€å±‚ç½‘ç»œã€‚\n"
"ç”±è¯æ˜è€…è¯æ˜ï¼Œå¹¶ä½œä¸ºä¸€ä¸ªå•ä¸€çš„ç´§å‡‘è¯æ˜å‘å¸ƒåˆ°ç¬¬ä¸€å±‚ç½‘ç»œã€\n"
"ç´§å‡‘çš„è¯æ˜ï¼Œå³ \"å·ç§¯\"ã€‚æ¢å¥è¯è¯´ï¼Œå°±åƒ\n"
"å’Œæ¯”ç‰¹å¸çš„çŸ¿å·¥ä¸€æ ·ï¼Œéƒ½æ˜¯ç¡®ä¿ç½‘ç»œå®‰å…¨çš„ä¸“ä¸šäººå‘˜ã€‚\n"
"ç½‘ç»œï¼ŒåŸºäºæœ‰æ•ˆæ€§å·ç§¯çš„ç½‘ç»œä¸­çš„æ’åºå™¨ä¹Ÿæ˜¯æä¾›äº¤æ˜“èƒ½åŠ›çš„ä¸“é—¨è§’è‰²ã€‚\n"
"æä¾›äº¤æ˜“èƒ½åŠ›ã€‚"

#: src/ch03-00-architecture.md:76
#, fuzzy
msgid ""
"This mechanism allows Validity (or ZK) rollups to handle a higher volume of transactions while maintaining the security of the underlying Ethereum network. It enhances scalability without compromising "
"on security."
msgstr ""
"è¿™ç§æœºåˆ¶å…è®¸æœ‰æ•ˆæ€§ï¼ˆæˆ– ZKï¼‰å·ç§¯å¤„ç†æ›´å¤šçš„äº¤æ˜“é‡ï¼ŒåŒæ—¶ä¿æŒåº•å±‚çš„å®‰å…¨æ€§ã€‚\n"
"äº¤æ˜“é‡ï¼ŒåŒæ—¶ç»´æŠ¤åº•å±‚\n"
"ä»¥å¤ªåŠç½‘ç»œçš„å®‰å…¨æ€§ã€‚å®ƒåœ¨ä¸å½±å“\n"
"å®‰å…¨æ€§ã€‚"

#: src/ch03-00-architecture.md:81
#, fuzzy
msgid "Sequencers follow a systematic method for transaction processing:"
msgstr "æ’åºå™¨é‡‡ç”¨ç³»ç»ŸåŒ–æ–¹æ³•è¿›è¡Œäº‹åŠ¡å¤„ç†ï¼š"

#: src/ch03-00-architecture.md:83
msgid "Sequencing: They collect transactions from users and order (sequence) them."
msgstr ""

#: src/ch03-00-architecture.md:86
msgid "Executing: Sequencers then process these transactions."
msgstr ""

#: src/ch03-00-architecture.md:88
msgid "Batching: Transactions are grouped together in batches or blocks for efficiency."
msgstr ""

#: src/ch03-00-architecture.md:91
msgid "Block Production: Sequencers produce blocks that contain batches of processed transactions."
msgstr ""

#: src/ch03-00-architecture.md:94
#, fuzzy
msgid ""
"Sequencers must be reliable and highly available, as their role is critical to the networkâ€™s smooth functioning. They need powerful and well-connected machines to perform their role effectively, as "
"they must process transactions rapidly and continuously."
msgstr ""
"ç¼–è§£ç å™¨å¿…é¡»å¯é ä¸”å¯ç”¨æ€§é«˜ï¼Œå› ä¸ºå®ƒä»¬çš„ä½œç”¨å¯¹ç½‘ç»œçš„å¹³ç¨³è¿è¡Œè‡³å…³é‡è¦ã€‚\n"
"å¯¹ç½‘ç»œçš„å¹³ç¨³è¿è¡Œè‡³å…³é‡è¦ã€‚å®ƒä»¬éœ€è¦åŠŸèƒ½å¼ºå¤§ã€è¿æ¥è‰¯å¥½çš„\n"
"çš„æœºå™¨æ‰èƒ½æœ‰æ•ˆå‘æŒ¥ä½œç”¨ï¼Œå› ä¸ºå®ƒä»¬å¿…é¡»\n"
"å¿«é€Ÿã€è¿ç»­åœ°å¤„ç†äº¤æ˜“ã€‚"

#: src/ch03-00-architecture.md:99
#, fuzzy
msgid ""
"The current roadmap for Starknet includes decentralizing the Sequencer role. This shift towards decentralization will allow more participants to become Sequencers, contributing to the robustness of "
"the network."
msgstr ""
"Starknet å½“å‰çš„å‘å±•è“å›¾åŒ…æ‹¬ä¸‹æ”¾åºåˆ—å™¨è§’è‰²ã€‚\n"
"è§’è‰²ã€‚è¿™ç§å»ä¸­å¿ƒåŒ–çš„è½¬å˜å°†ä½¿æ›´å¤šçš„å‚ä¸è€…\n"
"æˆä¸ºåºåˆ—å‘˜ï¼Œä»è€Œå¢å¼ºç½‘ç»œçš„ç¨³å¥æ€§ã€‚"

#: src/ch03-00-architecture.md:103
#, fuzzy
msgid "For more details in the Sequencer role, refer to the dedicated subchapter in this Chapter."
msgstr ""
"æœ‰å…³åºåˆ—å™¨è§’è‰²çš„æ›´å¤šè¯¦æƒ…ï¼Œè¯·å‚é˜…æœ¬ç« ä¸­ä¸“é—¨çš„\n"
"å­ç« èŠ‚ã€‚"

#: src/ch03-00-architecture.md:106 src/ch03-03-provers.md:1
#, fuzzy
msgid "Provers"
msgstr "è¯æ˜å™¨ ğŸš§"

#: src/ch03-00-architecture.md:108
#, fuzzy
msgid ""
"Provers serve as the second line of verification in the Starknet network. Their main task is to validate the work of the Sequencers (when they receive the block produced by the Sequencer) and to "
"generate proofs that these processes were correctly performed."
msgstr ""
"éªŒè¯å™¨æ˜¯Starknetçš„ç¬¬äºŒé“éªŒè¯å…³å¡ã€‚\n"
"ç½‘ç»œçš„ç¬¬äºŒé“éªŒè¯çº¿ã€‚å®ƒä»¬çš„ä¸»è¦ä»»åŠ¡æ˜¯éªŒè¯åºåˆ—å™¨çš„å·¥ä½œï¼ˆå½“å®ƒä»¬æ”¶åˆ°åºåˆ—å™¨ç”Ÿæˆçš„åŒºå—æ—¶\n"
"æ—¶ï¼‰éªŒè¯åºåˆ—å™¨çš„å·¥ä½œï¼Œå¹¶ç”Ÿæˆè¯æ˜ï¼Œè¯æ˜è¿™äº›è¿‡ç¨‹æ˜¯æ­£ç¡®æ‰§è¡Œçš„ã€‚\n"
"è¯æ˜è¿™äº›è¿‡ç¨‹çš„æ­£ç¡®æ€§ã€‚"

#: src/ch03-00-architecture.md:113
#, fuzzy
msgid "The duties of a Prover include:"
msgstr "Prover çš„èŒè´£åŒ…æ‹¬"

#: src/ch03-00-architecture.md:115
msgid "Receiving Blocks: Provers obtain blocks of processed transactions from Sequencers."
msgstr ""

#: src/ch03-00-architecture.md:118
msgid "Processing: Provers process these blocks a second time, ensuring that all transactions within the block have been correctly handled."
msgstr ""

#: src/ch03-00-architecture.md:121
msgid "Proof Generation: After processing, Provers generate a proof of correct transaction processing."
msgstr ""

#: src/ch03-00-architecture.md:124
msgid "Sending Proof to Ethereum: Finally, the proof is sent to the Ethereum network for validation. If the proof is correct, the Ethereum network accepts the block of transactions."
msgstr ""

#: src/ch03-00-architecture.md:128
#, fuzzy
msgid ""
"Provers need even more computational power than Sequencers because they have to calculate and generate proofs, a process that is computationally heavy. However, the work of Provers can be split into "
"multiple parts, allowing for parallelism and efficient proof generation. The proof generation process is asynchronous, meaning it doesnâ€™t have to occur immediately or in real-time. This flexibility "
"allows for the workload to be distributed among multiple Provers. Each Prover can work on a different block, allowing for parallelism and efficient proof generation."
msgstr ""
"è¯æ˜è€…æ‰€éœ€çš„è®¡ç®—èƒ½åŠ›ç”šè‡³æ¯”åºåˆ—å‘ç”Ÿå™¨è¿˜é«˜ï¼Œå› ä¸ºå®ƒä»¬\n"
"å› ä¸ºå®ƒä»¬å¿…é¡»è®¡ç®—å’Œç”Ÿæˆè¯æ˜ï¼Œè€Œè¿™æ˜¯ä¸€ä¸ªè®¡ç®—é‡å¾ˆå¤§çš„è¿‡ç¨‹ã€‚\n"
"ç¹é‡ã€‚ä¸è¿‡ï¼Œè¯æ˜è€…çš„å·¥ä½œå¯ä»¥åˆ†æˆå¤šä¸ªéƒ¨åˆ†ã€\n"
"è¿™æ ·å°±å¯ä»¥å¹¶è¡Œé«˜æ•ˆåœ°ç”Ÿæˆè¯æ˜ã€‚è¯æ˜\n"
"ç”Ÿæˆè¿‡ç¨‹æ˜¯å¼‚æ­¥çš„ï¼Œè¿™æ„å‘³ç€å®ƒä¸å¿…ç«‹å³æˆ–å®æ—¶è¿›è¡Œã€‚\n"
"ç«‹å³æˆ–å®æ—¶è¿›è¡Œã€‚è¿™ç§çµæ´»æ€§å…è®¸\n"
"åˆ†é…ç»™å¤šä¸ªè¯æ˜è€…ã€‚æ¯ä¸ªè¯æ˜è€…å¯ä»¥å¤„ç†\n"
"ä¸åŒçš„åŒºå—ï¼Œä»è€Œå®ç°å¹¶è¡Œå’Œé«˜æ•ˆçš„è¯æ˜\n"
"ç”Ÿæˆã€‚"

#: src/ch03-00-architecture.md:138
#, fuzzy
msgid "The design of Starknet relies on these two types of actors â€” Sequencers and Provers â€” working in tandem to ensure efficient processing and secure verification of transactions."
msgstr ""
"Starknetçš„è®¾è®¡ä¾èµ–äºè¿™ä¸¤ç±»è¡ŒåŠ¨è€…--ç¼–æ’å™¨å’Œè¯æ˜å™¨--çš„ååŒå·¥ä½œï¼Œä»¥ç¡®ä¿é«˜æ•ˆçš„å¤„ç†å’ŒéªŒè¯ã€‚\n"
"å’Œè¯æ˜è€…ååŒå·¥ä½œï¼Œä»¥ç¡®ä¿é«˜æ•ˆå¤„ç†å’Œå®‰å…¨éªŒè¯äº¤æ˜“ã€‚\n"
"äº¤æ˜“çš„å®‰å…¨éªŒè¯ã€‚"

#: src/ch03-00-architecture.md:142
#, fuzzy
msgid "For more details in the Prover role, refer to the dedicated subchapter in this Chapter."
msgstr ""
"æœ‰å…³ Prover è§’è‰²çš„æ›´å¤šè¯¦æƒ…ï¼Œè¯·å‚é˜…æœ¬ç« çš„ä¸“é—¨å­ç« \n"
"å­ç« èŠ‚ã€‚"

#: src/ch03-00-architecture.md:145
#, fuzzy
msgid "Optimizing Sequencers and Provers: Debunking Common Misconceptions"
msgstr "## ä¼˜åŒ–åºåˆ—å™¨å’Œæ ¡éªŒå™¨ï¼šæ­ç©¿å¸¸è§è¯¯è§£"

#: src/ch03-00-architecture.md:147
#, fuzzy
msgid ""
"The relationship between Sequencers and Provers in blockchain technology often sparks debate. A common misunderstanding suggests that either the Prover or the Sequencer is the main bottleneck. To set "
"the record straight, letâ€™s discuss the optimization of both components."
msgstr ""
"åŒºå—é“¾æŠ€æœ¯ä¸­çš„åºåˆ—å™¨å’Œè¯æ˜å™¨ä¹‹é—´çš„å…³ç³»\n"
"ç»å¸¸å¼•å‘äº‰è®ºã€‚ä¸€ä¸ªå¸¸è§çš„è¯¯è§£æ˜¯\n"
"è¯æ˜è€…æˆ–åºåˆ—å™¨æ˜¯ä¸»è¦ç“¶é¢ˆã€‚ä¸ºäº†æ¾„æ¸…äº‹å®\n"
"è®©æˆ‘ä»¬æ¥è®¨è®ºä¸€ä¸‹è¿™ä¸¤ä¸ªç»„ä»¶çš„ä¼˜åŒ–é—®é¢˜ã€‚"

#: src/ch03-00-architecture.md:152
#, fuzzy
msgid ""
"Starknet, utilizing the Cairo programming language, currently supports only sequential transactions. Plans are in place to introduce parallel transactions in the future. However, as of now, the "
"Sequencer operates one transaction at a time, making it the bottleneck in the system."
msgstr ""
"Starknetä½¿ç”¨Cairoç¼–ç¨‹è¯­è¨€ï¼Œç›®å‰åªæ”¯æŒé¡ºåºäº‹åŠ¡ã€‚\n"
"ç›®å‰åªæ”¯æŒé¡ºåºäº‹åŠ¡ã€‚è®¡åˆ’åœ¨æœªæ¥å¼•å…¥å¹¶è¡Œ\n"
"å¹¶è¡Œäº‹åŠ¡ã€‚ä¸è¿‡ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œåºåˆ—å‘ç”Ÿå™¨æ¯æ¬¡åªè¿è¡Œä¸€ä¸ªäº‹åŠ¡ï¼Œè¿™ä½¿å®ƒæˆä¸ºç³»ç»Ÿçš„ç“¶é¢ˆã€‚\n"
"ä¸€æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªäº‹åŠ¡ï¼Œæˆä¸ºç³»ç»Ÿçš„ç“¶é¢ˆã€‚"

#: src/ch03-00-architecture.md:157
#, fuzzy
msgid ""
"In contrast, Provers operate asynchronously and can execute multiple tasks in parallel. The use of proof recursion allows for task distribution across multiple machines, making scalability less of an "
"issue for Provers."
msgstr ""
"ç›¸æ¯”ä¹‹ä¸‹ï¼ŒProvers æ˜¯å¼‚æ­¥è¿è¡Œçš„ï¼Œå¯ä»¥å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä»»åŠ¡ã€‚\n"
"ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œã€‚ä½¿ç”¨è¯æ˜é€’å½’å¯ä»¥å°†ä»»åŠ¡\n"
"ä»»åŠ¡åˆ†é…åˆ°å¤šå°æœºå™¨ä¸Šï¼Œä»è€Œå‡å°‘äº†è¯æ˜è€…çš„å¯æ‰©å±•æ€§é—®é¢˜ã€‚\n"
"æ‰©å±•æ€§é—®é¢˜ã€‚"

#: src/ch03-00-architecture.md:162
#, fuzzy
msgid ""
"Given the asynchronous and scalable nature of Provers, focus in Starknet has shifted to enhancing the Sequencerâ€™s efficiency. This explains why current development efforts are primarily aimed at the "
"sequencing side of the equation."
msgstr ""
"é‰´äº Provers çš„å¼‚æ­¥å’Œå¯æ‰©å±•ç‰¹æ€§ï¼ŒStarknet çš„é‡ç‚¹\n"
"çš„é‡ç‚¹å·²è½¬å‘æé«˜åºåˆ—å™¨çš„æ•ˆç‡ã€‚è¿™å°±è§£é‡Šäº†ä¸ºä»€ä¹ˆ\n"
"ç›®å‰çš„å¼€å‘å·¥ä½œä¸»è¦é›†ä¸­åœ¨æ’åºæ–¹é¢ã€‚\n"
"çš„åŸå› ã€‚"

#: src/ch03-00-architecture.md:169
#, fuzzy
msgid ""
"When it comes to defining what nodes do in Bitcoin or Ethereum, people often misinterpret their role as keeping track of every transaction within the network. This, however, is not entirely accurate."
msgstr ""
"åœ¨å®šä¹‰èŠ‚ç‚¹åœ¨æ¯”ç‰¹å¸æˆ–ä»¥å¤ªåŠä¸­çš„ä½œç”¨æ—¶ï¼Œäººä»¬\n"
"å¸¸å¸¸è¢«è¯¯è§£ä¸ºè·Ÿè¸ªç½‘ç»œä¸­çš„æ¯ä¸€ç¬”äº¤æ˜“ã€‚\n"
"ç½‘ç»œä¸­çš„æ¯ä¸€ç¬”äº¤æ˜“ã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸å®Œå…¨å‡†ç¡®ã€‚"

#: src/ch03-00-architecture.md:173
#, fuzzy
msgid ""
"Nodes serve as auditors of the network, maintaining the state of the network, such as how much Bitcoin each participant owns or the current state of a specific smart contract. They accomplish this by "
"processing transactions and preserving a record of all transactions, but thatâ€™s a means to an end, not the end itself."
msgstr ""
"èŠ‚ç‚¹å……å½“ç½‘ç»œçš„å®¡è®¡å‘˜ï¼Œç»´æŠ¤ç½‘ç»œçš„çŠ¶æ€ï¼Œä¾‹å¦‚æ¯ä¸ªå‚ä¸è€…æ‹¥æœ‰å¤šå°‘æ¯”ç‰¹å¸æˆ–å½“å‰çš„æ¯”ç‰¹å¸æ•°é‡ã€‚\n"
"ç½‘ç»œçš„çŠ¶æ€ï¼Œå¦‚æ¯ä¸ªå‚ä¸è€…æ‹¥æœ‰å¤šå°‘æ¯”ç‰¹å¸æˆ–ç‰¹å®šæ™ºèƒ½åˆçº¦çš„å½“å‰\n"
"ç‰¹å®šæ™ºèƒ½åˆçº¦çš„å½“å‰çŠ¶æ€ã€‚å®ƒä»¬é€šè¿‡å¤„ç†\n"
"ä½†è¿™åªæ˜¯è¾¾åˆ°ç›®çš„çš„æ‰‹æ®µï¼Œè€Œä¸æ˜¯ç›®çš„ã€‚\n"
"ä½†è¿™åªæ˜¯è¾¾åˆ°ç›®çš„çš„æ‰‹æ®µï¼Œè€Œä¸æ˜¯ç›®çš„æœ¬èº«ã€‚"

#: src/ch03-00-architecture.md:179
#, fuzzy
msgid ""
"In Validity rollups and specifically within Starknet, this concept is somewhat reversed. Nodes donâ€™t necessarily have to process transactions to get the state. In contrast to Ethereum or Bitcoin, "
"Starknet nodes arenâ€™t required to process all transactions to maintain the state of the network."
msgstr ""
"åœ¨æœ‰æ•ˆæ€§å·ç§¯ä¸­ï¼Œç‰¹åˆ«æ˜¯åœ¨Starknetä¸­ï¼Œè¿™ä¸€æ¦‚å¿µæœ‰ç‚¹ç›¸åã€‚\n"
"æœ‰äº›ç›¸åã€‚èŠ‚ç‚¹ä¸ä¸€å®šè¦å¤„ç†äº¤æ˜“\n"
"æ¥è·å–çŠ¶æ€ã€‚ä¸ä»¥å¤ªåŠæˆ–æ¯”ç‰¹å¸ç›¸æ¯”ï¼ŒStarknet èŠ‚ç‚¹\n"
"å¹¶ä¸éœ€è¦å¤„ç†æ‰€æœ‰äº¤æ˜“æ¥ç»´æŒç½‘ç»œçŠ¶æ€ã€‚\n"
"ç½‘ç»œçŠ¶æ€ã€‚"

#: src/ch03-00-architecture.md:185
#, fuzzy
msgid ""
"There are two main ways to access network state data: via an API gateway or using the RPC protocol to communicate with a node. Operating your own node is typically faster than using a shared "
"architecture, like the gateway. Over time, Starknet plans to deprecate APIs and replace them with a JSON RPC standard, making it even more beneficial to operate your own node."
msgstr ""
"è®¿é—®ç½‘ç»œçŠ¶æ€æ•°æ®æœ‰ä¸¤ç§ä¸»è¦æ–¹å¼ï¼šé€šè¿‡ API ç½‘å…³\n"
"æˆ–ä½¿ç”¨ RPC åè®®ä¸èŠ‚ç‚¹é€šä¿¡ã€‚æ“ä½œè‡ªå·±çš„\n"
"èŠ‚ç‚¹é€šå¸¸æ¯”ä½¿ç”¨å…±äº«æ¶æ„ï¼ˆå¦‚\n"
"ç½‘å…³ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼ŒStarknet è®¡åˆ’æ·˜æ±° APIï¼Œä»£ä¹‹ä»¥\n"
"ä»£ä¹‹ä»¥ JSON RPC æ ‡å‡†ï¼Œä»è€Œä½¿æ“ä½œè‡ªå·±çš„èŠ‚ç‚¹å˜å¾—æ›´åŠ æœ‰åˆ©ã€‚\n"
"è‡ªå·±çš„èŠ‚ç‚¹ã€‚"

#: src/ch03-00-architecture.md:192
#, fuzzy
msgid "Itâ€™s worth noting that encouraging more people to run nodes increases the resilience of the network and prevents server flooding, which has been an issue in networks in other L2s."
msgstr ""
"å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œé¼“åŠ±æ›´å¤šçš„äººè¿è¡ŒèŠ‚ç‚¹å¯ä»¥å¢å¼ºç½‘ç»œçš„å¼¹æ€§ï¼Œé˜²æ­¢æœåŠ¡å™¨æ³›æ»¥ã€‚\n"
"å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œé¼“åŠ±æ›´å¤šçš„äººè¿è¡ŒèŠ‚ç‚¹å¯ä»¥æé«˜ç½‘ç»œçš„å¼¹æ€§ï¼Œé˜²æ­¢æœåŠ¡å™¨æ³›æ´ªï¼Œè€Œè¿™åœ¨å…¶ä»– L2 ç½‘ç»œä¸­ä¸€ç›´æ˜¯ä¸ªé—®é¢˜ã€‚\n"
"åœ¨å…¶ä»–äºŒçº§ç½‘ç»œä¸­ï¼ŒæœåŠ¡å™¨æ³›æ´ªä¸€ç›´æ˜¯ä¸ªé—®é¢˜ã€‚"

#: src/ch03-00-architecture.md:196
#, fuzzy
msgid "Currently, there are primarily three methods for a node to keep track of the networkâ€™s state and we can have nodes implement any of these methods:"
msgstr ""
"ç›®å‰ï¼ŒèŠ‚ç‚¹è·Ÿè¸ªç½‘ç»œçŠ¶æ€çš„æ–¹æ³•ä¸»è¦æœ‰ä¸‰ç§\n"
"æˆ‘ä»¬å¯ä»¥è®©èŠ‚ç‚¹å®ç°å…¶ä¸­ä»»ä½•ä¸€ç§æ–¹æ³•\n"
"æ–¹æ³•ï¼š"

#: src/ch03-00-architecture.md:200
msgid ""
"**Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can take all the transactions and re-execute them. Although this approach is accurate, it isnâ€™t scalable unless you have a powerful "
"machine thatâ€™s capable of handling the load. If you can replay all transactions, you can become a Sequencer."
msgstr ""

#: src/ch03-00-architecture.md:206
msgid "**Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to execute the network correctly. When the Sequencer updates the state and adds a new block, nodes accept the update as accurate."
msgstr ""

#: src/ch03-00-architecture.md:210
msgid ""
"**Checking Proof Validation on L1**: Nodes can monitor the state of the network by observing L1 and ensuring that every time a proof is sent, they receive the updated state. This way, they donâ€™t have "
"to trust anyone and only need to keep track of the latest valid transaction for Starknet."
msgstr ""

#: src/ch03-00-architecture.md:216
#, fuzzy
msgid "Each type of node setup comes with its own set of hardware requirements and trust assumptions."
msgstr ""
"æ¯ç§èŠ‚ç‚¹è®¾ç½®éƒ½æœ‰è‡ªå·±çš„ç¡¬ä»¶è¦æ±‚å’Œä¿¡ä»»å‡è®¾ã€‚\n"
"å’Œä¿¡ä»»å‡è®¾ã€‚"

#: src/ch03-00-architecture.md:219
#, fuzzy
msgid "Nodes That Replay Transactions"
msgstr "#### é‡æ’­äº¤æ˜“çš„èŠ‚ç‚¹"

#: src/ch03-00-architecture.md:221
#, fuzzy
msgid ""
"Nodes that replay transactions require powerful machines to track and execute all transactions. These nodes donâ€™t have trust assumptions; they rely solely on the transactions they execute, "
"guaranteeing that the state at any given point is valid."
msgstr ""
"é‡æ”¾äº‹åŠ¡çš„èŠ‚ç‚¹éœ€è¦åŠŸèƒ½å¼ºå¤§çš„æœºå™¨æ¥è·Ÿè¸ªå’Œæ‰§è¡Œæ‰€æœ‰äº‹åŠ¡ã€‚\n"
"æ‰§è¡Œæ‰€æœ‰äº‹åŠ¡ã€‚è¿™äº›èŠ‚ç‚¹æ²¡æœ‰ä¿¡ä»»å‡è®¾ï¼›å®ƒä»¬\n"
"å®Œå…¨ä¾èµ–äºå®ƒä»¬æ‰§è¡Œçš„äº‹åŠ¡ï¼Œä»¥ä¿è¯ä»»ä½•ç»™å®šç‚¹çš„çŠ¶æ€éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚\n"
"ä»»ä½•ç»™å®šç‚¹çš„çŠ¶æ€éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚"

#: src/ch03-00-architecture.md:226
#, fuzzy
msgid "Nodes That Rely on L2 Consensus"
msgstr "#### ä¾é  L2 å…±è¯†çš„èŠ‚ç‚¹"

#: src/ch03-00-architecture.md:228
#, fuzzy
msgid ""
"Nodes relying on L2 consensus require less computational power. They need sufficient storage to keep the state but donâ€™t need to process a lot of transactions. The trade-off here is a trust "
"assumption. Currently, Starknet revolves around one Sequencer, so these nodes are trusting Starkware not to disrupt the network. However, once a consensus mechanism and leader election amongst "
"Sequencers are in place, these nodes will only need to trust that a Sequencer who staked their stake to produce a block is not willing to lose it."
msgstr ""
"ä¾èµ– L2 å…±è¯†çš„èŠ‚ç‚¹æ‰€éœ€çš„è®¡ç®—èƒ½åŠ›è¾ƒä½ã€‚å®ƒä»¬\n"
"éœ€è¦è¶³å¤Ÿçš„å­˜å‚¨ç©ºé—´æ¥ä¿å­˜çŠ¶æ€ï¼Œä½†ä¸éœ€è¦å¤„ç†å¤§é‡çš„äº‹åŠ¡ã€‚\n"
"å¤§é‡äº‹åŠ¡ã€‚è¿™é‡Œçš„æƒè¡¡å°±æ˜¯ä¿¡ä»»å‡è®¾ã€‚\n"
"ç›®å‰ï¼ŒStarknet å›´ç»•ç€ä¸€ä¸ªåºåˆ—å™¨ï¼Œå› æ­¤è¿™äº›èŠ‚ç‚¹\n"
"å› æ­¤è¿™äº›èŠ‚ç‚¹ç›¸ä¿¡ Starkware ä¸ä¼šç ´åç½‘ç»œã€‚ä½†æ˜¯ï¼Œä¸€æ—¦\n"
"æœºåˆ¶å’Œåºåˆ—å™¨ä¹‹é—´çš„é¢†å¯¼è€…é€‰ä¸¾åˆ°ä½åï¼Œè¿™äº›èŠ‚ç‚¹åªéœ€ç›¸ä¿¡\n"
"èŠ‚ç‚¹å°†åªéœ€è¦ç›¸ä¿¡æŠ¼æ³¨äº§ç”ŸåŒºå—çš„ Sequencer\n"
"ä¸æ„¿æ„å¤±å»å®ƒã€‚"

#: src/ch03-00-architecture.md:237
#, fuzzy
msgid "Nodes That Check Proof Validation on L1"
msgstr "###åœ¨ L1 ä¸Šæ£€æŸ¥è¯æ˜éªŒè¯çš„èŠ‚ç‚¹"

#: src/ch03-00-architecture.md:239
#, fuzzy
msgid ""
"Nodes that only update their state based on proof validation on L1 require the least hardware. They have the same requirements as an Ethereum node, and once Ethereum light nodes become a reality, "
"maintaining such a node could be as simple as using a smartphone. The only trade-off is latency. Proofs are not sent to Ethereum every block but intermittently, resulting in delayed state updates. "
"Plans are in place to produce proofs more frequently, even if they are not sent to Ethereum immediately, allowing these nodes to reduce their latency. However, this development is still a way off in "
"the Starknet roadmap."
msgstr ""
"åªæ ¹æ® L1 ä¸Šçš„è¯æ˜éªŒè¯æ›´æ–°çŠ¶æ€çš„èŠ‚ç‚¹\n"
"çš„èŠ‚ç‚¹æ‰€éœ€çš„ç¡¬ä»¶æœ€å°‘ã€‚å®ƒä»¬ä¸\n"
"ä¸€æ—¦ä»¥å¤ªåŠè½»èŠ‚ç‚¹æˆä¸ºç°å®ã€\n"
"ç»´æŠ¤è¿™æ ·çš„èŠ‚ç‚¹å°±åƒä½¿ç”¨æ™ºèƒ½æ‰‹æœºä¸€æ ·ç®€å•ã€‚å”¯ä¸€çš„\n"
"å”¯ä¸€çš„æƒè¡¡æ˜¯å»¶è¿Ÿã€‚è¯æ˜ä¸æ˜¯æ¯ä¸ªåŒºå—éƒ½å‘é€åˆ°ä»¥å¤ªåŠ\n"
"è€Œæ˜¯æ–­æ–­ç»­ç»­åœ°å‘é€ï¼Œå¯¼è‡´çŠ¶æ€æ›´æ–°å»¶è¿Ÿã€‚è®¡åˆ’\n"
"è®¡åˆ’æ›´é¢‘ç¹åœ°ç”Ÿæˆè¯æ˜ï¼Œå³ä½¿å®ƒä»¬ä¸æ˜¯ç«‹å³å‘é€åˆ°\n"
"ä»¥å¤ªåŠï¼Œä¹Ÿèƒ½è®©è¿™äº›èŠ‚ç‚¹å‡å°‘å»¶è¿Ÿã€‚\n"
"ä¸è¿‡ï¼Œåœ¨ Starknet çš„è·¯çº¿å›¾ä¸­ï¼Œè¿™ä¸€å‘å±•è¿˜é¥é¥æ— æœŸã€‚"

#: src/ch03-00-architecture.md:251
#, fuzzy
msgid ""
"Through this chapter, we delve into Starknetâ€™s structure, uncovering the importance of Sequencers, Provers, and nodes. Each plays a unique role, but together, they create a highly scalable, efficient, "
"and secure network that marks a significant step forward in Layer 2 solutions. As Starknet evolves towards decentralization, understanding these roles will provide valuable insight into the inner "
"workings of this network."
msgstr ""
"åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥ç ”ç©¶Starknetçš„ç»“æ„ï¼Œæ­ç¤ºåºåˆ—å™¨ã€è¯æ˜å™¨å’ŒèŠ‚ç‚¹çš„é‡è¦æ€§ã€‚\n"
"åºåˆ—å™¨ã€è¯æ˜å™¨å’ŒèŠ‚ç‚¹çš„é‡è¦æ€§ã€‚å®ƒä»¬å„è‡ªå‘æŒ¥ç€ç‹¬ç‰¹çš„ä½œç”¨ã€\n"
"ä½†å®ƒä»¬å…±åŒåˆ›å»ºäº†ä¸€ä¸ªé«˜åº¦å¯æ‰©å±•ã€é«˜æ•ˆå’Œå®‰å…¨çš„\n"
"ç½‘ç»œï¼Œæ ‡å¿—ç€ç¬¬ 2 å±‚è§£å†³æ–¹æ¡ˆå‘å‰è¿ˆè¿›äº†ä¸€å¤§æ­¥ã€‚éšç€\n"
"éšç€Starknetå‘å»ä¸­å¿ƒåŒ–å‘å±•ï¼Œäº†è§£è¿™äº›è§’è‰²\n"
"å°†ä¸ºäº†è§£è¯¥ç½‘ç»œçš„å†…éƒ¨è¿ä½œæä¾›å®è´µçš„ä¿¡æ¯ã€‚"

#: src/ch03-00-architecture.md:258
#, fuzzy
msgid "As we venture further into the Starknet universe, our next stop will be an exploration of the transaction lifecycle before we dive into the heart of coding with Cairo."
msgstr ""
"å½“æˆ‘ä»¬è¿›ä¸€æ­¥æ¢ç´¢Starknetä¸–ç•Œæ—¶ï¼Œæˆ‘ä»¬çš„ä¸‹ä¸€ç«™å°†æ˜¯\n"
"æˆ‘ä»¬çš„ä¸‹ä¸€ç«™å°†æ˜¯æ¢ç´¢äº‹åŠ¡ç”Ÿå‘½å‘¨æœŸï¼Œç„¶åå†è¿›å…¥\n"
"ç”¨Cairoç¼–ç çš„æ ¸å¿ƒã€‚"

#: src/ch03-01-transactions.md:1
#, fuzzy
msgid "Transaction Versions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-transactions.md:3
msgid ""
"Understanding Starknet's transaction types is essential to master its architecture and capabilities. Each transaction type serves a unique purpose, and getting a grip on their differences is crucial "
"for proficient Starknet usage."
msgstr ""

#: src/ch03-01-transactions.md:5
#, fuzzy
msgid "Starknet OS: The Backbone"
msgstr "## Starknetå †æ ˆ"

#: src/ch03-01-transactions.md:7
msgid "Central to Starknet's functionality is the Starknet Operating System (OS), a Cairo program that fuels the network. This OS orchestrates key activities, including:"
msgstr ""

#: src/ch03-01-transactions.md:9
#, fuzzy
msgid "Deploying contracts"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch03-01-transactions.md:10
#, fuzzy
msgid "Executing transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-transactions.md:11
msgid "Facilitating L1\\<\\>L2 message exchanges"
msgstr ""

#: src/ch03-01-transactions.md:13
msgid "In Starknet terminology, \"protocol level\" alludes to modifications in the foundational Starknet OS Cairo program, ensuring its steadfastness."
msgstr ""

#: src/ch03-01-transactions.md:15
#, fuzzy
msgid "Transaction Types"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-transactions.md:17
msgid "**Declare Transactions**: Unique in their ability to introduce new classes, leading to potential new smart contracts."
msgstr ""

#: src/ch03-01-transactions.md:18
msgid "**Invoke Transactions**: They call upon an action but can't introduce new ones."
msgstr ""

#: src/ch03-01-transactions.md:19
msgid "**Deploy Account Transactions**: Designed for setting up smart wallet contracts."
msgstr ""

#: src/ch03-01-transactions.md:21
#, fuzzy
msgid "Declare Transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-transactions.md:23
msgid "Declare transactions are the sole mechanism for introducing new smart contracts to Starknet."
msgstr ""

#: src/ch03-01-transactions.md:25
msgid ""
"Recall programming in C++. Before employing a variable or function, it's first 'declared', signaling to the compiler its existence and type. Only then can you 'define' or use it. Declare transactions "
"in Starknet operate on similar principles: they announce a new operation, prepping it for future use."
msgstr ""

#: src/ch03-01-transactions.md:27
msgid "Versions:"
msgstr ""

#: src/ch03-01-transactions.md:29
msgid "V0 - Suited for Cairo 0 contracts before nonces."
msgstr ""

#: src/ch03-01-transactions.md:30
msgid "V1 - Tailored for Cairo 0 with nonces."
msgstr ""

#: src/ch03-01-transactions.md:31
msgid "V2 (current) - Optimized for the modern Cairo contracts."
msgstr ""

#: src/ch03-01-transactions.md:33
msgid "Here's a key distinction to understand between the different Cairo versions:"
msgstr ""

#: src/ch03-01-transactions.md:35
msgid ""
"With Cairo 0, developers sent Cairo Assembly (CASM) code directly to the sequencer. But with the contemporary Cairo version, they send Sierra code to the Sequencer. Breaking it down, Cairo 0 compiled "
"straight to CASM, while the current Cairo version compiles to Sierra, which subsequently compiles to CASM. A crucial difference is that Sierra executions are infallible and always provable, whereas in "
"Cairo 0, transactions could fail. If they did, they became non-provable. The latest Cairo iteration ensures all code compiles to Sierra, making every transaction reliable."
msgstr ""

#: src/ch03-01-transactions.md:37
msgid "When declaring a contract with the latest version, developers are essentially announcing Sierra code, not just raw CASM."
msgstr ""

#: src/ch03-01-transactions.md:39
msgid ""
"Examining the parameters of a V2 transaction reveals measures that ensure the class hash corresponds to the Sierra code being dispatched. The class hash encompasses the hash of the Cairo assembly "
"code, but since developers send Sierra code, it's imperative to ensure that the dispatched code aligns with the indicated class hash."
msgstr ""

#: src/ch03-01-transactions.md:41
msgid "// TODO -> Provide specifics about the parameters included in the transaction."
msgstr ""

#: src/ch03-01-transactions.md:43
msgid "In essence, using the most recent Cairo version implies the utilization of the latest Declare transaction version."
msgstr ""

#: src/ch03-01-transactions.md:45
#, fuzzy
msgid "Invoke Transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-transactions.md:47
msgid ""
"Unlike Declare transactions, Invoke transactions don't add new functions. They ask the network to carry out actions, such as executing or deploying contracts. This method contrasts with Ethereum, "
"where a contract can either be deployed by sending a distinct transaction or by having another smart contract factory to deploy it. Starknet uses only the second method."
msgstr ""

#: src/ch03-01-transactions.md:49
msgid "The Universal Deployer Contract (UDC) in Starknet illustrates this idea. UDC, a public utility, helps deploy contracts. This mirrors how in C++, a declared function is called to perform tasks."
msgstr ""

#: src/ch03-01-transactions.md:51
msgid ""
"In computer science terms, think of how functions operate in C++. After declaring a function or object, you invoke it to take action. Starknet's Invoke transaction works similarly, activating pre-"
"declared contracts or functions."
msgstr ""

#: src/ch03-01-transactions.md:53
msgid ""
"Every Invoke transaction in Starknet undergoes `__validate__` and `__execute__` stages. The `__validate__` step checks the transaction's correctness, similar to a syntax or logic check. After "
"validation, the `__execute__` phase processes the transaction."
msgstr ""

#: src/ch03-01-transactions.md:55
msgid "This two-step process, focusing on utilizing existing functionalities, highlights Starknet's distinct transaction strategy."
msgstr ""

#: src/ch03-01-transactions.md:57
#, fuzzy
msgid "Deploy Account Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-transactions.md:59
msgid ""
"A challenge arises: How do you set up accounts without having one already? When creating your first smart wallet contract, deployment fees arise. How do you cover these without a smart wallet? The "
"solution is deploy account transactions."
msgstr ""

#: src/ch03-01-transactions.md:61
msgid ""
"Uniquely in Starknet, addresses can accept funds even without an associated smart wallet. This trait is pivotal during deployment. Before an account is formally created, the `__validate__` function "
"checks the proposed deployment address (even if it lacks a smart wallet) for sufficient funds. If present, the constructor proceeds, resulting in account deployment. This method guarantees the new "
"account's legitimacy and financial readiness."
msgstr ""

#: src/ch03-01-transactions.md:65
msgid ""
"It's vital to understand each transaction type. Declare transactions stand out for their role in presenting new functions. By likening the process to C++ declarations, developers can grasp the "
"reasoning behind each transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:3
msgid "This chapter outlines the path of a Starknet transaction from its initiation to its finalization."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:5
msgid "Starknet processes transactions in distinct steps:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:7
msgid "A transaction starts by being sent to a gateway, a node, which acts as the Mempool."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:8
msgid "The Sequencer, currently a single service, first validates and then executes the transactions in order."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:9
msgid "If validated successfully, the status becomes RECEIVED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:10
msgid "If not, the status is REJECTED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:11
msgid "Successfully executed transactions are applied to the state and marked as ACCEPTED_ON_L2."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:12
msgid "Failed transactions during this phase are REVERTED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:13
msgid "In the Prover stage, the system operates on the new block, computes its proof, and sends it to L1."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:15
msgid "The following image shows the transaction flow:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:19
msgid "Before exploring each step in-depth, let's clarify the different transaction statuses."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:21
msgid "Each transaction has two primary status types:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:23
msgid "**finality_status**: Reflects the transaction's finality. Possible values are:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:24
msgid "RECEIVED: The transaction passed Mempool validation but hasn't been included in a block."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:25
msgid "ACCEPTED_ON_L2 and ACCEPTED_ON_L1: The transaction was added to a block on L2 or L1, respectively."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:26
msgid "**execution_status**: Indicates the transaction's execution outcome. Values include:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:27
msgid "REJECTED, REVERTED, or SUCCEEDED."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:29
msgid ""
"To obtain this information, query the transaction receipt returned by the Nodes. Refer to the Tooling chapter in the Starknet Book for methods like the `transaction_receipt` command in starkli or the "
"`fetch_transaction_receipt` method in the starknet-py library. We will use these tools throughout this chapter."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:31
#, fuzzy
msgid "Nonces in Starknet"
msgstr "## Starknetä¸­çš„æµ‹åºä»ª"

#: src/ch03-01-01-transactions-lifecycle.md:33
msgid ""
"Initially, Starknet did not incorporate nonces. This omission meant that the same transaction could be sent multiple times with an identical nonce, leading to duplicate hashesâ€”a problem. In Ethereum, "
"nonces not only sequence transactions but also ensure each has a unique hash. Similarly, Starknet employs nonces to assign a distinct hash to every transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:35
msgid ""
"Starknet's current stance on nonces mandates that they be sequential. In other words, when you transmit a transaction from your account, its nonce must precisely follow the previous transaction's "
"nonce."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:37
msgid "Although nonce abstraction would allow developers to manage this logic at the smart contract level, Starknet is reviewing this feature. However, its implementation is not deemed a priority."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:39
#, fuzzy
msgid "Transaction Creation"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-01-transactions-lifecycle.md:41
msgid "A transaction starts with its preparation. The sender:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:43
msgid "Queries their account nonce, which acts as a unique identifier for the transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:44
msgid "Signs the transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:45
msgid "Sends it to their Node."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:47
msgid ""
"The Node, analogous to a post office, receives the transaction and broadcasts it on the Starknet network, primarily to the Sequencer. As the network evolves, the transaction will be broadcasted to "
"multiple Sequencers."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:49
msgid ""
"Before broadcasting the transaction to the Sequencer, the gateways perform a validation step, such as checking that the max fee exceeds a minimum fee and the account's balance is greater than the max "
"fee. The transaction will be saved in the storage if the validation function passes."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:51
#, fuzzy
msgid "The Sequencer's Role"
msgstr "æ’åºå™¨"

#: src/ch03-01-01-transactions-lifecycle.md:53
msgid "On receiving the transaction, the Sequencer acknowledges its receipt but hasn't processed it yetâ€”similar to Ethereum's mempool state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:55
#, fuzzy
msgid "Sequencer's Process:"
msgstr "æ’åºå™¨"

#: src/ch03-01-01-transactions-lifecycle.md:57
msgid "Receive the transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:58
msgid "Validate it."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:59
#, fuzzy
msgid "Execute it."
msgstr "## æ‰§è¡Œ"

#: src/ch03-01-01-transactions-lifecycle.md:60
msgid "Update the state."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:62
msgid ""
"Remember, Starknet processes transactions sequentially. The nonce won't change until the Sequencer processes the transaction. This can complicate backend application development, potentially causing "
"errors if sending multiple transactions consecutively."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:64
msgid "Acceptance on Layer-2 (L2)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:66
msgid ""
"Once the Sequencer validates and executes a transaction, it updates the state without waiting for block creation. The transaction finality status changes from 'RECEIVED' to 'ACCEPTED ON L2' at this "
"stage and the execution status to 'SUCCEEDED'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:68
msgid ""
"Following the state update, the transaction is included in a block. However, the block isn't emitted immediately. The Sequencer decides the opportune moment to emit the block, either when there are "
"enough transactions to form a block or after a certain time has passed. When the block is emitted, the block becomes available for other Nodes to query."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:70
msgid "The transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:72
msgid "Finality status: ACCEPTED_ON_L2"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:73
msgid "Execution status: SUCCEEDED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:75
msgid "If a transaction fails during execution, it will be included in the block with the status 'REVERTED'. In other words, REVERTED transactions"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:77
msgid ""
"It's essential to remember that at this stage, no proof has been generated, and the transaction relies on L2 consensus for security against censorship. There remains a slim possibility of transaction "
"reversal if all Sequencers collude. Therefore, these stages should be seen as different layers of transaction finality."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:79
msgid "Acceptance on Layer-1 (L1)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:81
msgid ""
"The final step in the transaction's lifecycle is its acceptance on Layer-1 (L1). A Prover receives the block containing the transaction, re-executes the block, generates a proof, and sends it to "
"Ethereum. Specifically, the proof is sent to a smart contract on Ethereum called the Verifier smart contract, which checks the proof's validity. If valid, the transaction's status changes to 'accepted "
"on L1', signifying the transaction's security by Ethereum consensus."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:83
msgid "Transaction Status Transition:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:85
msgid "Accepted on L2 -> Accepted on L1"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:87
msgid "\\[Optional\\] Transaction Finality in Starknet"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:89
msgid ""
"Transaction finality refers to the point at which a transaction is considered irreversible and is no longer susceptible to being reversed or undone. It's the assurance that once a transaction is "
"committed, it can't be altered or rolled back, hence securing the integrity of the transaction and the system as a whole."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:91
msgid "Let's dive into the transaction finality in both Starknet and Ethereum, and how they compare."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:93
#, fuzzy
msgid "Ethereum Transaction Finality"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-01-transactions-lifecycle.md:95
msgid ""
"Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A transaction has the finality status when it is part of a block that can't change without a significant amount of ETH getting burned. "
"The number of blocks required to ensure that a transaction won't be rolled back is called 'blocks to finality', and the time to create those blocks is called 'time to finality'."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:97
msgid "It is considered to be an average of 6 blocks to reach the finality status; given that a new block is validated each 12 seconds, the average time to finality for a transaction is 75 seconds."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:99
#, fuzzy
msgid "Starknet Transaction Finality"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-01-transactions-lifecycle.md:101
msgid ""
"Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction finality process. The first step is when the transaction gets accepted on Layer-2 (Starknet), and the second step is when the "
"transaction gets accepted on Layer-1 (Ethereum)."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:103
msgid ""
"Accepted on L2: When a transaction is processed by the Sequencer and included in a block on Starknet, it reaches L2 finality. However, this finality relies on the L2 consensus and comes with a slight "
"risk of collusion among Sequencers leading to transaction reversal. Accepted on L1: The absolute finality comes when the block containing the transaction gets a proof generated, the proof is validated "
"by the Verifier contract on Ethereum, and the state is updated on Ethereum. At this point, the transaction is as secure as the Ethereum's PoS consensus can provide, meaning it becomes computationally "
"infeasible to alter or reverse."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:106
#, fuzzy
msgid "Comparison"
msgstr "Cairo æ˜¯ç”± Starkware å‘æ˜çš„ä¸€ç§å¼€æºç¼–ç¨‹è¯­è¨€ã€‚å®ƒæ˜¯ä¸€ç§å›¾çµå®Œå¤‡çš„è¯­è¨€ï¼Œç”¨äºé€šç”¨è®¡ç®—ã€‚å®ƒæ˜¯ä¸€ç§ä½çº§è¯­è¨€ï¼Œæ—¨åœ¨ç¼–è¯‘åˆ°Cairoè™šæ‹Ÿæœºã€‚ç‚¹å‡»æ­¤å¤„äº†è§£æ›´å¤šä¿¡æ¯ï¼š[Cairo](.../theory/cairo.md)ã€‚"

#: src/ch03-01-01-transactions-lifecycle.md:108
msgid "The main difference between Ethereum and Starknet's transaction finality lies in the stages of finality and their reliance on consensus mechanisms."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:110
msgid ""
"Ethereum's transaction finality becomes increasingly unlikely to be reversed as more blocks are added. Starknet's finality process is two-fold. The initial finality (L2) is quicker but relies on L2 "
"consensus and carries a small risk of collusion. The ultimate finality (L1) is slower, as it involves generation and validation of proofs and updates on Ethereum. However, once reached, it provides "
"the same level of security as an Ethereum transaction."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:113
#, fuzzy
msgid "REJECTED Transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch03-01-01-transactions-lifecycle.md:115
msgid ""
"When a transaction passes validation in the Mempool but fails during the sequencer's **validate** phase, it receives the REJECTED status. Such transactions are not included in any block and maintain "
"the `finality_status` as RECEIVED. This rejection can occur for reasons including:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:117
msgid "Check max_fee is higher than the minimal tx cost"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:118
msgid "Check Account balance is at least max_fee"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:119
msgid "Check nonce. A mismatched nonce, where the transaction's nonce doesn't align with the account's expected next nonce."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:120
msgid "Execute **validate** (here a repeated contract declaration will fail and the transaction will be rejected)"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:121
msgid "Limit #txs per account in the Gateway"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:123
msgid "Such transaction will have the following status:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:125
msgid "Finality status: RECEIVED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:126
msgid "Execution status: REJECTED"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:128
msgid "To demonstrate a transaction with an invalid nonce, consider the Python code below (`get_transaction_receipt.py`). Using the `starknet-py` library, it fetches a rejected transaction:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:134
msgid "\"testnet\""
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:139
msgid "\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\""
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:143
#, fuzzy
msgid "Execute the code with:"
msgstr "æ‰§è¡Œå‘½ä»¤åä¼šæ˜¾ç¤ºï¼š"

#: src/ch03-01-01-transactions-lifecycle.md:149
msgid "The resulting transaction receipt will include:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:152
msgid "<TransactionExecutionStatus.REJECTED: 'REJECTED'"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:152
msgid "'RECEIVED'"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:153
msgid "None,"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:154
msgid "0"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:157
msgid "It's important to note that the user isn't charged a fee because the transaction didn't execute in the Sequencer."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:159
#, fuzzy
msgid "Handling of Reverted Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-01-transactions-lifecycle.md:161
msgid "A transaction can be reverted due to failed execution, the transaction will still be included in a block, and the account will be charged for the resources consumed."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:163
msgid ""
"This adds a trust assumption for the Sequencer to be honest and non-censoring. In later versions, there will be an OS change that will enable the Sequencer to prove that a transaction failed and "
"charge the correct amount of gas for it, thus making it censorship-resistant with provably failed transactions."
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:165
#, fuzzy
msgid "Transaction Status Transition"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch03-01-01-transactions-lifecycle.md:167
msgid "Received -> Reverted"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:169
#, fuzzy
msgid "Transaction Lifecycle Summary"
msgstr "äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ"

#: src/ch03-01-01-transactions-lifecycle.md:171
msgid "The following outlines the various steps in a transaction's lifecycle:"
msgstr ""

#: src/ch03-01-01-transactions-lifecycle.md:177
msgid ""
"The lifecycle of a Starknet transaction is a carefully curated journey, ensuring efficient, secure, and transparent transaction processing. It incorporates everything from transaction creation, "
"Sequencer processing, Layer-2 and Layer-1 validation, to handling rejected and reverted transactions. By comprehending this lifecycle, developers and users can better navigate the Starknet ecosystem "
"and leverage its capabilities to the fullest."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:3
#, fuzzy
msgid "**NOTE:** This section is a work in progress. Contributions are welcome."
msgstr "**æ³¨ï¼šæœ¬éƒ¨åˆ†æ­£åœ¨ç¼–å†™ä¸­ã€‚æ¬¢è¿æŠ•ç¨¿ã€‚"

#: src/ch03-01-02-fee-mechanism.md:5
#, fuzzy
msgid "Implementing a fee system enhances Starknet's performance. Without fees, the system risks becoming overwhelmed by numerous transactions, even with optimizations."
msgstr "å®æ–½æ”¶è´¹ç³»ç»Ÿå¯ä»¥æé«˜Starknetçš„æ€§èƒ½ã€‚å¦‚æœä¸æ”¶è´¹ï¼Œå³ä½¿è¿›è¡Œäº†ä¼˜åŒ–ï¼Œç³»ç»Ÿä¹Ÿæœ‰å¯èƒ½è¢«å¤§é‡äº¤æ˜“æ·¹æ²¡ã€‚"

#: src/ch03-01-02-fee-mechanism.md:7
#, fuzzy
msgid "Fee Collection"
msgstr "## æ”¶è´¹"

#: src/ch03-01-02-fee-mechanism.md:9
#, fuzzy
msgid "When a transaction occurs on Layer 2 (L2), Starknet collects the corresponding fee using ERC-20 tokens. The transaction submitter pays the fee, and the sequencer receives it."
msgstr "å½“ç¬¬äºŒå±‚ï¼ˆL2ï¼‰å‘ç”Ÿäº¤æ˜“æ—¶ï¼ŒStarknetå°†ä½¿ç”¨ ERC-20 ä»£å¸æ”¶å–ç›¸åº”çš„è´¹ç”¨ã€‚äº¤æ˜“æäº¤è€…æ”¯ä»˜è´¹ç”¨ï¼Œæ’åºè€…æ¥æ”¶è´¹ç”¨ã€‚"

#: src/ch03-01-02-fee-mechanism.md:11
#, fuzzy
msgid "Fee Calculation"
msgstr "## è´¹ç”¨è®¡ç®—"

#: src/ch03-01-02-fee-mechanism.md:13
#, fuzzy
msgid "Fee Measurement"
msgstr "### è´¹ç”¨æµ‹ç®—"

#: src/ch03-01-02-fee-mechanism.md:15
#, fuzzy
msgid "Currently, fees are denominated in ETH. To determine the expected fee, multiply the transaction's gas estimate by the gas price:"
msgstr "ç›®å‰ï¼Œè´¹ç”¨ä»¥ ETH è®¡ä»·ã€‚è¦ç¡®å®šé¢„æœŸè´¹ç”¨ï¼Œè¯·å°†äº¤æ˜“çš„å¤©ç„¶æ°”ä¼°ç®—å€¼ä¹˜ä»¥å¤©ç„¶æ°”ä»·æ ¼ï¼š"

#: src/ch03-01-02-fee-mechanism.md:21
#, fuzzy
msgid "Fee Computation"
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch03-01-02-fee-mechanism.md:23
#, fuzzy
msgid "To grasp fee computation, understand these terms:"
msgstr "è¦æŒæ¡è´¹ç”¨è®¡ç®—ï¼Œè¯·å…ˆäº†è§£è¿™äº›æœ¯è¯­ï¼š"

#: src/ch03-01-02-fee-mechanism.md:25
msgid "**Built-In**: These are predefined operations in your code, simplifying common tasks or calculations. The following are built-ins:"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:27
msgid ""
"**Cairo Steps**: These building blocks in Cairo facilitate various program operations. Essential for running smart contracts and apps on blockchain platforms, the steps used influence a program's cost "
"and efficiency."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:28
msgid "**Pedersen Hashes**: A method to convert data into a distinct code, similar to a data fingerprint, ensuring data integrity on blockchains."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:29
msgid "**Range Checks**: Safety measures in programs, ensuring numbers or values stay within designated limits to avoid errors."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:30
msgid "**Signature Verifications**: These confirm that a digital signature matches the anticipated one, verifying the sender's authenticity."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:32
msgid "**Weight**: Indicates the significance or cost of an operation, showing how resource-intensive an action is in the program."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:34
#, fuzzy
msgid "Computation"
msgstr "Cairo æ˜¯ç”± Starkware å‘æ˜çš„ä¸€ç§å¼€æºç¼–ç¨‹è¯­è¨€ã€‚å®ƒæ˜¯ä¸€ç§å›¾çµå®Œå¤‡çš„è¯­è¨€ï¼Œç”¨äºé€šç”¨è®¡ç®—ã€‚å®ƒæ˜¯ä¸€ç§ä½çº§è¯­è¨€ï¼Œæ—¨åœ¨ç¼–è¯‘åˆ°Cairoè™šæ‹Ÿæœºã€‚ç‚¹å‡»æ­¤å¤„äº†è§£æ›´å¤šä¿¡æ¯ï¼š[Cairo](.../theory/cairo.md)ã€‚"

#: src/ch03-01-02-fee-mechanism.md:36
#, fuzzy
msgid "In Cairo, each execution trace is divided into distinct slots dedicated to specific built-in components, influencing fee calculation."
msgstr "åœ¨Cairoï¼Œæ¯ä¸ªæ‰§è¡Œè½¨è¿¹éƒ½è¢«åˆ’åˆ†ä¸ºä¸åŒçš„æ—¶æ®µï¼Œä¸“é—¨ç”¨äºå½±å“è´¹ç”¨è®¡ç®—çš„ç‰¹å®šå†…ç½®ç»„ä»¶ã€‚"

#: src/ch03-01-02-fee-mechanism.md:38
#, fuzzy
msgid "Consider a trace containing the following component limits:"
msgstr "è€ƒè™‘åŒ…å«ä»¥ä¸‹åˆ†é‡é™å€¼çš„è½¨è¿¹ï¼š"

#: src/ch03-01-02-fee-mechanism.md:40 src/ch03-01-02-fee-mechanism.md:70
#, fuzzy
msgid "Component"
msgstr "ä¸»è¦ç»„æˆéƒ¨åˆ†ï¼š"

#: src/ch03-01-02-fee-mechanism.md:40
msgid "Limit"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:42
msgid "Cairo Steps"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:42
msgid "200,000,000"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:43
msgid "Pedersen Hashes"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:43
msgid "5,000,000"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:44
msgid "Signature Verifications"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:44
msgid "1,000,000"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:45
msgid "Range Checks"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:45
msgid "2,500,000"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:47
#, fuzzy
msgid "When a component reaches its maximum, the proof is sent to Layer 1. It's imperative to set these component divisions beforehand as they cannot be adjusted dynamically."
msgstr "å½“åˆ†é‡è¾¾åˆ°æœ€å¤§å€¼æ—¶ï¼Œè¯æ˜å°†è¢«å‘é€åˆ°ç¬¬ 1 å±‚ã€‚å¿…é¡»äº‹å…ˆè®¾ç½®è¿™äº›åˆ†é‡ï¼Œå› ä¸ºå®ƒä»¬ä¸èƒ½åŠ¨æ€è°ƒæ•´ã€‚"

#: src/ch03-01-02-fee-mechanism.md:49
#, fuzzy
msgid ""
"Assuming a transaction utilizes 10,000 Cairo steps and 500 Pedersen hashes, it could accommodate 40,000 such transactions in this trace (given the calculation 20,000,000/500). The gas price becomes "
"1/40,000 of the proof submission cost. In this instance, the number of Cairo steps isn't the constraining factor, so it isn't factored into our performance estimate."
msgstr ""
"å‡è®¾ä¸€ä¸ªäº¤æ˜“ä½¿ç”¨ 10,000 ä¸ªCairoæ­¥éª¤å’Œ 500 ä¸ªä½©å¾·æ£®å“ˆå¸Œå€¼ï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªè½¨è¿¹ä¸­å¯ä»¥å®¹çº³ 40,000 ä¸ªè¿™æ ·çš„äº¤æ˜“ï¼ˆæŒ‰ç…§ 20,000,000/500 è®¡ç®—ï¼‰ã€‚æ°”ä½“ä»·æ ¼å°±å˜æˆäº†æäº¤è¯æ˜æˆæœ¬çš„ 1/40000ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒCairoæ­¥æ•°å¹¶ä¸æ˜¯"
"é™åˆ¶å› ç´ ï¼Œå› æ­¤æˆ‘ä»¬åœ¨ä¼°ç®—æ€§èƒ½æ—¶å¹¶æ²¡æœ‰å°†å…¶è€ƒè™‘åœ¨å†…ã€‚"

#: src/ch03-01-02-fee-mechanism.md:51
#, fuzzy
msgid "Typically, the sequencer determines a vector, `CairoResourceUsage`, for every transaction. This vector accounts for:"
msgstr "é€šå¸¸ï¼Œæ’åºå™¨ä¼šä¸ºæ¯ä¸ªäº‹åŠ¡ç¡®å®šä¸€ä¸ªå‘é‡ \"CairoResourceUsage\"ã€‚è¯¥å‘é‡åŒ…æ‹¬"

#: src/ch03-01-02-fee-mechanism.md:53
msgid "The count of Cairo steps."
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:54
#, fuzzy
msgid "The application count of each Cairo built-in (like range checks and Pedersen hashes)."
msgstr ""
"1.Cairoæ­¥æ•°ã€‚\n"
"2.æ¯ä¸ªCairoå†…ç½®ç¨‹åºçš„åº”ç”¨æ¬¡æ•°ï¼ˆå¦‚èŒƒå›´æ£€æŸ¥å’Œ Pedersen å“ˆå¸Œå€¼ï¼‰ã€‚"

#: src/ch03-01-02-fee-mechanism.md:56
#, fuzzy
msgid "The sequencer then pairs this data with the `CairoResourceFeeWeights` vector, dictating the gas cost of each proof component."
msgstr "ç„¶åï¼Œæ’åºå™¨å°†è¿™äº›æ•°æ®ä¸ \"Cairoèµ„æºè´¹ç”¨æƒé‡ \"å‘é‡é…å¯¹ï¼Œå†³å®šæ¯ä¸ªè¯æ˜ç»„ä»¶çš„æ°”ä½“æˆæœ¬ã€‚"

#: src/ch03-01-02-fee-mechanism.md:60
#, fuzzy
msgid ""
"If a proof with 20,000,000 Pedersen hashes costs 5 million gas, then the Pedersen built-in has a weight of 0.25 gas per use (calculated as 5,000,000/20,000,000). Sequencers set these weight values "
"based on proof parameters."
msgstr "> å¦‚æœä¸€ä¸ªæœ‰ 20,000,000 ä¸ª Pedersen å“ˆå¸Œå€¼çš„æ ¡æ ·éœ€è¦ 500 ä¸‡ä¸ªæ°”ä½“ï¼Œé‚£ä¹ˆå†…ç½® Pedersen æ¯æ¬¡ä½¿ç”¨çš„é‡é‡ä¸º 0.25 ä¸ªæ°”ä½“ï¼ˆè®¡ç®—å…¬å¼ä¸º 5,000,000/20,000,000ï¼‰ã€‚åºåˆ—å™¨æ ¹æ®æ‰“æ ·å‚æ•°è®¾ç½®è¿™äº›é‡é‡å€¼ã€‚"

#: src/ch03-01-02-fee-mechanism.md:62
#, fuzzy
msgid "The fee is determined by the most restrictive component and is calculated as:"
msgstr "è´¹ç”¨ç”±é™åˆ¶æ€§æœ€å¼ºçš„éƒ¨åˆ†å†³å®šï¼Œè®¡ç®—å…¬å¼ä¸º"

#: src/ch03-01-02-fee-mechanism.md:68
#, fuzzy
msgid "Where \"k\" denotes the Cairo resource elements, encompassing step numbers and built-ins. The weightings for these components are:"
msgstr "å…¶ä¸­ï¼Œ\"k \"è¡¨ç¤ºCairoèµ„æºè¦ç´ ï¼ŒåŒ…æ‹¬æ­¥éª¤ç¼–å·å’Œå†…ç½®è¦ç´ ã€‚è¿™äº›è¦ç´ çš„æƒé‡ä¸º"

#: src/ch03-01-02-fee-mechanism.md:70
msgid "Gas Cost"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:70
msgid "Range"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:72
msgid "Cairo Step"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:72
msgid "0.01 gwei/gas"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:72
msgid "per step"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:73
msgid "Pedersen"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:73 src/ch03-01-02-fee-mechanism.md:74
msgid "0.32 gwei/gas"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:73 src/ch03-01-02-fee-mechanism.md:74 src/ch03-01-02-fee-mechanism.md:75 src/ch03-01-02-fee-mechanism.md:76 src/ch03-01-02-fee-mechanism.md:77
#: src/ch03-01-02-fee-mechanism.md:78 src/ch03-01-02-fee-mechanism.md:79
#, fuzzy
msgid "per application"
msgstr "## è´¹ç”¨è®¡ç®—"

#: src/ch03-01-02-fee-mechanism.md:74
msgid "Poseidon"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:75
msgid "Range Check"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:75
msgid "0.16 gwei/gas"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:76
msgid "ECDSA"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:76 src/ch03-01-02-fee-mechanism.md:77
msgid "20.48 gwei/gas"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:77
msgid "Keccak"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:78
msgid "Bitwise"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:78
msgid "0.64 gwei/gas"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:79
msgid "EC_OP"
msgstr ""

#: src/ch03-01-02-fee-mechanism.md:79
msgid "10.24 gwei/gas"
msgstr ""

#: src/ch03-01-03-data-availability.md:3
msgid "Data availability is key in blockchain networks, especially in Layer 2 solutions like Starknet."
msgstr ""

#: src/ch03-01-03-data-availability.md:5
msgid ""
"Rollups, acting as a bridge between the Ethereum blockchain and off-chain computation, enable transactions off-chain while maintaining Ethereum's security and asset system. The focus often lies on "
"scaling computation and execution, but it's just part of the challenge. Both computation and data aspects are vital for effective blockchain scaling."
msgstr ""

#: src/ch03-01-03-data-availability.md:7
msgid ""
"The growing use of rollups, which facilitate more off-chain execution, intensifies the need for efficient data availability solutions. This demand arises from the necessity to store, access, and "
"verify data from off-chain transactions. Robust data availability solutions are critical for rollup success. Without effective data handling, the scalability and performance advantages of rollups "
"could be significantly undermined."
msgstr ""

#: src/ch03-01-03-data-availability.md:9
msgid ""
"Base layer blockchains such as Ethereum are evolving towards becoming Data Availability (DA) layers (more [here](https://www.youtube.com/watch?v=PNPryqrJg3s)). A prime example of this evolution is "
"Celestia. They have spearheaded this movement by developing a Layer 1 blockchain with a DA-centric approach."
msgstr ""

#: src/ch03-01-03-data-availability.md:11
msgid ""
"In parallel, Ethereum is undergoing a significant transition. Historically an execution-focused blockchain, Ethereum is now incorporating new Ethereum Improvement Proposals (EIPs) to shift its focus "
"towards DA."
msgstr ""

#: src/ch03-01-03-data-availability.md:13
msgid "Data Availability in Starknet"
msgstr ""

#: src/ch03-01-03-data-availability.md:15
msgid ""
"**State Transition Process**: In Starknet, as in most blockchain networks, the system transitions from a state $n$ to state $(n+1)$ by executing a series of transactions within a block. In Starknet's "
"case, this is done through the Cairo language."
msgstr ""

#: src/ch03-01-03-data-availability.md:17
msgid "**Accessing Current State Information**: To know the current state $n$ of the network, there are two primary sources:"
msgstr ""

#: src/ch03-01-03-data-availability.md:18
msgid "**The Sequencer**: It holds comprehensive details about the network's current state."
msgstr ""

#: src/ch03-01-03-data-availability.md:19
msgid "**Layer 2 Full Nodes**: In Starknet, there are multiple full nodes, such as Juno, Papyrus, and Pathfinder, which users can run on their computers."
msgstr ""

#: src/ch03-01-03-data-availability.md:21
msgid ""
"The liveness problem arises from a concern: what happens if both the sequencer and all the full nodes become unresponsive? This could be due to a variety of reasons, such as technical failures or "
"external attacks."
msgstr ""

#: src/ch03-01-03-data-availability.md:23
msgid ""
"If for some reason, both the sequencer and the Layer 2 full nodes stop responding, there would be no way to ascertain the current state $n$ of the network. In such a scenario, while transactions could "
"still be received, the network would be unable to transition to state $(n+1)$ due to the lack of information about state $n$. Consequently, the network would essentially become stuck."
msgstr ""

#: src/ch03-01-03-data-availability.md:25
msgid "Although this situation is highly unlikely, its potential impact is significant. It would halt the progress of the network, preventing any state transitions and effectively freezing operations."
msgstr ""

#: src/ch03-01-03-data-availability.md:27
msgid "State Diffs"
msgstr ""

#: src/ch03-01-03-data-availability.md:29
msgid ""
"Starknet addresses the liveness problem through the transmission of validity proofs and state differences to Layer 1. This process is critical for ensuring that the network remains operational and its "
"state can be verified independently of the sequencer and Layer 2 full nodes."
msgstr ""

#: src/ch03-01-03-data-availability.md:31
msgid "**Validity Proof to Layer 1**: After computing the validity proof, Starknet sends it to Layer 1, specifically to the Verifier."
msgstr ""

#: src/ch03-01-03-data-availability.md:33
msgid ""
"**State Diff as Cold Data**: Along with the validity proof, Starknet also sends what's known as the 'state diff.' The state diff represents the changes in the Layer 2 state since the last validity "
"proof was sent. This includes updates and modifications made to the network's state."
msgstr ""

#: src/ch03-01-03-data-availability.md:37
msgid ""
"The state diff involves a substantial amount of data. To manage this, the data is sent as 'cold data' to Layer 1. It implies that the data isn't directly stored but is made available in a way that "
"requires significant transactional capacity to transfer to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:39
msgid "Data Availability and State Changes in Transactions"
msgstr ""

#: src/ch03-01-03-data-availability.md:41
msgid ""
"**Transmitting Changes, Not Balances**: What Starknet sends to Layer 1 for data availability are the changes in state, not the new balances. This involves capturing how each transaction within a "
"validity proof alters the state."
msgstr ""

#: src/ch03-01-03-data-availability.md:43
msgid "**Example 1**: Consider a simple scenario with three participants: Jimmy, Rose, and Nick."
msgstr ""

#: src/ch03-01-03-data-availability.md:45
msgid "**Transaction Sequence**: Jimmy sends one ETH to Rose, then Rose sends half an ETH to Nick."
msgstr ""

#: src/ch03-01-03-data-availability.md:46
msgid "**State Changes Sent to Layer 1**: The data sent to Layer 1 would reflect that Jimmy has one ETH less, Rose has half an ETH more, and Nick also gains half an ETH."
msgstr ""

#: src/ch03-01-03-data-availability.md:48
msgid ""
"**Example 2**: The net changes are what matter. For instance, if Jimmy and Rose send ETH back and forth, but the end result is Jimmy having half an ETH more and Rose half an ETH less, only these net "
"changes are sent to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:52
msgid "This approach means that even with multiple transactions, the actual data sent for availability can be less if the net state changes are minimal."
msgstr ""

#: src/ch03-01-03-data-availability.md:54
msgid ""
"In cases where transactions between parties nullify each other (e.g., Rose sends one ETH to Nick, and then Nick sends it back), no change in the state occurs. Consequently, nothing is sent to Layer 1 "
"for data availability, making it the cheapest form of transaction."
msgstr ""

#: src/ch03-01-03-data-availability.md:56
msgid ""
"Since the cost of sending data to Ethereum as cold data constitutes about 90% of a Layer 2 transaction's cost, reducing the amount of data sent can significantly impact overall transaction costs. "
"Projects on Starknet often use strategies to minimize state changes in their transactions, thereby reducing the data sent to Layer 1 and lowering transaction costs."
msgstr ""

#: src/ch03-01-03-data-availability.md:58
msgid "Reducing Data Availability Costs in Starknet"
msgstr ""

#: src/ch03-01-03-data-availability.md:60
msgid ""
"Two main mechanisms to reduce data availability costs are currently under consideration: the implementation of EIP 4844 and the concept of Volition. Both aim to optimize how data is stored and reduce "
"the associated costs."
msgstr ""

#: src/ch03-01-03-data-availability.md:62
msgid "EIP 4844: Blob Data and Cost Reduction"
msgstr ""

#: src/ch03-01-03-data-availability.md:64
msgid ""
"EIP 4844 proposes a change in how data availability information is sent to Layer 1. Instead of using call data, the information would be sent as blobs. This mechanism is expected to be cheaper than "
"the current method used by Starknet for posting data to Ethereum. Consequently, it would make Layer 2 transactions more affordable. A notable downside of this approach is the limited lifespan of blob "
"data. Once posted to Ethereum, this data will only be available for one month before being pruned by Layer 1 nodes."
msgstr ""

#: src/ch03-01-03-data-availability.md:66
msgid "Starknet's adoption of this feature depends on its implementation on the Ethereum mainnet. It's anticipated to be incorporated into Starknet by mid-2024, following its activation on Ethereum."
msgstr ""

#: src/ch03-01-03-data-availability.md:68
msgid "Volition: Flexible Data Storage Options"
msgstr ""

#: src/ch03-01-03-data-availability.md:70
msgid ""
"Volition introduces the concept of choosing where to store data for transaction liveness. Users can opt to post data either to Ethereum or off-chain alternatives such as a data availability committee, "
"systems like Celestia, or EigenDA. The cost of using Volition varies based on the chosen storage option. Off-chain options are expected to be cheaper than using EIP 4844."
msgstr ""

#: src/ch03-01-03-data-availability.md:72
msgid "The timeline for enabling Volition on Starknet is not yet determined, but it's certain to follow the support of EIP 4844."
msgstr ""

#: src/ch03-01-03-data-availability.md:74
msgid ""
"While EIP 4844's blob data approach will be beneficial for multiple rollups, Volition offers a unique advantage for Starknet by providing more flexibility in data storage and potentially lowering "
"costs further. The implementation of Volition requires having a virtual machine that is not limited by the adherence to emulate the EVM, so a custom virtual machine like Cairo is required."
msgstr ""

#: src/ch03-01-03-data-availability.md:76
#, fuzzy
msgid "Recreating Starknet's State"
msgstr "## ä¸Starknet React é›†æˆ"

#: src/ch03-01-03-data-availability.md:78
msgid "This process is a contingency plan for extreme scenarios where the sequencer and Layer 2 full nodes become unavailable."
msgstr ""

#: src/ch03-01-03-data-availability.md:80
msgid "Starknet, like any blockchain network, started with an empty state and a genesis block. Over time, it has processed multiple blocks, leading to changes in its state."
msgstr ""

#: src/ch03-01-03-data-availability.md:82
msgid "Periodically, Starknet sends a validity proof to Layer 1. This proof attests to the computations of all the blocks processed since the last proof was sent."
msgstr ""

#: src/ch03-01-03-data-availability.md:84
msgid ""
"Along with the validity proof, Starknet sends the state difference. This state difference details the changes from the empty state to the current state, as a result of executing transactions in all "
"these blocks. The state difference is transmitted to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:86
msgid ""
"As Starknet continues to produce more blocks on Layer 2, the process repeats. At some point, a new validity proof, along with a new set of transactions for data availability and the new state "
"difference, is sent to Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:88
msgid ""
"By applying the state differences in order, as they are sent to Layer 1, it's possible to reconstruct the Layer 2 state. This means that the entire history and current state of Starknet can be pieced "
"together from the data available on Layer 1. This is the role of the Layer 1 indexer."
msgstr ""

#: src/ch03-01-03-data-availability.md:92
msgid "This process ensures that the network's state is never lost and can always be recovered from Layer 1 data."
msgstr ""

#: src/ch03-01-03-data-availability.md:94
#, fuzzy
msgid "The StarknetOS"
msgstr "Starknet ä¹‹ä¹¦"

#: src/ch03-01-03-data-availability.md:96
msgid ""
"The StarknetOS, the last step inside the Sequencer, plays a crucial role in determining why the state diff is the output of the SHARP and how it interacts with the network's state. The StarknetOS is "
"based on Cairo Zero, an older version of the Cairo programming language."
msgstr ""

#: src/ch03-01-03-data-availability.md:100
msgid "The StarknetOS receives four main inputs:"
msgstr ""

#: src/ch03-01-03-data-availability.md:102
msgid "The current state of the network."
msgstr ""

#: src/ch03-01-03-data-availability.md:103
msgid "New blocks created since the last validity proof was sent to Layer 1. These include declare_account and invoke transactions."
msgstr ""

#: src/ch03-01-03-data-availability.md:104
msgid "Class hashes resulting from declared transactions."
msgstr ""

#: src/ch03-01-03-data-availability.md:105
msgid "Compiled class hashes resulting from declared transactions."
msgstr ""

#: src/ch03-01-03-data-availability.md:107
msgid ""
"The StarknetOS takes the current state and processes the new transactions and blocks. It evaluates what changes occur in the state as a result of these transactions. The output from this process "
"includes:"
msgstr ""

#: src/ch03-01-03-data-availability.md:109
msgid "The state diff: Changes in the state."
msgstr ""

#: src/ch03-01-03-data-availability.md:110
msgid "Class hashes of newly declared smart contracts."
msgstr ""

#: src/ch03-01-03-data-availability.md:111
msgid "Compiled class hashes of newly declared smart contracts."
msgstr ""

#: src/ch03-01-03-data-availability.md:115
msgid ""
"The sequencer executes numerous transactions and creates blocks. When enough blocks accumulate, they trigger the creation of a validity proof. These blocks are passed to the StarknetOS to calculate "
"the state diff, class hashes, and compiled class hashes. This is the information that the Prover is tasked with proving. The output from the [Blockchain Writer](https://etherscan.io/"
"address/0x16d5783a96ab20c9157d7933ac236646b29589a4), therefore, includes these three elements: state diff, class hashes, and compiled class hashes. This output is what gets sent to the memory pages "
"smart contract on Ethereum."
msgstr ""

#: src/ch03-01-03-data-availability.md:117
msgid "The Blockchain Writer Module"
msgstr ""

#: src/ch03-01-03-data-availability.md:119
msgid ""
"Contrary to a direct interaction between the Prover and the Ethereum Verifier, there's an intermediary process involving SHARP. The Prover in Starknet (currently [the Stone Prover](https://github.com/"
"starkware-libs/stone-prover)) is focused solely on proving the execution of a Cairo program. Its role is confined to generating proofs without concerning itself with Ethereum directly. The primary "
"concern of the Prover is to accurately prove the execution of Cairo programs."
msgstr ""

#: src/ch03-01-03-data-availability.md:121
msgid "Internally, SHARP utilizes an Externally Owned Account (EOA) specifically for interacting with Ethereum. This account is responsible for conducting transactions on the Ethereum network."
msgstr ""

#: src/ch03-01-03-data-availability.md:123
msgid ""
"**Handling Validity Proofs and State Diff**: The actual module within SHARP that sends the validity proof and state diff to the memory pages on Ethereum is known as the [Blockchain Writer](https://"
"etherscan.io/address/0x16d5783a96ab20c9157d7933ac236646b29589a4). This module bridges the gap between the internal workings of Starknet and the Ethereum blockchain."
msgstr ""

#: src/ch03-01-03-data-availability.md:125
msgid ""
"**Direct Interaction with Ethereum**: The output from the Prover is directed to the Blockchain Writer. It is this Blockchain Writer that interacts with Ethereum, sending data to the appropriate "
"location on the Layer 1."
msgstr ""

#: src/ch03-01-03-data-availability.md:127
msgid ""
"**Final Step in Data Transmission**: The Blockchain Writer represents the final step in the process where the proven data from Starknet's internal operations is transmitted to Ethereum for storage and "
"verification."
msgstr ""

#: src/ch03-01-03-data-availability.md:131
msgid ""
"This is Ethereum address of the Blockchain Writer, which is by itself an EOA holding resources: [0x16d5783a96ab20c9157d7933ac236646b29589a4](https://etherscan.io/"
"address/0x16d5783a96ab20c9157d7933ac236646b29589a4)."
msgstr ""

#: src/ch03-01-03-data-availability.md:133
msgid ""
"The cost for data availability in Starknet, as handled by SHARP, is a direct expense. There isn't any form of subsidy for these costs. SHARP bears the full financial responsibility for the block space "
"required on Ethereum. The lack of subsidy in DA costs directly influences the fees users pay for transactions on Starknet."
msgstr ""

#: src/ch03-01-03-data-availability.md:135
msgid ""
"A closer look at the transactions emanating from the [Blockchain Writer](https://etherscan.io/address/0x16d5783a96ab20c9157d7933ac236646b29589a4), which are responsible for DA, reveals substantial "
"costs. SHARP incurs millions of dollars in expenses for block space on Ethereum each month."
msgstr ""

#: src/ch03-01-03-data-availability.md:137
msgid "Data Availability Modes"
msgstr ""

#: src/ch03-01-03-data-availability.md:139
msgid "Currently, there are three primary modes, with two already in use and a third on the horizon. These modes are Rollup, Validium, and Volition."
msgstr ""

#: src/ch03-01-03-data-availability.md:141
msgid "1. Rollup Mode"
msgstr ""

#: src/ch03-01-03-data-availability.md:143
msgid "**Definition and Characteristics**: The data for DA is posted directly on Ethereum. This approach is what classifies a Layer 2 solution as a Rollup."
msgstr ""

#: src/ch03-01-03-data-availability.md:144
msgid "**Advantages**: The primary benefit of Rollup mode is enhanced liveness due to the reliability and track record of Ethereum. It provides robust guarantees about data availability."
msgstr ""

#: src/ch03-01-03-data-availability.md:145
msgid "**Cost Implications**: This mode tends to be more expensive due to the cost associated with posting data on Ethereum. However, future implementations like EIP 4844 may reduce these costs."
msgstr ""

#: src/ch03-01-03-data-availability.md:146
msgid "**Example**: Starknet, which sends data to the memory pages smart contract, is an example of a Rollup."
msgstr ""

#: src/ch03-01-03-data-availability.md:148
msgid "2. Validium Mode"
msgstr ""

#: src/ch03-01-03-data-availability.md:150
msgid "**Definition and Characteristics**: Characterized by Layer 2 networks not utilizing Ethereum for DA. Instead, data is stored off-chain."
msgstr ""

#: src/ch03-01-03-data-availability.md:151
msgid "**Advantages**: The primary advantage of Validium is cost efficiency. Transactions in Validiums are typically much cheaper than in Rollups."
msgstr ""

#: src/ch03-01-03-data-availability.md:152
msgid "**Liveness Guarantees**: The trade-off for reduced cost is weaker liveness guarantees compared to Ethereum-based DA."
msgstr ""

#: src/ch03-01-03-data-availability.md:153
msgid "**Example**: StarkEx is an example of Validium, known for its significantly lower transaction costs compared to Rollups."
msgstr ""

#: src/ch03-01-03-data-availability.md:155
msgid "3. Volition Mode (Upcoming)"
msgstr ""

#: src/ch03-01-03-data-availability.md:157
msgid ""
"**Definition and Characteristics**: Volition mode is a hybrid DA mode that combines aspects of both Rollup and Validium. It offers users the choice of where to store data, either on-chain (Ethereum) "
"or off-chain."
msgstr ""

#: src/ch03-01-03-data-availability.md:158
msgid "**User Choice**: The key feature of Volition mode is the flexibility it provides users in deciding their data storage preferences, balancing between cost and liveness guarantees."
msgstr ""

#: src/ch03-01-03-data-availability.md:159
msgid "**Implementation Timeline**: Volition mode is expected to be introduced to networks like Starknet in the near future, potentially within a year or so."
msgstr ""

#: src/ch03-01-03-data-availability.md:161
msgid "The following table summarizes the key characteristics of each mode:"
msgstr ""

#: src/ch03-01-03-data-availability.md:163
msgid "Mode"
msgstr ""

#: src/ch03-01-03-data-availability.md:163
#, fuzzy
msgid "Definition"
msgstr "## Starknetçš„å®šä¹‰"

#: src/ch03-01-03-data-availability.md:163
msgid "Advantages"
msgstr ""

#: src/ch03-01-03-data-availability.md:163
msgid "Cost"
msgstr ""

#: src/ch03-01-03-data-availability.md:163
#, fuzzy
msgid "Example"
msgstr "ç¤ºä¾‹"

#: src/ch03-01-03-data-availability.md:165
msgid "Rollup"
msgstr ""

#: src/ch03-01-03-data-availability.md:165
msgid "Data posted on Ethereum; a Layer 2 solution."
msgstr ""

#: src/ch03-01-03-data-availability.md:165
msgid "Reliable, robust data availability."
msgstr ""

#: src/ch03-01-03-data-availability.md:165
msgid "Higher cost."
msgstr ""

#: src/ch03-01-03-data-availability.md:165 src/ch03-03-provers.md:194
#, fuzzy
msgid "Starknet"
msgstr "Starknet ä¹‹ä¹¦"

#: src/ch03-01-03-data-availability.md:166
msgid "Validium"
msgstr ""

#: src/ch03-01-03-data-availability.md:166
msgid "Data stored off-chain, not on Ethereum."
msgstr ""

#: src/ch03-01-03-data-availability.md:166
#, fuzzy
msgid "Lower transaction costs."
msgstr "äº¤æ˜“"

#: src/ch03-01-03-data-availability.md:166
msgid "Lower cost."
msgstr ""

#: src/ch03-01-03-data-availability.md:166 src/ch03-03-provers.md:192
msgid "StarkEx"
msgstr ""

#: src/ch03-01-03-data-availability.md:167
msgid "Volition"
msgstr ""

#: src/ch03-01-03-data-availability.md:167
msgid "Hybrid mode, choice of on-chain or off-chain."
msgstr ""

#: src/ch03-01-03-data-availability.md:167
msgid "Balance between cost and data availability."
msgstr ""

#: src/ch03-01-03-data-availability.md:167
msgid "\\-"
msgstr ""

#: src/ch03-02-sequencers.md:3
msgid "Before diving in, make sure to check out the [Architecture](./ch03-00-architecture.md) chapter for a quick exploration of Starknetâ€™s sequencers, provers and nodes."
msgstr ""

#: src/ch03-02-sequencers.md:6
#, fuzzy
msgid ""
"Three main layers exist in blockchain: data availability, ordering, and execution. Sequencers have evolved within this evolving modular landscape of blockchain technology. Most L1 blockchains, like "
"Ethereum, handle all these tasks. Initially, blockchains served as distributed virtual machines focused on organizing and executing transactions. Even roll-ups running on Ethereum today often "
"centralize sequencing (ordering) and execution while relying on Ethereum for data availability. This is the current state of Starknet, which uses Ethereum for data availability and a centralized "
"Sequencer for ordering and execution. However, it is possible to decentralize sequencing and execution, as Starknet is doing."
msgstr ""
"åŒºå—é“¾æœ‰ä¸‰ä¸ªä¸»è¦å±‚æ¬¡ï¼šæ•°æ®å¯ç”¨æ€§ã€æ’åºå’Œæ‰§è¡Œã€‚\n"
"æ‰§è¡Œã€‚æ’åºå™¨å°±æ˜¯åœ¨è¿™ç§ä¸æ–­å‘å±•çš„æ¨¡å—åŒ–\n"
"åŒºå—é“¾æŠ€æœ¯çš„ä¸æ–­å‘å±•ã€‚å¤§å¤šæ•° L1 åŒºå—é“¾ï¼Œå¦‚ä»¥å¤ªåŠã€\n"
"å¤„ç†æ‰€æœ‰è¿™äº›ä»»åŠ¡ã€‚æœ€åˆï¼ŒåŒºå—é“¾ä½œä¸ºåˆ†å¸ƒå¼\n"
"è™šæ‹Ÿæœºï¼Œä¸“æ³¨äºç»„ç»‡å’Œæ‰§è¡Œäº¤æ˜“ã€‚å³ä½¿æ˜¯\n"
"å¦‚ä»Šï¼Œå³ä½¿æ˜¯åœ¨ä»¥å¤ªåŠä¸Šè¿è¡Œçš„å·ç§¯é“¾ä¹Ÿç»å¸¸é›†ä¸­æ’åº\n"
"(æ’åºï¼‰å’Œæ‰§è¡Œï¼ŒåŒæ—¶ä¾èµ–ä»¥å¤ªåŠæä¾›æ•°æ®\n"
"å¯ç”¨æ€§ã€‚è¿™å°±æ˜¯ Starknet çš„ç°çŠ¶ï¼Œå®ƒä½¿ç”¨ä»¥å¤ªåŠ\n"
"æ¥æä¾›æ•°æ®å¯ç”¨æ€§ï¼Œå¹¶ä½¿ç”¨é›†ä¸­å¼æ’åºå™¨æ¥è¿›è¡Œæ’åºå’Œæ‰§è¡Œã€‚\n"
"æ‰§è¡Œã€‚ç„¶è€Œï¼Œå»ä¸­å¿ƒåŒ–æ’åºå’Œæ‰§è¡Œä¹Ÿæ˜¯å¯èƒ½çš„ã€‚\n"
"æ‰§è¡Œï¼Œå°±åƒ Starknet æ­£åœ¨åšçš„é‚£æ ·ã€‚"

#: src/ch03-02-sequencers.md:18
#, fuzzy
msgid ""
"Each of these layers plays a crucial role in achieving consensus. First, the data must be available. Second, it needs to be put in a specific order. Thatâ€™s the main job of a Sequencer, whether run by "
"a single computer or a decentralized protocol. Lastly, you execute transactions in the order theyâ€™ve been sequenced. This final step, done by the Sequencer too, determines the systemâ€™s current state "
"and keeps all connected clients on the same page."
msgstr ""
"åœ¨è¾¾æˆå…±è¯†çš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€å±‚éƒ½å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ã€‚é¦–å…ˆã€\n"
"æ•°æ®å¿…é¡»å¯ç”¨ã€‚å…¶æ¬¡ï¼Œæ•°æ®å¿…é¡»æŒ‰ç…§ç‰¹å®šçš„\n"
"é¡ºåºæ’åˆ—ã€‚è¿™å°±æ˜¯åºåˆ—å™¨çš„ä¸»è¦å·¥ä½œï¼Œæ— è®ºæ˜¯ç”±å•å°è®¡ç®—æœºè¿è¡Œçš„åºåˆ—å™¨\n"
"è®¡ç®—æœºæˆ–åˆ†æ•£åè®®è¿è¡Œã€‚æœ€åï¼Œæ‰§è¡Œäº¤æ˜“\n"
"æŒ‰é¡ºåºæ‰§è¡Œã€‚è¿™æœ€åä¸€æ­¥ä¹Ÿæ˜¯ç”±\n"
"å®šç³»ç»Ÿçš„å½“å‰çŠ¶æ€ï¼Œå¹¶è®©æ‰€æœ‰è¿æ¥çš„å®¢æˆ·ç«¯ä¿æŒä¸€è‡´ã€‚\n"
"è¿æ¥çš„å®¢æˆ·ç«¯ä¿æŒä¸€è‡´ã€‚"

#: src/ch03-02-sequencers.md:26
#, fuzzy
msgid "Introduction to Sequencers"
msgstr "## éŸ³åºå™¨ç®€ä»‹"

#: src/ch03-02-sequencers.md:28
#, fuzzy
msgid ""
"The advent of Layer Two (L2) solutions like Roll-Ups has altered the blockchain landscape, improving scalability and efficiency. But what about transaction order? Is it still managed by the base layer "
"(L1), or is an external system involved? Enter Sequencers. They ensure transactions are in the correct order, regardless of whether theyâ€™re managed by L1 or another system."
msgstr ""
"Roll-Ups ç­‰ç¬¬äºŒå±‚ï¼ˆL2ï¼‰è§£å†³æ–¹æ¡ˆçš„å‡ºç°æ”¹å˜äº†\n"
"åŒºå—é“¾çš„æ ¼å±€ï¼Œæé«˜äº†å¯æ‰©å±•æ€§å’Œæ•ˆç‡ã€‚ä½†æ˜¯\n"
"äº¤æ˜“ç§©åºå‘¢ï¼Ÿæ˜¯ä»ç”±åŸºç¡€å±‚ï¼ˆL1ï¼‰ç®¡ç†ï¼Œè¿˜æ˜¯æœ‰å¤–éƒ¨ç³»ç»Ÿå‚ä¸ï¼Ÿ\n"
"æ¶‰åŠå¤–éƒ¨ç³»ç»Ÿï¼Ÿè¿›å…¥åºåˆ—å™¨ã€‚å®ƒä»¬èƒ½ç¡®ä¿\n"
"äº‹åŠ¡é¡ºåºæ­£ç¡®ï¼Œæ— è®ºå®ƒä»¬æ˜¯ç”± L1 è¿˜æ˜¯å…¶ä»–ç³»ç»Ÿç®¡ç†ã€‚\n"
"ç”± L1 è¿˜æ˜¯å…¶ä»–ç³»ç»Ÿç®¡ç†ã€‚"

#: src/ch03-02-sequencers.md:35
#, fuzzy
msgid ""
"In essence, sequencing has two core tasks: sequencing (ordering) and executing (validation). First, it orders transactions, determining the canonical sequence of blocks for a given chain fork. It then "
"appends new blocks to this sequence. Second, it executes these transactions, updating the systemâ€™s state based on a given function."
msgstr ""
"ä»æœ¬è´¨ä¸Šè®²ï¼Œæ’åºæœ‰ä¸¤ä¸ªæ ¸å¿ƒä»»åŠ¡ï¼šæ’åºï¼ˆæ’åºï¼‰å’Œæ‰§è¡Œï¼ˆéªŒè¯ï¼‰ã€‚\n"
"æ‰§è¡Œï¼ˆéªŒè¯ï¼‰ã€‚é¦–å…ˆï¼Œå®ƒå¯¹äº¤æ˜“è¿›è¡Œæ’åºï¼Œç¡®å®š\n"
"ç»™å®šé“¾åˆ†å‰çš„å…¸å‹åŒºå—é¡ºåºã€‚ç„¶åï¼Œå®ƒå°†æ–°\n"
"åŒºå—åˆ°è¯¥åºåˆ—ä¸­ã€‚å…¶æ¬¡ï¼Œå®ƒæ‰§è¡Œè¿™äº›äº‹åŠ¡ã€\n"
"æ ¹æ®ç»™å®šå‡½æ•°æ›´æ–°ç³»ç»ŸçŠ¶æ€ã€‚"

#: src/ch03-02-sequencers.md:41
#, fuzzy
msgid ""
"To clarify, we see sequencing as the act of taking a group of unordered transactions and producing an ordered block. Sequencers also confirm the resulting state of the machine. However, the approach "
"explained here separates these tasks. While some systems handle both ordering and state validation simultaneously, we advocate for treating them as distinct steps."
msgstr ""
"ä¸ºäº†æ¾„æ¸…è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬è®¤ä¸ºæ’åºæ˜¯å°†ä¸€ç»„æ— åºçš„äº¤æ˜“\n"
"äº¤æ˜“å¹¶ç”Ÿæˆä¸€ä¸ªæœ‰åºåŒºå—çš„è¡Œä¸ºã€‚æ’åºå™¨è¿˜ä¼šç¡®è®¤\n"
"æœºå™¨çš„çŠ¶æ€ã€‚ä¸è¿‡ï¼Œè¿™é‡Œè§£é‡Šçš„æ–¹æ³•\n"
"å°†è¿™äº›ä»»åŠ¡åˆ†å¼€ã€‚è™½ç„¶æœ‰äº›ç³»ç»Ÿä¼šåŒæ—¶å¤„ç†æ’åºå’ŒçŠ¶æ€\n"
"åŒæ—¶è¿›è¡Œï¼Œä½†æˆ‘ä»¬ä¸»å¼ å°†å®ƒä»¬ä½œä¸ºä¸åŒçš„\n"
"æ­¥éª¤ã€‚"

#: src/ch03-02-sequencers.md:50
#, fuzzy
msgid "Sequencer role in the Starknet network"
msgstr "<span class=\"caption\">Sequencer role in the Starknet network</span>"

#: src/ch03-02-sequencers.md:52
#, fuzzy
msgid "Sequencers in Starknet"
msgstr "## Starknetä¸­çš„æµ‹åºä»ª"

#: src/ch03-02-sequencers.md:54
#, fuzzy
msgid ""
"Letâ€™s delve into Sequencers by focusing on [Madara](https://github.com/keep-starknet-strange/madara) and [Kraken](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer), two high-"
"performance Starknet Sequencers. A Sequencer must, at least, do two things: order and execute transactions."
msgstr ""
"è®©æˆ‘ä»¬æ·±å…¥äº†è§£åºåˆ—å™¨ï¼Œé‡ç‚¹å…³æ³¨\n"
"[ç›è¾¾æ‹‰](https://github.com/keep-starknet-strange/madara) å’Œ\n"
"[å¡æ‹‰åŸº](https://github.com/lambdaclass/starknet_stack/tree/main/sequencer)ã€\n"
"ä¸¤ä¸ªé«˜æ€§èƒ½Starknetç¼–æ›²å™¨ã€‚åºåˆ—å™¨è‡³å°‘å¿…é¡»åšä¸¤ä»¶äº‹ï¼šæ’åºå’Œæ‰§è¡Œäº‹åŠ¡ã€‚\n"
"ä¸¤ä»¶äº‹ï¼šæ’åºå’Œæ‰§è¡Œäº‹åŠ¡ã€‚"

#: src/ch03-02-sequencers.md:60
#, fuzzy
msgid ""
"**Ordering**: Madara handles the sequencing process, supporting methods from simple FCFS and PGA to complex ones like Narwhall & Bullshark. It also manages the mempool, a critical data structure that "
"holds unconfirmed transactions. Developers can choose the consensus protocol through Madaraâ€™s use of Substrate, which offers multiple built-in options."
msgstr ""
"- ** æ’åº**ï¼šMadara å¤„ç†æ’åºè¿‡ç¨‹ï¼Œæ”¯æŒ\n"
"  ä»ç®€å•çš„ FCFS å’Œ PGA åˆ°å¤æ‚çš„ Narwhall å’Œ\n"
"  Bullshark ç­‰å¤æ‚æ–¹æ³•ã€‚å®ƒè¿˜ç®¡ç†å†…å­˜æ± ï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ•°æ®ç»“æ„\n"
"  å­˜å‚¨æœªç¡®è®¤äº‹åŠ¡çš„é‡è¦æ•°æ®ç»“æ„ã€‚å¼€å‘è€…å¯ä»¥é€šè¿‡\n"
"  å…±è¯†åè®®ã€‚\n"
"  å¤šç§å†…ç½®é€‰é¡¹ã€‚\n"
"\n"
"- **æ‰§è¡Œ**ï¼šMadara å¯è®©ä½ åœ¨ä¸¤ç§æ‰§è¡Œå·¥å…·ç®±ä¸­è¿›è¡Œé€‰æ‹©ï¼š\n"
"  [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)\n"
"  å’Œ\n"
"  [Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust)ã€‚\n"
"  ä¸¤è€…éƒ½ä½¿ç”¨ [Cairo VM](https://github.com/lambdaclass/cairo-vm)ä½œä¸ºæ¡†æ¶ã€‚\n"
"  æ¡†æ¶ã€‚"

#: src/ch03-02-sequencers.md:67
#, fuzzy
msgid ""
"**Execution**: Madara lets you choose between two execution crates: [Blockifier](https://github.com/starkware-libs/blockifier/tree/main) and [Starknet_in_Rust](https://github.com/lambdaclass/"
"starknet_in_rust). Both use the [Cairo VM](https://github.com/lambdaclass/cairo-vm) for their framework."
msgstr ""
"- ** æ’åº**ï¼šMadara å¤„ç†æ’åºè¿‡ç¨‹ï¼Œæ”¯æŒ\n"
"  ä»ç®€å•çš„ FCFS å’Œ PGA åˆ°å¤æ‚çš„ Narwhall å’Œ\n"
"  Bullshark ç­‰å¤æ‚æ–¹æ³•ã€‚å®ƒè¿˜ç®¡ç†å†…å­˜æ± ï¼Œè¿™æ˜¯ä¸€ä¸ªé‡è¦çš„æ•°æ®ç»“æ„\n"
"  å­˜å‚¨æœªç¡®è®¤äº‹åŠ¡çš„é‡è¦æ•°æ®ç»“æ„ã€‚å¼€å‘è€…å¯ä»¥é€šè¿‡\n"
"  å…±è¯†åè®®ã€‚\n"
"  å¤šç§å†…ç½®é€‰é¡¹ã€‚\n"
"\n"
"- **æ‰§è¡Œ**ï¼šMadara å¯è®©ä½ åœ¨ä¸¤ç§æ‰§è¡Œå·¥å…·ç®±ä¸­è¿›è¡Œé€‰æ‹©ï¼š\n"
"  [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)\n"
"  å’Œ\n"
"  [Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust)ã€‚\n"
"  ä¸¤è€…éƒ½ä½¿ç”¨ [Cairo VM](https://github.com/lambdaclass/cairo-vm)ä½œä¸ºæ¡†æ¶ã€‚\n"
"  æ¡†æ¶ã€‚"

#: src/ch03-02-sequencers.md:74
#, fuzzy
msgid "We also have the Kraken Sequencer as another option."
msgstr "æˆ‘ä»¬è¿˜æœ‰ Kraken Sequencer ä½œä¸ºå¦ä¸€ç§é€‰æ‹©ã€‚"

#: src/ch03-02-sequencers.md:76
#, fuzzy
msgid "**Ordering**: It employs Narwhall & Bullshark for mempool management. You can choose from multiple consensus methods, like Bullshark, Tendermint, or Hotstuff."
msgstr ""
"- **è®¢è´­**ï¼šå®ƒé‡‡ç”¨ Narwhall å’Œ Bullshark è¿›è¡Œå†…å­˜æ± \n"
"  ç®¡ç†ã€‚æ‚¨å¯ä»¥é€‰æ‹©å¤šç§å…±è¯†æ–¹æ³•ï¼Œå¦‚\n"
"  Bullsharkã€Tendermint æˆ– Hotstuffã€‚\n"
"\n"
"- **æ‰§è¡Œ**ï¼šåœ¨ Starknet_in_Rust ä¸Šè¿è¡Œã€‚æ‰§è¡Œå¯ä»¥æ¨è¿Ÿåˆ°\n"
"  Cairo\n"
"  Native](https://github.com/lambdaclass/cairo_native) æˆ– [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)ã€‚"

#: src/ch03-02-sequencers.md:80
#, fuzzy
msgid "**Execution**: Runs on Starknet_in_Rust. Execution can be deferred to either [Cairo Native](https://github.com/lambdaclass/cairo_native) or [Cairo VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""
"- **è®¢è´­**ï¼šå®ƒé‡‡ç”¨ Narwhall å’Œ Bullshark è¿›è¡Œå†…å­˜æ± \n"
"  ç®¡ç†ã€‚æ‚¨å¯ä»¥é€‰æ‹©å¤šç§å…±è¯†æ–¹æ³•ï¼Œå¦‚\n"
"  Bullsharkã€Tendermint æˆ– Hotstuffã€‚\n"
"\n"
"- **æ‰§è¡Œ**ï¼šåœ¨ Starknet_in_Rust ä¸Šè¿è¡Œã€‚æ‰§è¡Œå¯ä»¥æ¨è¿Ÿåˆ°\n"
"  Cairo\n"
"  Native](https://github.com/lambdaclass/cairo_native) æˆ– [Cairo\n"
"  VM](https://github.com/lambdaclass/cairo-vm)ã€‚"

#: src/ch03-02-sequencers.md:143
#, fuzzy
msgid "Understanding the Execution Layer"
msgstr "### äº†è§£æ‰§è¡Œå±‚"

#: src/ch03-02-sequencers.md:145
msgid ""
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main), a Rust component in Starknet Sequencers, generates state diffs and blocks. It uses [Cairo VM](https://github.com/lambdaclass/cairo-"
"vm). Its goal is to become a full Starknet Sequencer."
msgstr ""

#: src/ch03-02-sequencers.md:150
msgid "Starknet_in_Rust is another Rust component for Starknet that also generates state diffs and blocks. It uses [Cairo VM](https://github.com/lambdaclass/cairo-vm)."
msgstr ""

#: src/ch03-02-sequencers.md:154
msgid ""
"[Cairo Native](https://github.com/lambdaclass/cairo_native) stands out by converting Cairoâ€™s Sierra code to MLIR. See an example [here](https://github.com/lambdaclass/cairo_native/blob/main/examples/"
"erc20.rs)."
msgstr ""

#: src/ch03-02-sequencers.md:158
#, fuzzy
msgid "The Need for Decentralized Sequencers"
msgstr "## å¯¹åˆ†æ•£å¼åºåˆ—å™¨çš„éœ€æ±‚"

#: src/ch03-02-sequencers.md:160
#, fuzzy
msgid "For more details on the Decentralization of Starknet, refer to the dedicated subchapter in this Chapter."
msgstr ""
"æœ‰å…³StarknetæƒåŠ›ä¸‹æ”¾çš„æ›´å¤šè¯¦æƒ…ï¼Œè¯·å‚é˜…æœ¬ç« çš„\n"
"æœ¬ç« çš„ä¸“é—¨åˆ†ç« ã€‚"

#: src/ch03-02-sequencers.md:163
#, fuzzy
msgid ""
"Proving transactions doesnâ€™t require to be decentralized (although in the near future Starknet will operate with decentralized provers). Once the order is set, anyone can submit a proof; itâ€™s either "
"correct or not. However, the process that determines this order should be decentralized to maintain a blockchainâ€™s original qualities."
msgstr ""
"è¯æ˜äº¤æ˜“å¹¶ä¸éœ€è¦å»ä¸­å¿ƒåŒ–ï¼ˆå°½ç®¡åœ¨\n"
"ä½†åœ¨ä¸ä¹…çš„å°†æ¥ï¼ŒStarknetå°†ä½¿ç”¨å»ä¸­å¿ƒåŒ–çš„è¯æ˜å™¨ï¼‰ã€‚ä¸€æ—¦\n"
"ä»»ä½•äººéƒ½å¯ä»¥æäº¤è¯æ˜ï¼›è¯æ˜è¦ä¹ˆæ­£ç¡®ï¼Œè¦ä¹ˆé”™è¯¯ã€‚\n"
"ä½†æ˜¯ï¼Œå†³å®šè¿™ä¸ªé¡ºåºçš„è¿‡ç¨‹åº”è¯¥æ˜¯å»ä¸­å¿ƒåŒ–çš„\n"
"ä»¥ä¿æŒåŒºå—é“¾çš„åŸæœ‰ç‰¹æ€§ã€‚"

#: src/ch03-02-sequencers.md:169
#, fuzzy
msgid ""
"In the context of Ethereumâ€™s Layer 1 (L1), Sequencers can be likened to Ethereum validators. They are responsible for creating and broadcasting blocks. This role is divided under the concept of "
"\"Proposer-Builder Separation\" (PBS) ([Hasu, 2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)). Block builders form blocks (order the transactions), while block proposers, unaware of the blockâ€™s "
"content, choose the most profitable one. This separation prevents transaction censorship at the protocol level. Currently, most Layer 2 (L2) Sequencers, including Starknet, perform both roles, which "
"can create issues."
msgstr ""
"åœ¨ä»¥å¤ªåŠç¬¬ä¸€å±‚ï¼ˆL1ï¼‰çš„èƒŒæ™¯ä¸‹ï¼Œåºåˆ—å™¨å¯ä»¥æ¯”ä½œ\n"
"ä»¥å¤ªåŠéªŒè¯å™¨ã€‚å®ƒä»¬è´Ÿè´£åˆ›å»ºå’Œå¹¿æ’­\n"
"åŒºå—ã€‚è¿™ä¸€è§’è‰²åœ¨ \"æè®®è€…--åˆ›å»ºè€…åˆ†ç¦»\"ï¼ˆProposer-Builder\n"
"åˆ†ç¦»\"ï¼ˆPBSï¼‰ï¼ˆ[Hasuã€\n"
"2023](https://www.youtube.com/watch?v=6xS0xMzh9Tc)ï¼‰ã€‚åŒºå—æ„å»ºè€…å½¢æˆ\n"
"äº¤æ˜“ï¼‰ï¼Œè€ŒåŒºå—æè®®è€…åœ¨ä¸çŸ¥é“åŒºå—å†…å®¹çš„æƒ…å†µä¸‹ï¼Œé€‰æ‹©æœ€æœ‰åˆ©å¯å›¾çš„\n"
"é€‰æ‹©æœ€æœ‰åˆ©å¯å›¾çš„åŒºå—ã€‚è¿™ç§åˆ†ç¦»\n"
"é˜²æ­¢äº†åè®®å±‚é¢çš„äº¤æ˜“å®¡æŸ¥ã€‚ç›®å‰ï¼Œå¤§å¤šæ•°\n"
"ç¬¬ 2 å±‚ï¼ˆL2ï¼‰åºåˆ—å™¨ï¼ˆåŒ…æ‹¬Starknetï¼‰éƒ½åŒæ—¶æ‰®æ¼”è¿™ä¸¤ç§è§’è‰²ï¼Œè¿™å¯èƒ½ä¼šäº§ç”Ÿé—®é¢˜ã€‚\n"
"ä¼šäº§ç”Ÿé—®é¢˜ã€‚"

#: src/ch03-02-sequencers.md:180
#, fuzzy
msgid ""
"The drive toward centralized Sequencers mainly stems from performance issues like high costs and poor user experience on Ethereum for both data storage and transaction ordering. The challenge is "
"scalability: how to expand without sacrificing decentralization. Opting for centralization risks turning the blockchain monopolistic, negating its unique advantages like network-effect services "
"without monopoly."
msgstr ""
"å¯¹é›†ä¸­å¼åºåˆ—å™¨çš„æ¨åŠ¨ä¸»è¦æºäºæ€§èƒ½é—®é¢˜ï¼Œå¦‚ä»¥å¤ªåŠä¸Šçš„é«˜æˆæœ¬å’Œç³Ÿç³•çš„ç”¨æˆ·ä½“éªŒã€‚\n"
"æˆæœ¬é«˜ã€ç”¨æˆ·ä½“éªŒå·®ç­‰é—®é¢˜ã€‚\n"
"æ•°æ®å­˜å‚¨å’Œäº¤æ˜“æ’åºçš„æˆæœ¬å’Œç”¨æˆ·ä½“éªŒå·®ç­‰æ€§èƒ½é—®é¢˜ã€‚æŒ‘æˆ˜åœ¨äºå¯æ‰©å±•æ€§ï¼šå¦‚ä½•\n"
"åœ¨ä¸ç‰ºç‰²å»ä¸­å¿ƒåŒ–çš„å‰æä¸‹è¿›è¡Œæ‰©å±•ã€‚é€‰æ‹©\n"
"ä¸­å¿ƒåŒ–æœ‰å¯èƒ½ä½¿åŒºå—é“¾å˜æˆå„æ–­æ€§çš„ï¼Œå¦å®šå…¶\n"
"ç½‘ç»œæ•ˆåº”æœåŠ¡ç­‰ç‹¬ç‰¹ä¼˜åŠ¿ã€‚"

#: src/ch03-02-sequencers.md:187
#, fuzzy
msgid ""
"With centralization, blockchain loses its core principles: credible neutrality and resistance to monopolization. Whatâ€™s wrong with a centralized system? It raises the risks of censorship (via "
"transaction reordering)."
msgstr ""
"éšç€ä¸­å¿ƒåŒ–çš„å‘å±•ï¼ŒåŒºå—é“¾å¤±å»äº†å…¶æ ¸å¿ƒåŸåˆ™ï¼šå¯ä¿¡æ€§ã€ä¸­ç«‹æ€§å’ŒæŠµåˆ¶å„æ–­ã€‚\n"
"ä¸­ç«‹æ€§å’ŒæŠµåˆ¶å„æ–­ã€‚ä¸­å¿ƒåŒ–ç³»ç»Ÿæœ‰ä»€ä¹ˆä¸å¥½ï¼Ÿ\n"
"ä¸­å¿ƒåŒ–ç³»ç»Ÿæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿå®ƒå¢åŠ äº†å®¡æŸ¥çš„é£é™©ï¼ˆé€šè¿‡äº¤æ˜“\n"
"é‡æ–°æ’åºï¼‰ã€‚"

#: src/ch03-02-sequencers.md:192
#, fuzzy
msgid "A centralized validity roll-up looks like this:"
msgstr "é›†ä¸­å¼æœ‰æ•ˆæ€§å·ç§¯çœ‹èµ·æ¥åƒè¿™æ ·ï¼š"

#: src/ch03-02-sequencers.md:194
msgid "User Interaction & Selection: Users send transactions to a centralized Sequencer, which selects and orders them."
msgstr ""

#: src/ch03-02-sequencers.md:197
msgid "Block Formation: The Sequencer packages these ordered transactions into a block."
msgstr ""

#: src/ch03-02-sequencers.md:200
msgid "Proof & Verification: The block is sent to a proving service, which generates a proof and posts it to Layer 1 (L1) for verification."
msgstr ""

#: src/ch03-02-sequencers.md:203
msgid "Verification: Once verified on L1, the transactions are considered finalized and integrated into the L1 blockchain."
msgstr ""

#: src/ch03-02-sequencers.md:208
msgid "Centralized rollup"
msgstr ""

#: src/ch03-02-sequencers.md:210
#, fuzzy
msgid "While centralized roll-ups can provide L1 security, they come with a significant downside: the risk of censorship. Hence, the push for decentralization in roll-ups."
msgstr ""
"è™½ç„¶é›†ä¸­å¼å·ç§¯å¯ä»¥æä¾› L1 çº§å®‰å…¨æ€§ï¼Œä½†ä¹Ÿæœ‰ä¸€ä¸ªæ˜¾è‘—çš„ç¼ºç‚¹ï¼šå®¡æŸ¥é£é™©ã€‚\n"
"ä¸€ä¸ªæ˜¾è‘—çš„ç¼ºç‚¹ï¼šå®¡æŸ¥é£é™©ã€‚å› æ­¤\n"
"åˆ†æ•£å¼å·ç§¯ã€‚"

#: src/ch03-02-sequencers.md:216
#, fuzzy
msgid ""
"This chapter has dissected the role of Sequencers in the complex ecosystem of blockchain technology, focusing on Starknetâ€™s current state and future directions. Sequencers essentially serve two main "
"functions: ordering transactions and executing them. While these tasks may seem straightforward, they are pivotal in achieving network consensus and ensuring security."
msgstr ""
"æœ¬ç« å‰–æäº† Sequencers åœ¨å¤æ‚çš„åŒºå—é“¾æŠ€æœ¯ç”Ÿæ€ç³»ç»Ÿä¸­çš„ä½œç”¨ã€‚\n"
"ç”Ÿæ€ç³»ç»Ÿä¸­çš„ä½œç”¨ï¼Œé‡ç‚¹ä»‹ç»äº† Starknet çš„ç°çŠ¶å’Œæœªæ¥å‘å±•æ–¹å‘ã€‚\n"
"å’Œæœªæ¥å‘å±•æ–¹å‘ã€‚åºåˆ—å™¨ä¸»è¦æœ‰ä¸¤å¤§åŠŸèƒ½ï¼š\n"
"è®¢è´­äº¤æ˜“å’Œæ‰§è¡Œäº¤æ˜“ã€‚è¿™äº›ä»»åŠ¡çœ‹ä¼¼ç®€å•\n"
"ç®€å•æ˜äº†ï¼Œä½†å®ƒä»¬åœ¨è¾¾æˆç½‘ç»œå…±è¯†å’Œç¡®ä¿å®‰å…¨æ–¹é¢è‡³å…³é‡è¦ã€‚\n"
"ç¡®ä¿å®‰å…¨çš„å…³é”®ã€‚"

#: src/ch03-02-sequencers.md:223
#, fuzzy
msgid ""
"Given the evolving modular architecture of blockchainâ€”with distinct layers for data availability, transaction ordering, and executionâ€”Sequencers provide a crucial link. Their role gains more "
"significance in the context of Layer 2 solutions, where achieving scalability without sacrificing decentralization is a pressing concern."
msgstr ""
"é‰´äºåŒºå—é“¾ä¸æ–­å‘å±•çš„æ¨¡å—åŒ–æ¶æ„--æ•°æ®å¯ç”¨æ€§ã€äº¤æ˜“æ’åºå’Œ\n"
"æ•°æ®å¯ç”¨æ€§ã€äº¤æ˜“æ’åºå’Œ\n"
"åˆ†å‰²å™¨æä¾›äº†ä¸€ä¸ªå…³é”®ç¯èŠ‚ã€‚åœ¨ç¬¬äºŒå±‚è§£å†³æ–¹æ¡ˆä¸­ï¼Œå®ƒä»¬çš„ä½œç”¨å˜å¾—æ›´åŠ é‡è¦ã€‚\n"
"åœ¨ç¬¬äºŒå±‚è§£å†³æ–¹æ¡ˆä¸­ï¼Œå®ƒä»¬çš„ä½œç”¨å˜å¾—æ›´åŠ é‡è¦ã€‚\n"
"åœ¨ä¸ç‰ºç‰²å»ä¸­å¿ƒåŒ–çš„å‰æä¸‹å®ç°å¯æ‰©å±•æ€§æ˜¯ä¸€ä¸ªè¿«åˆ‡éœ€è¦è§£å†³çš„é—®é¢˜ã€‚"

#: src/ch03-02-sequencers.md:229
#, fuzzy
msgid ""
"In Starknet, Sequencers like Madara and Kraken demonstrate the potential of high-performance, customizable solutions. These Sequencers allow for a range of ordering methods and execution frameworks, "
"proving that thereâ€™s room for innovation even within seemingly rigid structures."
msgstr ""
"åœ¨Starknetä¸­ï¼ŒMadara å’Œ Kraken ç­‰åºåˆ—å™¨å±•ç¤ºäº†é«˜æ€§èƒ½å®šåˆ¶è§£å†³æ–¹æ¡ˆçš„æ½œåŠ›ã€‚\n"
"é«˜æ€§èƒ½ã€å¯å®šåˆ¶è§£å†³æ–¹æ¡ˆçš„æ½œåŠ›ã€‚è¿™äº›åºåˆ—å™¨å…è®¸\n"
"ä¸€ç³»åˆ—æ’åºæ–¹æ³•å’Œæ‰§è¡Œæ¡†æ¶ï¼Œè¯æ˜å³ä½¿åœ¨çœ‹ä¼¼åƒµåŒ–çš„ç»“æ„ä¸­ï¼Œä¹Ÿæœ‰åˆ›æ–°çš„ç©ºé—´ã€‚\n"
"å³ä½¿åœ¨çœ‹ä¼¼åƒµåŒ–çš„ç»“æ„ä¸­ä¹Ÿæœ‰åˆ›æ–°çš„ç©ºé—´ã€‚"

#: src/ch03-02-sequencers.md:234
#, fuzzy
msgid ""
"The discussion on \"Proposer-Builder Separation\" (PBS) highlights the need for role specialization to maintain a systemâ€™s integrity and thwart transaction censorship. This becomes especially crucial "
"when we recognize that the current model of many L2 Sequencers, Starknet included, performs both proposing and building, potentially exposing the network to vulnerabilities."
msgstr ""
"å…³äº \"å»ºè®®è€…--å»ºè®¾è€…åˆ†ç¦»\"ï¼ˆPBSï¼‰çš„è®¨è®ºçªå‡ºäº†\n"
"è§’è‰²ä¸“ä¸šåŒ–çš„å¿…è¦æ€§ï¼Œä»¥ä¿æŒç³»ç»Ÿçš„å®Œæ•´æ€§å¹¶é˜²æ­¢\n"
"äº‹åŠ¡å®¡æŸ¥ã€‚å½“æˆ‘ä»¬\n"
"è¿™ä¸€ç‚¹å˜å¾—å°¤ä¸ºé‡è¦ã€‚\n"
"ç­‰è®¸å¤š L2 æ’åºå™¨çš„å½“å‰æ¨¡å¼éƒ½åŒæ—¶è¿›è¡Œæè®®å’Œæ„å»ºï¼Œè¿™å¯èƒ½ä¼šä½¿ç½‘ç»œé¢ä¸´æ¼æ´ã€‚\n"
"ç½‘ç»œæ¼æ´ã€‚"

#: src/ch03-02-sequencers.md:241
#, fuzzy
msgid ""
"To reiterate, Sequencers arenâ€™t just a mechanism for transaction ordering and execution; they are a linchpin in blockchainâ€™s decentralized ethos. Whether centralized or decentralized, Sequencers must "
"strike a delicate balance between scalability, efficiency, and the overarching principle of decentralization."
msgstr ""
"é‡ç”³ä¸€ä¸‹ï¼Œåºåˆ—å™¨ä¸ä»…ä»…æ˜¯äº¤æ˜“æ’åºå’Œæ‰§è¡Œçš„æœºåˆ¶ï¼Œå®ƒè¿˜æ˜¯åŒºå—é“¾çš„å…³é”®ã€‚\n"
"æ’åºå’Œæ‰§è¡Œçš„æœºåˆ¶ï¼›å®ƒä»¬æ˜¯åŒºå—é“¾å»ä¸­å¿ƒåŒ–ç²¾ç¥çš„å…³é”®æ‰€åœ¨ã€‚\n"
"å»ä¸­å¿ƒåŒ–ç²¾ç¥çš„å…³é”®ã€‚æ— è®ºæ˜¯ä¸­å¿ƒåŒ–è¿˜æ˜¯å»ä¸­å¿ƒåŒ–ï¼Œåºåˆ—å™¨\n"
"éƒ½å¿…é¡»åœ¨å¯æ‰©å±•æ€§ã€æ•ˆç‡å’Œ\n"
"å»ä¸­å¿ƒåŒ–çš„æ€»ä½“åŸåˆ™ä¹‹é—´å–å¾—å¾®å¦™çš„å¹³è¡¡ã€‚"

#: src/ch03-02-sequencers.md:247
#, fuzzy
msgid ""
"As blockchain technology continues to mature, itâ€™s worth keeping an eye on how the role of Sequencers evolves. They hold the potential to either strengthen or weaken the unique advantages that make "
"blockchain technology so revolutionary."
msgstr ""
"éšç€åŒºå—é“¾æŠ€æœ¯çš„ä¸æ–­æˆç†Ÿï¼Œå€¼å¾—å…³æ³¨çš„æ˜¯\n"
"åºåˆ—å™¨çš„ä½œç”¨å¦‚ä½•æ¼”å˜ã€‚å®ƒä»¬æœ‰å¯èƒ½\n"
"åŠ å¼ºæˆ–å‰Šå¼±ä½¿åŒºå—é“¾æŠ€æœ¯å…·æœ‰é©å‘½æ€§æ„ä¹‰çš„ç‹¬ç‰¹ä¼˜åŠ¿ã€‚\n"
"æŠ€æœ¯å¦‚æ­¤å…·æœ‰é©å‘½æ€§çš„ç‹¬ç‰¹ä¼˜åŠ¿ã€‚"

#: src/ch03-02-01-madara.md:3
msgid ""
"Madara is a Starknet sequencer that operates on the Substrate framework, executing Cairo programs and Starknet smart contracts with the Cairo VM. Madara enables the launch and control of Starknet "
"Appchains or L3s."
msgstr ""

#: src/ch03-02-01-madara.md:5
#, fuzzy
msgid "Get Started with Madara"
msgstr "## å¼€å§‹ä½¿ç”¨Katana"

#: src/ch03-02-01-madara.md:13
msgid ""
"In this section, we will guide you through the building process so you can start hacking on the Madara stack. We will go from running your chain locally to changing the consensus algorithm and "
"interacting with smart contracts on your own chain!"
msgstr ""

#: src/ch03-02-01-madara.md:16
msgid "Let's start"
msgstr ""

#: src/ch03-02-01-madara.md:20
#, fuzzy
msgid "Install dependencies"
msgstr "## æ·»åŠ ä¾èµ–é¡¹"

#: src/ch03-02-01-madara.md:22
msgid " We first need to make sure you have everything needed to complete this tutorial."
msgstr ""

#: src/ch03-02-01-madara.md:25
msgid "Dependency"
msgstr ""

#: src/ch03-02-01-madara.md:25
msgid "Version"
msgstr ""

#: src/ch03-02-01-madara.md:27 src/ch03-04-nodes.md:80 src/ch03-04-nodes.md:81
msgid "Rust"
msgstr ""

#: src/ch03-02-01-madara.md:27
msgid "rustc 1.69.0-nightly"
msgstr ""

#: src/ch03-02-01-madara.md:27
#, fuzzy
msgid "`curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs \\| sh` "
msgstr ""
"```bash\n"
"curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh\n"
"```"

#: src/ch03-02-01-madara.md:27
msgid "`rustup toolchain install nightly`"
msgstr ""

#: src/ch03-02-01-madara.md:28
msgid "nvm"
msgstr ""

#: src/ch03-02-01-madara.md:28
msgid "latest"
msgstr ""

#: src/ch03-02-01-madara.md:28
msgid "`curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh \\| bash`"
msgstr ""

#: src/ch03-02-01-madara.md:29
msgid "Cairo"
msgstr ""

#: src/ch03-02-01-madara.md:29
msgid "1.0"
msgstr ""

#: src/ch03-02-01-madara.md:29
msgid "`curl -L https://github.com/franalgaba/cairo-installer/raw/main/bin/cairo-installer \\| bash`"
msgstr ""

#: src/ch03-02-01-madara.md:31
msgid "for macos ensure you have protobuf to avoid build time errors"
msgstr ""

#: src/ch03-02-01-madara.md:37
msgid "Build the chain"
msgstr ""

#: src/ch03-02-01-madara.md:39
msgid ""
"We will spin up a CairoVM Rollup from the Madara Stack source code. You could use docker images, but this way we keep the option to modify component behavior if you need to do so. The Madara stack "
"source code is a monorepo which can be found [here](https://github.com/keep-starknet-strange/madara)"
msgstr ""

#: src/ch03-02-01-madara.md:48
msgid "Then let's build the chain in `release` mode"
msgstr ""

#: src/ch03-02-01-madara.md:57
msgid "**Single-Node Development Chain**"
msgstr ""

#: src/ch03-02-01-madara.md:59
msgid "This command will start the single-node development chain with non-persistent"
msgstr ""

#: src/ch03-02-01-madara.md:61
msgid "run madara setup configuration:"
msgstr ""

#: src/ch03-02-01-madara.md:67
msgid "run madara node:"
msgstr ""

#: src/ch03-02-01-madara.md:73
msgid "Purge the development chain's state (only if you you want to keep the persist state of the node ):"
msgstr ""

#: src/ch03-02-01-madara.md:79
msgid "Start the development chain with detailed logging:"
msgstr ""

#: src/ch03-02-01-madara.md:82 src/ch03-02-01-madara.md:307
msgid "1"
msgstr ""

#: src/ch03-02-01-madara.md:85
#, fuzzy
msgid "Node example"
msgstr "# ç¤ºä¾‹"

#: src/ch03-02-01-madara.md:87
msgid "![running madara node example](./img/ch03-02-01-madara-1.png) If everything works correctly, we can go to the next step and create our own genesis state!"
msgstr ""

#: src/ch03-02-01-madara.md:90
msgid "By default, the chain will run with the following config :"
msgstr ""

#: src/ch03-02-01-madara.md:92
msgid "[GRANDPA & AURA](https://docs.substrate.io/learn/consensus/#default-consensus-models)"
msgstr ""

#: src/ch03-02-01-madara.md:93
msgid "An `admin` account contract at address `0x0000000000000000000000000000000000000000000000000000000000000001`"
msgstr ""

#: src/ch03-02-01-madara.md:94
msgid "A test contract at address `0x0000000000000000000000000000000000000000000000000000000000001111`"
msgstr ""

#: src/ch03-02-01-madara.md:95
msgid "A fee token (ETH) at address `0x040e59c2c182a58fb0a74349bfa4769cbbcba32547591dd3fb1def8623997d00`"
msgstr ""

#: src/ch03-02-01-madara.md:96
msgid "The `admin` account address has a `MAX` balance of fee token"
msgstr ""

#: src/ch03-02-01-madara.md:97
msgid "An ERC20 contract at address `0x040e59c2c182a58fb0a74349bfa4769cbbcba32547591dd3fb1def8623997d00`"
msgstr ""

#: src/ch03-02-01-madara.md:99
msgid "This chain specification can be thought of as the main source of information that will be used when connecting to the chain."
msgstr ""

#: src/ch03-02-01-madara.md:101
msgid "_(Not available yet) Deploy your settlement smart contracts_"
msgstr ""

#: src/ch03-02-01-madara.md:103
msgid "Connect with Polkadot-JS Apps Front-end"
msgstr ""

#: src/ch03-02-01-madara.md:105
msgid ""
"Once the node template is running locally, you can connect it with **Polkadot-JS Apps** front-end to interact with your chain. use [polkadat frontend](https://polkadot.js.org/apps/#/explorer?rpc=ws://"
"localhost:9944) or [madara zone frontend](https://explorer.madara.zone/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/accounts) connecting the Apps to your local node template."
msgstr ""

#: src/ch03-02-01-madara.md:110
msgid "UI connection"
msgstr ""

#: src/ch03-02-01-madara.md:112
msgid "![running madara node example](./img/ch03-02-01-madara-2.png)"
msgstr ""

#: src/ch03-02-01-madara.md:114
msgid "Start your chain"
msgstr ""

#: src/ch03-02-01-madara.md:116
msgid "Now that we are all setup, we can finally run the chain!"
msgstr ""

#: src/ch03-02-01-madara.md:118
msgid "There are a lot of ways you can run the chain depending on which role you want to take :"
msgstr ""

#: src/ch03-02-01-madara.md:120
msgid "**Full node**"
msgstr ""

#: src/ch03-02-01-madara.md:120
msgid " Synchronizes with the chain to store the most recent block state and block headers for older blocks. When developing your chain, you can simply run it in developer mode :"
msgstr ""

#: src/ch03-02-01-madara.md:128
msgid "**Archive node**"
msgstr ""

#: src/ch03-02-01-madara.md:128
msgid " Maintains all blocks starting from the genesis block with complete state available for every block. "
msgstr ""

#: src/ch03-02-01-madara.md:130
msgid " If you want to keep the whole state of the chain in a \\`/tmp/ folder :"
msgstr ""

#: src/ch03-02-01-madara.md:137
msgid "In this case, note that you can purge the chain's state whenever you like by running :"
msgstr ""

#: src/ch03-02-01-madara.md:143
msgid "**RPC node**"
msgstr ""

#: src/ch03-02-01-madara.md:143
msgid ""
" Exposes an RPC interface over HTTP or WebSocket ports for the chain so that users can read the blockchain state and submit transactions. There are often multiple RPC nodes behind a load balancer. If "
"you only care about exposing the RPC you can run the following :"
msgstr ""

#: src/ch03-02-01-madara.md:152
msgid "run Madara app rpc :"
msgstr ""

#: src/ch03-02-01-madara.md:158
msgid ""
"you can now interact with madara rpc  \n"
"Eg you can get the chain using the rpc"
msgstr ""

#: src/ch03-02-01-madara.md:163 src/ch03-02-01-madara.md:189 src/ch03-02-01-madara.md:337
msgid "'Content-Type: application/json'"
msgstr ""

#: src/ch03-02-01-madara.md:164
msgid ""
"'{\n"
"       \"jsonrpc\": \"2.0\",\n"
"       \"method\": \"starknet_chainId\",\n"
"       \"params\": [],\n"
"       \"id\": 1\n"
"     }'"
msgstr ""

#: src/ch03-02-01-madara.md:172
msgid "Madara rpc [examples](https://github.com/keep-starknet-strange/madara/tree/main/examples/rpc/starknet)"
msgstr ""

#: src/ch03-02-01-madara.md:174
msgid "Output example"
msgstr ""

#: src/ch03-02-01-madara.md:176
msgid "![running madara node example](./img/ch03-02-01-madara-3.png)"
msgstr ""

#: src/ch03-02-01-madara.md:178
msgid "**Validator node**"
msgstr ""

#: src/ch03-02-01-madara.md:178
msgid " Secures the chain by staking some chosen asset and votes on consensus along with other validators."
msgstr ""

#: src/ch03-02-01-madara.md:181
#, fuzzy
msgid "Deploy an account on your chain"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch03-02-01-madara.md:183
msgid "Ooook, now your chain is finally running. It's time to deploy your own account!"
msgstr ""

#: src/ch03-02-01-madara.md:185
msgid "Example of curl commad"
msgstr ""

#: src/ch03-02-01-madara.md:190
msgid ""
"'{\n"
"    \"jsonrpc\": \"2.0\",\n"
"    \"method\": \"starknet_addDeployAccountTransaction\",\n"
"    \"params\": {\n"
"        \"deploy_account_transaction\": {\n"
"            \"type\": \"DEPLOY_ACCOUNT\",\n"
"            \"max_fee\": \"0x0\",\n"
"            \"version\": \"0x1\",\n"
"            \"signature\": [\n"
"                \"0xd96bc7affb5648b601ddb49e9fd23f6ebfe59375e2ce5dd06b7db638d21b71\",\n"
"                \"0x6582c1512c8515254a52deb5fef1320d4f5dd0cb8352b260a4e7a90c61510ba\",\n"
"                \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"                \"0x0\",\n"
"                \"0x0\",\n"
"                \"0x0\",\n"
"                \"0x0\",\n"
"                \"0x0\",\n"
"                \"0x0\",\n"
"                \"0x0\"\n"
"            ],\n"
"            \"nonce\": \"0x0\",\n"
"            \"contract_address_salt\": \"0x61fcdc5594c726dc437ddc763265853d4dce51a57e25ff1d97b3e31401c7f4c\",\n"
"            \"constructor_calldata\": [\n"
"                \"0x5aa23d5bb71ddaa783da7ea79d405315bafa7cf0387a74f4593578c3e9e6570\",\n"
"                \"0x2dd76e7ad84dbed81c314ffe5e7a7cacfb8f4836f01af4e913f275f89a3de1a\",\n"
"                \"0x1\",\n"
"                \"0x61fcdc5594c726dc437ddc763265853d4dce51a57e25ff1d97b3e31401c7f4c\"\n"
"            ],\n"
"            \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\"\n"
"        }\n"
"    },\n"
"    \"id\": 1\n"
"}'"
msgstr ""

#: src/ch03-02-01-madara.md:225
msgid "expected json result ![account deployment result](./img/ch03-02-01-madara-4.png)"
msgstr ""

#: src/ch03-02-01-madara.md:228
msgid "Building Madara App Chain Your Using madara appchain Template"
msgstr ""

#: src/ch03-02-01-madara.md:230
msgid "clone the Madara appchain Template"
msgstr ""

#: src/ch03-02-01-madara.md:232
#, fuzzy
msgid ""
"```\n"
"git clone https://github.com/keep-starknet-strange/madara-app-chain-template.git\n"
"```"
msgstr ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"

#: src/ch03-02-01-madara.md:238
msgid "Ensure you have[ Required dependancies ](#dependencies)To run madara AppChain "
msgstr ""

#: src/ch03-02-01-madara.md:239
msgid ""
" Depending on your operating system and Rust version, there might be additional packages required to compile this template. Check the [Install](https://docs.substrate.io/install/) instructions for "
"your platform for the most common dependencies. Alternatively, you can use one of the [alternative installation](#alternatives-installations) options."
msgstr ""

#: src/ch03-02-01-madara.md:244
msgid "Build"
msgstr ""

#: src/ch03-02-01-madara.md:246
#, fuzzy
msgid "Use the following command to build the node without launching it:"
msgstr "æ‰§è¡Œä»¥ä¸‹æ“ä½œä»¥ç¼–è¯‘åˆçº¦ï¼š"

#: src/ch03-02-01-madara.md:252
msgid "Embedded Docs"
msgstr ""

#: src/ch03-02-01-madara.md:254
msgid "After you build the project, you can use the following command to explore its parameters and subcommands:"
msgstr ""

#: src/ch03-02-01-madara.md:260
msgid "You can generate and view the [Rust Docs](https://doc.rust-lang.org/cargo/commands/cargo-doc.html) for this template with this command:"
msgstr ""

#: src/ch03-02-01-madara.md:266
msgid "Single-Node Development Chain"
msgstr ""

#: src/ch03-02-01-madara.md:268
msgid "Set up the chain with the genesis config. More about defining the genesis state is mentioned below."
msgstr ""

#: src/ch03-02-01-madara.md:274
msgid "The following command starts a single-node development chain."
msgstr ""

#: src/ch03-02-01-madara.md:280
msgid "You can specify the folder where you want to store the genesis state as follows"
msgstr ""

#: src/ch03-02-01-madara.md:286
msgid "If you used a custom folder to store the genesis state, you need to specify it when running"
msgstr ""

#: src/ch03-02-01-madara.md:292
msgid "Please note, Madara overrides the default `dev` flag in substrate to meet its requirements. The following flags are automatically enabled with the `--dev` argument:"
msgstr ""

#: src/ch03-02-01-madara.md:294
msgid "`--chain=dev`, `--force-authoring`, `--alice`, `--tmp`, `--rpc-external`, `--rpc-methods=unsafe`"
msgstr ""

#: src/ch03-02-01-madara.md:296
msgid ""
"To store the chain state in the same folder as the genesis state, run the following command. You cannot combine the `base-path` command with `--dev` as `--dev` enforces `--tmp` which will store the db "
"at a temporary folder. You can, however, manually specify all flags that the dev flag adds automatically. Keep in mind, the path must be the same as the one you used in the setup command."
msgstr ""

#: src/ch03-02-01-madara.md:304
#, fuzzy
msgid "To start the development chain with detailed logging, run the following command:"
msgstr "è¦ä»æºä»£ç å®‰è£… `katana`ï¼Œè¯·è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#: src/ch03-02-01-madara.md:310
msgid "Connect with Polkadot-JS Apps Front-End"
msgstr ""

#: src/ch03-02-01-madara.md:312
msgid ""
"After you start the app chain locally, you can interact with it using the hosted version of the [Polkadot/Substrate Portal](https://polkadot.js.org/apps/#/explorer?rpc=ws://localhost:9944) front-end "
"by connecting to the local node endpoint. A hosted version is also available on [IPFS (redirect) here](https://dotapps.io/) or [IPNS (direct) here](ipns://dotapps.io/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/"
"explorer). You can also find the source code and instructions for hosting your own instance on the [polkadot-js/apps](https://github.com/polkadot-js/apps) repository."
msgstr ""

#: src/ch03-02-01-madara.md:316
msgid "Multi-Node Local Testnet"
msgstr ""

#: src/ch03-02-01-madara.md:318
msgid "If you want to see the multi-node consensus algorithm in action, see [Simulate a network](https://docs.substrate.io/tutorials/get-started/simulate-network/)."
msgstr ""

#: src/ch03-02-01-madara.md:320
msgid "Template Structure"
msgstr ""

#: src/ch03-02-01-madara.md:322
msgid "The app chain template gives you complete flexibility to modify exiting features of Madara and add new features as well."
msgstr ""

#: src/ch03-02-01-madara.md:324
msgid "Configuring appChain ID"
msgstr ""

#: src/ch03-02-01-madara.md:326
msgid "Fetching your Chain ID:"
msgstr ""

#: src/ch03-02-01-madara.md:328
msgid "The default chain ID on Madara is `SN_GOERLI`, to verify your chain ID, a POST call can be made to the RPC endpoint."
msgstr ""

#: src/ch03-02-01-madara.md:330
msgid "Initiate RPC Request:"
msgstr ""

#: src/ch03-02-01-madara.md:332
msgid "Execute the following POST request via curl to query the chain ID from your Madara node."
msgstr ""

#: src/ch03-02-01-madara.md:333
msgid "Endpoint: http://localhost:9944 (replace with the appropriate remote URL)."
msgstr ""

#: src/ch03-02-01-madara.md:336
msgid "'http://localhost:9944'"
msgstr ""

#: src/ch03-02-01-madara.md:338
msgid ""
"'{\n"
"        \"id\": 0,\n"
"        \"jsonrpc\": \"2.0\",\n"
"        \"method\": \"starknet_chainId\",\n"
"        \"params\": {}\n"
"    }'"
msgstr ""

#: src/ch03-02-01-madara.md:346
#, fuzzy
msgid "Parse Response:"
msgstr "è¿”å›æ˜¯ï¼š"

#: src/ch03-02-01-madara.md:348
msgid "Extract the chain ID in hex format from the \"result\" field within the JSON response."
msgstr ""

#: src/ch03-02-01-madara.md:352
msgid "\"jsonrpc\""
msgstr ""

#: src/ch03-02-01-madara.md:352
msgid "\"2.0\""
msgstr ""

#: src/ch03-02-01-madara.md:353
msgid "\"0x534e5f474f45524c49\""
msgstr ""

#: src/ch03-02-01-madara.md:358
msgid "Translate Hex:"
msgstr ""

#: src/ch03-02-01-madara.md:360
msgid "Use a hex converter tool (e.g., https://stark-utils.vercel.app/converter) to obtain the readable string representation of the chain ID."
msgstr ""

#: src/ch03-02-01-madara.md:362
msgid "Setting a custom Chain ID:"
msgstr ""

#: src/ch03-02-01-madara.md:364
msgid ""
"The Chain ID for your Madara app chain is configured in `crates/runtime/src/pallets.rs`. In Madara your chain ID is represented as the montgomery representation for a string. To update this follow the "
"below steps;"
msgstr ""

#: src/ch03-02-01-madara.md:368
msgid "Define your Chain ID:"
msgstr ""

#: src/ch03-02-01-madara.md:370
msgid "Choose a string to represent your app chain."
msgstr ""

#: src/ch03-02-01-madara.md:372
msgid "Convert Chain ID to felt"
msgstr ""

#: src/ch03-02-01-madara.md:374
msgid ""
"Navigate to `https://stark-utils.vercel.app/converter` and input your chosen string. The generated felt value is your hexadecimal representation for the string. ![stack](./img/ch03-02-01-madara-5-"
"stark-utils.png)"
msgstr ""

#: src/ch03-02-01-madara.md:377
msgid "Generate montgomery representation:"
msgstr ""

#: src/ch03-02-01-madara.md:379
msgid "Use Starkli to convert the felt value to a montgomery representation compatible with Madara."
msgstr ""

#: src/ch03-02-01-madara.md:391
msgid "Update the Chain ID:"
msgstr ""

#: src/ch03-02-01-madara.md:393
msgid "Open crates/primitives/chain-id/src/lib.rs and add your Chain ID alongside existing definitions:"
msgstr ""

#: src/ch03-02-01-madara.md:404
msgid "Update `pallets.rs`:"
msgstr ""

#: src/ch03-02-01-madara.md:406
msgid ""
"Modify the import statement in `crates/runtime/src/pallets.rs` to include your new Chain ID definition (refer to https://github.com/keep-starknet-strange/madara/blob/main/crates/runtime/src/pallets."
"rs#L13 for reference)."
msgstr ""

#: src/ch03-02-01-madara.md:407
msgid "Update the usage of the Chain ID within the code itself (refer to https://github.com/keep-starknet-strange/madara/blob/main/crates/runtime/src/pallets.rs#L164 for reference)."
msgstr ""

#: src/ch03-02-01-madara.md:409
msgid "Rebuild your Madara app chain with the updated pallets.rs file. Your app chain will now operate with your custom Chain ID."
msgstr ""

#: src/ch03-02-01-madara.md:411
msgid "appchain tooling"
msgstr ""

#: src/ch03-02-01-madara.md:413
msgid ""
"Madara is made to be **100%** Starknet compatible out of the box. This means that you can leverage all existing Starknet tools (detailed list [here](https://www.starknet.io/en/developers/tools-and-"
"resources)). In these docs, we cover some famous tools for you"
msgstr ""

#: src/ch03-02-01-madara.md:417
msgid "Argent X Overview"
msgstr ""

#: src/ch03-02-01-madara.md:419
msgid "[Argent X](https://www.argent.xyz/argent-x/) is an open-source Starknet wallet."
msgstr ""

#: src/ch03-02-01-madara.md:421
msgid "Installing Argent X"
msgstr ""

#: src/ch03-02-01-madara.md:423
msgid "Follow the official Argent X installation [instructions](https://www.argent.xyz/learn/how-to-create-an-argent-x-wallet/`)."
msgstr ""

#: src/ch03-02-01-madara.md:425
msgid "Use Argent X with Madara"
msgstr ""

#: src/ch03-02-01-madara.md:427
msgid ""
"Argent X includes the Mainnet, Sepolia, and Goerli networks by default, but connecting with your local Madara chain requires manual configuration. This involves adding a custom network within Argent "
"X's settings."
msgstr ""

#: src/ch03-02-01-madara.md:429
msgid "Configuring Argent X for Madara appchain"
msgstr ""

#: src/ch03-02-01-madara.md:431
msgid "Open the Argent X wallet and navigate to Settings."
msgstr ""

#: src/ch03-02-01-madara.md:433
msgid "![stack](./img/ch03-02-01-madara-6-argent-step1.png)"
msgstr ""

#: src/ch03-02-01-madara.md:435
msgid "Select \"Developer settings\" and then \"Manage networks\"."
msgstr ""

#: src/ch03-02-01-madara.md:437
msgid "![stack](./img/ch03-02-01-madara-6-argent-step2.png)"
msgstr ""

#: src/ch03-02-01-madara.md:439
msgid "Click the plus button on the top right to add a network."
msgstr ""

#: src/ch03-02-01-madara.md:441
msgid "![stack](./img/ch03-02-01-madara-6-argent-step3.png)"
msgstr ""

#: src/ch03-02-01-madara.md:443
msgid "Fill in the following fields:"
msgstr ""

#: src/ch03-02-01-madara.md:445
msgid "**Network Name**: A friendly name for the Madara network."
msgstr ""

#: src/ch03-02-01-madara.md:447
msgid "**Chain ID**: The default chain ID on Madara is `SN_GOERLI`, to retrieve your chain ID or to set a custom chain ID, refer to the [Chain ID](../tools/chain-id.mdx) section of Madara documentation."
msgstr ""

#: src/ch03-02-01-madara.md:451
msgid "RPC URL: `http://localhost:9944`"
msgstr ""

#: src/ch03-02-01-madara.md:453
msgid "Sequencer URL: `http://localhost:9944`"
msgstr ""

#: src/ch03-02-01-madara.md:455
msgid "![stack](./img/ch03-02-01-madara-6-argent-step4.png)"
msgstr ""

#: src/ch03-02-01-madara.md:457
msgid "Save the new network configuration."
msgstr ""

#: src/ch03-02-01-madara.md:459 src/ch03-02-01-madara.md:519
msgid "Once you have added Madara as a network, you can now connect to it."
msgstr ""

#: src/ch03-02-01-madara.md:461 src/ch03-02-01-madara.md:590
#, fuzzy
msgid "Deploying your Starknet wallet"
msgstr "## åœ¨Starknetæµ‹è¯•ç½‘ä¸Šéƒ¨ç½²"

#: src/ch03-02-01-madara.md:463
msgid "Upon creation, an Argent X wallet generates a Starknet address. However, this address exists in an \"undeployed\" state until you initiate your first transaction."
msgstr ""

#: src/ch03-02-01-madara.md:465
msgid ""
"Argent X manages the activation process under the hood; your first outgoing transaction acts as the trigger. This transaction initiates the deployment of your smart contract on the Madara chain. This "
"deployment incurs a one-time fee."
msgstr ""

#: src/ch03-02-01-madara.md:470
#, fuzzy
msgid "[Website](https://www.argent.xyz/argent-x/)"
msgstr ""
"- [Braavos](https://braavos.app/)\n"
"- [Argent](https://www.argent.xyz/argent-x/)"

#: src/ch03-02-01-madara.md:471
msgid "[FAQ](https://www.argent.xyz/faq/)"
msgstr ""

#: src/ch03-02-01-madara.md:472
msgid "[Twitter](https://twitter.com/argentHQ)"
msgstr ""

#: src/ch03-02-01-madara.md:474
msgid "Braavos Overview"
msgstr ""

#: src/ch03-02-01-madara.md:476
msgid "[Braavos](https://www.braavos.app) is a Starknet wallet."
msgstr ""

#: src/ch03-02-01-madara.md:478
msgid "Installing Braavos"
msgstr ""

#: src/ch03-02-01-madara.md:480
msgid "Follow the official Braavos installation [instructions](https://braavos.app/faq/setting-up-your-braavos-wallet-easy-starknet-guide/`)."
msgstr ""

#: src/ch03-02-01-madara.md:482
msgid "Use Braavos with Madara appchain"
msgstr ""

#: src/ch03-02-01-madara.md:484
msgid ""
"Braavos includes the Mainnet, Sepolia, and Goerli networks by default, but connecting with your local Madara chain requires manual configuration. This involves adding a custom network within Braavos's "
"settings."
msgstr ""

#: src/ch03-02-01-madara.md:486
msgid "Configuring Braavos for Madara"
msgstr ""

#: src/ch03-02-01-madara.md:488
msgid "Access Network Tab"
msgstr ""

#: src/ch03-02-01-madara.md:490
msgid "Open the Braavos wallet and navigate to the \"Network\" tab."
msgstr ""

#: src/ch03-02-01-madara.md:492
msgid "![stack](./img/ch03-02-01-madara-6-braavos-step1.png)"
msgstr ""

#: src/ch03-02-01-madara.md:494
msgid "Enable Developer Mode"
msgstr ""

#: src/ch03-02-01-madara.md:496
msgid "Locate the \"Developer\" option and select it. If prompted, choose \"Add Account\" to proceed."
msgstr ""

#: src/ch03-02-01-madara.md:498
msgid "![stack](./img/ch03-02-01-madara-6-braavos-step2.png)"
msgstr ""

#: src/ch03-02-01-madara.md:500
#, fuzzy
msgid "Access General Configuration:"
msgstr "`Fuzzer Configuration`"

#: src/ch03-02-01-madara.md:502
msgid "Click on the account icon, on the top left side and navigate to the `General` tab."
msgstr ""

#: src/ch03-02-01-madara.md:504
msgid "![stack](./img/ch03-02-01-madara-6-braavos-step3.png)"
msgstr ""

#: src/ch03-02-01-madara.md:506
msgid "Switch to the Developer Tab"
msgstr ""

#: src/ch03-02-01-madara.md:508
msgid "Within the \"General\" section, switch to the \"Developer\" tab. ![stack](./img/ch03-02-01-madara-6-braavos-step4.png)"
msgstr ""

#: src/ch03-02-01-madara.md:511
#, fuzzy
msgid "Configure RPC Connection"
msgstr "## ç®¡ç†è¿æ¥"

#: src/ch03-02-01-madara.md:513
msgid "Enable the \"Use RPC provider\" checkbox."
msgstr ""

#: src/ch03-02-01-madara.md:514
msgid "Set the \"Node host\" field to localhost."
msgstr ""

#: src/ch03-02-01-madara.md:515
msgid "Set the \"Node port\" field to 9944, assuming you're using the default Madara port."
msgstr ""

#: src/ch03-02-01-madara.md:517
msgid "![stack](./img/ch03-02-01-madara-6-braavos-step5.png)"
msgstr ""

#: src/ch03-02-01-madara.md:521
#, fuzzy
msgid "Starkli Overview"
msgstr "## Starknetä¸»é¡µæ¦‚è§ˆ"

#: src/ch03-02-01-madara.md:523
msgid ""
"Starkli is a command-line interface (CLI) tool designed to streamline interaction with your Madara chain. It simplifies managing accounts, deploying and interacting with smart contracts, and accessing "
"network data."
msgstr ""

#: src/ch03-02-01-madara.md:525
#, fuzzy
msgid "Installing Starkli"
msgstr "å®‰è£… starknetJSï¼š"

#: src/ch03-02-01-madara.md:536
#, fuzzy
msgid "Install starkli v0.1.20"
msgstr "å®‰è£… starknetJSï¼š"

#: src/ch03-02-01-madara.md:538
msgid "Madara currently is only compatible with starkli v0.1.20. Active development is underway to ensure the latest version is supported. Run starkliup to install starkli v0.1.20"
msgstr ""

#: src/ch03-02-01-madara.md:545
msgid "Starkli should now be installed. Restart the terminal"
msgstr ""

#: src/ch03-02-01-madara.md:548
#, fuzzy
msgid "Verify Starkli installation"
msgstr "## Starkli å®‰è£…"

#: src/ch03-02-01-madara.md:554
#, fuzzy
msgid "The output should display"
msgstr "è¾“å‡ºç»“æœåº”ç±»ä¼¼äºï¼š"

#: src/ch03-02-01-madara.md:562
msgid "Starkli allows you to perform all operations on your chain without leaving the command line."
msgstr ""

#: src/ch03-02-01-madara.md:564
msgid "Use Starkli in Madara"
msgstr ""

#: src/ch03-02-01-madara.md:566
msgid "Before starting with configuring Starkli, add your Madara RPC URL to the env. By default, this would be `http://localhost:9944`"
msgstr ""

#: src/ch03-02-01-madara.md:569
msgid "\"http://localhost:9944/\""
msgstr ""

#: src/ch03-02-01-madara.md:572
msgid "Configuring Starkli for Madara"
msgstr ""

#: src/ch03-02-01-madara.md:574
msgid ""
"The Starkli tutorial [here](https://book.starkli.rs/tutorials/starkli-101) should work with Madara. If you face issues when deploying your smart contract, ensure you're Scarb `0.6.1`. You can use asdf "
"for the same as explained [here](https://docs.swmansion.com/scarb/download.html#install-via-asdf)."
msgstr ""

#: src/ch03-02-01-madara.md:577
msgid "Also, make sure you've added the following lines in your Scarb.toml"
msgstr ""

#: src/ch03-02-01-madara.md:581
msgid "\">=2.1.0\""
msgstr ""

#: src/ch03-02-01-madara.md:588
msgid "[Docs](https://book.starkli.rs/)"
msgstr ""

#: src/ch03-02-01-madara.md:592
msgid "Upon creation, a Braavos wallet generates a Starknet address. However, this address exists in an \"undeployed\" state until you initiate your first transaction."
msgstr ""

#: src/ch03-02-01-madara.md:594
msgid ""
"Braavos manages the activation process under the hood; your first outgoing transaction acts as the trigger. This transaction initiates the creation and deployment of your personal smart contract on "
"the Madara chain. This deployment incurs a one-time fee."
msgstr ""

#: src/ch03-02-01-madara.md:599
msgid "[Website](https://braavos.app/)"
msgstr ""

#: src/ch03-02-01-madara.md:600
msgid "[FAQ](https://braavos.app/faq/)"
msgstr ""

#: src/ch03-02-01-madara.md:601
msgid "[Twitter](https://twitter.com/Braavos)"
msgstr ""

#: src/ch03-02-01-madara.md:603
#, fuzzy
msgid "Starknet.js Overview"
msgstr "## Starknetä¸»é¡µæ¦‚è§ˆ"

#: src/ch03-02-01-madara.md:605
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is a lightweight JavaScript/TypeScript library enabling interaction between your DApp and Starknet. Starknet.js allows you to interact with Starknet "
"accounts, providers, and contracts."
msgstr ""

#: src/ch03-02-01-madara.md:607
#, fuzzy
msgid "Installing Starknet.js"
msgstr "## å®‰è£… Starknet.js åº“"

#: src/ch03-02-01-madara.md:609
msgid "Follow the official Starknet.js installation instructions: https://www.starknetjs.com/docs/guides/intro"
msgstr ""

#: src/ch03-02-01-madara.md:611
msgid "Configuring Starknet.js for Madara"
msgstr ""

#: src/ch03-02-01-madara.md:613
msgid "Connecting to your running Madara node requires you to point your provider to the Madara RPC URL."
msgstr ""

#: src/ch03-02-01-madara.md:617
msgid "\"http://localhost:9944\""
msgstr ""

#: src/ch03-02-01-madara.md:621
msgid "You can now use this provider to interact with the chain as explained in the Starknet.js [docs](https://www.starknetjs.com/docs/guides/intro)."
msgstr ""

#: src/ch03-02-01-madara.md:623
msgid ""
"[Karnot](https://karnot.xyz) has also developed ready-to-use scripts using Starknet.js to fund wallets, declare and deploy contracts and some other useful tasks. You can refer to them [here](https://"
"github.com/karnotxyz/madara-get-started)."
msgstr ""

#: src/ch03-02-01-madara.md:628
msgid "[Website](hhttps://www.starknetjs.com)"
msgstr ""

#: src/ch03-02-01-madara.md:629
msgid "[Docs](https://www.starknetjs.com/docs/API/)"
msgstr ""

#: src/ch03-02-01-madara.md:631
msgid ""
"Moreover, Madara is built upon Substrate so you can actually _also_ leverage some popular substrate tooling like [polkadot.js](https://polkadot.js.org/apps/), [telemetry](https://telemetry.polkadot."
"io/), [polkadot-api](https://www.npmjs.com/package/@polkadot/api) and others."
msgstr ""

#: src/ch03-02-01-madara.md:634
msgid "Existing Pallets"
msgstr ""

#: src/ch03-02-01-madara.md:636
msgid ""
"Madara comes with only one pallet - `pallet_starknet`. This pallet allows app chains to execute Cairo contracts and have 100% RPC compatabiltiy with Starknet mainnet. This means all Cairo tooling "
"should work out of the box with the app chain. At the same time, the pallet also allows the app chain to fine tune specific parameters to meet their own needs."
msgstr ""

#: src/ch03-02-01-madara.md:638
msgid "`DisableTransactionFee`: If true, calculate and store the Starknet state commitments"
msgstr ""

#: src/ch03-02-01-madara.md:639
msgid "`DisableNonceValidation`: If true, check and increment nonce after a transaction"
msgstr ""

#: src/ch03-02-01-madara.md:640
msgid "`InvokeTxMaxNSteps`: Maximum number of Cairo steps for an invoke transaction"
msgstr ""

#: src/ch03-02-01-madara.md:641
msgid "`ValidateMaxNSteps`: Maximum number of Cairo steps when validating a transaction"
msgstr ""

#: src/ch03-02-01-madara.md:642
msgid "`MaxRecursionDepth`: Maximum recursion depth for transactions"
msgstr ""

#: src/ch03-02-01-madara.md:643
msgid "`ChainId`: The chain id of the app chain"
msgstr ""

#: src/ch03-02-01-madara.md:645
msgid "All these options can be configured inside `crates/runtime/src/pallets.rs`"
msgstr ""

#: src/ch03-02-01-madara.md:647
msgid "How to add New Pallets"
msgstr ""

#: src/ch03-02-01-madara.md:649
msgid "Before you can use a new pallet, you must add some information about it to the configuration file that the compiler uses to build the runtime binary."
msgstr ""

#: src/ch03-02-01-madara.md:651
msgid ""
"For Rust programs, you use the Cargo.toml file to define the configuration settings and dependencies that determine what gets compiled in the resulting binary. Because the Substrate runtime compiles "
"to both a native platform binary that includes standard library Rust functions and a WebAssembly (Wasm) binary that does not include the standard Rust library, the Cargo.toml file controls two "
"important pieces of information:"
msgstr ""

#: src/ch03-02-01-madara.md:653
msgid "The pallets to be imported as dependencies for the runtime, including the location and version of the pallets to import."
msgstr ""

#: src/ch03-02-01-madara.md:654
msgid ""
"The features in each pallet that should be enabled when compiling the native Rust binary. By enabling the standard (std) feature set from each pallet, you can compile the runtime to include functions, "
"types, and primitives that would otherwise be missing when you build the WebAssembly binary."
msgstr ""

#: src/ch03-02-01-madara.md:656
msgid ""
"For information about adding dependencies in Cargo.toml files, see Dependencies in the Cargo documentation. For information about enabling and managing features from dependent packages, see Features "
"in the Cargo documentation."
msgstr ""

#: src/ch03-02-01-madara.md:658
msgid "To add the dependencies for the Nicks pallet to the runtime:"
msgstr ""

#: src/ch03-02-01-madara.md:660
msgid "Open a terminal shell and change to the root directory for the Madara Appchain template."
msgstr ""

#: src/ch03-02-01-madara.md:661
msgid "Open the runtime/Cargo.toml configuration file in a text editor."
msgstr ""

#: src/ch03-02-01-madara.md:662
msgid "Locate the \\[dependencies\\] section and note how other pallets are imported."
msgstr ""

#: src/ch03-02-01-madara.md:664
msgid ""
"Copy an existing pallet dependency description and replace the pallet name with pallet-nicks to make the pallet available to the node template runtime. For example, add a line similar to the following:"
msgstr ""

#: src/ch03-02-01-madara.md:667
msgid ""
"```\n"
"    pallet-nicks = { version = \"4.0.0-dev\", default-features = false, git = \"https://github.com/paritytech/polkadot-sdk.git\", branch = \"polkadot-v1.0.0\" }\n"
"```"
msgstr ""

#: src/ch03-02-01-madara.md:671
msgid "This line imports the pallet-nicks crate as a dependency and specifies the following:"
msgstr ""

#: src/ch03-02-01-madara.md:673
msgid "Version to identify which version of the crate you want to import."
msgstr ""

#: src/ch03-02-01-madara.md:674
msgid "The default behavior for including pallet features when compiling the runtime with the standard Rust libraries."
msgstr ""

#: src/ch03-02-01-madara.md:675
msgid "Repository location for retrieving the pallet-nicks crate."
msgstr ""

#: src/ch03-02-01-madara.md:676
msgid "Branch to use for retrieving the crate. Be sure to use the same version and branch information for the Nicks pallet as you see used for the other pallets included in the runtime."
msgstr ""

#: src/ch03-02-01-madara.md:678
msgid "These details should be the same for every pallet in any given version of the node template."
msgstr ""

#: src/ch03-02-01-madara.md:680
msgid "Add the pallet-nicks/std features to the list of features to enable when compiling the runtime."
msgstr ""

#: src/ch03-02-01-madara.md:682
msgid ""
"```\n"
"[features]\n"
"default = [\"std\"]\n"
"std = [\n"
"  ...\n"
"  \"pallet-aura/std\",\n"
"  \"pallet-balances/std\",\n"
"  \"pallet-nicks/std\",\n"
"  ...\n"
"]\n"
"```"
msgstr ""

#: src/ch03-02-01-madara.md:694
msgid "If you forget to update the features section in the Cargo.toml file, you might see cannot find function errors when you compile the runtime binary."
msgstr ""

#: src/ch03-02-01-madara.md:696
msgid "You can read more about it [here](https://docs.substrate.io/tutorials/build-application-logic/add-a-pallet/)."
msgstr ""

#: src/ch03-02-01-madara.md:698
#, fuzzy
msgid "Runtime configuration"
msgstr "`Fuzzer Configuration`"

#: src/ch03-02-01-madara.md:700
msgid "Similar to new pallets, runtime configurations can be just like they're done in Substrate. You can edit all the available parameters inside `crates/runtime/src/config.rs`."
msgstr ""

#: src/ch03-02-01-madara.md:702
msgid "For example, to change the block time, you can edit the `MILLISECS_PER_BLOCK` variable."
msgstr ""

#: src/ch03-02-01-madara.md:704
#, fuzzy
msgid "Alternatives Installations"
msgstr "åŸºæœ¬å®‰è£…"

#: src/ch03-02-01-madara.md:706
msgid "Instead of installing dependencies and building this source directly, consider the following alternatives."
msgstr ""

#: src/ch03-02-01-madara.md:708
msgid "Nix"
msgstr ""

#: src/ch03-02-01-madara.md:710
msgid ""
"Install [nix](https://nixos.org/), and optionally [direnv](https://github.com/direnv/direnv) and [lorri](https://github.com/nix-community/lorri) for a fully plug-and-play experience for setting up the "
"development environment. To get all the correct dependencies, activate direnv `direnv allow` and lorri `lorri shell`."
msgstr ""

#: src/ch03-02-01-madara.md:713
msgid "Docker"
msgstr ""

#: src/ch03-02-01-madara.md:715
msgid "building madara in docker"
msgstr ""

#: src/ch03-02-01-madara.md:717
#, fuzzy
msgid "First, install [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/)."
msgstr ""
"å»ºè®®ä½¿ç”¨çš„æ“ä½œç³»ç»Ÿå’Œè½¯ä»¶Ubuntu LTSã€\n"
"[Docker](https://docs.docker.com/engine/install/ubuntu) å’Œ [Docker\n"
"Compose](https://docs.docker.com/compose/install/linux)ã€‚ç¡®ä¿\n"
"å®‰è£…äº†å¿…è¦çš„å·¥å…·ï¼š"

#: src/ch03-02-01-madara.md:720
msgid "pulling predeployed madara docker image"
msgstr ""

#: src/ch03-02-01-madara.md:726
msgid "runining docker container"
msgstr ""

#: src/ch03-02-01-madara.md:732
msgid "Please use the [Madara Dockerfile](https://github.com/keep-starknet-strange/madara/blob/main/Dockerfile) as a reference to build the Docker container with your App Chain node as a binary."
msgstr ""

#: src/ch03-03-provers.md:3
#, fuzzy
msgid ""
"SHARP is like public transportation for proofs on Starknet, aggregating multiple Cairo programs to save costs and boost efficiency. It uses recursive proofs, allowing parallelization and optimization, "
"making it more affordable for all users. Critical services like the gateway, validator, and Prover work together with a stateless design for flexibility. SHARPâ€™s adoption by StarkEx, Starknet, and "
"external users (through the Cairo Playground) highlights its significance and potential for future optimization."
msgstr ""
"SHARP å°±åƒStarknetæ‰“æ ·çš„å…¬å…±äº¤é€šï¼Œæ±‡é›†äº†\n"
"å¤šä¸ªCairoè®¡åˆ’ï¼Œä»¥èŠ‚çº¦æˆæœ¬ï¼Œæé«˜æ•ˆç‡ã€‚å®ƒä½¿ç”¨\n"
"é€’å½’è¯æ˜ï¼Œå…è®¸å¹¶è¡ŒåŒ–å’Œä¼˜åŒ–ï¼Œä½¿æ‰€æœ‰ç”¨æˆ·éƒ½èƒ½è´Ÿæ‹…å¾—èµ·ã€‚\n"
"è®©æ‰€æœ‰ç”¨æˆ·éƒ½èƒ½è´Ÿæ‹…å¾—èµ·ã€‚å…³é”®æœåŠ¡ï¼Œå¦‚ç½‘å…³ã€\n"
"éªŒè¯å™¨å’Œè¯æ˜å™¨ç­‰å…³é”®æœåŠ¡ä¸€èµ·å·¥ä½œï¼Œé‡‡ç”¨æ— çŠ¶æ€è®¾è®¡ï¼Œå…·æœ‰çµæ´»æ€§ã€‚\n"
"çµæ´»æ€§ã€‚StarkExã€Starknet å’Œå¤–éƒ¨ç”¨æˆ·ï¼ˆé€šè¿‡ Cairo Playgroundï¼‰éƒ½é‡‡ç”¨äº† SHARPã€‚\n"
"(é€šè¿‡Cairoæ¸¸ä¹åœºï¼‰çš„é‡‡ç”¨å‡¸æ˜¾äº†å…¶é‡è¦æ€§å’Œæœªæ¥ä¼˜åŒ–çš„æ½œåŠ›ã€‚\n"
"æœªæ¥ä¼˜åŒ–çš„æ½œåŠ›ã€‚"

#: src/ch03-03-provers.md:12
#, fuzzy
msgid "This chapter will discuss SHARP, how it has evolved to incorporate recursive proofs, and its role in reducing costs and improving efficiency within the Starknet network."
msgstr ""
"æœ¬ç« å°†è®¨è®º SHARPï¼Œå®ƒæ˜¯å¦‚ä½•å‘å±•ä»¥çº³å…¥é€’å½’è¯æ˜çš„ã€‚\n"
"é€’å½’è¯æ˜ï¼Œä»¥åŠå®ƒåœ¨é™ä½æˆæœ¬å’Œæé«˜Starknetæ•ˆç‡æ–¹é¢çš„ä½œç”¨ã€‚\n"
"æé«˜Starknetæ•ˆç‡çš„ä½œç”¨ã€‚"

#: src/ch03-03-provers.md:16
#, fuzzy
msgid "What is SHARP?"
msgstr "##ä»€ä¹ˆæ˜¯å¤æ™®ï¼Ÿ"

#: src/ch03-03-provers.md:18
#, fuzzy
msgid ""
"SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet that aggregates multiple Cairo programs from different users, each containing different logic. These Cairo programs are then "
"executed together, generating a single proof common to all the programs. Rather than sending the proof directly to the Solidity Verifier in Ethereum, it is initially sent to a STARK Verifier program "
"written in Cairo. The STARK Verifier generates a new proof to confirm that the initial proofs were verified, which can be sent back into SHARP and the STARK Verifier. This recursive proof process will "
"be discussed in more detail later in this chapter. Ultimately, the last proof in the series is sent to the Solidity Verifier on Ethereum. In other words, there are many proofs generated until we reach "
"Ethereum and the Solidity Verifier."
msgstr ""
"SHARP æ˜¯ \"å…±äº«è¯æ˜å™¨ \"çš„ç¼©å†™ï¼Œæ˜¯Starknetä¸­ä½¿ç”¨çš„ä¸€ç§æœºåˆ¶ã€‚\n"
"ä¸­ä½¿ç”¨çš„ä¸€ç§æœºåˆ¶ï¼Œå®ƒå°†æ¥è‡ªä¸åŒç”¨æˆ·çš„å¤šä¸ªCairoç¨‹åºèšåˆåœ¨ä¸€èµ·ï¼Œæ¯ä¸ªç¨‹åºéƒ½\n"
"åŒ…å«ä¸åŒçš„é€»è¾‘ã€‚ç„¶åå°†è¿™äº›Cairoç¨‹åº\n"
"ä¸€èµ·æ‰§è¡Œï¼Œç”Ÿæˆæ‰€æœ‰ç¨‹åºå…±æœ‰çš„ä¸€ä¸ªè¯æ˜ã€‚è€Œä¸æ˜¯\n"
"ç›´æ¥å‘é€ç»™ä»¥å¤ªåŠçš„ Solidity æ ¡éªŒå™¨ï¼Œè€Œæ˜¯\n"
"è€Œæ˜¯å…ˆå‘é€ç»™ç”¨Cairoç¼–å†™çš„ STARK æ ¡éªŒç¨‹åºã€‚è¯¥\n"
"STARK æ ¡éªŒå™¨ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„è¯æ˜ï¼Œä»¥ç¡®è®¤åˆå§‹è¯æ˜\n"
"å¾—åˆ°éªŒè¯ï¼Œç„¶åå†å‘é€å› SHARP å’Œ STARK æ ¡éªŒå™¨ã€‚\n"
"æœ¬ç« ç¨åå°†è¯¦ç»†è®¨è®ºè¿™ä¸€é€’å½’è¯æ˜è¿‡ç¨‹ã€‚\n"
"æœ¬ç« ç¨åå°†è¯¦ç»†è®¨è®ºã€‚æœ€ç»ˆï¼Œè¿™ä¸€ç³»åˆ—ä¸­çš„æœ€åä¸€ä¸ªè¯æ˜ä¼šè¢«å‘é€åˆ°\n"
"ä»¥å¤ªåŠä¸Šçš„ Solidity æ ¡éªŒå™¨ã€‚æ¢å¥è¯è¯´ï¼Œåœ¨æˆ‘ä»¬åˆ°è¾¾ä»¥å¤ªåŠ\n"
"ç›´åˆ°æˆ‘ä»¬åˆ°è¾¾ä»¥å¤ªåŠå’Œ Solidity æ ¡éªŒå™¨ã€‚"

#: src/ch03-03-provers.md:31
#, fuzzy
msgid ""
"The primary benefit of SHARP system lies in its ability to decrease costs and enhance efficiency within the Starknet network. It achieves this by aggregating multiple Cairo jobs, which are individual "
"sets of computations. This aggregation allows the protocol to leverage the exponential amortization offered by STARK proofs."
msgstr ""
"SHARP ç³»ç»Ÿçš„ä¸»è¦ä¼˜åŠ¿åœ¨äºå®ƒèƒ½å¤Ÿé™ä½æˆæœ¬ï¼Œæé«˜Starknetç½‘ç»œçš„æ•ˆç‡ã€‚\n"
"æˆæœ¬å’Œæé«˜Starknetæ•ˆç‡çš„èƒ½åŠ›ã€‚å®ƒé€šè¿‡\n"
"å®ƒé€šè¿‡èšåˆå¤šä¸ªCairoä½œä¸šï¼ˆå³å•ä¸ªè®¡ç®—é›†ï¼‰æ¥å®ç°è¿™ä¸€ç›®æ ‡ã€‚\n"
"è®¡ç®—ã€‚è¿™ç§èšåˆä½¿åè®®èƒ½å¤Ÿåˆ©ç”¨Starknetæä¾›çš„\n"
"STARK è¯æ˜æä¾›çš„æŒ‡æ•°çº§æ‘Šé”€ã€‚"

#: src/ch03-03-provers.md:37
#, fuzzy
msgid ""
"Exponential amortization means that as the computational load of the proofs increases, the cost of verifying those proofs rises at a slower logarithmic rate than the computation increase. In other "
"words, the computation itself grows slower than the verification cost. As a result, the cost of each transaction within the aggregated set is significantly reduced, making the overall process more "
"cost-effective and accessible for users."
msgstr ""
"æŒ‡æ•°æ‘Šé”€æ„å‘³ç€ï¼Œéšç€è¯æ˜çš„è®¡ç®—è´Ÿè·å¢åŠ \n"
"è¯æ˜çš„å¢åŠ ï¼ŒéªŒè¯è¿™äº›è¯æ˜çš„æˆæœ¬ä¼šä»¥æ¯”è®¡ç®—é‡å¢åŠ æ›´æ…¢çš„å¯¹æ•°é€Ÿåº¦ä¸Šå‡ã€‚\n"
"å¯¹æ•°é€Ÿç‡ä¸Šå‡ã€‚æ¢å¥è¯è¯´\n"
"æ¢å¥è¯è¯´ï¼Œè®¡ç®—æœ¬èº«çš„å¢é•¿é€Ÿåº¦è¦æ…¢äºéªŒè¯æˆæœ¬çš„å¢é•¿é€Ÿåº¦ã€‚å› æ­¤\n"
"èšåˆé›†å†…æ¯ç¬”äº¤æ˜“çš„æˆæœ¬å°±ä¼šå¤§å¤§é™ä½ï¼Œä½¿æ•´ä¸ªæµç¨‹çš„æˆæœ¬æ›´ä½ã€‚\n"
"å› æ­¤ï¼Œèšåˆé›†å†…æ¯ç¬”äº¤æ˜“çš„æˆæœ¬éƒ½ä¼šå¤§å¤§é™ä½ï¼Œä»è€Œä½¿æ•´ä¸ªæµç¨‹æ›´å…·æˆæœ¬æ•ˆç›Šï¼Œä¹Ÿæ›´ä¾¿äºç”¨æˆ·ä½¿ç”¨ã€‚\n"
"ç”¨æˆ·ã€‚"

#: src/ch03-03-provers.md:45
#, fuzzy
msgid ""
"In SHARP and Cairo context, \"jobs\" refer to the individual Cairo programs or tasks submitted by different users. These jobs contain specific logic or computations that must be executed on the "
"Starknet network."
msgstr ""
"åœ¨ SHARP å’ŒCairoçš„è¯­å¢ƒä¸­ï¼Œ\"ä½œä¸š \"æ˜¯æŒ‡ä¸åŒç”¨æˆ·æäº¤çš„å•ä¸ªCairo\n"
"ç¨‹åºæˆ–ä»»åŠ¡ã€‚è¿™äº›ä»»åŠ¡åŒ…å«\n"
"å¿…é¡»åœ¨Starknetæ‰§è¡Œçš„ç‰¹å®šé€»è¾‘æˆ–è®¡ç®—ã€‚\n"
"ç½‘ç»œä¸Šæ‰§è¡Œã€‚"

#: src/ch03-03-provers.md:50
#, fuzzy
msgid ""
"Additionally, SHARP allows smaller users with limited computation to benefit from joining other jobs and share the cost of generating the proofs. This collaborative approach is similar to using public "
"transportation instead of a private car, where the cost is distributed among all participants, making it more affordable for everyone."
msgstr ""
"æ­¤å¤–ï¼ŒSHARP è¿˜å…è®¸è®¡ç®—èƒ½åŠ›æœ‰é™çš„å°å‹ç”¨æˆ·\n"
"ä»åŠ å…¥å…¶ä»–å·¥ä½œä¸­è·ç›Šï¼Œå¹¶åˆ†æ‹…ç”Ÿæˆè¯æ˜çš„æˆæœ¬ã€‚\n"
"è¯æ˜ã€‚è¿™ç§åˆä½œæ–¹å¼ç±»ä¼¼äº\n"
"è¿™ç§åˆä½œæ–¹å¼ç±»ä¼¼äºä½¿ç”¨å…¬å…±äº¤é€šè€Œä¸æ˜¯ç§å®¶è½¦ã€‚\n"
"è´¹ç”¨ç”±æ‰€æœ‰å‚ä¸è€…åˆ†æ‹…ï¼Œä½¿æ¯ä¸ªäººéƒ½èƒ½è´Ÿæ‹…å¾—èµ·ã€‚"

#: src/ch03-03-provers.md:56
#, fuzzy
msgid "Recursive Proofs in SHARP"
msgstr "## SHARP ä¸­çš„é€’å½’è¯æ˜"

#: src/ch03-03-provers.md:58
#, fuzzy
msgid ""
"One of the most powerful features of SHARP is its use of recursive proofs. Rather than directly sending the generated proofs to the Solidity Verifier, they are first sent to a STARK Verifier program "
"written in Cairo. This Verifier, which is also a Cairo Program, receives the proof and creates a new Cairo job that is sent to the Prover. The Prover then generates a new proof to confirm that the "
"initial proofs were verified. These new proofs can be sent back into SHARP and the STARK Verifier, restarting the process."
msgstr ""
"SHARP æœ€å¼ºå¤§çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯ä½¿ç”¨é€’å½’è¯æ˜ã€‚\n"
"è¯æ˜ã€‚å®ƒä¸æ˜¯ç›´æ¥å°†ç”Ÿæˆçš„è¯æ˜å‘é€ç»™\n"
"SolidityéªŒè¯å™¨ï¼Œè€Œæ˜¯å…ˆå°†å®ƒä»¬å‘é€åˆ°ç”¨Cairoè¯­è¨€ç¼–å†™çš„STARKéªŒè¯å™¨ç¨‹åºä¸­ã€‚\n"
"Cairoç¼–å†™çš„ STARK æ ¡éªŒç¨‹åºã€‚è¯¥éªŒè¯ç¨‹åºä¹Ÿæ˜¯ä¸€ä¸ªCairoç¨‹åºï¼Œå®ƒæ¥æ”¶è¯æ˜å¹¶åˆ›å»ºæ–°çš„Cairoä»»åŠ¡ã€‚\n"
"å¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„ Cairo ä½œä¸šï¼Œç„¶åå‘é€ç»™éªŒè¯å™¨ã€‚éªŒè¯è€…\n"
"è¯æ˜è€…éšåç”Ÿæˆä¸€ä¸ªæ–°çš„è¯æ˜ï¼Œä»¥ç¡®è®¤åˆå§‹è¯æ˜\n"
"å·²è¢«éªŒè¯ã€‚è¿™äº›æ–°çš„è¯æ˜å¯ä»¥å‘é€å› SHARP å’Œ\n"
"STARK æ ¡éªŒå™¨ï¼Œé‡æ–°å¯åŠ¨æµç¨‹ã€‚"

#: src/ch03-03-provers.md:67
#, fuzzy
msgid ""
"This process continues recursively, with each new proof being sent to the Cairo Verifier until a trigger is reached. At this point, the last proof in the series is sent to the Solidity Verifier on "
"Ethereum. This approach allows for greater parallelization of the computation and reduces the time and cost associated with generating and verifying proofs."
msgstr ""
"è¿™ä¸ªè¿‡ç¨‹ä¸æ–­é€’å½’ï¼Œæ¯ä¸ªæ–°çš„è¯æ˜éƒ½ä¼šè¢«å‘é€åˆ°\n"
"CairoéªŒè¯å™¨ï¼Œç›´åˆ°è¾¾åˆ°è§¦å‘ç‚¹ã€‚æ­¤æ—¶ï¼Œç³»åˆ—ä¸­çš„æœ€åä¸€ä¸ª\n"
"è¯æ˜è¢«å‘é€åˆ°ä»¥å¤ªåŠä¸Šçš„ Solidity æ ¡éªŒå™¨ã€‚è¿™ç§\n"
"è¿™ç§æ–¹æ³•å¯ä»¥æé«˜è®¡ç®—çš„å¹¶è¡ŒåŒ–ç¨‹åº¦ï¼Œå¹¶\n"
"å‡å°‘ä¸ç”Ÿæˆå’ŒéªŒè¯è¯æ˜ç›¸å…³çš„æ—¶é—´å’Œæˆæœ¬ã€‚\n"
"è¯æ˜çš„æ—¶é—´å’Œæˆæœ¬ã€‚"

#: src/ch03-03-provers.md:97
#, fuzzy
msgid "At first glance, recursive proofs may seem more complex and time-consuming. However, there are several benefits to this approach:"
msgstr ""
"ä¹ä¸€çœ‹ï¼Œé€’å½’è¯æ˜ä¼¼ä¹æ›´å¤æ‚ã€æ›´è€—æ—¶ã€‚\n"
"è´¹æ—¶ã€‚ç„¶è€Œï¼Œè¿™ç§æ–¹æ³•æœ‰å‡ ä¸ªå¥½å¤„ï¼š"

#: src/ch03-03-provers.md:100
msgid "**Parallelization**: Recursive proofs allow for work parallelization, reducing user latency and improving SHARP efficiency."
msgstr ""

#: src/ch03-03-provers.md:104
msgid ""
"**Cheaper on-chain costs**: Parallelization enables SHARP to create larger proofs, which would have previously been limited by the availability of large cloud machines (which are rare and limited). As "
"a result, on-chain costs are reduced."
msgstr ""

#: src/ch03-03-provers.md:109
msgid "**Lower cloud costs**: Since each job is shorter, the required memory for processing is reduced, resulting in lower cloud costs."
msgstr ""

#: src/ch03-03-provers.md:112
msgid "**Optimization**: Recursive proofs enable SHARP to optimize for various factors, including latency, on-chain costs, and time to proof."
msgstr ""

#: src/ch03-03-provers.md:116
msgid "**Cairo support**: Recursive proofs only require support in Cairo, without the need to add support in the Solidity Verifier."
msgstr ""

#: src/ch03-03-provers.md:119
#, fuzzy
msgid ""
"Latency in Starknet encompasses the time taken for processing, confirming, and including transactions in a block. It is affected by factors like network congestion, transaction fees, and system "
"efficiency. Minimizing latency ensures faster transaction processing and user feedback."
msgstr ""
"Starknetçš„å»¶è¿ŸåŒ…æ‹¬å¤„ç†ã€ç¡®è®¤å’ŒåŒ…å«åŒºå—ä¸­çš„äº¤æ˜“æ‰€éœ€çš„æ—¶é—´ã€\n"
"ç¡®è®¤ä»¥åŠå°†äº¤æ˜“çº³å…¥åŒºå—æ‰€éœ€çš„æ—¶é—´ã€‚å®ƒå—\n"
"ç½‘ç»œæ‹¥å µã€äº¤æ˜“è´¹ç”¨å’Œç³»ç»Ÿæ•ˆç‡ç­‰å› ç´ çš„å½±å“ã€‚\n"
"æ•ˆç‡ç­‰å› ç´ çš„å½±å“ã€‚æœ€å¤§é™åº¦åœ°å‡å°‘å»¶è¿Ÿå¯ç¡®ä¿æ›´å¿«çš„äº¤æ˜“å¤„ç†å’Œç”¨æˆ·åé¦ˆã€‚\n"
"ç”¨æˆ·åé¦ˆã€‚"

#: src/ch03-03-provers.md:125
#, fuzzy
msgid "Time to proof, however, specifically pertains to the duration required to generate and verify cryptographic proofs for transactions or operations."
msgstr ""
"ä¸è¿‡ï¼Œè¯æ˜æ‰€éœ€æ—¶é—´å…·ä½“æŒ‡çš„æ˜¯\n"
"ç”Ÿæˆå’ŒéªŒè¯äº¤æ˜“æˆ–æ“ä½œçš„åŠ å¯†è¯æ˜æ‰€éœ€çš„æ—¶é—´ã€‚\n"
"æ“ä½œæ‰€éœ€çš„æ—¶é—´ã€‚"

#: src/ch03-03-provers.md:129
#, fuzzy
msgid "SHARP Backend Architecture and Data Pipeline"
msgstr "## SHARP åç«¯æ¶æ„å’Œæ•°æ®ç®¡é“"

#: src/ch03-03-provers.md:131
#, fuzzy
msgid "SHARP back end architecture consists of several services that work together to process Cairo jobs and generate proofs. These services include:"
msgstr ""
"SHARP åç«¯æ¶æ„ç”±å¤šä¸ªæœåŠ¡ç»„æˆï¼Œå®ƒä»¬å…±åŒ\n"
"å…±åŒå¤„ç†Cairoä½œä¸šå¹¶ç”Ÿæˆè¯æ˜ã€‚è¿™äº›æœåŠ¡\n"
"åŒ…æ‹¬"

#: src/ch03-03-provers.md:135
msgid "**Gateway**: Cairo jobs enter SHARP through the gateway."
msgstr ""

#: src/ch03-03-provers.md:137
msgid "**Job Creator**: It prevents job duplication and ensures that the system operates consistently, regardless of multiple identical requests."
msgstr ""

#: src/ch03-03-provers.md:141
msgid ""
"**Validator**: This is the first important step. The validator service runs validation checks on each job, ensuring they meet the requirements and can fit within the prover machines. Invalid jobs are "
"tagged as such and do not proceed to the Prover."
msgstr ""

#: src/ch03-03-provers.md:146
msgid "**Scheduler**: The scheduler service creates \"trains\" that aggregate jobs and send them to the Prover. Recursive jobs are paired and sent to the Prover together."
msgstr ""

#: src/ch03-03-provers.md:150
msgid ""
"**Cairo Runner**: This service runs Cairo for the Proverâ€™s needs. The Cairo Runner service runs Cairo programs, executing the necessary computations and generating the execution trace as an "
"intermediate result. The Prover then uses this execution trace."
msgstr ""

#: src/ch03-03-provers.md:155
msgid "**Prover**: The Prover computes the proofs for each train (that contains a few jobs)."
msgstr ""

#: src/ch03-03-provers.md:158
msgid "**Dispatcher**: The Dispatcher serves two functions in the SHARP system."
msgstr ""

#: src/ch03-03-provers.md:161
msgid "In the case of a recursive proof, the Dispatcher runs the Cairo Verifier program on the proof it has received from the Prover, resulting in a new Cairo job that goes back to the Validator."
msgstr ""

#: src/ch03-03-provers.md:165
msgid "In the case of a proof that needs to go on chain (e.g., to Ethereum), the Dispatcher creates \"packages\" from the proof, which can then be sent to the Blockchain Writer."
msgstr ""

#: src/ch03-03-provers.md:169
msgid ""
"**Blockchain Writer**: Once the packages have been created by the Dispatcher, they are sent to the Blockchain Writer. The Blockchain Writer is responsible for sending the packages to the appropriate "
"blockchain (e.g., Ethereum) for verification. This is an important step in the SHARP system, as it ensures that the proofs are properly verified and that the transactions are securely recorded on the "
"blockchain."
msgstr ""

#: src/ch03-03-provers.md:177
msgid ""
"**Catcher**: The Catcher monitors blockchain (e.g., Ethereum) transactions to ensure that they have been accepted. While the Catcher is relevant for internal monitoring purposes, it is important to "
"note that if a transaction fails, the fact wonâ€™t be registered on-chain in the fact registry. As a result, the soundness of the system is still preserved even without the catcher."
msgstr ""

#: src/ch03-03-provers.md:184
#, fuzzy
msgid "SHARP is designed to be stateless (each Cairo job is executed in its own context and has no dependency on other jobs), allowing for greater flexibility in processing jobs."
msgstr ""
"SHARP çš„è®¾è®¡æ˜¯æ— çŠ¶æ€çš„ï¼ˆæ¯ä¸ª Cairo ä½œä¸šéƒ½åœ¨è‡ªå·±çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œï¼Œä¸ä¾èµ–äºå…¶ä»–ä½œä¸šã€‚\n"
"ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œï¼Œä¸ä¾èµ–äºå…¶ä»–ä½œä¸šï¼‰ï¼Œä½¿ä½œä¸šå¤„ç†æ›´åŠ çµæ´»ã€‚\n"
"å¤„ç†ä½œä¸šçš„çµæ´»æ€§ã€‚"

#: src/ch03-03-provers.md:188
#, fuzzy
msgid "Current SHARP Users"
msgstr "## ç›®å‰çš„å¤æ™®ç”¨æˆ·"

#: src/ch03-03-provers.md:190
#, fuzzy
msgid "Currently, the primary users of SHARP include:"
msgstr "ç›®å‰ï¼ŒSHARP çš„ä¸»è¦ç”¨æˆ·åŒ…æ‹¬"

#: src/ch03-03-provers.md:196
#, fuzzy
msgid "External users who use the Cairo Playground"
msgstr ""
"- StarkEx\n"
"\n"
"- Starknet\n"
"\n"
"- ä½¿ç”¨Cairoæ¸¸ä¹åœºçš„å¤–éƒ¨ç”¨æˆ·"

#: src/ch03-03-provers.md:198
#, fuzzy
msgid "Challenges and Optimization"
msgstr "## æŒ‘æˆ˜ä¸ä¼˜åŒ–"

#: src/ch03-03-provers.md:200
#, fuzzy
msgid "Optimizing the Prover involves numerous challenges and potential projects on which the Starkware team and the community are currently working:"
msgstr ""
"ä¼˜åŒ– Prover æ¶‰åŠè®¸å¤šæŒ‘æˆ˜å’Œæ½œåœ¨é¡¹ç›®ï¼ŒStarkware å›¢é˜Ÿå’Œç¤¾åŒºç›®å‰æ­£åœ¨å¼€å±•è¿™äº›æŒ‘æˆ˜å’Œé¡¹ç›®ã€‚\n"
"é¡¹ç›®ï¼ŒStarkware å›¢é˜Ÿå’Œç¤¾åŒºç›®å‰æ­£åœ¨å¼€å±•ä»¥ä¸‹å·¥ä½œ\n"
"å·¥ä½œï¼š"

#: src/ch03-03-provers.md:204
msgid "Exploring more efficient hash functions: SHARP is constantly exploring more efficient hash functions for Cairo, the Prover, and Solidity."
msgstr ""

#: src/ch03-03-provers.md:208
msgid "Investigating smaller fields: Investigating smaller fields for recursive proof steps could lead to more efficient computations."
msgstr ""

#: src/ch03-03-provers.md:211
msgid "Adjusting various parameters: SHARP is continually adjusting various parameters of the STARK protocol, such as FRI parameters and block factors."
msgstr ""

#: src/ch03-03-provers.md:215
msgid "Optimizing the Cairo code: SHARP is optimizing the Cairo code to make it faster, resulting in a faster recursive prover."
msgstr ""

#: src/ch03-03-provers.md:218
msgid "Developing dynamic layouts: This will allow Cairo programs to scale resources depending on their needs."
msgstr ""

#: src/ch03-03-provers.md:221
msgid "Improving scheduling algorithm: This is another optimization path that can be taken. It is not within the Prover itself."
msgstr ""

#: src/ch03-03-provers.md:224
#, fuzzy
msgid ""
"In particular, dynamic layouts (you can learn more about layouts here (TODO)) will allow Cairo programs to scale resources depending on their needs. This can lead to more efficient computation and "
"better utilization of resources. Dynamic layouts allow SHARP to determine the required resources for a specific job and adjust the layout accordingly instead of relying on predefined layouts with "
"fixed resources. This approach can provide tailored solutions for each job, improving overall efficiency."
msgstr ""
"å°¤å…¶æ˜¯åŠ¨æ€å¸ƒå±€ï¼ˆç‚¹å‡»æ­¤å¤„äº†è§£æ›´å¤šå…³äºå¸ƒå±€çš„ä¿¡æ¯\n"
"(TODO)ï¼‰å°†å…è®¸Cairoç¨‹åºæ ¹æ®è‡ªå·±çš„éœ€è¦æ¥æ‰©å±•èµ„æºã€‚\n"
"èµ„æºã€‚è¿™å°†æé«˜è®¡ç®—æ•ˆç‡å’Œèµ„æºåˆ©ç”¨ç‡ã€‚\n"
"åˆ©ç”¨èµ„æºã€‚åŠ¨æ€å¸ƒå±€å…è®¸SHARPç¡®å®šç‰¹å®šä½œä¸šæ‰€éœ€çš„èµ„æºï¼Œå¹¶å¯¹èµ„æºè¿›è¡Œè°ƒæ•´ã€‚\n"
"ç‰¹å®šä½œä¸šæ‰€éœ€çš„èµ„æºï¼Œå¹¶ç›¸åº”è°ƒæ•´å¸ƒå±€\n"
"è€Œä¸æ˜¯ä¾èµ–å¸¦æœ‰å›ºå®šèµ„æºçš„é¢„å®šä¹‰å¸ƒå±€ã€‚è¿™ç§\n"
"è¿™ç§æ–¹æ³•å¯ä¸ºæ¯é¡¹å·¥ä½œæä¾›é‡èº«å®šåˆ¶çš„è§£å†³æ–¹æ¡ˆï¼Œä»è€Œæé«˜æ•´ä½“æ•ˆç‡ã€‚\n"
"æ•ˆç‡ã€‚"

#: src/ch03-03-provers.md:235
#, fuzzy
msgid ""
"In conclusion, SHARP is a critical component of Starknetâ€™s architecture, providing a more efficient and cost-effective solution for processing Cairo programs and verifying their proofs. By leveraging "
"the power of STARK technology and incorporating recursive proofs, SHARP plays a vital role in improving the overall performance and scalability of the Starknet network. The stateless nature of SHARP "
"and the reliance on the cryptographic soundness of the STARK proving system make it an innovative and valuable addition to the blockchain ecosystem."
msgstr ""
"æ€»ä¹‹ï¼ŒSHARP æ˜¯Starknetæ¶æ„çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€\n"
"ä¸ºå¤„ç†Cairoç¨‹åºå’ŒéªŒè¯å…¶è¯æ˜æä¾›äº†æ›´é«˜æ•ˆã€æ›´å…·æˆæœ¬æ•ˆç›Šçš„è§£å†³æ–¹æ¡ˆã€‚\n"
"Cairoç¨‹åºå¹¶éªŒè¯å…¶è¯æ˜ã€‚é€šè¿‡åˆ©ç”¨\n"
"é€šè¿‡åˆ©ç”¨ STARK æŠ€æœ¯å’Œé€’å½’è¯æ˜ï¼ŒSHARP åœ¨æé«˜æ•´ä½“æ€§èƒ½å’Œæ‰©å±•æ€§æ–¹é¢å‘æŒ¥äº†é‡è¦ä½œç”¨ã€‚\n"
"åœ¨æé«˜Starknetçš„æ•´ä½“æ€§èƒ½å’Œå¯æ‰©å±•æ€§æ–¹é¢å‘æŒ¥äº†é‡è¦ä½œç”¨ã€‚\n"
"Starknetç½‘ç»œçš„æ•´ä½“æ€§èƒ½å’Œå¯æ‰©å±•æ€§æ–¹é¢å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ã€‚SHARP çš„æ— çŠ¶æ€ç‰¹æ€§å’Œå¯¹ STARK æŠ€æœ¯çš„å¯†ç å¥å…¨æ€§çš„ä¾èµ–\n"
"è¯æ˜ç³»ç»Ÿçš„åŠ å¯†ç¨³å¥æ€§ï¼Œä½¿å…¶æˆä¸ºåŒºå—é“¾æŠ€æœ¯çš„ä¸€ä¸ªåˆ›æ–°å’Œå®è´µçš„è¡¥å……ã€‚\n"
"åŒºå—é“¾ç”Ÿæ€ç³»ç»Ÿçš„åˆ›æ–°å’Œå®è´µè¡¥å……ã€‚"

#: src/ch03-04-nodes.md:3
msgid "This chapter explores the role and functionality of nodes in the Starknet ecosystem, their interactions with sequencers, and their overall importance."
msgstr ""

#: src/ch03-04-nodes.md:5
msgid "Contributing to the Guide"
msgstr ""

#: src/ch03-04-nodes.md:7
msgid "Your contributions can help enhance this guide. Specifically, you can add:"
msgstr ""

#: src/ch03-04-nodes.md:9
msgid "Additional hardware options for running a Starknet node."
msgstr ""

#: src/ch03-04-nodes.md:10
msgid "Alternative methods to set up and operate a Starknet node."
msgstr ""

#: src/ch03-04-nodes.md:12
msgid "To contribute, feel free to [open a PR](https://github.com/starknet-edu/starknetbook) with your suggestions or additions."
msgstr ""

#: src/ch03-04-nodes.md:14
#, fuzzy
msgid "Overview of Nodes in the Starknet Ecosystem"
msgstr "## StarknetæŠ€æœ¯æ¦‚è§ˆ"

#: src/ch03-04-nodes.md:16
msgid ""
"A node in the Starknet ecosystem is a computer equipped with Starknet software, contributing significantly to the network's operations. Nodes are vital for the Starknet ecosystem's functionality, "
"security, and overall health. Without nodes, the Starknet network would not be able to function effectively."
msgstr ""

#: src/ch03-04-nodes.md:18
msgid "Nodes in Starknet are categorized into two types:"
msgstr ""

#: src/ch03-04-nodes.md:20
msgid "**Full Nodes**: Store the entire Starknet state and validate all transactions, crucial for the network's integrity."
msgstr ""

#: src/ch03-04-nodes.md:22
msgid "**Light Nodes**: Do not store the entire Starknet state but rely on full nodes for information. They are faster and more efficient but offer less security than full nodes."
msgstr ""

#: src/ch03-04-nodes.md:24
msgid "Core Functions of Nodes"
msgstr ""

#: src/ch03-04-nodes.md:26
msgid "Nodes are fundamental to the Starknet network, performing a variety of critical functions:"
msgstr ""

#: src/ch03-04-nodes.md:28
msgid "**Transaction Validation**: Nodes ensure transactions comply with Starknet's rules, helping prevent fraud and malicious activities."
msgstr ""

#: src/ch03-04-nodes.md:30
msgid "**Block Creation and Propagation**: They create and circulate blocks to maintain a consistent blockchain view across the network."
msgstr ""

#: src/ch03-04-nodes.md:32
msgid "**State Maintenance**: Nodes track the Starknet network's current state, including user balances and smart contract code, essential for transaction processing and smart contract execution."
msgstr ""

#: src/ch03-04-nodes.md:34
msgid "**API Endpoint Provision**: Nodes provide API endpoints, aiding developers in creating applications, wallets, and tools for network interaction."
msgstr ""

#: src/ch03-04-nodes.md:36
msgid "**Transaction Relay**: They relay user transactions to other nodes, improving network performance and reducing congestion."
msgstr ""

#: src/ch03-04-nodes.md:38
msgid "Interplay of Nodes, Sequencers, Clients, and Mempool in the Starknet Network"
msgstr ""

#: src/ch03-04-nodes.md:40
#, fuzzy
msgid "Nodes and Sequencers"
msgstr "æ’åºå™¨"

#: src/ch03-04-nodes.md:42
msgid "Nodes and sequencers are interdependent:"
msgstr ""

#: src/ch03-04-nodes.md:44
msgid ""
"**Nodes and Block Production**: Nodes depend on sequencers to create blocks and update the network state. Sequencers integrate the transactions validated by nodes into blocks, maintaining a consistent "
"and current Starknet state."
msgstr ""

#: src/ch03-04-nodes.md:46
msgid ""
"**Sequencers and Transaction Validation**: Sequencers rely on nodes for transaction validation and network consensus. Prior to executing transactions, sequencers work with nodes to confirm transaction "
"legitimacy, deterring fraudulent activities. Nodes also contribute to the consensus mechanism, ensuring uniformity in the blockchain state."
msgstr ""

#: src/ch03-04-nodes.md:48
msgid "Nodes and Clients"
msgstr ""

#: src/ch03-04-nodes.md:50
msgid "The relationship between nodes and clients in the Starknet ecosystem is characterized by a client-server model:"
msgstr ""

#: src/ch03-04-nodes.md:52
msgid ""
"**Client Requests and Node Responses**: Clients initiate by sending requests, like transaction submissions or state queries. Nodes process these, validating transactions, updating the network state, "
"and furnishing clients with the requested data."
msgstr ""

#: src/ch03-04-nodes.md:54
msgid ""
"**Client Experience**: Clients receive node responses, updating their local view with the latest network information. This loop enables user interaction with Starknet DApps, with nodes maintaining "
"network integrity and clients offering a user-friendly interface."
msgstr ""

#: src/ch03-04-nodes.md:56
msgid "Nodes and the Mempool"
msgstr ""

#: src/ch03-04-nodes.md:58
msgid "The mempool acts as a holding area for unprocessed transactions:"
msgstr ""

#: src/ch03-04-nodes.md:60
msgid "**Transaction Validation and Mempool Storage**: Upon receiving a transaction, nodes validate it. Valid transactions are added to the mempool and broadcast to other network nodes."
msgstr ""

#: src/ch03-04-nodes.md:62
msgid "**Transaction Selection and Block Inclusion**: Nodes select transactions from the mempool for processing, incorporating them into blocks that are added to the blockchain."
msgstr ""

#: src/ch03-04-nodes.md:64
#, fuzzy
msgid "Node Implementations in Starknet"
msgstr "## Starknetä¸­çš„æµ‹åºä»ª"

#: src/ch03-04-nodes.md:66
msgid "Starknet's node implementations bring unique strengths:"
msgstr ""

#: src/ch03-04-nodes.md:68
msgid ""
"**[Pathfinder](https://github.com/eqlabs/pathfinder)**: By Equilibrium, Pathfinder is a Rust-written full node. It excels in high performance, scalability, and aligns with the Starknet Cairo "
"specification."
msgstr ""

#: src/ch03-04-nodes.md:70
msgid "**[Juno](https://github.com/NethermindEth/juno)**: Nethermind's Juno, another full node in Golang, is known for user-friendliness, ease of deployment, and Ethereum tool compatibility."
msgstr ""

#: src/ch03-04-nodes.md:72
msgid ""
"**[Papyrus](https://github.com/starkware-libs/papyrus)**: StarkWare's Papyrus, a Rust-based full node, focuses on security and robustness. It's integral to the upcoming Starknet Sequencer, expected to "
"boost network throughput."
msgstr ""

#: src/ch03-04-nodes.md:74
msgid "These implementations are under continuous improvement, with new features and enhancements. The choice of implementation depends on user or developer preferences and requirements."
msgstr ""

#: src/ch03-04-nodes.md:76
msgid "Key characteristics of each node implementation are summarized below:"
msgstr ""

#: src/ch03-04-nodes.md:78
#, fuzzy
msgid "Node Implementation"
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch03-04-nodes.md:78
msgid "Language"
msgstr ""

#: src/ch03-04-nodes.md:78
msgid "Strengths"
msgstr ""

#: src/ch03-04-nodes.md:80
msgid "Pathfinder"
msgstr ""

#: src/ch03-04-nodes.md:80
msgid "High performance, scalability, Cairo specification adherence"
msgstr ""

#: src/ch03-04-nodes.md:81
msgid "Papyrus"
msgstr ""

#: src/ch03-04-nodes.md:81
msgid "Security, robustness, Starknet Sequencer foundation"
msgstr ""

#: src/ch03-04-nodes.md:82
msgid "Juno"
msgstr ""

#: src/ch03-04-nodes.md:82
msgid "Golang"
msgstr ""

#: src/ch03-04-nodes.md:82
msgid "User-friendliness, ease of deployment, Ethereum compatibility"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:1
#, fuzzy
msgid "Implementing a Pathfinder Node"
msgstr "## å®ç° ERC20 token"

#: src/ch03-04-01-pathfinder-node.md:3
msgid "Hardware Recommendations for Pathfinder Node"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:5
msgid "To ensure optimal performance and reliability, the following hardware is recommended for running a Pathfinder node:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:7
msgid "**CPU**: Intel Core i7-9700 or AMD Ryzen 7 3700X"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:8
msgid "**Memory**: 32GB"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:9
msgid "**Storage**: 1TB SSD"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:10
msgid "**Network**: Gigabit Ethernet"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:12
msgid "Estimated Costs for Recommended Hardware"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:14
msgid "The approximate pricing in USD for the recommended hardware is:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:16
msgid "**CPU**: $300"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:17
msgid "**Memory**: $100"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:18
msgid "**Storage**: $100"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:19
msgid "**Network Hardware**: $50"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:21
msgid "Total estimated cost: Approximately $550."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:23
msgid "Running Pathfinder Node Using Docker"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:25
msgid ""
"For those who prefer a self-managed setup of all dependencies, refer to the comprehensive [Installation from Source](https://github.com/eqlabs/pathfinder/blob/main/doc/install-from-source.md) guide."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:27
msgid "Prerequisites"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:29
msgid "Ensure [Docker is installed](https://docs.docker.com/get-docker/). For Ubuntu, use `sudo snap install docker`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:31
#, fuzzy
msgid "Setup and Execution"
msgstr "## æ‰§è¡Œ"

#: src/ch03-04-01-pathfinder-node.md:33
msgid "**Prepare Data Directory**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:35
msgid "Create a data directory, `$HOME/pathfinder`, to store persistent files used by `pathfinder`:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:41
msgid "**Start Pathfinder Node**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:43
msgid "Run the `pathfinder` node using Docker with the following command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:51 src/ch03-04-01-pathfinder-node.md:109
msgid "\"$(id -u):$(id -g)\""
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:53 src/ch03-04-01-pathfinder-node.md:111
msgid "\"https://goerli.infura.io/v3/<project-id>\""
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:58
msgid "**Monitoring Logs**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:60
msgid "To view the node logs, use:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:66
msgid "**Stopping Pathfinder Node**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:68
msgid "To stop the node, use:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:74
msgid "This setup ensures the Pathfinder node operates efficiently with automatic restarts and background running capabilities."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:76
msgid "Updating the Pathfinder Docker Image"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:78
msgid "When a new Pathfinder release is available, the node will log a message like:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:84
msgid "Update Steps"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:86
msgid "Pull the Latest Docker Image:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:92
msgid "Stop and Remove the Current Container:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:99
msgid "Re-create the Container with the New Image:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:101
msgid "Use the same command as before to start the node"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:116
msgid "Docker Image Availability"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:118
msgid "The `:latest` docker image corresponds with the latest [Pathfinder release](https://github.com/eqlabs/pathfinder/releases), not the `main` branch."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:120
msgid "Using Docker Compose"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:122
msgid "Alternatively, **`docker-compose`** can be used."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:124
#, fuzzy
msgid "Setup:"
msgstr "## è®¾ç½®"

#: src/ch03-04-01-pathfinder-node.md:126
msgid "Create the folder `pathfinder` where your `docker-compose.yaml` is."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:129
msgid "# replace the value by of PATHFINDER_ETHEREUM_API_URL by the HTTP(s) URL pointing to your Ethereum node's endpoint\n"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:135
msgid "Check logs:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:141
msgid "Database Snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:143
msgid ""
"Re-syncing the whole history for either the mainnet or testnet networks might take a long time. To speed up the process you can use database snapshot files that contain the full state and history of "
"the network up to a specific block."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:145
msgid "The database files are hosted on Cloudflare R2. There are two ways to download the files:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:147
msgid "Using the [Rclone](https://rclone.org/) tool"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:148
msgid "Via the HTTPS URL: we've found this to be less reliable in general"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:150
msgid "Rclone setup"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:152
msgid "We recommend using RClone. Add the following to your RClone configuration file (`$HOME/.config/rclone/rclone.conf`):"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:154
msgid ""
"```ini\n"
"[pathfinder-snapshots]\n"
"type = s3\n"
"provider = Cloudflare\n"
"env_auth = false\n"
"access_key_id = 7635ce5752c94f802d97a28186e0c96d\n"
"secret_access_key = 529f8db483aae4df4e2a781b9db0c8a3a7c75c82ff70787ba2620310791c7821\n"
"endpoint = https://cbf011119e7864a873158d83f3304e27.r2.cloudflarestorage.com\n"
"acl = private\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:165
msgid "You can then download a compressed database using the command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:171
msgid "Uncompressing database snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:173
msgid "**To avoid issues please check that the SHA2-256 checksum of the compressed file you've downloaded matches the value we've published.**"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:175
msgid "We're storing database snapshots as SQLite database files compressed with [zstd](https://github.com/facebook/zstd). You can uncompress the files you've downloaded using the following command:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:181
msgid "This produces uncompressed database file `goerli.sqlite` that can then be used by pathfinder."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:183
msgid "Available database snapshots"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Network"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Block"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Pathfinder version required"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Filename"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Download URL"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "Compressed size"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:185
msgid "SHA2-256 checksum of compressed file"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "testnet"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "880310"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187 src/ch03-04-01-pathfinder-node.md:188
msgid "\\>= 0.9.0"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "`testnet_0.9.0_880310.sqlite.zst`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "[Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/testnet_0.9.0_880310.sqlite.zst)"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "102.36 GB"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:187
msgid "`55f7e30e4cc3ba3fb0cd610487e5eb4a69428af1aacc340ba60cf1018b58b51c`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "mainnet"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "309113"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "`mainnet_0.9.0_309113.sqlite.zst`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "[Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/mainnet_0.9.0_309113.sqlite.zst)"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "279.85 GB"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:188
msgid "`0430900a18cd6ae26465280bbe922ed5d37cfcc305babfc164e21d927b4644ce`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
#, fuzzy
msgid "integration"
msgstr "ä»‹ç»"

#: src/ch03-04-01-pathfinder-node.md:189
msgid "315152"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
msgid "\\>= 0.9.1"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
msgid "`integration_0.9.1_315152.sqlite.zst`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
msgid "[Download](https://pub-1fac64c3c0334cda85b45bcc02635c32.r2.dev/integration_0.9.1_315152.sqlite.zst)"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
msgid "8.45 GB"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:189
msgid "`2ad5ab46163624bd6d9aaa0dff3cdd5c7406e69ace78f1585f9d8f011b8b9526`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:191
#, fuzzy
msgid "Configuration"
msgstr "`Fuzzer Configuration`"

#: src/ch03-04-01-pathfinder-node.md:193
msgid "The `pathfinder` node options can be configured via the command line as well as environment variables."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:195
msgid "The command line options are passed in after the `docker run` options, as follows:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:201
msgid "Using `--help` will display the `pathfinder` options, including their environment variable names:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:207
msgid "Pending Support"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:209
msgid ""
"Block times on `mainnet` can be prohibitively long for certain applications. As a workaround, Starknet added the concept of a `pending` block which is the block currently under construction. This is "
"supported by pathfinder, and usage is documented in the [JSON-RPC API](#json-rpc-api) with various methods accepting `\"block_id\"=\"pending\"`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:211
msgid "Note that `pending` support is disabled by default and must be enabled by setting `poll-pending=true` in the configuration options."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:213
msgid "Logging"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:215
msgid "Logging can be configured using the `RUST_LOG` environment variable. We recommend setting it when you start the container:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:222
msgid "The following log levels are supported, from most to least verbose:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:227
msgid "# default\n"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:232
msgid "Network Selection"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:234
msgid "The Starknet network can be selected with the `--network` configuration option."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:236
msgid "If `--network` is not specified, network selection will default to match your Ethereum endpoint:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:238
msgid "Starknet mainnet for Ethereum mainnet,"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:239
msgid "Starknet testnet for Ethereum Goerli"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:241
msgid "Custom networks & gateway proxies"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:243
msgid ""
"You can specify a custom network with `--network custom` and specifying the `--gateway-url`, `feeder-gateway-url` and `chain-id` options. Note that `chain-id` should be specified as text e.g. "
"`SN_GOERLI`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:246
msgid "This can be used to interact with a custom Starknet gateway, or to use a gateway proxy."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:248
msgid "JSON-RPC API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:250
msgid ""
"You can interact with Starknet using the JSON-RPC API. Pathfinder supports the official Starknet RPC API and in addition supplements this with its own pathfinder specific extensions such as "
"`pathfinder_getProof`."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:252
msgid ""
"Currently pathfinder supports `v0.3`, `v0.4`, and `v0.5` versions of the Starknet JSON-RPC specification. The `path` of the URL used to access the JSON-RPC server determines which version of the API "
"is served:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:255
msgid "the `v0.3.0` API is exposed on the `/rpc/v0.3` and `/rpc/v0_3` path"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:256
msgid "the `v0.4.0` API is exposed on the `/`, `/rpc/v0.4` and `/rpc/v0_4` path"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:257
msgid "the `v0.5.1` API is exposed on the `/rpc/v0.5` and `/rpc/v0_5` path"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:258
msgid "the pathfinder extension API is exposed on `/rpc/pathfinder/v0.1`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:260
msgid "Note that the pathfinder extension is versioned separately from the Starknet specification itself."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:262
msgid "Pathfinder extension API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:264
msgid "You can find the API specification [here](https://github.com/eqlabs/pathfinder/blob/main/doc/rpc/pathfinder_rpc_api.json)."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:266
msgid "Monitoring API"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:268
msgid "Pathfinder has a monitoring API which can be enabled with the `--monitor-address` configuration option."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:270
msgid "Health"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:272
msgid "`/health` provides a method to check the health status of your `pathfinder` node, and is commonly useful in Kubernetes docker setups. It returns a `200 OK` status if the node is healthy."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:274
msgid "Readiness"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:276
msgid ""
"`pathfinder` does several things before it is ready to respond to RPC queries. In most cases this startup time is less than a second, however there are certain scenarios where this can be considerably "
"longer. For example, applying an expensive database migration after an upgrade could take several minutes (or even longer) on testnet. Or perhaps our startup network checks fail many times due to "
"connection issues."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:278
msgid ""
"`/ready` provides a way of checking whether the node's JSON-RPC API is ready to be queried. It returns a `503 Service Unavailable` status until all startup tasks complete, and then `200 OK` from then "
"on."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:280
msgid "Metrics"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:282
msgid "`/metrics` provides a [Prometheus](https://prometheus.io/) metrics scrape endpoint. Currently the following metrics are available:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:284
msgid "RPC related counters"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:286
msgid "`rpc_method_calls_total`,"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:287
msgid "`rpc_method_calls_failed_total`,"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:289
msgid "You **must** use the label key `method` to retrieve a counter for a particular RPC method, for example:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:291
msgid ""
"```\n"
"rpc_method_calls_total{method=\"starknet_getStateUpdate\"}\n"
"rpc_method_calls_failed_total{method=\"starknet_chainId\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:296
msgid "You may also use the label key `version` to specify a particular version of the RPC API, for example:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:298
msgid ""
"```\n"
"rpc_method_calls_total{method=\"starknet_getEvents\", version=\"v0.3\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:302
msgid "Feeder Gateway and Gateway related counters"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:304
msgid "`gateway_requests_total`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:305
msgid "`gateway_requests_failed_total`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:307
msgid "Labels:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:309
msgid "`method`, to retrieve a counter for a particular sequencer request type"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:310
msgid "`tag`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:311
msgid "works with: `get_block`, `get_state_update`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:312 src/ch03-04-01-pathfinder-node.md:317
msgid "valid values:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:313
msgid "`pending`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:314
msgid "`latest`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:315
msgid "`reason`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:316
msgid "works with: `gateway_requests_failed_total`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:318
msgid "`decode`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:319
msgid "`starknet`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:320
msgid "`rate_limiting`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:322
#, fuzzy
msgid "Valid examples:"
msgstr "# ç¤ºä¾‹"

#: src/ch03-04-01-pathfinder-node.md:324
msgid ""
"```\n"
"gateway_requests_total{method=\"get_block\"}\n"
"gateway_requests_total{method=\"get_block\", tag=\"latest\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", tag=\"pending\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", tag=\"pending\", reason=\"starknet\"}\n"
"gateway_requests_failed_total{method=\"get_state_update\", reason=\"rate_limiting\"}\n"
"```"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:333
msgid "These **will not work**:"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:335
msgid "`gateway_requests_total{method=\"get_transaction\", tag=\"latest\"}`, `tag` is not supported for that `method`"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:336
msgid "`gateway_requests_total{method=\"get_transaction\", reason=\"decode\"}`, `reason` is only supported for failures."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:338
msgid "Sync related metrics"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:340
msgid "`current_block` currently sync'd block height of the node"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:341
msgid "`highest_block` height of the block chain"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:342
msgid "`block_time` timestamp difference between the current block and its parent"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:343
msgid "`block_latency` delay between current block being published and sync'd locally"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:344
msgid "`block_download` time taken to download current block's data excluding classes"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:345
msgid "`block_processing` time taken to process and store the current block"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:347
msgid "Build info metrics"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:349
msgid "`pathfinder_build_info` reports curent version as a `version` property"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:351
msgid "Build from source"
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:353
msgid "See the [guide](https://github.com/eqlabs/pathfinder/blob/main/doc/install-from-source.md)."
msgstr ""

#: src/ch03-04-01-pathfinder-node.md:355
msgid "The above guide is inspired by [Pathfinder](https://github.com/eqlabs/pathfinder)"
msgstr ""

#: src/ch03-05-layer-3.md:1
#, fuzzy
msgid "Layer 3 (App Chains)"
msgstr "Layer 3 å’Œåº”ç”¨é“¾ ğŸš§  "

#: src/ch03-05-layer-3.md:3
msgid ""
"Appchains let you create a blockchain designed precisely for your applicationâ€™s needs. These specialized blockchains allow customization in various aspects, such as hash functions and consensus "
"algorithms. Moreover, they inherit the security features of the Layer 1 or Layer 2 blockchains they are built upon."
msgstr ""

#: src/ch03-05-layer-3.md:11
msgid ""
"Layer 3 blockchains can exist on top of Layer 2 blockchains. You can even build additional layers (Layer 4 and so on) on top of Layer 3 for more complex solutions. A sample layout is shown in the "
"following diagram."
msgstr ""

#: src/ch03-05-layer-3.md:18
#, fuzzy
msgid "Example of an environment with a Layers 3 and 4"
msgstr "<span class=\"caption\">Example of an environment with a Layers 3 and 4</span>"

#: src/ch03-05-layer-3.md:20
#, fuzzy
msgid "In this example ecosystem, Layer 3 options include:"
msgstr "åœ¨æ­¤ç¤ºä¾‹ç”Ÿæ€ç³»ç»Ÿä¸­ï¼Œç¬¬ 3 å±‚é€‰é¡¹åŒ…æ‹¬"

#: src/ch03-05-layer-3.md:22
msgid "The Public Starknet (L2), which is a general-purpose blockchain for decentralized applications."
msgstr ""

#: src/ch03-05-layer-3.md:25
msgid "A L3 Starknet optimized for cost-sensitive applications."
msgstr ""

#: src/ch03-05-layer-3.md:27
msgid "Customized L3 Starknet systems designed for enhanced performance, using specific storage structures or data compression techniques."
msgstr ""

#: src/ch03-05-layer-3.md:30
msgid "StarkEx systems used by platforms like dYdX and Sorare, offering proven scalability through data availability solutions like Validium or Rollup."
msgstr ""

#: src/ch03-05-layer-3.md:34
msgid "Privacy-focused Starknet instances, which could also function as a Layer 4, for conducting transactions without including them in public Starknets."
msgstr ""

#: src/ch03-05-layer-3.md:38
#, fuzzy
msgid "Benefits of Layer 3"
msgstr "## ç¬¬ 3 å±‚çš„ä¼˜åŠ¿"

#: src/ch03-05-layer-3.md:40
msgid ""
"Layer 3 app chains (with [Madara](https://github.com/keep-starknet-strange/madara) as an apt sequencer or other option), offer a variety of advantages due to its modularity and flexibility. Hereâ€™s an "
"overview of the key benefits:"
msgstr ""

#: src/ch03-05-layer-3.md:45
msgid ""
"**Quick Iteration**: App chains enable rapid protocol changes, freeing you from the constraints of the public Layer 2 roadmap. For example, you could rapidly deploy new DeFi algorithms tailored to "
"your user base."
msgstr ""

#: src/ch03-05-layer-3.md:50
msgid ""
"**Governance Independence**: You maintain complete control over feature development and improvements, avoiding the need for decentralized governance consensus. This enables, for example, quick "
"implementation of user-suggested features."
msgstr ""

#: src/ch03-05-layer-3.md:55
msgid "**Cost Efficiency**: Layer 3 offers substantial cost reductions, potentially up to 1 million times compared to Layer 1, making it economically feasible to run more complex applications."
msgstr ""

#: src/ch03-05-layer-3.md:59
msgid "**Security**: While there may be some trade-offs, such as reduced censorship resistance, the core security mechanisms remain strong."
msgstr ""

#: src/ch03-05-layer-3.md:62
msgid "**Congestion Avoidance**: App chains are shielded from network congestion, providing a more stable transaction environment, crucial for real-time applications like gaming."
msgstr ""

#: src/ch03-05-layer-3.md:66
msgid "**Privacy Enhancements**: Layer 3 can serve as a testing ground for privacy-centric features, which could include anonymous transactions or encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:70
msgid ""
"**Innovation Platform**: App chains act as experimental fields where novel features can be developed and tested. For instance, they could serve as a testbed for new consensus algorithms before these "
"are considered for Layer 2."
msgstr ""

#: src/ch03-05-layer-3.md:75
msgid "In summary, Layer 3 provides the flexibility, cost-efficiency, and environment conducive for innovation, without significant compromise on security."
msgstr ""

#: src/ch03-05-layer-3.md:79
msgid "Madara as a Sequencer for Layer 3 App Chains"
msgstr ""

#: src/ch03-05-layer-3.md:81
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a specialized sequencer developed to execute transactions and group them into batches. Created by the StarkWare Exploration Team, it "
"functions as a starting point for building Layer 3 Starknet appchains. This expands the possibilities for innovation within the Starknet ecosystem."
msgstr ""

#: src/ch03-05-layer-3.md:87
msgid "Madaraâ€™s flexibility allows for the creation of Layer 3 appchains optimized for various needs, for example:"
msgstr ""

#: src/ch03-05-layer-3.md:90
msgid "Cost-Efficiency: Create an appchain for running a decentralized exchange (DEX) with lower fees compared to the public Starknet."
msgstr ""

#: src/ch03-05-layer-3.md:93
msgid "Performance: Build an appchain to operate a DEX with faster transaction times."
msgstr ""

#: src/ch03-05-layer-3.md:96
msgid "Privacy: Design an appchain to facilitate anonymous transactions or encrypted messaging services."
msgstr ""

#: src/ch03-05-layer-3.md:99
#, fuzzy
msgid "For more information on Madara, refer to the subchapter with the same title."
msgstr ""
"æœ‰å…³StarknetæƒåŠ›ä¸‹æ”¾çš„æ›´å¤šè¯¦æƒ…ï¼Œè¯·å‚é˜…æœ¬ç« çš„\n"
"æœ¬ç« çš„ä¸“é—¨åˆ†ç« ã€‚"

#: src/ch03-06-solidity-verifier.md:3
msgid "Before exploring this chapter, review the Starknet Architecture chapter for foundational knowledge. Familiarity with concepts such as Sequencers, Provers, SHARP, and Sharp Jobs is assumed."
msgstr ""

#: src/ch03-06-solidity-verifier.md:5
msgid "Starknet's Solidity Verifier plays a pivotal role in the rollup landscape, ensuring the truth of transactions and smart contracts."
msgstr ""

#: src/ch03-06-solidity-verifier.md:7
msgid "Quick Overview: SHARP and Sharp Jobs"
msgstr ""

#: src/ch03-06-solidity-verifier.md:9
msgid "**NOTE:** For a more detailed explanation of SHARP and Sharp Jobs, refer to the Provers subchapter in the Starknet Architecture chapter. This is a brief review."
msgstr ""

#: src/ch03-06-solidity-verifier.md:11
msgid ""
"SHARP, or Shared Prover, in Starknet, aggregates various Cairo programs from distinct users. These programs, each with unique logic, run together, producing a common proof for all, optimizing cost and "
"efficiency."
msgstr ""

#: src/ch03-06-solidity-verifier.md:15
#, fuzzy
msgid "Sharp Workflow"
msgstr "# Scarb å·¥ä½œæµç¨‹"

#: src/ch03-06-solidity-verifier.md:17
msgid "Furthermore, SHARP supports combining multiple proofs into one, enhancing its efficiency by allowing parallel proof processing and verification."
msgstr ""

#: src/ch03-06-solidity-verifier.md:19
msgid "SHARP verifies numerous Starknet transactions, like transfers, trades, and state updates. It also confirms smart contract executions."
msgstr ""

#: src/ch03-06-solidity-verifier.md:21
msgid ""
"To illustrate SHARP: Think of commuting by bus. The bus driver, the prover, transports passengers, the Cairo programs. The driver checks only the tickets of passengers alighting at the upcoming stop, "
"much like SHARP. The prover forms a single proof for all Cairo programs in a batch, but verifies only the proofs of programs executing in the succeeding block."
msgstr ""

#: src/ch03-06-solidity-verifier.md:23
msgid ""
"**Sharp Jobs**. Known as Shared Prover Jobs, Sharp Jobs let multiple users present their Cairo programs for combined execution, distributing the proof generation cost. This shared approach makes "
"Starknet more economical for users, enabling them to join ongoing jobs and leverage economies of scale."
msgstr ""

#: src/ch03-06-solidity-verifier.md:25
#, fuzzy
msgid "Solidity Verifiers"
msgstr "Solidity éªŒè¯å™¨"

#: src/ch03-06-solidity-verifier.md:27
msgid "A Solidity verifier is an L1 smart contract, crafted in Solidity, designed to validate STARK proofs from SHARP (Shared Prover)."
msgstr ""

#: src/ch03-06-solidity-verifier.md:29
msgid "Previous Architecture: Monolithic Verifier"
msgstr ""

#: src/ch03-06-solidity-verifier.md:31
msgid ""
"Historically, the Solidity Verifier was a monolithic contract, both initiated and executed by the same contract. For illustration, the operator would invoke the `update state` function on the main "
"contract, providing the state to be modified and confirming its validity. Subsequently, the main contract would present the proof to both the verifier and the validium committee. Once they validated "
"the proof, the state would be updated in the main contract."
msgstr ""

#: src/ch03-06-solidity-verifier.md:35
#, fuzzy
msgid "Previous Architecture"
msgstr "# æ¶æ„"

#: src/ch03-06-solidity-verifier.md:37
msgid "However, this architecture faced several constraints:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:39
msgid "Batching transactions frequently surpassed the original geth32kb transaction size limit (later adjusted to 128kb) due to accumulating excessive transactions."
msgstr ""

#: src/ch03-06-solidity-verifier.md:40
msgid "The gas required often outstripped the block size (e.g., 8 Mgas), as the block couldn't accommodate a complete batch of proof."
msgstr ""

#: src/ch03-06-solidity-verifier.md:41
msgid "A prospective constraint was that the verifier wouldn't support proof bundling, which is fundamental for SHARP."
msgstr ""

#: src/ch03-06-solidity-verifier.md:43
#, fuzzy
msgid "Current Architecture: Multiple Smart Contracts"
msgstr "## Starknetæ™ºèƒ½åˆçº¦ç®€ä»‹"

#: src/ch03-06-solidity-verifier.md:45
msgid "The current verifier utilizes multiple smart contracts rather than being a singular, monolithic structure."
msgstr ""

#: src/ch03-06-solidity-verifier.md:47
msgid "Here are some key smart contracts associated with the verifier:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:49
msgid ""
"[`GpsStatementVerifier`](https://etherscan.io/address/0x47312450b3ac8b5b8e247a6bb6d523e7605bdb60): This is the primary contract of the Sharp verifier. It verifies a proof and then registers the "
"related facts using `verifyProofAndRegister`. It acts as an umbrella for various layouts, each named `CpuFrilessVerifier`. Every layout has a unique combination of built-in resources."
msgstr ""

#: src/ch03-06-solidity-verifier.md:53
msgid "The system routes each proof to its relevant layout."
msgstr ""

#: src/ch03-06-solidity-verifier.md:55
msgid ""
"[`MemoryPageFactRegistry`](https://etherscan.io/address/0xfd14567eaf9ba941cb8c8a94eec14831ca7fd1b4): This registry maintains facts for memory pages, primarily used to register outputs for data "
"availability in rollup mode. The Fact Registry is a separate smart contract ensuring the verification and validity of attestations or facts. The verifier function is separated from the main contract "
"to ensure each segment works optimally within its limits. The main proof segment relies on other parts, but these parts operate independently."
msgstr ""

#: src/ch03-06-solidity-verifier.md:57
msgid "[`MerkleStatementContract`](https://etherscan.io/address/0x5899efea757e0dbd6d114b3375c23d7540f65fa4): This contract verifies merkle paths."
msgstr ""

#: src/ch03-06-solidity-verifier.md:59
msgid "[`FriStatementContract`](https://etherscan.io/address/0x3e6118da317f7a433031f03bb71ab870d87dd2dd): It focuses on verifying the FRI layers."
msgstr ""

#: src/ch03-06-solidity-verifier.md:61 src/ch03-06-solidity-verifier.md:67
#, fuzzy
msgid "Sharp Verifier Contract Map"
msgstr "<span class=\"caption\">Sharp Verifier Contract Map</span>"

#: src/ch03-06-solidity-verifier.md:63
msgid "The Sharp Verifier Contract Map contains roughly 40 contracts, detailing various components of the Solidity verifier. The images below display the contracts and their Ethereum Mainnet addresses."
msgstr ""

#: src/ch03-06-solidity-verifier.md:71
#, fuzzy
msgid "Sharp Verifier Contract Map (Continued)"
msgstr "<span class=\"caption\">Sharp Verifier Contract Map (Continued)</span>"

#: src/ch03-06-solidity-verifier.md:73
msgid "These contracts function as follows:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:75
msgid ""
"**Proxy**: This contract facilitates upgradability. It interacts with the `GpsStatementVerifier` contract using the `delegate_call` method. Notably, the state resides in the `GpsStatementVerifier` "
"contract, not in the proxy."
msgstr ""

#: src/ch03-06-solidity-verifier.md:76
msgid ""
"**CallProxy**: Positioned between the `Proxy` and the `GpsStatementVerifier` contracts, it functions like a typical proxy. However, it avoids the `delegate_call` method and calls the function in the "
"implementation contract directly."
msgstr ""

#: src/ch03-06-solidity-verifier.md:77
msgid ""
"**CairoBootloaderProgram**: Comprising numerical Cairo programs, it validates the Cairo program of a statement. The bootloader manages the logic executing Cairo programs to generate proof and program "
"hash."
msgstr ""

#: src/ch03-06-solidity-verifier.md:78
msgid "**PedersenHashPoints (X & Y Column)**: These lookup tables store vast amounts of data. Validation functions consult them to compute the Pedersen hash."
msgstr ""

#: src/ch03-06-solidity-verifier.md:79
msgid "**EcdsaPoints (X & Y Column)**: Similar to the Pedersen hash, these tables assist in calculating the elliptic curve."
msgstr ""

#: src/ch03-06-solidity-verifier.md:80
msgid ""
"**CpuFrilessVerifier/CpuOods/CpuConstantPoly (0 - 7)**: These verifier contracts vary in layout as shown in the `GpsStatementVerifier` layout image. Each layout encompasses resources, built-ins, "
"constraints, and more, designed for a specific task. Each has unique parameters for its constructor."
msgstr ""

#: src/ch03-06-solidity-verifier.md:81
msgid "**PoseidonPoseidon**: These contracts back the new Poseidon built-in and contain Poseidon-specific lookup tables."
msgstr ""

#: src/ch03-06-solidity-verifier.md:83
#, fuzzy
msgid "Constructor Parameters of Key Contracts"
msgstr "## Starknetæ™ºèƒ½åˆçº¦ç®€ä»‹"

#: src/ch03-06-solidity-verifier.md:85
msgid ""
"When constructing the primary verifier contracts, specific parameters are employed to facilitate functionality. These parameters reference other auxiliary contracts, decentralizing the logic and "
"ensuring the main contract remains under the 24kb deployment limit."
msgstr ""

#: src/ch03-06-solidity-verifier.md:87
msgid "Below is a visual representation of these parameters in relation to key contracts `CpuFrilessVerifiers` and `GpsStatementVerifier`:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:92
msgid "CpuFrilessVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:94
msgid "`CpuFrilessVerifiers` is designed to handle a diverse range of tasks. Its parameters encompass:"
msgstr "`CpuFrilessVerifiers` is designed to handle a diverse range of tasks. Its parameters encompass:"

#: src/ch03-06-solidity-verifier.md:96
msgid "**Auxiliary Polynomial Contracts:** These include `CpuConstraintPoly`, `PedersenHashPointsxColumn`, `PedersenHashPointsYColumn`, `EcdsaPointsXColumn`, and `EcdsaPointsYColumn`."
msgstr ""

#: src/ch03-06-solidity-verifier.md:97
msgid "**Poseidon-Related Contracts:** Several `PoseidonPoseidonFullRoundKey` and `PoseidonPoseidonPartialRoundKey` contracts."
msgstr ""

#: src/ch03-06-solidity-verifier.md:98
msgid "**Sampling and Memory:** The contract uses `CpuOods` for out-of-domain sampling and `MemoryPageFactRegistry` for memory-related tasks."
msgstr ""

#: src/ch03-06-solidity-verifier.md:99
msgid "**Verification:** It integrates with `MerkleStatementContract` for merkle verification and `FriStatementContract` for Fri-related tasks."
msgstr ""

#: src/ch03-06-solidity-verifier.md:100
msgid "**Security:** The `num_security_bits` and `min_proof_of_work_bits` contracts ensure secure operation."
msgstr ""

#: src/ch03-06-solidity-verifier.md:102
msgid "**NOTE:** For instances like `CpuFrilessVerifier0`, specific contracts (e.g., `CpuConstraintPoly0`, `PoseidonPoseidonFullRoundKeyColumn0`, `CpuOods0`) become particularly relevant."
msgstr ""

#: src/ch03-06-solidity-verifier.md:104
msgid "GpsStatementVerifier Constructor Parameters"
msgstr ""

#: src/ch03-06-solidity-verifier.md:106
msgid "The `GpsStatementVerifier` functions as the hub of verifier operations, necessitating various parameters for effective functioning:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:108
msgid "**Bootloader:** It references the `CairoBootloaderProgram` to initiate the system."
msgstr ""

#: src/ch03-06-solidity-verifier.md:109
msgid "**Memory Operations:** This is facilitated by the `MemoryPageFactRegistry` contract."
msgstr ""

#: src/ch03-06-solidity-verifier.md:110
msgid "**Sub-Verifiers:** It integrates a series of sub-verifiers (`CpuFrilessVerifier0` through `CpuFrilessVerifier7`) to decentralize tasks."
msgstr ""

#: src/ch03-06-solidity-verifier.md:111
msgid "**Verification:** The hashes, `hashed_supported_cairo_verifiers` and `simple_bootloader_program_hash`, are essential for validation processes."
msgstr ""

#: src/ch03-06-solidity-verifier.md:113
#, fuzzy
msgid "Interconnection of Contracts"
msgstr "## ä¸åˆçº¦çš„äº¤äº’"

#: src/ch03-06-solidity-verifier.md:115
msgid "The `GpsStatementVerifier` serves as the primary verifier contract, optimized for minimal logic to fit within deployment size constraints. To function effectively:"
msgstr ""

#: src/ch03-06-solidity-verifier.md:117
msgid "It relies on smaller verifier contracts, which are already deployed and contain varied verification logic."
msgstr ""

#: src/ch03-06-solidity-verifier.md:118
msgid "These smaller contracts, in turn, depend on other contracts, established during their construction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:120
msgid "In essence, while the diverse functionalities reside in separate contracts for clarity and size efficiency, they are all interlinked within the `GpsStatementVerifier`."
msgstr ""

#: src/ch03-06-solidity-verifier.md:122
msgid ""
"For future enhancements or adjustments, the proxy and callproxy contracts facilitate upgradability, allowing seamless updates to the `GpsStatementVerifier` without compromising its foundational logic."
msgstr ""

#: src/ch03-06-solidity-verifier.md:124 src/ch03-06-solidity-verifier.md:128
#, fuzzy
msgid "Sharp Verification Flow"
msgstr "<span class=\"caption\">Sharp Verification Flow</span>"

#: src/ch03-06-solidity-verifier.md:130
msgid ""
"The Sharp dispatcher transmits all essential transactions for verification, including: a. `MemoryPages` (usually many). b. `MerkleStatements` (typically between 3 and 5). c. `FriStatements` (generally "
"ranging from 5 to 15)."
msgstr ""

#: src/ch03-06-solidity-verifier.md:135
msgid "The Sharp dispatcher then forwards the proof using `verifyProofAndRegister`."
msgstr ""

#: src/ch03-06-solidity-verifier.md:137
msgid "Applications, such as the Starknet monitor, validate the status. Once verification completes, they send an `updateState` transaction."
msgstr ""

#: src/ch03-06-solidity-verifier.md:141
msgid ""
"Starknet transformed the Solidity Verifier from a single unit to a flexible, multi-contract system, highlighting its focus on scalability and efficiency. Using SHARP and refining verification steps, "
"Starknet makes sure the Solidity Verifier stays a strong cornerstone in its setup."
msgstr ""

#: src/ch03-08-smart-contracts.md:1
#, fuzzy
msgid "Smart Contracts"
msgstr "## åˆçº¦"

#: src/ch03-08-smart-contracts.md:3
msgid "Starknet contracts, are programs written in cairo and can run on the starknet virtual machine, they have access to the starknet state, and can interact with other contracts."
msgstr ""

#: src/ch03-08-smart-contracts.md:5
msgid "This Chapter will introduce you to starknet smart contracts, their components, smart contract declaration, deployment and interaction using starkli."
msgstr ""

#: src/ch03-08-smart-contracts.md:7
#, fuzzy
msgid "Smart Contract Example"
msgstr "## ERC20 åˆçº¦ç¤ºä¾‹"

#: src/ch03-08-smart-contracts.md:9
msgid ""
"Having explained what starknet smart contracts are, we'll be writing a moderately simple contract called a Piggy Bank contract, this example will demonstrate how to write a smart contract using the "
"factory pattern and also how to integrate the starknet component system into your smart contracts."
msgstr ""

#: src/ch03-08-smart-contracts.md:11
msgid ""
"The piggy bank contract is a factory contract model that allows users to create their own personalized savings contract. At the point of creation, users are to specify their savings target, which "
"could be towards a specific time or a specific amount, and a child contract is created and personalized to their savings target."
msgstr ""

#: src/ch03-08-smart-contracts.md:13
msgid ""
"The factory contract keeps tabs on all the child contracts created and also maps a user to his personalized contract. The user, after creating a personalized savings contract, can then deposit and "
"save towards his target. But if, for any reason, the user has to withdraw from his savings contract before meeting the savings target, then a fine worth 10% of the withdrawal amount would be paid by "
"the user."
msgstr ""

#: src/ch03-08-smart-contracts.md:15
msgid ""
"The contract uses a combination of functions and an ownership component to track and maintain the above explained functionality. Eventâ€™s are also emitted on each function call that modifies the "
"contract's state. So a good understanding of the logic and implementation of this contract example would give you mastery of the components system in Cairo, the factory standard model, emitting "
"events, and a whole lot of other methods useful in writing smart contracts on starknet."
msgstr ""

#: src/ch03-08-smart-contracts.md:17
msgid ""
"Please note that during the course of this journey, Iâ€™ll be using interchangeably the terms child contract and personalized contract. Please note that the term child contract in this case refers to a "
"personalized piggy bank contract created from the factory contract."
msgstr ""

#: src/ch03-08-smart-contracts.md:19
msgid "Piggy Bank Child Contract:"
msgstr ""

#: src/ch03-08-smart-contracts.md:51
msgid "// fn get_owner(self: @TContractState) -> ContractAddress;\n"
msgstr ""

#: src/ch03-08-smart-contracts.md:223
msgid "Piggy Bank Factory"
msgstr ""

#: src/ch03-08-smart-contracts.md:306
msgid "// Contructor arguments\n"
msgstr ""

#: src/ch03-08-smart-contracts.md:314
#, fuzzy
msgid "// Contract deployment\n"
msgstr "3.è´¦æˆ·éƒ¨ç½²"

#: src/ch03-08-01-deploymet-and-interaction.md:1
#, fuzzy
msgid "Deploying and Interacting With a Smart Contract"
msgstr "# ç¼–è¯‘ã€éƒ¨ç½²å’Œäº¤äº’åˆçº¦"

#: src/ch03-08-01-deploymet-and-interaction.md:3
msgid "In this section we will be focussing on declaring, deploying and interacting with the piggy bank contract we wrote in the previous section."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:5
#, fuzzy
msgid "Requirements:"
msgstr "**æœ€ä½è¦æ±‚ï¼š**"

#: src/ch03-08-01-deploymet-and-interaction.md:7
msgid "To declare and deploy the piggy bank contract, itâ€™s required that you have the following available; don't worry, weâ€™ll point you to resources or links to get them sorted out."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:9
msgid "Starkli: Starkli is a CLI tool that connects us to the Starknet blockchain. Installation steps can be found [here](./ch02-01-basic-installation.md)."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:11
msgid ""
"Starknet testnet RPC: You need your personalized gateway to access the starknet network. Starkli utilizes this API gateway to communicate with the starknet network: you can get one from Blast [here]"
"(https://blastapi.io/public-api/starknet)."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:13
msgid "Deployer Account: To interact with the starknet network via Starkli, you need a cli account/ wallet. You can easily set that up by going through [this page](./ch04-02-hello-account.html)."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:15
msgid ""
"Sufficient gas fees to cover the declaration and deployment steps: you can get starknet Sepolia Eth either by bridging your Sepolia Eth on Ethereum to Starknet [here](https://www.yetanotherswap.com/"
"bridge)."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:17
msgid "Once youâ€™ve been able to sort all that out, let's proceed with declaring and deploying the piggy bank contract."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:19
#, fuzzy
msgid "Contract Declaration:"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch03-08-01-deploymet-and-interaction.md:21
msgid ""
"The first step in deploying a starknet smart contract is to build the contract. To do this, we cd into the root directory of the piggy bank project, and then in our terminal, we run the'scarb build\\` "
"command. This command creates a new folder in our root directory folder, then generates two json files for each contract; the first is the compiled_contract_class.json file, while the second is the "
"contract_clas.json file."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:25
msgid ""
"The next step is to declare the contract. A contract declaration in Starknet is a transaction that returns a class hash, which would be used to deploy a new instance of a contract. Being a "
"transaction, declaration requires that the account being used for the declaration have sufficient gas fees to cover the cost of that transaction."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:27
msgid ""
"Also, it is important to understand that since we are deploying a factory contract, it's required that we declare the child contract as well as the factory contract, then deploy just the factory "
"contract after which pass in the child contract class hash as a constructor argument to the factory contract, and from this instance of the clash hash, new child contracts would be deployed."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:29
msgid ""
"```shell\n"
"starkli declare target/dev/piggy_bank_piggyBank.contract_class.json --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/."
"starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:33
msgid ""
"To declare the piggy bank child contract, we use the above command (remember to replace the account keystore and account file name and path as its found on your own system). Next, weâ€™re prompted to "
"input the password set while preparing our CLI wallet, after which the contract is compiled, and we get a similar message below:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:37
msgid ""
"From the above snippet, our class hash is: `0x05f58aecd2781660741534140776b6a12bcc6d46ebda92ac851c1bad55d74006`. With this class hash, other contracts would be deployed. Next would be to declare our "
"factory contract."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:39
msgid ""
"```shell\n"
"starkli declare target/dev/piggy_bank_piggyFactory.contract_class.json --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --keystore "
"~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:43
msgid ""
"This time, we get a response similar to the previous declaration containing a class hash: `0x026323e14ce298448d12e2504cb872f7ec6049a389230c2c0b3d9d99507e303d` These two class hashes could be found on "
"any explorer. By pasting the clash hash on the search bar, we get details regarding the contract declaration."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:46
#, fuzzy
msgid "Contract Deployment:"
msgstr "æµ‹è¯•ç½‘éƒ¨ç½²"

#: src/ch03-08-01-deploymet-and-interaction.md:48
msgid ""
"Since weâ€™ve deployed the two contracts and also now have the class hash for the two contracts, our next step would be to deploy our factory contract and also pass in the class hash of the child "
"contract to it so it can customize and create new instances of the class hash for users. To deploy the factory contract, we use a sample command as shown below:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:50
msgid ""
"```shell\n"
"starkli deploy 0x026323e14ce298448d12e2504cb872f7ec6049a389230c2c0b3d9d99507e303d 0x05f58aecd2781660741534140776b6a12bcc6d46ebda92ac851c1bad55d74006 "
"0x049D36570D4e46f48e99674bd3fcc84644DdD6b96F7C741B1562B82f9e004dC7 0x076957612bA0927c9C3F6156Ffaa1A52Bc330256869d85A8A0D0999B3e4c6387 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --"
"account ~/.starkli-wallets/deployer/argent_sepolia_account.json --keystore ~/.starkli-wallets/deployer/argent_sepolia_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:54
msgid "I understand this might look confusing, so let's use a simpler command structure to describe it:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:60
msgid ""
"From the above snippet, we first state the method we intend to use (deploy), then we pass in the class hash to be deployed (`<FACTORY CLASS HASH>`). Finally, we pass in the constructor argument in "
"order of their appearance in our contract (`<CHILD CONTRACT CLASS HASH>` `<ETH CONTRACT ADDRESS>` `<ADMIN CONTRACT ADDRESS>`)"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:64
msgid "From the above snippet, our newly deployed contract address is `0x0137a70c3cda7037631f43e3c6a76ea30cf6ba53dbabaebb164b427dab8a8d16`"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:66
msgid "Creating a Personalized Piggy Bank"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:68
msgid ""
"To create a personal piggy bank, we interact with the factory contract. We'll be calling the `createPiggyBank` function and passing in the following arguments; a savings target type; we pass in 1 if "
"we want to save towards a target amount; or we pass in 0 if weâ€™ll be saving towards a target time. Finally, we pass in a target amount or a target time (epoch time). In this demo, weâ€™ll be saving "
"towards a target amount, so weâ€™ll be passing in 1 and a target amount (0.0001 eth). To interact with our piggy factory onchan, we use an invoke method as shown in the below command;"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:71
msgid ""
"```shell\n"
"starkli invoke 0x0137a70c3cda7037631f43e3c6a76ea30cf6ba53dbabaebb164b427dab8a8d16 createPiggyBank 1 100000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-"
"wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:75
msgid ""
"After sending the above command, a transaction hash is returned to us. This hash, when scanned on an explorer, contains all the details of our invoke transaction and the status of the transaction, "
"whether or not it has been accepted on L1."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:79
msgid ""
"Our transaction hash is `0x077a2d9f64f19da764957e88440bc4cca50f792c62bccd163ee114b8b9e59a67`. Next, we need to get the contract address of our personalized piggy bank, so we make another call to our "
"factory contract to get our piggy bankâ€™s address. We use the below code to achieve this, we call the `getPiggyBankAddr` function, then pass in our contract address as an argument to that function."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:81
msgid ""
"```shell\n"
"starkli call 0x04f4c7a6a7de241e138f1c20b81d939a6e5807fdf8ea8845a86a61493e8de4ff getPiggyBankAddr 0x076957612bA0927c9C3F6156Ffaa1A52Bc330256869d85A8A0D0999B3e4c6387 --rpc https://starknet-sepolia."
"public.blastapi.io/rpc/v0_6\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:85
msgid ""
"After calling this function using the command above, we get a response on our terminal containing the address of the child piggy bank personalized to the address we passed in as an argument, the first "
"argument is the address of the factory contract while the second is the function name while the third is the address of the user which we intend to fetch his piggy bank address."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:89
msgid "Interacting With Our Personalized Pigy Bank:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:91
msgid ""
"At this point, we have been able to create a piggy bank contract customized specifically to our savings target, and we have the address for that contract. We are now left with interacting with our "
"contract by depositing Eth into it and also withdrawing from it."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:93
msgid ""
"But before we jump into depositing Eth into our contract, its important to note that Ether on starknet is actually a regular ERC20 token, so weâ€™ll need to grant approval to our Piggy contract to be "
"able to spend our Eth. We can achieve this by using the below command to call the approve function on the Eth contract address."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:95
msgid ""
"```shell\n"
"starkli invoke 0x049D36570D4e46f48e99674bd3fcc84644DdD6b96F7C741B1562B82f9e004dC7 approve 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b u256:100000000000000000 --rpc https://"
"starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:99
msgid ""
"The first address is the address of the erc20 token then the second is the address of our personalized piggybank address. After running the above code, we get a transaction hash containing details "
"about our approval transaction:"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:104
msgid "The next step would be to deposit into our piggy bank contract using this command;"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:106
msgid ""
"```shell\n"
"starkli invoke 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b deposit 1000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/"
"deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:110
msgid ""
"As with other invoke function calls weâ€™ve made, we also get a transaction hash for this transaction. Finally, after repeated calls to deposit ether into our contract, once we have saved up an amount "
"of our choice, we can call the withdraw function to withdraw from our account."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:112
msgid ""
"```shell\n"
"starkli invoke 0x044a5cc1518cd4f4dc4b40c5d2e72de2a82c5c7c7e2c0f840182b79aacb9773b withdraw 1000000000000000 --rpc https://starknet-sepolia.public.blastapi.io/rpc/v0_6 --account ~/.starkli-wallets/"
"deployer/account0_account.json --keystore ~/.starkli-wallets/deployer/account0_keystore.json\n"
"```"
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:116
msgid "Finally, we get a transaction hash containing details regarding our withdrawal `0x0781103066cf3bfa07ce59c1082c802db8a46caa276a293d9fcbe8610b85c1a8`."
msgstr ""

#: src/ch03-08-01-deploymet-and-interaction.md:120
msgid ""
"Scanning the above transaction hash on Voyager gives us the details contained in the image above; among other things, it contains a breakdown of how our withdrawal was distributed. Since we didn't "
"deposit up to our target amount before withdrawing, 10% of our withdrawal amount was sent to the factory contract, while the remaining 90% was sent to our address."
msgstr ""

#: src/ch03-08-02-important-methods.md:1
msgid "Important Starknet Methods"
msgstr ""

#: src/ch03-08-02-important-methods.md:3
msgid ""
"The table below contains important methods used while building starknet smart contracts. It contains the name of the method, a keyword to import such a method, and finally a simple single line usage "
"of each method. Also note that multiple method imports can be chained to make the codebase simpler and also avoid repetition, e.g., \\`use starknet::{get_contract_address, ContractAddress}."
msgstr ""

#: src/ch03-08-02-important-methods.md:5
msgid "Table 1.0"
msgstr ""

#: src/ch04-00-account-abstraction.md:3
msgid "Account Abstraction (AA) represents an approach to managing accounts and transactions in blockchain networks. It involves two key concepts:"
msgstr ""

#: src/ch04-00-account-abstraction.md:5
msgid "**Transaction Flexibility**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:7
msgid "Smart contracts validate their transactions, moving away from a universal validation model."
msgstr ""

#: src/ch04-00-account-abstraction.md:8
msgid "Benefits include smart contracts covering gas fees, supporting multiple signers for one account, and using alternative cryptographic signatures."
msgstr ""

#: src/ch04-00-account-abstraction.md:10
msgid "**User Experience Optimization**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:11
msgid "AA enables developers to design flexible security models, such as using different keys for routine and high-value transactions."
msgstr ""

#: src/ch04-00-account-abstraction.md:12
msgid "It offers alternatives to seed phrases for account recovery, simplifying the user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:14
msgid ""
"Technically, AA replaces Externally Owned Accounts (EOA) with a broader account concept. In this model, accounts are smart contracts, each with its unique rules and behaviors. These rules can govern "
"transaction ordering, signatures, access controls, and more, offering extensive customization."
msgstr ""

#: src/ch04-00-account-abstraction.md:16
msgid "**Key Definitions of AA**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:18
msgid ""
"**Definition 1**: As described by [Martin Triay at Devcon 6](https://www.youtube.com/watch?v=Osc_gwNW3Fw), AA allows smart contracts to pay for their transactions. This shifts away from traditional "
"Externally Owned Accounts or Smart Wallets."
msgstr ""

#: src/ch04-00-account-abstraction.md:19
msgid ""
"**Definition 2**: [Lightclient at Devcon 6](https://app.devcon.org/schedule/9mvqce) defines AA as validation abstraction. Unlike Ethereum's Layer 1 single validation method, AA permits various "
"signature types, cryptographic methods, and execution processes."
msgstr ""

#: src/ch04-00-account-abstraction.md:21
#, fuzzy
msgid "Applications of Account Abstraction"
msgstr "4: è´¦æˆ·æŠ½è±¡"

#: src/ch04-00-account-abstraction.md:23
msgid "Account Abstraction (AA) enhances the accessibility and security of self-custody in blockchain technology. Here are a few of the features that AA enables:"
msgstr ""

#: src/ch04-00-account-abstraction.md:25
msgid "**Hardware Signer**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:27
msgid "AA enables transaction signing with keys stored in a smartphoneâ€™s secure enclave, incorporating biometric identity for enhanced security and ease of use."
msgstr ""

#: src/ch04-00-account-abstraction.md:29
msgid "**Social Recovery**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:31
msgid "In case of lost or compromised keys, AA allows for secure key replacement, removing the need for seed phrases and simplifying the user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:33
msgid "**Key Rotation**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:35
msgid "If a key is compromised, it can be easily replaced without needing to transfer assets."
msgstr ""

#: src/ch04-00-account-abstraction.md:37
msgid "**Session Keys**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:39
msgid "AA facilitates a _sign in once_ feature for web3 applications, allowing transactions on your behalf and minimizing constant approvals."
msgstr ""

#: src/ch04-00-account-abstraction.md:41
msgid "**Custom Transaction Validation Schemes**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:42
msgid "AA supports various signature schemes and security rules, enabling tailored security measures for individual needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:44
msgid "AA also bolsters security in several ways:"
msgstr ""

#: src/ch04-00-account-abstraction.md:46
msgid "**Improved Key Management**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:48
msgid "Multiple devices can be linked to your wallet, ensuring account access even if one device is lost."
msgstr ""

#: src/ch04-00-account-abstraction.md:50
msgid "**Diverse Signature and Validation Schemes**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:52
msgid "AA accommodates additional security measures like two-factor authentication for substantial transactions, catering to individual security needs."
msgstr ""

#: src/ch04-00-account-abstraction.md:54
msgid "**Custom Security Policies**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:55
msgid "Security can be customized for different user types or devices, incorporating best practices from banking and web2 sectors."
msgstr ""

#: src/ch04-00-account-abstraction.md:57
msgid "Ethereum Account System"
msgstr ""

#: src/ch04-00-account-abstraction.md:59
msgid "Understanding Ethereum's current account system is important to appreciating the benefits of Account Abstraction (AA). Ethereum's account system comprises two types:"
msgstr ""

#: src/ch04-00-account-abstraction.md:61
msgid "**Externally Owned Accounts (EOAs)**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:63
msgid "Used by individuals, wallets, or entities external to the Ethereum network."
msgstr ""

#: src/ch04-00-account-abstraction.md:64
msgid "Identified by addresses derived from the public key of a cryptographic signer, which includes a private key and a public key."
msgstr ""

#: src/ch04-00-account-abstraction.md:65
msgid "The private key signs transactions or messages to prove ownership, while the public key verifies the signature."
msgstr ""

#: src/ch04-00-account-abstraction.md:66
msgid "Transactions must be signed by the EOA's private key to modify the account state, ensuring security through unique cryptographic identity."
msgstr ""

#: src/ch04-00-account-abstraction.md:68
msgid "**Contract Accounts (CAs)**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:69
msgid "Essentially smart contracts on the Ethereum blockchain."
msgstr ""

#: src/ch04-00-account-abstraction.md:70
msgid "Lack private keys and are activated by transactions or messages from EOAs."
msgstr ""

#: src/ch04-00-account-abstraction.md:71
msgid "Their behavior is defined by their code."
msgstr ""

#: src/ch04-00-account-abstraction.md:73
msgid "Challenges in the current account model include:"
msgstr ""

#: src/ch04-00-account-abstraction.md:75
#, fuzzy
msgid "**Key Management**:"
msgstr "### ç¼“å­˜ç®¡ç†"

#: src/ch04-00-account-abstraction.md:77
msgid "Loss of a private key means irreversible loss of account control and assets."
msgstr ""

#: src/ch04-00-account-abstraction.md:78
msgid "If stolen, the thief gains complete access to the account and its assets."
msgstr ""

#: src/ch04-00-account-abstraction.md:80
msgid "**User Experience**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:82
msgid "The Ethereum account model currently lacks user-friendly key or account recovery options."
msgstr ""

#: src/ch04-00-account-abstraction.md:83
msgid "Complex interfaces like crypto wallets can deter non-technical users, limiting broader adoption."
msgstr ""

#: src/ch04-00-account-abstraction.md:85
msgid "**Lack of Flexibility**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:86
msgid "The traditional model restricts custom transaction validation schemes, limiting potential security and access control enhancements."
msgstr ""

#: src/ch04-00-account-abstraction.md:88
msgid "AA aims to address these issues, presenting opportunities for improved security, scalability, and user experience."
msgstr ""

#: src/ch04-00-account-abstraction.md:90
msgid "Why Isnâ€™t Account Abstraction Implemented in Ethereumâ€™s Layer 1 Yet?"
msgstr ""

#: src/ch04-00-account-abstraction.md:92
msgid ""
"Ethereum's Layer 1 (L1) currently lacks support for Account Abstraction (AA) at the protocol level, not due to a lack of interest or recognition of its value, but rather because of the complexity "
"involved in its integration."
msgstr ""

#: src/ch04-00-account-abstraction.md:94
msgid "Key challenges to implementing AA in Ethereumâ€™s L1 include:"
msgstr ""

#: src/ch04-00-account-abstraction.md:96
msgid "**Entrenched Nature of Externally Owned Accounts (EOAs)**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:98
msgid "EOAs are integral to Ethereum's core protocol."
msgstr ""

#: src/ch04-00-account-abstraction.md:99
msgid "Modifying them to support AA is a daunting task, especially as Ethereum's value and usage continue to grow."
msgstr ""

#: src/ch04-00-account-abstraction.md:101
msgid "**Limitations of the Ethereum Virtual Machine (EVM)**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:102
msgid "The EVM, Ethereum's smart contract runtime environment, faces limitations that obstruct AA implementation."
msgstr ""

#: src/ch04-00-account-abstraction.md:103
msgid "Despite several AA proposals since Ethereum's inception, they have been delayed due to prioritization of other critical updates and improvements."
msgstr ""

#: src/ch04-00-account-abstraction.md:105
msgid "However, the rise of Layer 2 (L2) solutions offers a new avenue for AA:"
msgstr ""

#: src/ch04-00-account-abstraction.md:107
msgid "**Layer 2 Solutions**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:108
msgid "Focused on scalability and performance, L2 solutions are more accommodating for AA."
msgstr ""

#: src/ch04-00-account-abstraction.md:109
msgid "Platforms like Starknet and ZKSync, inspired by EIP4337, are pioneering native AA implementations."
msgstr ""

#: src/ch04-00-account-abstraction.md:111
msgid "Due to the ongoing delays and complexities of integrating AA into Ethereumâ€™s L1, many advocates, have shifted their focus:"
msgstr ""

#: src/ch04-00-account-abstraction.md:113
msgid "**Shift to Layer 2 Advocacy**:"
msgstr ""

#: src/ch04-00-account-abstraction.md:114
msgid "Instead of waiting for EOAs to phase out and AA to integrate into Ethereum's core, proponents now support the adoption of AA through L2 solutions."
msgstr ""

#: src/ch04-00-account-abstraction.md:115
msgid "This approach aims to deliver AA benefits to users more quickly and maintain Ethereum's competitive edge in the fast-evolving crypto space."
msgstr ""

#: src/ch04-00-account-abstraction.md:119
msgid ""
"In this subchapter, we've looked at Account Abstraction (AA) in Ethereum. AA makes transactions more flexible and improves how users manage their accounts. It's set to solve problems like key "
"management and user experience in Ethereum, but its integration into Ethereum's main layer has been slow due to technical hurdles and established systems."
msgstr ""

#: src/ch04-00-account-abstraction.md:121
msgid "Layer 2 solutions, however, are opening doors for AA. Starknet is a key player here."
msgstr ""

#: src/ch04-00-account-abstraction.md:123
msgid "Next, we'll get practical. You'll learn to code AA contracts in Starknet."
msgstr ""

#: src/ch04-01-accounts.md:1
#, fuzzy
msgid "Account Contracts"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch04-01-accounts.md:3
msgid "With a clearer understanding of the AA concept, let's proceed to code it in Starknet."
msgstr ""

#: src/ch04-01-accounts.md:5
#, fuzzy
msgid "Account Contract Interface"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch04-01-accounts.md:7
msgid ""
"Account contracts, being a type of smart contracts, are distinguished by specific methods. A smart contract becomes an account contract when it follows the public interface outlined in SNIP-6 "
"([Starknet Improvement Proposal-6: Standard Account Interface](https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md)). This standard draws inspiration from SRC-6 and SRC-5, "
"similar to Ethereum's ERCs, which establish application conventions and contract standards."
msgstr ""

#: src/ch04-01-accounts.md:10
msgid ""
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
msgstr ""

#: src/ch04-01-accounts.md:19
msgid "/// @title SRC-6 Standard Account\n"
msgstr ""

#: src/ch04-01-accounts.md:22
msgid ""
"/// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
msgstr ""

#: src/ch04-01-accounts.md:27
msgid ""
"/// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
msgstr ""

#: src/ch04-01-accounts.md:32
msgid ""
"/// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
msgstr ""

#: src/ch04-01-accounts.md:38
#, fuzzy
msgid "/// @title SRC-5 Standard Interface Detection\n"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch04-01-accounts.md:41
msgid ""
"/// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
msgstr ""

#: src/ch04-01-accounts.md:49
msgid "From the proposal, an account contract should have the `__execute__`, `__validate__`, and `is_valid_signature` methods from the `ISRC6` trait."
msgstr ""

#: src/ch04-01-accounts.md:51
#, fuzzy
msgid "The provided functions serve these purposes:"
msgstr "æä¾›è€…å……å½“ä»¥ä¸‹æ´»åŠ¨çš„åª’ä»‹ï¼š"

#: src/ch04-01-accounts.md:53
msgid ""
"`__validate__`: Validates a list of calls intended for execution based on the contract's rules. Instead of a boolean, it returns a short string like 'VALID' within a `felt252` to convey validation "
"results. In Cairo, this short string is the ASCII representation of a single felt. If verification fails, any felt other than 'VALID' can be returned. Often, `0` is chosen."
msgstr ""

#: src/ch04-01-accounts.md:54
msgid ""
"`is_valid_signature`: Confirms the authenticity of a transaction's signature. It takes a transaction data hash and a signature, and compares it against a public key or another method chosen by the "
"contract's author. The result is a short 'VALID' string within a `felt252`."
msgstr ""

#: src/ch04-01-accounts.md:55
msgid ""
"`__execute__`: After validation, `__execute__` carries out a series of contract calls (as `Call` structs). It gives back an array of `Span<felt252>` structs, showing the return values of those calls."
msgstr ""

#: src/ch04-01-accounts.md:57
msgid ""
"Moreover, the `SNIP-5` (Standard Interface Detection) trait needs to be defined with a function called `supports_interface`. This function verifies whether a contract supports a specific interface, "
"receiving an interface ID and returning a boolean."
msgstr ""

#: src/ch04-01-accounts.md:68
msgid ""
"In essence, when a user dispatches an `invoke` transaction, the protocol initiates by invoking the `__validate__` method. This verifies the associated signer's authenticity. For security reasons, "
"particularly to safeguard the Sequencer from Denial of Service (DoS) attacks \\[1\\], there are constraints on the operations within the `__validate__` method. If the signature is verified, the method "
"yields a `'VALID'` `felt252` value. If not, it returns 0."
msgstr ""

#: src/ch04-01-accounts.md:70
msgid ""
"After the protocol verifies the signer, it proceeds to invoke the `__execute__` function, passing an array of all desired operationsâ€”referred to as \"calls\"â€”as an argument. Each of these calls "
"specifies a target smart contract address (`to`), the method to be executed (`selector`), and the arguments this method requires (`calldata`)."
msgstr ""

#: src/ch04-01-accounts.md:90
msgid ""
"Executing a `Call` may yield a return value from the target smart contract. Whether it's a felt252, boolean, or a more intricate data structure like a struct or array, Starknet protocol serializes the "
"return using `Span<felt252>`. Since `Span` captures a segment of an Array \\[2\\], the `__execute__` function outputs an array of `Span<felt252>` elements. This array signifies the serialized feedback "
"from every operation in the multicall."
msgstr ""

#: src/ch04-01-accounts.md:92
msgid ""
"The `is_valid_signature` method isn't mandated or employed by the Starknet protocol. Instead, it's a convention within the Starknet developer community. Its purpose is to facilitate user "
"authentication in web3 applications. For instance, consider a user attempting to log into an NFT marketplace using their digital wallet. The web application prompts the user to sign a message, then it "
"uses the `is_valid_signature` function to confirm the authenticity of the associated wallet address."
msgstr ""

#: src/ch04-01-accounts.md:94
msgid ""
"To ensure other smart contracts recognize the compliance of an account contract with the SNIP-6 public interface, developers should incorporate the `supports_interface` method from the `ISRC5` "
"introspection trait. This method requires the Interface ID of SNIP-6 as its argument."
msgstr ""

#: src/ch04-01-accounts.md:104
msgid "// Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
msgstr ""

#: src/ch04-01-accounts.md:112
msgid ""
"The `interface_id` corresponds to the aggregated hash of the trait's selectors, as detailed in Ethereum's ERC165 \\[3\\]. Developers can either compute the ID using the `src5-rs` utility \\[4\\] or "
"rely on the pre-calculated ID: `1270010605630597976495846281167968799381097569185364931397797212080166453709`."
msgstr ""

#: src/ch04-01-accounts.md:114
msgid "The fundamental structure for the account contract, aligning with the SNIP-G Interface standard, looks like this:"
msgstr ""

#: src/ch04-01-accounts.md:134
#, fuzzy
msgid "Expanding the Interface"
msgstr "### ä»åˆçº¦è¯»å–æ•°æ®"

#: src/ch04-01-accounts.md:136
msgid ""
"While the components mentioned earlier lay the foundation for an account contract in alignment with the SNIP-6 standard, developers can introduce more features to enhance the contract's capabilities."
msgstr ""

#: src/ch04-01-accounts.md:138
msgid ""
"For example, integrate the `__validate_declare__` function if the contract declares other contracts and handles the corresponding gas fees. This offers a way to authenticate the contract declaration. "
"For those keen on counterfactual smart contract deployment, the `__validate_deploy__` function can be included."
msgstr ""

#: src/ch04-01-accounts.md:140
msgid ""
"Counterfactual deployment lets developers set up an account contract without depending on another account contract for gas fees. This method is valuable when there's no desire to link a new account "
"contract with its deploying address, ensuring a fresh start."
msgstr ""

#: src/ch04-01-accounts.md:142
msgid "This approach involves:"
msgstr ""

#: src/ch04-01-accounts.md:144
msgid "Locally determining the potential address of our account contract without actual deployment, feasible with the Starkli \\[5\\] tool."
msgstr ""

#: src/ch04-01-accounts.md:145
msgid "Transferring sufficient ETH to the predicted address to cover the deployment costs."
msgstr ""

#: src/ch04-01-accounts.md:146
msgid ""
"Sending a `deploy_account` transaction to Starknet containing our contract's compiled code. The sequencer then activates the account contract at the estimated address, compensating its gas fees from "
"the transferred ETH. No `declare` action is needed beforehand."
msgstr ""

#: src/ch04-01-accounts.md:148
msgid "For better compatibility with tools like Starkli later on, expose the signer's `public_key` through a view function in the public interface. Below is the augmented account contract interface:"
msgstr ""

#: src/ch04-01-accounts.md:151
msgid "/// @title IAccountAddon - Extended account contract interface\n"
msgstr ""

#: src/ch04-01-accounts.md:153
msgid ""
"/// @notice Validates if a declare transaction can proceed\n"
"    /// @param class_hash Hash of the smart contract under declaration\n"
"    /// @return 'VALID' string as felt, if valid\n"
msgstr ""

#: src/ch04-01-accounts.md:158
msgid ""
"/// @notice Validates if counterfactual deployment can proceed\n"
"    /// @param class_hash Hash of the account contract under deployment\n"
"    /// @param salt Modifier for account address\n"
"    /// @param public_key Account signer's public key\n"
"    /// @return 'VALID' string as felt, if valid\n"
msgstr ""

#: src/ch04-01-accounts.md:165
msgid ""
"/// @notice Fetches the signer's public key\n"
"    /// @return Public key\n"
msgstr ""

#: src/ch04-01-accounts.md:171
msgid "In conclusion, a comprehensive account contract incorporates the **SNIP-5**, **SNIP-6**, and the Addon interfaces."
msgstr ""

#: src/ch04-01-accounts.md:174
#, fuzzy
msgid "// Cheat sheet\n"
msgstr "# Scarb Cheat Sheet"

#: src/ch04-01-accounts.md:200
msgid "Recap"
msgstr ""

#: src/ch04-01-accounts.md:202
msgid "We've broken down the distinctions between account contracts and basic smart contracts, particularly focusing on the methods laid out in SNIP-6."
msgstr ""

#: src/ch04-01-accounts.md:204
msgid "Introduced the `ISRC6` trait, spotlighting essential functions:"
msgstr ""

#: src/ch04-01-accounts.md:206
msgid "`__validate__`: Validates transactions."
msgstr ""

#: src/ch04-01-accounts.md:207
msgid "`is_valid_signature`: Verifies signatures."
msgstr ""

#: src/ch04-01-accounts.md:208
msgid "`__execute__`: Executes contract calls."
msgstr ""

#: src/ch04-01-accounts.md:210
msgid "Discussed the `ISRC5` trait and highlighted the importance of the `supports_interface` function in confirming interface support."
msgstr ""

#: src/ch04-01-accounts.md:212
msgid "Detailed the `Call` struct to represent a single contract call, explaining its components: `to`, `selector`, and `calldata`."
msgstr ""

#: src/ch04-01-accounts.md:214
msgid "Touched on advanced features for account contracts, such as the `__validate_declare__` and `__validate_deploy__` functions."
msgstr ""

#: src/ch04-01-accounts.md:216
msgid "Coming up, we'll craft a basic account contract and deploy it on Starknet, offering hands-on insight into their functionality and interactions."
msgstr ""

#: src/ch04-02-hello-account.md:1
#, fuzzy
msgid "Hello World! Account Contract"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch04-02-hello-account.md:3
msgid ""
"This section guides you through the creation of the simplest possible account contract, adhering to the SNIP-6 standard. The account contract will be the simplest implementation of an account "
"contract, with the following features:"
msgstr ""

#: src/ch04-02-hello-account.md:5
msgid "Signature validation for transactions will be not enforced. In other words, every transaction will be considered valid no matter who signed it; there will be no pivate key."
msgstr ""

#: src/ch04-02-hello-account.md:6
msgid "It will make a single call and not multicall in the execution phase."
msgstr ""

#: src/ch04-02-hello-account.md:7
msgid "It will only implement the SNIP-6 standard which is the minimum to be considered an account contract."
msgstr ""

#: src/ch04-02-hello-account.md:9
msgid "We will deployed using `starknet.py` and use it to deploy other contracts."
msgstr ""

#: src/ch04-02-hello-account.md:11 src/ch04-03-standard-account.md:5
#, fuzzy
msgid "Setting Up Your Project"
msgstr "## è®¾ç½®æ–°çš„ React é¡¹ç›®"

#: src/ch04-02-hello-account.md:13 src/ch04-03-standard-account.md:7
msgid ""
"For deploying an account contract to Starknet's testnet or mainnet, use Scarb version 2.3.1, which is compatible with the Sierra 1.3.0 target supported by both networks. For the latest information, "
"review the [Starknet Release Notes](https://docs.starknet.io/documentation/starknet_versions/version_notes/). As of November 2023, Scarb version 2.3.1 is the recommended choice."
msgstr ""

#: src/ch04-02-hello-account.md:15 src/ch04-03-standard-account.md:9
msgid "To check your current Scarb version, run:"
msgstr ""

#: src/ch04-02-hello-account.md:21
msgid ""
"To install or update Scarb, refer to the Basic Installation instructions in [Chapter 2](./ch02-01-basic-installation.html#scarb-package-manager-installation), covering macOS and Linux environments:"
msgstr ""

#: src/ch04-02-hello-account.md:27 src/ch04-03-standard-account.md:21
#, fuzzy
msgid "Starting a New Scarb Project"
msgstr "## å¯åŠ¨æ–°çš„Starkneté¡¹ç›®"

#: src/ch04-02-hello-account.md:29 src/ch04-03-standard-account.md:23
msgid "Begin by creating a new project (more details in the Scarb subchapter in Chapter 2):"
msgstr ""

#: src/ch04-02-hello-account.md:35 src/ch04-03-standard-account.md:29
msgid "Check the generated project structure:"
msgstr ""

#: src/ch04-02-hello-account.md:46 src/ch04-03-standard-account.md:40
msgid "By default, Scarb sets up for vanilla Cairo. Add Starknet capacities by editing `Scarb.toml` to include the `starknet` dependency:"
msgstr ""

#: src/ch04-02-hello-account.md:50
#, fuzzy
msgid "\"hello_account\""
msgstr "ä½ å¥½ï¼Œè´¦æˆ·ï¼"

#: src/ch04-02-hello-account.md:51 src/ch04-03-standard-account.md:45
msgid "\"0.1.0\""
msgstr ""

#: src/ch04-02-hello-account.md:54 src/ch04-03-standard-account.md:49
msgid "\">=2.3.0\""
msgstr ""

#: src/ch04-02-hello-account.md:62
msgid "Replace the code in `src/lib.cairo` with the Hello World account contract:"
msgstr ""

#: src/ch04-02-hello-account.md:66
msgid "// IERC6 obtained from Open Zeppelin's cairo-contracts/src/account/interface.cairo\n"
msgstr ""

#: src/ch04-02-hello-account.md:82
msgid "// Empty storage. No public key is stored.\n"
msgstr ""

#: src/ch04-02-hello-account.md:89 src/ch04-02-hello-account.md:146
msgid "// No signature is required so any signature is valid.\n"
msgstr ""

#: src/ch04-02-hello-account.md:111 src/ch04-03-standard-account.md:78
msgid "Compile your project to ensure the setup is correct:"
msgstr ""

#: src/ch04-02-hello-account.md:117
msgid "SNIP-6 Standard"
msgstr ""

#: src/ch04-02-hello-account.md:119 src/ch04-03-standard-account.md:86
msgid "To define an account contract, implement the `ISRC6` trait:"
msgstr ""

#: src/ch04-02-hello-account.md:130
msgid ""
"The `__execute__` and `__validate__` functions are designed for exclusive use by the Starknet protocol to enhance account security. Despite their public accessibility, only the Starknet protocol can "
"invoke these functions, identified by using the zero address. In this minimal account contract we will not enforce this restriction, but we will do it in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:132
#, fuzzy
msgid "Validating Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-02-hello-account.md:134
msgid "The `is_valid_signature` function is responsible for this validation, returning `VALIDATED` if the signature is valid. The `VALIDATED` constant is imported from the `starknet` module."
msgstr ""

#: src/ch04-02-hello-account.md:140
msgid ""
"Notice that the `is_valid_signature` function accepts all the transactions as valid. We are not storing a public key in the contract, so we cannot validate the signature. We will add this "
"functionality in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:151
msgid ""
"The `__validate__` function calls the `is_valid_signature` function with a dummy hash and signature. The `__validate__` function is called by the Starknet protocol to validate the transaction. If the "
"transaction is not valid, the execution of the transaction is aborted."
msgstr ""

#: src/ch04-02-hello-account.md:162
msgid "In other words we have implemented a contract that accepts all the transactions as valid. We will add the signature validation in the next examples."
msgstr ""

#: src/ch04-02-hello-account.md:164
#, fuzzy
msgid "Executing Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-02-hello-account.md:166
msgid ""
"The `__execute__` function is responsible for executing the transaction. In this minimal account contract we will only execute a single call. We will add the multicall functionality in the next "
"examples."
msgstr ""

#: src/ch04-02-hello-account.md:178
msgid ""
"The `__execute__` function calls the `call_contract_syscall` function from the `starknet` module. This function executes the call and returns the result. The `call_contract_syscall` function is a "
"Starknet syscall, which means that it is executed by the Starknet protocol. The Starknet protocol is responsible for executing the call and returning the result. The Starknet protocol will also "
"validate the call, so we do not need to validate the call in the `__execute__` function."
msgstr ""

#: src/ch04-02-hello-account.md:182
msgid "\\[TODO\\]"
msgstr ""

#: src/ch04-03-standard-account.md:3
msgid ""
"This section guides you through the creation of a standard account contract, adhering to the SNIP-6 and SRC-5 standards. Previously, we created a simple account contract that lacked signature "
"validation and multicall execution. This time, we'll implement a more robust account contract that includes these features and adheres to the standards of an account contract."
msgstr ""

#: src/ch04-03-standard-account.md:15
msgid "To install or update Scarb, refer to the Basic Installation instructions in Chapter 2, covering macOS and Linux environments:"
msgstr ""

#: src/ch04-03-standard-account.md:44
msgid "\"aa\""
msgstr ""

#: src/ch04-03-standard-account.md:46
msgid "\"2.3.0\""
msgstr ""

#: src/ch04-03-standard-account.md:56
msgid "Replace the code in `src/lib.cairo` with an account contract scaffold:"
msgstr ""

#: src/ch04-03-standard-account.md:69
msgid "To validate signatures, store the public key associated with the signer's private key."
msgstr ""

#: src/ch04-03-standard-account.md:84
msgid "Implementing SNIP-6 Standard"
msgstr ""

#: src/ch04-03-standard-account.md:96
msgid ""
"The `#[external(v0)]` attribute marks functions with unique selectors for external interaction. The Starknet protocol exclusively uses `__execute__` and `__validate__`, whereas `is_valid_signature` is "
"available for web3 applications to validate signatures."
msgstr ""

#: src/ch04-03-standard-account.md:98
msgid ""
"The `trait IAccount<T>`\\*\\* with `#[starknet::interface]` attribute groups publicly accessible functions, like `is_valid_signature`. Functions `__execute__` and `__validate__`, though public, are "
"accessible only indirectly."
msgstr ""

#: src/ch04-03-standard-account.md:122
msgid "// These functions are protocol-specific and not intended for direct external use.\n"
msgstr ""

#: src/ch04-03-standard-account.md:132
msgid "Restricted Function Access for Security"
msgstr ""

#: src/ch04-03-standard-account.md:134
msgid ""
"The `__execute__` and `__validate__` functions are designed for exclusive use by the Starknet protocol to enhance account security. Despite their public accessibility, only the Starknet protocol can "
"invoke these functions, identified by using the zero address."
msgstr ""

#: src/ch04-03-standard-account.md:142
msgid "// Enforces Starknet protocol-only access to specific functions\n"
msgstr ""

#: src/ch04-03-standard-account.md:146
msgid "// Executes protocol-specific operations\n"
msgstr ""

#: src/ch04-03-standard-account.md:148 src/ch04-03-standard-account.md:154
msgid ""
"// Verifies protocol-level caller\n"
"      // ... (implementation details)\n"
msgstr ""

#: src/ch04-03-standard-account.md:152
msgid "// Validates protocol-specific operations\n"
msgstr ""

#: src/ch04-03-standard-account.md:159
msgid "// Defines a private function to check for protocol-level access\n"
msgstr ""

#: src/ch04-03-standard-account.md:163
msgid "// ... (access validation logic)\n"
msgstr ""

#: src/ch04-03-standard-account.md:169
msgid "Enhanced Security Through Protocol-Exclusive Functions"
msgstr ""

#: src/ch04-03-standard-account.md:171
msgid ""
"Starknet enhances the security of accounts by restricting the callability of certain functions. The `__execute__` and `__validate__` functions, though publicly visible, are callable solely by the "
"Starknet protocol. This protocol asserts its unique calling rights by using a designated zero addressâ€”a special value that signifies protocol-level operations."
msgstr ""

#: src/ch04-03-standard-account.md:179
msgid "// Implements function access control for Starknet protocol\n"
msgstr ""

#: src/ch04-03-standard-account.md:183
msgid "// The __execute__ function is a protocol-exclusive operation\n"
msgstr ""

#: src/ch04-03-standard-account.md:185
msgid ""
"// Validates the caller as the Starknet protocol\n"
"      // ... (execution logic)\n"
msgstr ""

#: src/ch04-03-standard-account.md:189
msgid "// The __validate__ function ensures the integrity of protocol-level calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:191
msgid ""
"// Ensures the caller is the Starknet protocol\n"
"      // ... (validation logic)\n"
msgstr ""

#: src/ch04-03-standard-account.md:196
msgid "// A private function, only_protocol, to enforce protocol-level access\n"
msgstr ""

#: src/ch04-03-standard-account.md:199
msgid "// only_protocol checks the caller's address against the zero address\n"
msgstr ""

#: src/ch04-03-standard-account.md:201
msgid ""
"// If the caller is not the zero address, access is denied\n"
"      // This guarantees that only the Starknet protocol can call the function\n"
"      // ... (access control logic)\n"
msgstr ""

#: src/ch04-03-standard-account.md:209
msgid "The `is_valid_signature` function, by contrast, is not bounded by `only_protocol`, maintaining its availability for broader use."
msgstr ""

#: src/ch04-03-standard-account.md:211
#, fuzzy
msgid "Transaction Signature Validation"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-03-standard-account.md:213
msgid "To verify transaction signatures, the account contract stores the public key of the signer. The `constructor` method initializes this public key during the contract's deployment."
msgstr ""

#: src/ch04-03-standard-account.md:218
msgid "// Persistent storage for account-related data\n"
msgstr ""

#: src/ch04-03-standard-account.md:221
msgid "// Stores the public key for signature validation\n"
msgstr ""

#: src/ch04-03-standard-account.md:224
msgid "// Sets the public key during contract deployment\n"
msgstr ""

#: src/ch04-03-standard-account.md:227
msgid "// Records the signer's public key\n"
msgstr ""

#: src/ch04-03-standard-account.md:229 src/ch04-03-standard-account.md:272 src/ch04-03-standard-account.md:305 src/ch04-03-standard-account.md:390 src/ch04-03-standard-account.md:424
#: src/ch04-03-standard-account.md:453
msgid "// ... Additional implementation details\n"
msgstr ""

#: src/ch04-03-standard-account.md:233
msgid ""
"The `is_valid_signature` function outputs `VALID` for an authentic signature and `0` for an invalid one. Additionally, the `is_valid_signature_bool` internal function provides a Boolean result for the "
"signature's validity."
msgstr ""

#: src/ch04-03-standard-account.md:238
msgid "// Import relevant cryptographic and data handling modules\n"
msgstr ""

#: src/ch04-03-standard-account.md:241
msgid "// Facilitates the use of the span() method\n"
msgstr ""

#: src/ch04-03-standard-account.md:243
msgid "// External function to validate the transaction signature\n"
msgstr ""

#: src/ch04-03-standard-account.md:247
msgid "// Converts the signature array into a span for processing\n"
msgstr ""

#: src/ch04-03-standard-account.md:249
msgid "// Returns 'VALID' or '0' based on signature validity\n"
msgstr ""

#: src/ch04-03-standard-account.md:253
msgid "// Private function to check the signature validity and return a Boolean\n"
msgstr ""

#: src/ch04-03-standard-account.md:256
msgid "// Validates the signature using a span of elements\n"
msgstr ""

#: src/ch04-03-standard-account.md:258
msgid "// Checks if the signature has the correct length\n"
msgstr ""

#: src/ch04-03-standard-account.md:261
msgid "// If the signature length is incorrect, returns false\n"
msgstr ""

#: src/ch04-03-standard-account.md:266
msgid "// Verifies the signature using the stored public key\n"
msgstr ""

#: src/ch04-03-standard-account.md:277
msgid "In the `__validate__` function, the `is_valid_signature_bool` method is utilized to confirm the integrity of transaction signatures."
msgstr ""

#: src/ch04-03-standard-account.md:282
msgid "// Import modules for transaction information retrieval\n"
msgstr ""

#: src/ch04-03-standard-account.md:286
msgid "// Protocol implementation for transaction validation\n"
msgstr ""

#: src/ch04-03-standard-account.md:290
msgid "// Validates the signature of a transaction\n"
msgstr ""

#: src/ch04-03-standard-account.md:292
msgid "// Ensures protocol-only access\n"
msgstr ""

#: src/ch04-03-standard-account.md:294
msgid "// Retrieves transaction information and unpacks it\n"
msgstr ""

#: src/ch04-03-standard-account.md:299
msgid "// Validates the signature and asserts its correctness\n"
msgstr ""

#: src/ch04-03-standard-account.md:301
msgid "// Stops execution if the signature is invalid\n"
msgstr ""

#: src/ch04-03-standard-account.md:302
msgid "// Indicates a valid signature\n"
msgstr ""

#: src/ch04-03-standard-account.md:309
msgid "Unified Signature Validation for Contract Operations"
msgstr ""

#: src/ch04-03-standard-account.md:311
msgid ""
"The `__validate_declare__` function is responsible for validating the signature of the `declare` function. On the other hand, `__validate_deploy__` facilitates counterfactual deployment,a method to "
"deploy an account contract without associating it to a specific deployer address."
msgstr ""

#: src/ch04-03-standard-account.md:316
msgid ""
"To streamline the validation process, we'll unify the behavior of the three validation functions `__validate__`,`__validate_declare__` and `__validate_deploy__`. The core logic from `__validate__` is "
"abstracted to `validate_transaction` private function, which is then invoked by the other two validation functions."
msgstr ""

#: src/ch04-03-standard-account.md:324
msgid "// Protocol implementation for the account contract\n"
msgstr ""

#: src/ch04-03-standard-account.md:329
msgid "// Validates general contract function calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:331 src/ch04-03-standard-account.md:337
msgid "// Ensures only the Starknet protocol can call\n"
msgstr ""

#: src/ch04-03-standard-account.md:332
msgid "// Centralized validation logic\n"
msgstr ""

#: src/ch04-03-standard-account.md:335
msgid "// Validates the 'declare' function signature\n"
msgstr ""

#: src/ch04-03-standard-account.md:338
msgid "// Reuses the validation logic\n"
msgstr ""

#: src/ch04-03-standard-account.md:341
msgid "// Validates counterfactual contract deployment\n"
msgstr ""

#: src/ch04-03-standard-account.md:343
msgid ""
"// Ensures only the Starknet protocol can call\n"
"      // Even though public_key is provided, it uses the one stored from the constructor\n"
msgstr ""

#: src/ch04-03-standard-account.md:345
msgid "// Applies the same validation logic\n"
msgstr ""

#: src/ch04-03-standard-account.md:349
msgid "// Private trait implementation that contains shared validation logic\n"
msgstr ""

#: src/ch04-03-standard-account.md:352
msgid "// Abstracted core logic for validating transactions\n"
msgstr ""

#: src/ch04-03-standard-account.md:354
#, fuzzy
msgid "// Extracts transaction information\n"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-03-standard-account.md:358
msgid "// Validates the transaction signature using an internal boolean function\n"
msgstr ""

#: src/ch04-03-standard-account.md:360
msgid "// Ensures signature correctness\n"
msgstr ""

#: src/ch04-03-standard-account.md:361
msgid "// Returns 'VALID' if the signature checks out\n"
msgstr ""

#: src/ch04-03-standard-account.md:367
msgid ""
"It's important to note that the `__validate_deploy__` function receives the public key as an argument. While this key is captured during the constructor phase before this function is invoked, it "
"remains crucial to provide it when initiating the transaction. Alternatively, the public key can be directly utilized within the `__validate_deploy__` function, bypassing the constructor."
msgstr ""

#: src/ch04-03-standard-account.md:373
#, fuzzy
msgid "Efficient Multicall Transaction Execution"
msgstr "### å¤šé‡è°ƒç”¨åˆçº¦äº¤äº’"

#: src/ch04-03-standard-account.md:375
msgid ""
"The `__execute__` function within the `Account` module of a Starknet contract is designed to process an array of `Call` structures. This multicall feature consolidates several user operations into a "
"single transaction, significantly improving the user experience by enabling batched operations."
msgstr ""

#: src/ch04-03-standard-account.md:381
msgid "// Protocol implementation to handle execution of calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:385
msgid "// The __execute__ function processes an array of calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:387
msgid "// Ensures Starknet protocol level access\n"
msgstr ""

#: src/ch04-03-standard-account.md:388
msgid "// Invokes batch processing of calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:395
msgid "Each `Call` represents the details required for executing a single operation by the smart contract:"
msgstr ""

#: src/ch04-03-standard-account.md:398
msgid "// Data structure encapsulating a contract call\n"
msgstr ""

#: src/ch04-03-standard-account.md:401
msgid "// The target contract address\n"
msgstr ""

#: src/ch04-03-standard-account.md:402
msgid "// The function selector\n"
msgstr ""

#: src/ch04-03-standard-account.md:403
msgid "// The parameters for the function call\n"
msgstr ""

#: src/ch04-03-standard-account.md:407
msgid "The contract defines a private function `execute_single_call` to handle individual calls. It utilizes the `call_contract_syscall` to directly invoke a function on another contract:"
msgstr ""

#: src/ch04-03-standard-account.md:412
msgid "// Import syscall for contract function invocation\n"
msgstr ""

#: src/ch04-03-standard-account.md:415
msgid "// Private trait implementation for individual call execution\n"
msgstr ""

#: src/ch04-03-standard-account.md:418
#, fuzzy
msgid "// Executes a single call to another contract\n"
msgstr "æ‰§è¡Œä»¥ä¸‹æ“ä½œä»¥ç¼–è¯‘åˆçº¦ï¼š"

#: src/ch04-03-standard-account.md:420
msgid "// Destructures the Call struct\n"
msgstr ""

#: src/ch04-03-standard-account.md:421
msgid "// Performs the contract call\n"
msgstr ""

#: src/ch04-03-standard-account.md:428
msgid "For the execution of multiple calls, `execute_multiple_calls` iterates over the array of Call structures, invoking `execute_single_call` for each and collecting the responses:"
msgstr ""

#: src/ch04-03-standard-account.md:433
msgid "// Private trait implementation for batch call execution\n"
msgstr ""

#: src/ch04-03-standard-account.md:436
msgid "// Handles an array of calls and accumulates the results\n"
msgstr ""

#: src/ch04-03-standard-account.md:438
msgid "// Initializes the result array\n"
msgstr ""

#: src/ch04-03-standard-account.md:442
msgid "// Executes each call individually\n"
msgstr ""

#: src/ch04-03-standard-account.md:443
msgid "// Appends the result of the call to the result array\n"
msgstr ""

#: src/ch04-03-standard-account.md:446
msgid "// Exits the loop when no more calls are left\n"
msgstr ""

#: src/ch04-03-standard-account.md:450
msgid "// Returns the array of results\n"
msgstr ""

#: src/ch04-03-standard-account.md:457
msgid ""
"In summary, the `__execute__` function orchestrates the execution of multiple calls within a single transaction. It leverages these internal functions to handle each call efficiently and return the "
"collective results:"
msgstr ""

#: src/ch04-03-standard-account.md:462
msgid "// External function definition within the protocol implementation\n"
msgstr ""

#: src/ch04-03-standard-account.md:466
msgid "// The __execute__ function takes an array of Call structures and processes them\n"
msgstr ""

#: src/ch04-03-standard-account.md:468
msgid "// Verifies that the function caller is the Starknet protocol\n"
msgstr ""

#: src/ch04-03-standard-account.md:469
msgid "// Delegates to a function for processing multiple calls\n"
msgstr ""

#: src/ch04-03-standard-account.md:471
msgid "// ... Additional implementation details may follow\n"
msgstr ""

#: src/ch04-03-standard-account.md:473
msgid "// ... Further module code may be present\n"
msgstr ""

#: src/ch04-03-standard-account.md:477
msgid ""
"The `__execute__` function first ensures that it is being called by the Starknet protocol itself, a security measure to prevent unauthorized access. It then calls the `execute_multiple_calls` function "
"to handle the actual execution of the calls."
msgstr ""

#: src/ch04-03-standard-account.md:479
msgid "Ensuring Compatibility with Transaction Versioning"
msgstr ""

#: src/ch04-03-standard-account.md:481
msgid ""
"Starknet incorporates a versioning system for transactions to maintain backward compatibility while introducing new functionalities. The account contract tutorial showcases support for the latest "
"transaction versions through a specific module, ensuring smooth operation of both legacy and updated transaction structures."
msgstr ""

#: src/ch04-03-standard-account.md:483
msgid ""
"To accommodate the evolution of Starknet and its enhanced functionalities, a versioning system was introduced for transactions. This ensures backward compatibility, allowing both old and new "
"transaction structures to operate concurrently."
msgstr ""

#: src/ch04-03-standard-account.md:487
#, fuzzy
msgid "Version 1 for `invoke` transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-03-standard-account.md:488
#, fuzzy
msgid "Version 1 for `deploy_account` transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-03-standard-account.md:489
#, fuzzy
msgid "Version 2 for `declare` transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-03-standard-account.md:491
msgid "These supported versions are logically grouped in a module called `SUPPORTED_TX_VERSION`:"
msgstr ""

#: src/ch04-03-standard-account.md:494
msgid "// Module defining supported transaction versions\n"
msgstr ""

#: src/ch04-03-standard-account.md:496
msgid "// Constants representing the supported versions\n"
msgstr ""

#: src/ch04-03-standard-account.md:497
msgid "// Supported version for deploy_account transactions\n"
msgstr ""

#: src/ch04-03-standard-account.md:498
msgid "// Supported version for declare transactions\n"
msgstr ""

#: src/ch04-03-standard-account.md:499
msgid "// Supported version for invoke transactions\n"
msgstr ""

#: src/ch04-03-standard-account.md:504
msgid "// The rest of the account contract module code\n"
msgstr ""

#: src/ch04-03-standard-account.md:509
msgid ""
"To handle the version checking, the account contract includes a private function `only_supported_tx_version`. This function compares the version of an incoming transaction against the specified "
"supported versions, halting execution with an error if a discrepancy is found."
msgstr ""

#: src/ch04-03-standard-account.md:511
msgid "The critical contract functions such as `__execute__`, `__validate__`, `__validate_declare__`, and `__validate_deploy__` implement this version check to confirm transaction compatibility."
msgstr ""

#: src/ch04-03-standard-account.md:516
msgid "// Importing constants from the SUPPORTED_TX_VERSION module\n"
msgstr ""

#: src/ch04-03-standard-account.md:519
msgid "// Protocol implementation for Starknet functions\n"
msgstr ""

#: src/ch04-03-standard-account.md:523
msgid "// Function to execute multiple calls with version check\n"
msgstr ""

#: src/ch04-03-standard-account.md:525
msgid "// Checks if the function caller is the Starknet protocol\n"
msgstr ""

#: src/ch04-03-standard-account.md:526
msgid "// Ensures the transaction is the supported version\n"
msgstr ""

#: src/ch04-03-standard-account.md:527
msgid "// Processes the calls if version check passes\n"
msgstr ""

#: src/ch04-03-standard-account.md:530
msgid "// Each of the following functions also includes the version check to ensure compatibility\n"
msgstr ""

#: src/ch04-03-standard-account.md:550
msgid "// Private implementation for checking supported transaction versions\n"
msgstr ""

#: src/ch04-03-standard-account.md:553
msgid "// Function to assert the transaction version is supported\n"
msgstr ""

#: src/ch04-03-standard-account.md:555
msgid "// Retrieves transaction details\n"
msgstr ""

#: src/ch04-03-standard-account.md:556
msgid "// Extracts the version from the transaction\n"
msgstr ""

#: src/ch04-03-standard-account.md:559
msgid "// Error message for unsupported versions\n"
msgstr ""

#: src/ch04-03-standard-account.md:562
msgid "// ... Additional private functions\n"
msgstr ""

#: src/ch04-03-standard-account.md:567
msgid ""
"By integrating transaction version control, the contract ensures it operates consistently with the network's current standards, providing a clear path for upgrading and maintaining compatibility with "
"Starknet's evolving ecosystem."
msgstr ""

#: src/ch04-03-standard-account.md:569
#, fuzzy
msgid "Handling Simulated Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-03-standard-account.md:571
msgid ""
"Starknet's simulation feature allows developers to estimate the gas cost of transactions without actually committing them to the network. This is particularly useful during development and testing "
"phases. The `estimate-only` flag available in tools like Starkli triggers the simulation process. To differentiate between actual transaction execution and simulation, Starknet uses a version offset "
"strategy."
msgstr ""

#: src/ch04-03-standard-account.md:573
msgid ""
"Simulated transactions are assigned a version number that is the sum of (2^{128}) and the version number of the actual transaction type. For example, if the latest version of a `declare` transaction "
"is 2, then a simulated `declare` transaction would have a version number of (2^{128} + 2). The same logic applies to other transaction types like `invoke` and `deploy_account`."
msgstr ""

#: src/ch04-03-standard-account.md:575
msgid "Here's how the `only_supported_tx_version` function is adjusted to accommodate both actual and simulated transaction versions:"
msgstr ""

#: src/ch04-03-standard-account.md:580
msgid "// Constant representing the version offset for simulated transactions\n"
msgstr ""

#: src/ch04-03-standard-account.md:581
msgid "// This is 2^128\n"
msgstr ""

#: src/ch04-03-standard-account.md:583
msgid "// Private trait implementation updated to validate transaction versions\n"
msgstr ""

#: src/ch04-03-standard-account.md:586
msgid "// Function to check for supported transaction versions, accounting for simulations\n"
msgstr ""

#: src/ch04-03-standard-account.md:588
msgid "// Retrieves the transaction metadata\n"
msgstr ""

#: src/ch04-03-standard-account.md:589
msgid "// Extracts the version for comparison\n"
msgstr ""

#: src/ch04-03-standard-account.md:591
msgid "// Validates whether the transaction version matches either the supported actual version or the simulated version\n"
msgstr ""

#: src/ch04-03-standard-account.md:595
msgid "// Assertion message for version mismatch\n"
msgstr ""

#: src/ch04-03-standard-account.md:598
msgid "// Additional private functions may follow\n"
msgstr ""

#: src/ch04-03-standard-account.md:600
msgid "// Remaining contract code may continue here\n"
msgstr ""

#: src/ch04-03-standard-account.md:604
msgid ""
"The code snippet showcases the account contract's capability to recognize and process both actual and simulated versions of transactions by incorporating the large numerical offset. This ensures that "
"the system can seamlessly operate with and adjust to the estimation process without affecting the actual transaction processing logic."
msgstr ""

#: src/ch04-03-standard-account.md:606
#, fuzzy
msgid "SRC-5 Standard and Contract Introspection"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch04-03-standard-account.md:608
msgid ""
"Contract introspection is a feature that allows Starknet contracts to self-report the interfaces they support, in compliance with the SRC-5 standard. The `supports_interface` function is a fundamental "
"part of this introspection process, enabling contracts to communicate their capabilities to others."
msgstr ""

#: src/ch04-03-standard-account.md:610
msgid ""
"For a contract to be SRC-5 compliant, it must return `true` when the `supports_interface` function is called with a specific `interface_id`. This unique identifier is chosen to represent the SRC-6 "
"standard's interface, which the contract claims to support. The identifier is a large integer specifically chosen to minimize the chance of accidental collisions with other identifiers."
msgstr ""

#: src/ch04-03-standard-account.md:612
msgid "In the account contract, the `supports_interface` function is part of the public interface, allowing other contracts to query its support for the SRC-6 standard:"
msgstr ""

#: src/ch04-03-standard-account.md:615
msgid "// SRC-5 trait defining the introspection method\n"
msgstr ""

#: src/ch04-03-standard-account.md:617
msgid "// Function to check interface support\n"
msgstr ""

#: src/ch04-03-standard-account.md:620
msgid "// Extension of the account contract's interface for SRC-5 compliance\n"
msgstr ""

#: src/ch04-03-standard-account.md:624
msgid ""
"// ... Additional methods\n"
"  // Method to validate interface support\n"
msgstr ""

#: src/ch04-03-standard-account.md:631
msgid "// Constant identifier for the SRC-6 trait\n"
msgstr ""

#: src/ch04-03-standard-account.md:634
msgid "// Public interface implementation for the account contract\n"
msgstr ""

#: src/ch04-03-standard-account.md:637
msgid ""
"// ... Other function implementations\n"
"    // Implementation of the interface support check\n"
msgstr ""

#: src/ch04-03-standard-account.md:640
msgid "// Compares the provided interface ID with the SRC-6 trait ID\n"
msgstr ""

#: src/ch04-03-standard-account.md:644
msgid "// ... Additional account contract code\n"
msgstr ""

#: src/ch04-03-standard-account.md:648
msgid ""
"By implementing this function, the account contract declares its ability to interact with other contracts expecting SRC-6 features, thus adhering to the standards of the Starknet protocol and "
"enhancing interoperability within the network."
msgstr ""

#: src/ch04-03-standard-account.md:650
msgid "Public Key Accessibility"
msgstr ""

#: src/ch04-03-standard-account.md:652
msgid ""
"For enhanced transparency and debugging purposes, it's recommended to make the public key of the account contract's signer accessible. This allows users to verify the correct deployment of the account "
"contract by comparing the stored public key with the signer's public key offline."
msgstr ""

#: src/ch04-03-standard-account.md:673
#, fuzzy
msgid "Final Implementation"
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch04-03-standard-account.md:675
msgid "We now have a fully functional account contract. Here's the final implementation;"
msgstr ""

#: src/ch04-03-standard-account.md:702
msgid "// 2**128\n"
msgstr ""

#: src/ch04-03-standard-account.md:703
msgid "// hash of SNIP-6 trait\n"
msgstr ""

#: src/ch04-03-standard-account.md:822
#, fuzzy
msgid "Account Contract Creation Summary"
msgstr "4: è´¦æˆ·æŠ½è±¡"

#: src/ch04-03-standard-account.md:824
#, fuzzy
msgid "**SNIP-6 Implementation**"
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch04-03-standard-account.md:826
msgid "Implements the `ISRC6` trait, defining the account contract's structure."
msgstr ""

#: src/ch04-03-standard-account.md:828
msgid "**Protocol-Only Function Access**"
msgstr ""

#: src/ch04-03-standard-account.md:830
msgid "Restricts `__validate__` and `__execute__` to StarkNet protocol access."
msgstr ""

#: src/ch04-03-standard-account.md:831
msgid "Makes `is_valid_signature` available for external calls."
msgstr ""

#: src/ch04-03-standard-account.md:832
msgid "Adds a `only_protocol` private function to enforce access rules."
msgstr ""

#: src/ch04-03-standard-account.md:834
msgid "**Signature Validation Process**"
msgstr ""

#: src/ch04-03-standard-account.md:836
msgid "Stores a public key to verify the signer's transactions."
msgstr ""

#: src/ch04-03-standard-account.md:837
msgid "Initializes with a `constructor` to set the public key."
msgstr ""

#: src/ch04-03-standard-account.md:838
msgid "Validates signatures with `is_valid_signature`, returning `VALID` or `0`."
msgstr ""

#: src/ch04-03-standard-account.md:839
msgid "Uses `is_valid_signature_bool` to return a true or false validation result."
msgstr ""

#: src/ch04-03-standard-account.md:841
msgid "**Declare and Deploy Function Validation**"
msgstr ""

#: src/ch04-03-standard-account.md:843
msgid "Sets up `__validate_declare__` to check the `declare` function's signature."
msgstr ""

#: src/ch04-03-standard-account.md:844
msgid "Designs `__validate_deploy__` for counterfactual deployments."
msgstr ""

#: src/ch04-03-standard-account.md:845
msgid "Abstracts core validation to `validate_transaction`."
msgstr ""

#: src/ch04-03-standard-account.md:847
#, fuzzy
msgid "**Transaction Execution Logic**"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-03-standard-account.md:849
msgid "Enables multicall capability with `__execute__`."
msgstr ""

#: src/ch04-03-standard-account.md:850
msgid "Handles calls individually with `execute_single_call` and in batches with `execute_multiple_calls`."
msgstr ""

#: src/ch04-03-standard-account.md:852
#, fuzzy
msgid "**Transaction Version Compatibility**"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-03-standard-account.md:854
msgid "Ensures compatibility with StarkNet updates using a versioning system."
msgstr ""

#: src/ch04-03-standard-account.md:855
msgid "Defines supported transaction types in `SUPPORTED_TX_VERSION`."
msgstr ""

#: src/ch04-03-standard-account.md:856
msgid "Checks transaction versions with `only_supported_tx_version`."
msgstr ""

#: src/ch04-03-standard-account.md:858
#, fuzzy
msgid "**Simulated Transaction Handling**"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-03-standard-account.md:860
msgid "Adapts `only_supported_tx_version` to recognize both actual and simulated versions."
msgstr ""

#: src/ch04-03-standard-account.md:862
#, fuzzy
msgid "**Contract Self-Identification**"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch04-03-standard-account.md:864
msgid "Allows self-identification with the SRC-5 standard via `supports_interface`."
msgstr ""

#: src/ch04-03-standard-account.md:866
msgid "**Public Key Visibility**"
msgstr ""

#: src/ch04-03-standard-account.md:868
msgid "Provides public key access for transparency."
msgstr ""

#: src/ch04-03-standard-account.md:870
#, fuzzy
msgid "**Complete Implementation**"
msgstr "### è´¹ç”¨è®¡ç®—"

#: src/ch04-03-standard-account.md:871
#, fuzzy
msgid "Presents the final account contract code."
msgstr "### å£°æ˜åˆçº¦"

#: src/ch04-03-standard-account.md:873
msgid "Next, we will deploy the account using Starkli to the testnet and interact with other smart contracts."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:1
#, fuzzy
msgid "Deploying Account Contracts"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch04-03-01-deploy-standard-account.md:3
msgid "After building our account contract, we'll now deploy it using Starkli on the testnet and interact with other contracts."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:5
msgid ""
"Ensure you've installed [starkli](https://github.com/xJonathanLEI/starkli) and [scarb](https://docs.swmansion.com/scarb/download.html). Review the Basic Installation subchapter in [Chapter 2](./"
"ch02-01-basic-installation.html#scarb-package-manager-installation) if you haven't."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:7
#, fuzzy
msgid "Account Contract Configuration Files"
msgstr "## åˆçº¦äº¤äº’"

#: src/ch04-03-01-deploy-standard-account.md:9
msgid "Starkli requires two key configuration files:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:11
msgid "`keystore.json`: A secure file that holds the private key."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:12
msgid "`account.json`: An open file with the account's public details like public key, class hash, and address."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:14
msgid "Optionally, Starkli can use:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:16
msgid "`envars.sh`: A script to set environment variables for Starkli commands."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:18
msgid "For multiple wallets, keep a clean directory structure. Each wallet should have its own folder with the three files inside. Group these under a `~/.starkli-wallets` directory."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:20
msgid "Here's a suggested structure:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:36
msgid "This setup promotes better organization."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:38
msgid "We'll make a custom folder in `.starkli-wallets` for our contract wallet:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:44
msgid "Next, we use Starkli to create `keystore.json` and `account.json`, then write `envars.sh` by hand."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:46
msgid "Creating the Keystore File with Starkli"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:48
msgid "Starkli simplifies creating a `keystore.json` file. This encrypted file holds your private key and sits in the `custom` directory. You can create this with one command:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:54
msgid "When you run this, you'll enter a password to secure the file. The resulting `keystore.json` is essential for setting up the `envars.sh` file, which stores environment variables."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:56
msgid "Create `envars.sh` like this:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:62
msgid "Open the file and insert:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:66 src/ch04-03-01-deploy-standard-account.md:164 src/ch04-03-01-deploy-standard-account.md:195 src/ch04-03-01-deploy-standard-account.md:275
#, fuzzy
msgid "~/.starkli-wallets/custom/keystore.json"
msgstr ""
"```bash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:69
msgid "Activate the variable by sourcing the file:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:75
msgid "Now, your environment is ready for the next step: creating the `account.json` file."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:77
#, fuzzy
msgid "Generating the Account Configuration File"
msgstr "## ä¸åˆçº¦äº¤äº’"

#: src/ch04-03-01-deploy-standard-account.md:79
msgid ""
"Our account contract's signature validation mirrors that in [Open Zeppelin's default account contract](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.7.0-rc.0/src/account/account."
"cairo), using a single signer and a STARK-compatible elliptic curve. Despite building our contract independently, we'll use Starkli's command for Open Zeppelin accounts to create our configuration:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:85
msgid ""
"After entering your keystore password, `account.json` is created. This file includes a class hash for OpenZeppelin's contract, not ours. Since the class hash influences the deployment address, the "
"shown address won't match our contract."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:87
#, fuzzy
msgid "Here's what account.json looks like:"
msgstr "ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„æè¿°ç¬¦ï¼š"

#: src/ch04-03-01-deploy-standard-account.md:93 src/ch04-03-01-deploy-standard-account.md:141
msgid "\"open_zeppelin\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:95 src/ch04-03-01-deploy-standard-account.md:143
msgid "\"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:96 src/ch04-03-01-deploy-standard-account.md:144
msgid "\"legacy\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:99 src/ch04-03-01-deploy-standard-account.md:147
msgid "\"undeployed\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:100
msgid "\"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:101 src/ch04-03-01-deploy-standard-account.md:149
msgid "\"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:106
msgid "To deploy our unique contract, we must compile our project to obtain the correct class hash and update `account.json` accordingly."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:108
#, fuzzy
msgid "Finding the Class Hash"
msgstr "## æ’°å†™æµ‹è¯• "

#: src/ch04-03-01-deploy-standard-account.md:110
msgid "Previously, we set up a `aa` directory for our account contract's Cairo code. If you don't have it, clone the repository:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:116
msgid "To compile the contract with Scarb, enter the project directory:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:123
msgid "The compiled contract lies in `target/dev`. Use Starkli to get the class hash:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:129
msgid "Next, edit `account.json` to insert the correct class hash:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:135
msgid "Ensure the `class_hash` is updated:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:148
msgid "\"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\""
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:154
msgid "To point to the updated `account.json`, modify `envars.sh`:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:160
msgid "Add the account path:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:165 src/ch04-03-01-deploy-standard-account.md:196 src/ch04-03-01-deploy-standard-account.md:276
#, fuzzy
msgid "~/.starkli-wallets/custom/account.json"
msgstr ""
"```bash\n"
"code ~/.starkli-wallets/custom/account.json\n"
"```"

#: src/ch04-03-01-deploy-standard-account.md:168
msgid "Source `envars.sh` to apply the changes:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:174
#, fuzzy
msgid "Now, we're ready to declare the contract on the testnet."
msgstr "å½“è®¾ç½®å®Œæˆåï¼Œæ‚¨å°±å¯ä»¥å°†æ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°Starknetæµ‹è¯•ç½‘ç»œäº†ã€‚"

#: src/ch04-03-01-deploy-standard-account.md:176
#, fuzzy
msgid "Establishing an RPC Provider"
msgstr "### é€‰æ‹© RPC æä¾›å•†"

#: src/ch04-03-01-deploy-standard-account.md:178
msgid "For transactions on Starknet, an RPC provider is essential. This guide uses [Infura](https://www.infura.io/) but a personal node is a viable alternative."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:180
msgid "Steps for Infura:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:182
msgid "Create an account."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:183
msgid "Start a new project for Starknet Goerli."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:184
msgid "Obtain the RPC URL."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:185
msgid "Add this URL to `envars.sh`:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:191
#, fuzzy
msgid "The file should now include:"
msgstr "Prover çš„èŒè´£åŒ…æ‹¬"

#: src/ch04-03-01-deploy-standard-account.md:197 src/ch04-03-01-deploy-standard-account.md:277
msgid "https://starknet-goerli.infura.io/v3/your-api-key"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:200
msgid "Replace `your-api-key` with the actual API key provided by Infura."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:202
#, fuzzy
msgid "Declaring the Account Contract"
msgstr "### å£°æ˜åˆçº¦"

#: src/ch04-03-01-deploy-standard-account.md:204
msgid ""
"You'll need a funded account to pay gas fees. Configure Starkli with a [Braavos](https://braavos.app/) or [Argent X](https://www.argent.xyz/argent-x/) wallet as the deployer. Instructions are "
"available [here](https://medium.com/starknet-edu/starkli-the-new-starknet-cli-86ea914a2933)."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:206
#, fuzzy
msgid "After setting up, your Starkli wallet structure will be:"
msgstr "åˆ›å»ºé¡¹ç›®åï¼Œæ‚¨å¯ä»¥å‘ç°å…¶ç»“æ„å¦‚ä¸‹ï¼š"

#: src/ch04-03-01-deploy-standard-account.md:222
msgid "Source the deployer's environment file in the `aa` directory to use it:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:228
msgid "Declare the contract with the deployer covering gas:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:234
msgid "After reaching \"Accepted on L2,\" status (less than a minute) switch back to the account's environment:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:240
msgid "Deploy the account with Starkli:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:246
msgid "Starkli will wait for you to fund the address displayed with at least the estimated fee from Starknet's [faucet](https://faucet.goerli.starknet.io/)."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:248
msgid "Once funded, press **`ENTER`** to deploy:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:255
msgid "Your account contract is now live on the Starknet testnet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:257
#, fuzzy
msgid "Using the Account Contract"
msgstr "### å£°æ˜åˆçº¦"

#: src/ch04-03-01-deploy-standard-account.md:259
msgid "To test our account contract, we can send 100 gwei to the wallet `0x070a...52d1` by calling the `transfer` function of the WETH smart contract on Starknet's testnet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:261
msgid "Invoke the transfer with Starkli (more details on Starkli's in Chapter 2):"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:267
msgid "A successful invoke confirms that our account contract has authenticated the signature, executed the transfer, and managed the gas fees."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:269
msgid "Here's a summary of all the steps from declaration to interaction:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:272
#, fuzzy
msgid "# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
msgstr "# ç¼–è¯‘ã€éƒ¨ç½²å’Œäº¤äº’åˆçº¦"

#: src/ch04-03-01-deploy-standard-account.md:273
#, fuzzy
msgid "# [1] Set up environment variables in envars.sh\n"
msgstr "## è®¾ç½®ç¯å¢ƒå˜é‡"

#: src/ch04-03-01-deploy-standard-account.md:278
msgid "# [2] Generate keystore.json\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:281
msgid "# [3] Initialize account.json\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:284
msgid "# [4] Build the contract with Scarb\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:287
#, fuzzy
msgid "# [5] Get the class hash\n"
msgstr "## æ’°å†™æµ‹è¯• "

#: src/ch04-03-01-deploy-standard-account.md:290
msgid "# [6] Update account.json with the real class hash\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:293
msgid "# [7] Set deployer wallet environment\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:296
msgid "# [8] Declare the contract using the deployer\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:299
msgid "# [9] Switch to the custom wallet\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:302
#, fuzzy
msgid "# [10] Deploy the contract\n"
msgstr "### éƒ¨ç½²åˆçº¦"

#: src/ch04-03-01-deploy-standard-account.md:305
msgid "# [11] Test the contract by transferring ETH\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:308
msgid "# [bonus] Recommended directory structure\n"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:316
#, fuzzy
msgid "Summary"
msgstr "## æ€»ç»“"

#: src/ch04-03-01-deploy-standard-account.md:318
msgid "We've successfully deployed and used our custom account contract on Starknet with Starkli. Here's what we accomplished:"
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:320
#, fuzzy
msgid "Set environment variables in `envars.sh`."
msgstr "## è®¾ç½®ç¯å¢ƒå˜é‡"

#: src/ch04-03-01-deploy-standard-account.md:321
msgid "Created `keystore.json` to securely store the private key."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:322
msgid "Initialized `account.json` as the account descriptor file."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:323
msgid "Used Braavos smart wallet to set up the deployer environment."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:324
#, fuzzy
msgid "Declared and deployed our account contract to the Starknet testnet."
msgstr "å½“è®¾ç½®å®Œæˆåï¼Œæ‚¨å°±å¯ä»¥å°†æ™ºèƒ½åˆçº¦éƒ¨ç½²åˆ°Starknetæµ‹è¯•ç½‘ç»œäº†ã€‚"

#: src/ch04-03-01-deploy-standard-account.md:325
msgid "Conducted a transfer to another wallet."
msgstr ""

#: src/ch04-03-01-deploy-standard-account.md:327
msgid ""
"We matched the Open Zeppelin's contract in terms of signature methods for the `constructor` and `__declare_deploy__` functions, which allowed us to use Starkli's Open Zeppelin preset. Should there be "
"a need for signature modification, Starknet JS SDK would be the tool of choice."
msgstr ""

#: src/ch04-05-examples.md:3
msgid "Here, we will explore numerous examples, elucidating the principles and techniques to effectively design and implement Account contracts."
msgstr ""

#: src/ch04-05-examples.md:6
msgid ""
"Before delving into the examples, we would like to issue a disclaimer: the contracts discussed in this chapter are for illustrative and educational purposes, and they have not undergone formal "
"auditing. This signifies that, while we strive to provide accurate and informative content, the implementation of these contracts in a live environment should be approached with due diligence. We "
"encourage users to thoroughly test and validate these contracts before their deployment on the mainnet."
msgstr ""

#: src/ch04-05-examples.md:15
msgid ""
"The goal of this chapter is not only to furnish a library of contract examples but also to foster collaboration and knowledge sharing among the Starknet community. We believe that the exchange of "
"ideas and constructive feedback is instrumental in advancing our collective understanding and expertise."
msgstr ""

#: src/ch04-05-examples.md:21
msgid ""
"If youâ€™ve developed or come across an innovative contract that could serve as a valuable learning resource for others, we invite you to contribute. Here are a few guidelines for your contribution:"
msgstr ""

#: src/ch04-05-examples.md:25
msgid ""
"**Open a PR:** To submit a contract example or suggest changes to existing ones, simply open a Pull Request. Ensure that your PR contains a thorough explanation of the contract, its use cases, and its "
"functionality."
msgstr ""

#: src/ch04-05-examples.md:30
msgid ""
"**Code Standards:** Please ensure that the submitted code is well-documented and adheres to the standard code conventions of Starknet. This will facilitate the review process and enhance the "
"readability and comprehensibility of the contract."
msgstr ""

#: src/ch04-05-examples.md:35
msgid ""
"**Detailed Explanation:** Accompany your code with a detailed explanation of the contract logic. Wherever possible, use diagrams, flowcharts, or pseudocode to illustrate complex mechanisms or "
"workflows."
msgstr ""

#: src/ch04-05-examples.md:40
msgid ""
"As we expand this repertoire of contract examples, we hope to equip the Starknet community with a robust toolset and inspire further exploration and innovation in the realm of custom account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:1
#, fuzzy
msgid "MultiCaller Account"
msgstr "Multicaller ğŸš§"

#: src/ch04-05-01-multicaller.md:3
msgid ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme) is a powerful technique that allows multiple constant smart contract function calls to be aggregated into a single call, "
"resulting in a consolidated output. With Starknetâ€™s account abstraction feature, multicalls can be seamlessly integrated into account contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:9
msgid "Why Multicalls?"
msgstr ""

#: src/ch04-05-01-multicaller.md:11
msgid "Multicalls come handy in several scenarios. Here are some examples:"
msgstr ""

#: src/ch04-05-01-multicaller.md:13
msgid ""
"**Token Swapping on Decentralized Exchanges**: In a typical token swap operation on a decentralized exchange (DEX), you first need to approve the spending of the tokens and then initiate the swap. "
"Executing these operations separately could be cumbersome from a user experience perspective. With multicall, these calls can be combined into a single transaction, simplifying the userâ€™s task."
msgstr ""

#: src/ch04-05-01-multicaller.md:20
msgid ""
"**Fetching Blockchain Data**: When you want to query the prices of two different tokens from the blockchain, itâ€™s beneficial to have them both come from the same block for consistency. Multicall "
"returns the latest block number along with the aggregated results, providing this consistency."
msgstr ""

#: src/ch04-05-01-multicaller.md:26
msgid "The benefits of multicall transactions can be realized more in the context of account abstraction."
msgstr ""

#: src/ch04-05-01-multicaller.md:29
#, fuzzy
msgid "Multicall Account Abstraction Creation."
msgstr "4: è´¦æˆ·æŠ½è±¡"

#: src/ch04-05-01-multicaller.md:31
msgid "[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme)"
msgstr ""

#: src/ch04-05-01-multicaller.md:33 src/ch04-05-01-multicaller.md:324
msgid "This is because multicall is a feature of Account Abstraction that lets you bundle multiple user operations into a single transaction for a smoother UX."
msgstr ""

#: src/ch04-05-01-multicaller.md:35 src/ch04-05-01-multicaller.md:326
msgid "The Call data type is a struct that has all the data you need to execute a single user operation."
msgstr ""

#: src/ch04-05-01-multicaller.md:37
msgid "There are different traits that a smart contract must implement to be considered an account contract. Let's create account abstraction from the scratch following the SNIP-6 and SRC-5 standards."
msgstr ""

#: src/ch04-05-01-multicaller.md:39
msgid "Project Setup."
msgstr ""

#: src/ch04-05-01-multicaller.md:41
msgid ""
"In order to be able to compile an account contract to Sierra, a prerequisite to deploy it to testnet or mainnet, youâ€™ll need to make sure to have a version of Scarb that includes a Cairo compiler that "
"targets Sierra 1.3 as itâ€™s the latest version supported by Starknetâ€™s testnet. At this point in time Scarb 0.7 is used."
msgstr ""

#: src/ch04-05-01-multicaller.md:43
msgid ""
"```\n"
"~ $ scarb --version\n"
">>>\n"
"scarb 0.7.0 (58cc88efb 2023-08-23)\n"
"cairo: 2.2.0 (https://crates.io/crates/cairo-lang-compiler/2.2.0)\n"
"sierra: 1.3.0\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:51
msgid "Create a new project with Scarb using the new command."
msgstr ""

#: src/ch04-05-01-multicaller.md:57 src/ch04-05-02-multisig.md:60
msgid "The command creates a folder with the same name that includes a configuration file for Scarb."
msgstr ""

#: src/ch04-05-01-multicaller.md:69
msgid "Scarb configures the project for vanilla Cairo instead of Starknet smart contracts by default."
msgstr ""

#: src/ch04-05-01-multicaller.md:71
msgid ""
"```dotnetcli\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""

#: src/ch04-05-01-multicaller.md:82
msgid "There is a need to make some changes to the configuration file to activate the Starknet plugin in the compiler so we can work with smart contracts."
msgstr ""

#: src/ch04-05-01-multicaller.md:84
#, fuzzy
msgid ""
"```dotnetcli\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \"2.2.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```bash\n"
"[package]\n"
"name = \"aa\"\n"
"version = \"0.1.0\"\n"
"cairo-version = \"2.3.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.3.0\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"```"

#: src/ch04-05-01-multicaller.md:97
msgid "Let's now replace the content of the sample Cairo code that comes with a new project with the scaffold of our account contract."
msgstr ""

#: src/ch04-05-01-multicaller.md:104
msgid "Given that one of the most important features of our account contract is to validate signatures, there is a need to store the public key associated with the private key of the signer."
msgstr ""

#: src/ch04-05-01-multicaller.md:117 src/ch04-05-02-multisig.md:131
msgid "To make sure everything is wired up correctly, letâ€™s compile our project."
msgstr ""

#: src/ch04-05-01-multicaller.md:126
msgid "Welldone, It works, time to move to the interesting part of our tutorial."
msgstr ""

#: src/ch04-05-01-multicaller.md:128 src/ch04-05-02-multisig.md:144 src/ch04-05-03-auto-payments.md:85
msgid "SNIP-6"
msgstr ""

#: src/ch04-05-01-multicaller.md:130
msgid "Remember that for a smart contract to be considered an account contract, it must implement the trait defined by SNIP-6."
msgstr ""

#: src/ch04-05-01-multicaller.md:140
msgid ""
"There is a need to eventually annotate the implementation of this trait with the `external` attribute, the contract state will be the first argument provided to each method. We can define the type of "
"the contract state with the generic `T`."
msgstr ""

#: src/ch04-05-01-multicaller.md:150
msgid ""
"The **execute** function is the only one that receives a reference to the contract state because itâ€™s the only one likely to either modify its internal state or to modify the state of another smart "
"contract and thus to require the payment of gas fees for its execution. The other two functions, **validate** and **is_valid_signature**, are read-only and shouldnâ€™t require the payment of gas fees. "
"For this reason they are both receiving a snapshot of the contract state instead."
msgstr ""

#: src/ch04-05-01-multicaller.md:152
msgid ""
"The question now becomes, how should we use this trait in our account contract. Should we annotate the trait with the **interface** attribute and then create an implementation like the code shown "
"below?"
msgstr ""

#: src/ch04-05-01-multicaller.md:170
msgid "Or should we use it instead `without` the interface attribute?"
msgstr ""

#: src/ch04-05-01-multicaller.md:187
msgid "What happens without defining the trait explicitly?"
msgstr ""

#: src/ch04-05-01-multicaller.md:199
msgid "From a technical view, both are all valid alternatives but they all fail to capture the right intention."
msgstr ""

#: src/ch04-05-01-multicaller.md:201
msgid ""
"Every function inside an implementation annotated with the external attribute will have its own selector that other people and smart contracts can use to interact with my account contract. But the "
"thing is, even though they can use the derived selectors to call those functions, but one will be recommended for users to use and for the Starknet protocol."
msgstr ""

#: src/ch04-05-01-multicaller.md:203
msgid ""
"The functions **execute** and **validate** are meant to be used only by the Starknet protocol even if the functions are publicly accessible via its selectors. The only function that is made public for "
"web3 apps to use for signature validation is **is_valid_signature**."
msgstr ""

#: src/ch04-05-01-multicaller.md:205
msgid ""
"Furthermore, a separate trait annotated with the interface attribute will be created and group all the functions in an account contract that users are expected to interact with. On the other hand, the "
"trait will be auto generated, for all those functions that users are not expected to use directly even though they are public."
msgstr ""

#: src/ch04-05-01-multicaller.md:238 src/ch04-05-02-multisig.md:711
msgid "Protecting Protocol-Only Functions"
msgstr ""

#: src/ch04-05-01-multicaller.md:240
msgid ""
"Although there might be legitimate use cases for other smart contracts to directly interact with the functions **execute** and **validate** of an account contract, these will rather be restricted to "
"be callable only by the Starknet protocol in case thereâ€™s an attack vector that has not been foresee."
msgstr ""

#: src/ch04-05-01-multicaller.md:242
msgid "To create private functions, this simply create a new implementation that is not annotated with the external attribute so no public selectors are created."
msgstr ""

#: src/ch04-05-01-multicaller.md:261
msgid "Validate Declare and Deploy"
msgstr ""

#: src/ch04-05-01-multicaller.md:263
msgid ""
"**validate_declare** is used to validate the signature of a declare transaction while **validate_deploy** is used for the same purpose but for the deploy_account transaction. The latter is often "
"referred to as â€œcounterfactual deploymentâ€."
msgstr ""

#: src/ch04-05-01-multicaller.md:307
#, fuzzy
msgid "Execute Transactions"
msgstr "äº¤æ˜“"

#: src/ch04-05-01-multicaller.md:309
msgid "Looking at the signature of the **execute** function it is noticed that an array of calls are being passed instead of a single element."
msgstr ""

#: src/ch04-05-01-multicaller.md:337
msgid "Instead of trying to face the multicall head on, letâ€™s first create a private function that deals with a single call that we can then reuse by iterating over the array of calls."
msgstr ""

#: src/ch04-05-01-multicaller.md:356
msgid "Destructure the `Call` struct and then we use the low level syscall `call_contract_syscall` to invoke a function on another smart contract without the help of a dispatcher."
msgstr ""

#: src/ch04-05-01-multicaller.md:358
msgid "However, with the single `call` function, multi call function can be built by iterating over a `Call` array and returning the responses as an array as well."
msgstr ""

#: src/ch04-05-01-multicaller.md:387
msgid "Finally, let's go back to the **execute** function and make use of the functions that was just created."
msgstr ""

#: src/ch04-05-01-multicaller.md:407
#, fuzzy
msgid "Supported Transaction Versions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-05-01-multicaller.md:409
msgid ""
"As Starknet evolved, changes have been required to the structure of the transactions to accommodate more advanced functionality. To avoid creating breaking changes whenever a transaction structure "
"needs to be updated, a â€œversionâ€ field was added to all transactions so older and newer transactions can co-exist."
msgstr ""

#: src/ch04-05-01-multicaller.md:411
msgid ""
"Maintaining different transaction versions is complex and because this is just a tutorial, Iâ€™ll restrict my account contract to only support the newest version of each type of transaction and those "
"are:"
msgstr ""

#: src/ch04-05-01-multicaller.md:413
#, fuzzy
msgid "Version 1 for invoke transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-05-01-multicaller.md:414
#, fuzzy
msgid "Version 1 for deploy_account transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-05-01-multicaller.md:415
#, fuzzy
msgid "Version 2 for declare transactions"
msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#: src/ch04-05-01-multicaller.md:417
msgid "The supported transaction versions will be discussed below in a module for logical grouping."
msgstr ""

#: src/ch04-05-01-multicaller.md:432
msgid ""
"Now create a private function that will check if the executed transaction is of the latest version and hence supported by your account contract. If not, you should abort the transaction execution with "
"an **assert**."
msgstr ""

#: src/ch04-05-01-multicaller.md:488
#, fuzzy
msgid "Simulated Transactions"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-05-01-multicaller.md:490
msgid ""
"Itâ€™s possible to request the Sequencer to estimate the amount of gas required to execute a transaction without actually executing it. Starkli for example provides the flag estimate-only that you can "
"append to any transaction to instruct the Sequencer to only simulate the transaction and return the estimated cost."
msgstr ""

#: src/ch04-05-01-multicaller.md:492
msgid ""
"To differentiate a regular transaction from a transaction simulation while protecting against replay attacks, the version of a transaction simulation is the same value as the normal transaction but "
"offset by the value 2^128. For example, the version of a simulated declare transaction is 2^128 + 2 because the latest version of a regular declare transaction is 2."
msgstr ""

#: src/ch04-05-01-multicaller.md:494
msgid "With that in mind, we can modify the function only_supported_tx_version to account for simulated transactions."
msgstr ""

#: src/ch04-05-01-multicaller.md:496
#, fuzzy
msgid ""
"```dotnetcli\n"
"...\n"
"\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  ...\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
"\n"
"  ...\n"
"\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    ...\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox();\n"
"      let version = tx_info.version;\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version'\n"
"      );\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"```"
msgstr ""
"```rust\n"
"#[starknet::contract]\n"
"mod Account {\n"
"  // Constant representing the version offset for simulated transactions\n"
"  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // This is 2^128\n"
"\n"
"  // Private trait implementation updated to validate transaction versions\n"
"  #[generate_trait]\n"
"  impl PrivateImpl of PrivateTrait {\n"
"    // Function to check for supported transaction versions, accounting for simulations\n"
"    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
"      let tx_info = get_tx_info().unbox(); // Retrieves the transaction metadata\n"
"      let version = tx_info.version; // Extracts the version for comparison\n"
"\n"
"      // Validates whether the transaction version matches either the supported actual version or the simulated version\n"
"      assert(\n"
"        version == supported_tx_version ||\n"
"        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
"        'Account: Unsupported tx version' // Assertion message for version mismatch\n"
"      );\n"
"    }\n"
"    // Additional private functions may follow\n"
"  }\n"
"  // Remaining contract code may continue here\n"
"}\n"
"```"

#: src/ch04-05-01-multicaller.md:523
#, fuzzy
msgid "Introspection"
msgstr "ä»‹ç»"

#: src/ch04-05-01-multicaller.md:525
msgid "Previously mentioned the standard SRC-5 is for introspection."
msgstr ""

#: src/ch04-05-01-multicaller.md:534
msgid ""
"For an account contract to self identify as such, it must return true when passed the interface_id 1270010605630597976495846281167968799381097569185364931397797212080166453709. The reason why that "
"particular number is used is explained in the previous article so go check it out for more details."
msgstr ""

#: src/ch04-05-01-multicaller.md:536
msgid "Because this is a public function that I do expect people and other smart contracts to call on my account contract, will add this function to its public interface."
msgstr ""

#: src/ch04-05-01-multicaller.md:565
msgid "Exposing the Public Key"
msgstr ""

#: src/ch04-05-01-multicaller.md:567
msgid ""
"Although not required, it is a good idea to expose the public key associated with the account contractâ€™s signer. One use case is to easily and safely debug the correct deployment of the account "
"contract by reading the stored public key and comparing it (offline) to the public key of my signer."
msgstr ""

#: src/ch04-05-01-multicaller.md:587
msgid "Finally, we have a fully functional account contract."
msgstr ""

#: src/ch04-05-01-multicaller.md:591
msgid ""
"The account contract created now might look complex but itâ€™s actually one of the simplests that can be created. The account contracts created by Braavos and Argent X are much more complex as they "
"support features like social recovery, multisig, hardware signer, email/password signer, etc."
msgstr ""

#: src/ch04-05-01-multicaller.md:593
msgid ""
"Both Braavos and Argent have open sourced their Cairo 0 version of their account contracts but Argent is the first one to also open source their Cairo version. OpenZeppelin (OZ) is also developing "
"their own implementation of a Cairo account contract but itâ€™s still a work in progress. This inspiration was deduced from OZâ€™s implementation when creating this tutorial."
msgstr ""

#: src/ch04-05-01-multicaller.md:595
msgid ""
"SNIP-6 is referenced multiple times as a standard to follow for an account contract but so far itâ€™s only a proposal under discussion that could change. This will not only affect the interface of your "
"account contract but also the ID used for introspection."
msgstr ""

#: src/ch04-05-01-multicaller.md:599
msgid ""
"While multicall provides significant benefits in terms of UX and data consistency, itâ€™s important to note that it may not significantly reduce gas fees compared to individual calls. However, the "
"primary advantage of using multicall is that it ensures results are derived from the same block, providing a much-improved user experience."
msgstr ""

#: src/ch04-05-01-multicaller.md:615
#, fuzzy
msgid "Reference"
msgstr "## å‚è€ƒæ–‡çŒ®"

#: src/ch04-05-01-multicaller.md:617
msgid "\\[1\\] OpenZeppelin, 2023: <https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.7.0-rc.0/src/account/account.cairo>"
msgstr ""

#: src/ch04-05-01-multicaller.md:618
msgid "\\[2\\] David Barreto, 2023: <https://medium.com/starknet-edu/account-abstraction-on-starknet-part-ii-24d52874e0bd>"
msgstr ""

#: src/ch04-05-02-multisig.md:1
msgid "Multisignature (multisig) Account."
msgstr ""

#: src/ch04-05-02-multisig.md:3
msgid ""
"Multisig, refers to a system where multiple signatures are required to authorize a transaction. This is commonly used in the context of cryptocurrency wallets, where funds can only be spent if a "
"certain number of private keys agree to the transaction."
msgstr ""

#: src/ch04-05-02-multisig.md:5
msgid ""
"Multisignature (multisig) technology is an integral part of the modern blockchain landscape. It enhances security by requiring multiple signatures to confirm a transaction, hence reducing the risk of "
"fraudulent transactions and increasing control over asset management."
msgstr ""

#: src/ch04-05-02-multisig.md:10
msgid ""
"In Starknet, the concept of multisig accounts is abstracted at the protocol level, allowing developers to implement custom account contracts that embody this concept. In this chapter, weâ€™ll delve into "
"the workings of a multisig account and see how itâ€™s created in Starknet using an account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:16
#, fuzzy
msgid "Why Multisig."
msgstr "å¤šç­¾ ğŸš§"

#: src/ch04-05-02-multisig.md:18
msgid "There are several reasons why someone might choose to use a multisig wallet:"
msgstr ""

#: src/ch04-05-02-multisig.md:20
msgid "Enhanced security:"
msgstr ""

#: src/ch04-05-02-multisig.md:22
msgid ""
"Multisig contract account are much more secure than traditional single-signature contract accounts. With a single-signature contract account, if your private key is lost or stolen, your funds are "
"gone. With a multisig contract account, even if one private key is compromised, the funds are still safe. This is because at least two (or more) private keys are required to authorize a transaction."
msgstr ""

#: src/ch04-05-02-multisig.md:24
msgid "Disaster recovery:"
msgstr ""

#: src/ch04-05-02-multisig.md:26
msgid ""
"Multisig contract account can be used to protect against the loss of a private key. If one private key is lost, the other keys can still be used to recover the funds. This can be helpful in the event "
"of a natural disaster, hardware failure, or other unforeseen event."
msgstr ""

#: src/ch04-05-02-multisig.md:28
msgid "Transparency and accountability:"
msgstr ""

#: src/ch04-05-02-multisig.md:30
msgid ""
"Multisig contract account can be used to increase transparency and accountability in organizations. For example, a company might use a multisig wallet to store its funds, and require the signatures of "
"two or more executives to authorize any spending. This can help to prevent fraud and ensure that everyone is aware of how the company's money is being spent."
msgstr ""

#: src/ch04-05-02-multisig.md:32
msgid "The benefits of Multisig contract account can be realized more in the context of account abstraction."
msgstr ""

#: src/ch04-05-02-multisig.md:34
#, fuzzy
msgid "Multisig Account Abstraction Creation."
msgstr "4: è´¦æˆ·æŠ½è±¡"

#: src/ch04-05-02-multisig.md:36
msgid ""
"Account abstraction enables built-in multisig functionality within accounts. Each account can be programmed to demand multiple signatures before transaction execution. This eliminates the need for "
"separate multisig smart contracts, simplifying their use."
msgstr ""

#: src/ch04-05-02-multisig.md:40
msgid ""
"A multisig account must have different traits that a smart contract must implement to be considered an account contract. In this book we will create an account contract from scratch following the "
"SNIP-6 and SRC-5 standards."
msgstr ""

#: src/ch04-05-02-multisig.md:42
msgid "Project Setup"
msgstr ""

#: src/ch04-05-02-multisig.md:44
msgid ""
"In order to be able to compile an account contract to Sierra, a prerequisite to deploy it to testnet or mainnet, youâ€™ll need to make sure to have a version of [Scarb](https://docs.swmansion.com/scarb/"
"download.html) that includes a Cairo compiler that targets Sierra 1.3 as itâ€™s the latest version supported by Starknetâ€™s testnet. At this point in time is Scarb 2.4.4 is used."
msgstr ""

#: src/ch04-05-02-multisig.md:46
msgid ""
"```cairo\n"
"mac@Macs-MacBook-Pro-2 Desktop % scarb --version\n"
"scarb 2.4.4 (0c8def3aa 2023-10-31)\n"
"cairo: 2.4.4 (https://crates.io/crates/cairo-lang-compiler/2.4.4)\n"
"sierra: 1.3.0\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:54
msgid "With Scarb we can create a new project using the new command."
msgstr ""

#: src/ch04-05-02-multisig.md:72
msgid "By default, Scarb configures our project for vanilla Cairo instead of Starknet smart contracts."
msgstr ""

#: src/ch04-05-02-multisig.md:74
msgid ""
"```cairo\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \"multisign\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:86
msgid "We need to make some changes to the configuration file to activate the Starknet plugin in the compiler so we can work with smart contracts."
msgstr ""

#: src/ch04-05-02-multisig.md:88
#, fuzzy
msgid ""
"```cairo\n"
"# Scarb.toml\n"
"\n"
"[package]\n"
"name = \" multisign \"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"\n"
"starknet = \">=2.4.4\"\n"
"\n"
"[[target.starknet-contract]]\n"
"sierra = true\n"
"casm = true\n"
"\n"
"\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin/cairo-contracts.git\", tag = \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch04-05-02-multisig.md:108
msgid "We can now replace the content of the sample Cairo code that comes with a new project with the scaffold of our account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:117
msgid "Given that one of the most important features of our account contract is to validate signatures, we need to store the public key associated with the private key of the signer."
msgstr ""

#: src/ch04-05-02-multisig.md:142
msgid "It works, time to move to the interesting part of our tutorial."
msgstr ""

#: src/ch04-05-02-multisig.md:146
msgid "Recall that for a smart contract to be considered an account contract, it must implement the trait defined by SNIP-6."
msgstr ""

#: src/ch04-05-02-multisig.md:157
msgid ""
"Because we will eventually annotate the implementation of this trait with the external attribute, the contract state will be the first argument provided to each method. We can define the type of the "
"contract state with the generic T."
msgstr ""

#: src/ch04-05-02-multisig.md:169
msgid ""
"The **execute** function is the only one that receives a reference to the contract state because itâ€™s the only one likely to either modify its internal state or to modify the state of another smart "
"contract and thus to require the payment of gas fees for its execution. The other two functions, **validate** and is_valid_signature, are read-only and shouldnâ€™t require the payment of gas fees. For "
"this reason they are both receiving a snapshot of the contract state instead."
msgstr ""

#: src/ch04-05-02-multisig.md:171
msgid "Let's now define the trait for our multisig account explicitly."
msgstr ""

#: src/ch04-05-02-multisig.md:186
msgid "Each function inside an implementation annotated with the external attribute will have its own selector that other people and smart contracts can use to interact with my account contract."
msgstr ""

#: src/ch04-05-02-multisig.md:188
msgid ""
"The functions **execute** and **validate** are meant to be used only by the Starknet protocol even if the functions are publicly accessible via its selectors. The only function that I want to make "
"public for web3 apps to use for signature validation is is_valid_signature."
msgstr ""

#: src/ch04-05-02-multisig.md:190
msgid ""
"In addition, we will create a separate trait annotated with the interface attribute that will group all the functions in the account contract that is expected to interact with. On the other hand, we "
"will auto generate the trait for all those functions that users will not see to use directly even though they are public."
msgstr ""

#: src/ch04-05-02-multisig.md:192
msgid ""
"```cairo\n"
"use starknet::account;\n"
"\n"
"// @title SRC-6 Standard Account\n"
"#[starknet::interface]\n"
"trait ISRC6<T> {\n"
"\t// @notice Execute a transaction through the account\n"
"\t// @param calls The list of calls to execute\n"
"\t// @return The list of each call's serialized return value\n"
"\tfn __execute__(\n"
"\t\tref self: T,\n"
"\t\tcalls: Array<account::Call>\n"
"\t) -> Array<Span<felt252>>;\n"
"\n"
"\t// @notice Assert whether the transaction is valid to be executed\n"
"\t// @param calls The list of calls to execute\n"
"\t// @return The string 'VALID' represented as a felt when is valid\n"
"\tfn __validate__(self: @T, calls: Array<account::Call>) -> felt252;\n"
"\n"
"\t// @notice Assert whether a given signature for a given hash is valid\n"
"\t// @dev signatures must be deserialized\n"
"\t// @param hash The hash of the data\n"
"\t// @param signature The signature to be validated\n"
"\t// @return The string 'VALID' represented as a felt when is valid\n"
"\tfn is_valid_signature(\n"
"\t\tself: @T,\n"
"\t\thash: felt252,\n"
"\t\tsignature: Array<felt252>\n"
"\t) -> felt252;\n"
"}\n"
"\n"
"// @title SRC-5 Iterface detection\n"
"#[starknet::interface]\n"
"trait ISRC5<T> {\n"
"\t// @notice Query if a contract implements an interface\n"
"\t// @param interface_id The interface identifier, as specified in SRC-5\n"
"\t// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"\tfn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"// @title Multisign Account\n"
"#[starknet::contract]\n"
"mod Multisign {\n"
"\tuse super::ISRC6;\n"
"\tuse super::ISRC5;\n"
"\tuse starknet::account;\n"
"\n"
"\tconst SRC6_INTERFACE_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\tconst MAX_SIGNERS_COUNT: usize = 32;\n"
"\n"
"\t#[storage]\n"
"\tstruct Storage {\n"
"\t\tsigners: LegacyMap<felt252, felt252>,\n"
"\t\tthreshold: usize,\n"
"\t\toutside_nonce: LegacyMap<felt252, felt252>\n"
"\t}\n"
"\n"
"\t// @notice Contructor of the account\n"
"\t// @dev Asserts threshold in relation with signers-len\n"
"\t// @param threshold Initial threshold\n"
"\t// @param signers Array of inital signers' public-keys\n"
"\t#[constructor]\n"
"\tfn constructor(\n"
"\t\tref self: ContractState,\n"
"\t\tthreshold: usize,\n"
"\t\tsigners: Array<felt252>) {\n"
"\t\tassert_threshold(threshold, signers.len());\n"
"\n"
"\t\tself.add_signers(signers.span(), 0);\n"
"\t\tself.threshold.write(threshold);\n"
"\t}\n"
"\n"
"\t#[external(v0)]\n"
"\timpl SRC6 of ISRC6<ContractState> {\n"
"\t\tfn __execute__(\n"
"\t\t\tref self: ContractState,\n"
"\t\t\tcalls: Array<account::Call>\n"
"\t\t) -> Array<Span<felt252>> {\n"
"\t\t\tassert_only_protocol();\n"
"\t\t\texecute_multi_call(calls.span())\n"
"\t\t}\n"
"\n"
"\t\tfn __validate__(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tcalls: Array<account::Call>\n"
"\t\t) -> felt252 {\n"
"\t\t\tassert_only_protocol();\n"
"\t\t\tassert(calls.len() > 0, 'validate/no-calls');\n"
"\t\t\tself.assert_valid_calls(calls.span());\n"
"\t\t\tstarknet::VALIDATED\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Array<felt252>\n"
"\t\t) -> felt252 {\n"
"\t\t\tif self.is_valid_signature_span(hash, signature.span()) {\n"
"\t\t\t\tstarknet::VALIDATED\n"
"\t\t\t} else {\n"
"\t\t\t\t0\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t#[external(v0)]\n"
"\timpl SRC5 of ISRC5<ContractState> {\n"
"\t\tfn supports_interface(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tinterface_id: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tinterface_id == SRC6_INTERFACE_ID\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t#[generate_trait]\n"
"\timpl Private of PrivateTrait {\n"
"\t\tfn add_signers(\n"
"\t\t\tref self: ContractState,\n"
"\t\t\tmut signers: Span<felt252>,\n"
"\t\t\tlast: felt252\n"
"\t\t) {\n"
"\t\t\tmatch signers.pop_front() {\n"
"\t\t\t\tOption::Some(signer_ref) => {\n"
"\t\t\t\t\tlet signer = *signer_ref;\n"
"\t\t\t\t\tassert(signer != 0, 'signer/zero-signer');\n"
"\t\t\t\t\tassert(!self.is_signer_using_last(signer, last),\n"
"\t\t\t\t\t\t'signer/is-already-signer');\n"
"\t\t\t\t\tself.signers.write(last, signer);\n"
"\t\t\t\t\tself.add_signers(signers, signer);\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => ()\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn is_signer_using_last(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tlast: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tlast == signer\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signature_span(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsignature: Span<felt252>\n"
"\t\t) -> bool {\n"
"\t\t\tlet threshold = self.threshold.read();\n"
"\t\t\tassert(threshold != 0, 'Uninitialized');\n"
"\t\t\tlet mut signatures = deserialize_signatures(signature)\n"
"\t\t\t\t.expect('signature/invalid-len');\n"
"\t\t\tassert(threshold == signatures.len(), 'signature/invalid-len');\n"
"\t\t\tlet mut last: u256 = 0;\n"
"\t\t\tloop {\n"
"\t\t\t\tmatch signatures.pop_front() {\n"
"\t\t\t\t\tOption::Some(signature_ref) => {\n"
"\t\t\t\t\t\tlet signature = *signature_ref;\n"
"\t\t\t\t\t\tlet signer_uint = signature.signer.into();\n"
"\t\t\t\t\t\tassert(signer_uint > last, 'signature/not-sorted');\n"
"\t\t\t\t\t\tif !self.is_valid_signer_signature(\n"
"\t\t\t\t\t\t\t\thash,\n"
"\t\t\t\t\t\t\t\tsignature.signer,\n"
"\t\t\t\t\t\t\t\tsignature.signature_r,\n"
"\t\t\t\t\t\t\t\tsignature.signature_s,\n"
"\t\t\t\t\t\t\t) {\n"
"\t\t\t\t\t\t\tbreak false;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tlast = signer_uint;\n"
"\t\t\t\t\t},\n"
"\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\tbreak true;\n"
"\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn is_valid_signer_signature(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\thash: felt252,\n"
"\t\t\tsigner: felt252,\n"
"\t\t\tsignature_r: felt252,\n"
"\t\t\tsignature_s: felt252\n"
"\t\t) -> bool {\n"
"\t\t\tassert(self.is_signer(signer), 'signer/not-a-signer');\n"
"\t\t\tecdsa::check_ecdsa_signature(hash, signer, signature_r, signature_s)\n"
"\t\t}\n"
"\n"
"\t\tfn is_signer(self: @ContractState, signer: felt252) -> bool {\n"
"\t\t\tif signer == 0 {\n"
"\t\t\t\treturn false;\n"
"\t\t\t}\n"
"\t\t\tlet next = self.signers.read(signer);\n"
"\t\t\tif next != 0 {\n"
"\t\t\t\treturn true;\n"
"\t\t\t}\n"
"\t\t\tself.get_last() == signer\n"
"\t\t}\n"
"\n"
"\t\tfn get_last(self: @ContractState) -> felt252 {\n"
"\t\t\tlet mut curr = self.signers.read(0);\n"
"\t\t\tloop {\n"
"\t\t\t\tlet next = self.signers.read(curr);\n"
"\t\t\t\tif next == 0 {\n"
"\t\t\t\t\tbreak curr;\n"
"\t\t\t\t}\n"
"\t\t\t\tcurr = next;\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tfn assert_valid_calls(\n"
"\t\t\tself: @ContractState,\n"
"\t\t\tcalls: Span<account::Call>\n"
"\t\t) {\n"
"\t\t\tassert_no_self_call(calls);\n"
"\n"
"\t\t\tlet tx_info = starknet::get_tx_info().unbox();\n"
"\t\t\tassert(\n"
"\t\t\t\tself.is_valid_signature_span(\n"
"\t\t\t\t\ttx_info.transaction_hash,\n"
"\t\t\t\t\ttx_info.signature\n"
"\t\t\t\t),\n"
"\t\t\t\t'call/invalid-signature'\n"
"\t\t\t)\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn assert_threshold(threshold: usize, signers_len: usize) {\n"
"\t\tassert(threshold != 0, 'threshold/is-zero');\n"
"\t\tassert(signers_len != 0, 'signers_len/is-zero');\n"
"\t\tassert(signers_len <= MAX_SIGNERS_COUNT,\n"
"\t\t\t\t'signers_len/too-high');\n"
"\t\tassert(threshold <= signers_len, 'threshold/too-high');\n"
"\t}\n"
"\n"
"\t#[derive(Copy, Drop, Serde)]\n"
"\tstruct SignerSignature {\n"
"\t\tsigner: felt252,\n"
"\t\tsignature_r: felt252,\n"
"\t\tsignature_s: felt252\n"
"\t}\n"
"\n"
"\tfn deserialize_signatures(\n"
"\t\tmut serialized: Span<felt252>\n"
"\t) -> Option<Span<SignerSignature>> {\n"
"\t\tlet mut signatures = ArrayTrait::new();\n"
"\t\tloop {\n"
"\t\t\tif serialized.len() == 0 {\n"
"\t\t\t\tbreak Option::Some(signatures.span());\n"
"\t\t\t}\n"
"\t\t\tmatch Serde::deserialize(ref serialized) {\n"
"\t\t\t\tOption::Some(s) => { signatures.append(s) },\n"
"\t\t\t\tOption::None => { break Option::None; },\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn assert_only_protocol() {\n"
"\t\tassert(starknet::get_caller_address().is_zero(), 'caller/non-zero');\n"
"\t}\n"
"\n"
"\tfn assert_no_self_call(\n"
"\t\tmut calls: Span<account::Call>\n"
"\t) {\n"
"\t\tlet self = starknet::get_contract_address();\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tassert(*call.to != self, 'call/call-to-self');\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak ;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tfn execute_multi_call(mut calls: Span<account::Call>) -> Array<Span<felt252>> {\n"
"\t\tassert(calls.len() != 0, 'execute/no-calls');\n"
"\t\tlet mut result: Array<Span<felt252>> = ArrayTrait::new();\n"
"\t\tlet mut idx = 0;\n"
"\t\tloop {\n"
"\t\t\tmatch calls.pop_front() {\n"
"\t\t\t\tOption::Some(call) => {\n"
"\t\t\t\t\tmatch starknet::call_contract_syscall(\n"
"\t\t\t\t\t\t*call.to,\n"
"\t\t\t\t\t\t*call.selector,\n"
"\t\t\t\t\t\tcall.calldata.span()\n"
"\t\t\t\t\t) {\n"
"\t\t\t\t\t\tResult::Ok(retdata) => {\n"
"\t\t\t\t\t\t\tresult.append(retdata);\n"
"\t\t\t\t\t\t\tidx += 1;\n"
"\t\t\t\t\t\t},\n"
"\t\t\t\t\t\tResult::Err(err) => {\n"
"\t\t\t\t\t\t\tlet mut data = ArrayTrait::new();\n"
"\t\t\t\t\t\t\tdata.append('call/multicall-faild');\n"
"\t\t\t\t\t\t\tdata.append(idx);\n"
"\t\t\t\t\t\t\tlet mut err = err;\n"
"\t\t\t\t\t\t\tloop {\n"
"\t\t\t\t\t\t\t\tmatch err.pop_front() {\n"
"\t\t\t\t\t\t\t\t\tOption::Some(v) => {\n"
"\t\t\t\t\t\t\t\t\t\tdata.append(v);\n"
"\t\t\t\t\t\t\t\t\t},\n"
"\t\t\t\t\t\t\t\t\tOption::None => {\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t};\n"
"\t\t\t\t\t\t\tpanic(data);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t}\n"
"\t\t\t\t},\n"
"\t\t\t\tOption::None => {\n"
"\t\t\t\t\tbreak;\n"
"\t\t\t\t}\n"
"\t\t\t}\n"
"\t\t};\n"
"\t\tresult\n"
"\t}\n"
"}\n"
"\n"
"\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:524
#, fuzzy
msgid "Exploring Multisig Functions"
msgstr "**å¤–éƒ¨å‡½æ•°**ï¼š"

#: src/ch04-05-02-multisig.md:526
msgid "Letâ€™s take a closer look at the various functions associated with multisig functionality in the provided contract."
msgstr ""

#: src/ch04-05-02-multisig.md:529
msgid "`add_signers` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:531
msgid ""
"This is an internal function designed to add the public keys of the account owners to a permanent storage. Ideally, a multisig account structure should permit adding and deleting owners as per the "
"agreement of the account owners. However, each change should be a transaction requiring the threshold number of signatures."
msgstr ""

#: src/ch04-05-02-multisig.md:561
msgid "`is_signer_using_last` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:563
msgid ""
"This function allows the owners of the account to submit transactions. Upon submission, the function checks the validity of the signer, ensures the caller is one of the account owners, and adds the "
"transaction to the transactions map. It also increments the current transaction index."
msgstr ""

#: src/ch04-05-02-multisig.md:624
msgid "`is_valid_signer_signature` Function"
msgstr ""

#: src/ch04-05-02-multisig.md:626
msgid ""
"Similarly, the **_`is_valid_signer_signature`_** function provides a way to record confirmations for each signer. An account owner, who did not submit the transaction, can confirm it, increasing its "
"confirmation count."
msgstr ""

#: src/ch04-05-02-multisig.md:657
#, fuzzy
msgid "_`execute_multi_call`_ Function"
msgstr "#### æ‰§è¡Œå‡½æ•°"

#: src/ch04-05-02-multisig.md:659
msgid ""
"The _execute_multi_call_ function serves as the final step in the transaction process. It checks the validity of the transaction, whether it has been previously executed, and if the threshold number "
"of signatures has been reached. The transaction is executed if all the checks pass."
msgstr ""

#: src/ch04-05-02-multisig.md:713
msgid ""
"There maybe other use cases for other smart contracts to directly interact with the functions **execute** and **validate** of my account contract, I would rather restrict them to be callable only by "
"the Starknet protocol in case thereâ€™s an attack vector that Iâ€™m failing to foresee."
msgstr ""

#: src/ch04-05-02-multisig.md:715
msgid ""
"When the Starknet protocol calls a function it uses the zero address as the caller. We can use this fact to create a private function named only_protocol. To create private functions we simply create "
"a new implementation that is not annotated with the external attribute so no public selectors are created."
msgstr ""

#: src/ch04-05-02-multisig.md:783
msgid "Notice that the function is_valid_signature is not protected by the **only_protocol** function because we do want to allow anyone to use it."
msgstr ""

#: src/ch04-05-02-multisig.md:785
msgid "Signature Validation"
msgstr ""

#: src/ch04-05-02-multisig.md:787
msgid ""
"To validate the signature of a transaction we will need to use the public key associated with the signer of the account contract. We have already defined public_key to be part of the storage of our "
"account but we need to capture its value during deployment using the constructor."
msgstr ""

#: src/ch04-05-02-multisig.md:789
msgid ""
"```cairo\n"
"\n"
"#[storage]\n"
"\t#[starknet::contract]\n"
"mod Multisign {\n"
"\tuse super::ISRC6;\n"
"\tuse super::ISRC5;\n"
"\tuse starknet::account;\n"
"\n"
"\tconst SRC6_INTERFACE_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
"\tconst MAX_SIGNERS_COUNT: usize = 32;\n"
"\n"
"\t#[storage]\n"
"\tstruct Storage {\n"
"\t\tsigners: LegacyMap<felt252, felt252>,\n"
"\t\tthreshold: usize,\n"
"\t\toutside_nonce: LegacyMap<felt252, felt252>\n"
"\t}\n"
"\n"
"\t// @notice Contructor of the account\n"
"\t// @dev Asserts threshold in relation with signers-len\n"
"\t// @param threshold Initial threshold\n"
"\t// @param signers Array of inital signers' public-keys\n"
"\t#[constructor]\n"
"\tfn constructor(\n"
"\t\tref self: ContractState,\n"
"\t\tthreshold: usize,\n"
"\t\tsigners: Array<felt252>) {\n"
"\t\tassert_threshold(threshold, signers.len());\n"
"\n"
"\t\tself.add_signers(signers.span(), 0);\n"
"\t\tself.threshold.write(threshold);\n"
"\t}\n"
"```"
msgstr ""

#: src/ch04-05-02-multisig.md:824
msgid ""
"The logic of the function is_valid_signature can be implemented , if the signature is valid, it should return the short string â€˜VALIDâ€™ and if not it should return the value 0. Returning zero is just a "
"convention, we can return any felt as long as it is not the felt that represents the short string â€˜VALIDâ€™."
msgstr ""

#: src/ch04-05-02-multisig.md:826
msgid ""
"The logic of returning a felt252 value instead of a boolean maybe confusing. Thatâ€™s why there is a need to create an internal function called is_valid_signature_bool that will perform the same logic "
"but will return a boolean instead of a felt252 depending on the result of validating a signature."
msgstr ""

#: src/ch04-05-02-multisig.md:876
msgid ""
"Private function can be used to validate a transaction signature as required by the **validate** function. In contrast to the function is_valid_signature we will use an assert to stop the transaction "
"execution in case the signature is found to be invalid. Hereâ€™s a little casting problem. The function is_valid_signature_bool expects the signature to be passed as an Array but the signature variable "
"inside the **validate** function is a Span. Because it is easier (and cheaper) to derive a Span from an Array than the opposite, Iâ€™ll change the function signature of is_valid_signature_bool to expect "
"a Span instead of an Array."
msgstr ""

#: src/ch04-05-02-multisig.md:879
msgid ""
"This little change will require deriving a Span from the signature variable inside the function is_valid_signature before calling is_valid_signature_bool which we can easily do with the span() method "
"available on the ArrayTrait."
msgstr ""

#: src/ch04-05-02-multisig.md:883
msgid ""
"In conclusion, account abstraction and multisig converge to create a more secure, flexible, and user-centric approach to account management in blockchain ecosystems. Additional benefits of this "
"relationship include:"
msgstr ""

#: src/ch04-05-02-multisig.md:886
msgid "Social recovery: Account abstraction enables social recovery mechanisms for multisig accounts, allowing for account recovery in case of key loss."
msgstr ""

#: src/ch04-05-02-multisig.md:888
msgid "Fee payment delegation: Account contracts can be configured to pay transaction fees, reducing friction for multisig transactions."
msgstr ""

#: src/ch04-05-02-multisig.md:890
msgid ""
"As account abstraction gains traction, multisig is poised to become a more accessible and versatile tool for safeguarding assets and enhancing control in Starknet protocol. This chapter is an "
"introduction to the concept of multisig accounts in Starknet and illustrated how they can be implemented using an account contract. However, itâ€™s important to note that this is a simplified example, "
"and a production-grade multisig contract should contain additional checks and validations for robustness and security."
msgstr ""

#: src/ch04-05-03-auto-payments.md:3
msgid ""
"As blockchain adoption increases, there will be a greater need for products with a superior user experience and core functionality that support real use cases. In a few simple steps, we can set up "
"automatic recurring payments today directly on our mobile banking applications. In fact, online bill pay is growing rapidly, and customers especially younger ones have come to expect the ability to "
"set up recurring payments and take advantage of other conveniences associated with using auto-payments. About 3 in 10 surveyed users have changed the way they pay their bills in the past two years and "
"finding a more convenient way to pay was the most frequently cited reason. However, this is not a trivial task on a blockchain like Ethereum, the largest blockchain network by on-chain payment "
"volumes. For certain types of digital wallets, such as a self-custodial wallet where the user has sole control over the wallet and private keys, automated programmable payments that can pull payments "
"automatically from a userâ€™s account at recurring intervals requires engineering work."
msgstr ""

#: src/ch04-05-03-auto-payments.md:5
msgid ""
"The concept and one of the leading Ethereum developer proposals known as Account Abstraction to explore how smart contracts can be implemented to enable automated programmable payments. We propose a "
"new solution towards a real-world application of auto payments to demonstrate how to write a smart contract for a self-custodial wallet that can pull funds automatically, instead of requiring the "
"user's active participation each time to instruct and push payments on a blockchain."
msgstr ""

#: src/ch04-05-03-auto-payments.md:7
msgid ""
"Consider a hypothetical scenario: today is the 25th of February. Alex is going away on vacation to the Alps, and she will be returning on March 10th. She must pay her mortgage, TV subscription and "
"utility bills by the 5th of every month. She does not have enough money to pay before she goes on vacation, but she will have enough money when she gets her paycheck on the 1st of March. How is Alex "
"going to enjoy her vacation without missing her payments?"
msgstr ""

#: src/ch04-05-03-auto-payments.md:9
msgid ""
"All Alex needs to do is set up recurring payments to automatically pay for her recurring bills. However, this is not as straightforward to execute on a blockchain. To see why this is the case, let us "
"consider the Ethereum network. We will begin by setting up some terminology that will help us better understand the issue at hand."
msgstr ""

#: src/ch04-05-03-auto-payments.md:11
msgid "Accounts on Ethereum"
msgstr ""

#: src/ch04-05-03-auto-payments.md:13
msgid ""
"Ethereum has two types of accounts: Externally Owned Accounts (EOA) and Contract Accounts. EOAs have a private and public key pairing which helps them initiate transactions. On the other hand, "
"Contract Accounts are smart contracts that rely on predefined codes to trigger particular transactions. In that view, accounts abstraction refers to the process of unifying both contracts under a "
"single merged type that makes it easier for users to interact with blockchain-based applications. This mechanism would enable user accounts to behave like smart contracts, unlocking many new use "
"cases. For instance, users could set up delegate accounts that process automatic periodic payments on users' behalf. Account abstraction can also unlock a broader range of innovative features that "
"simplify the Web 3 experience for average users, including gasless transactions or changing the account signer at every particular interval to increase security."
msgstr ""

#: src/ch04-05-03-auto-payments.md:17
#, fuzzy
msgid "Auto Payments on Ethereum"
msgstr "è‡ªåŠ¨ä»˜æ¬¾ ğŸš§"

#: src/ch04-05-03-auto-payments.md:19
msgid ""
"Let us revisit Alexâ€™s situation. Suppose Alex owns a user account which is where her paychecks are deposited and from where she would like to pay her mortgage, TV subscription and utility bills. "
"Today, to pay her bills, Alex has to initiate a transaction that transfers tokens from her EOA to a user account belonging to the recipient, that is, to whomever she is paying her bills. In more "
"detail, Alexâ€™s EOA has an associated secret or private key known only to Alex. This private key is used by Alex in the generation of an Elliptic Curve Digital Signature Algorithm (ECDSA) signature "
"that is crucial for the creation of a valid transaction. And this already brings us to the problem at hand. If Alex is away on holiday, who will generate this signature to create the transaction that "
"will make her payment?"
msgstr ""

#: src/ch04-05-03-auto-payments.md:21
msgid ""
"One solution is for Alex to use what is known as a custodial wallet. With a custodial wallet, another party controls Alexâ€™s private key. In other words, Alex trusts a third party to secure her funds "
"and return them if she wanted to trade or send them somewhere else. The upside here is that Alex can set up an auto payment connected to her custodial wallet. Since the custodian, who is the party "
"that manages her wallet, has access to her private key, they will be able to generate the signature needed to create the transactions for her scheduled auto payments. And this can happen while Alex is "
"away on holiday. The downside is that while a custodial wallet lessens Alexâ€™s personal responsibility, it requires Alexâ€™s trust in the custodian who holds her funds."
msgstr ""

#: src/ch04-05-03-auto-payments.md:23
msgid ""
"With a self-custodial wallet, one where the user has total control over her wallet, Alex has sole control of her private key. While there is no need to trust a third party when using a self-custodial "
"wallet, this also means that Alex will not be able to set up an auto payment as she must be the one using her key to generate the signature needed for the payment transaction."
msgstr ""

#: src/ch04-05-03-auto-payments.md:25
msgid ""
"Another way to understand this is through the terminology of pull and push payments. A pull payment is a payment transaction that is triggered by the payee, while a push payment on the other hand is a "
"payment transaction that is triggered by the payer. Ethereum supports push payments but doesnâ€™t natively support pull payments â€“ auto payments are an example of pull payments."
msgstr ""

#: src/ch04-05-03-auto-payments.md:27
msgid "![Alt text](image.png)"
msgstr ""

#: src/ch04-05-03-auto-payments.md:31
msgid ""
"Account abstraction (AA) is a proposal that attempts to combine user accounts and smart contracts into just one Ethereum account type by making user accounts function like smart contracts. As we will "
"see ahead, AA allows us to design a neat solution for auto payments. But more generally, the motivating rationale behind AA is quite simple but fundamental: Ethereum transactions today have several "
"rigid requirements hardcoded into the Ethereum protocol. For instance, transactions on the Ethereum blockchain today are valid only if they have a valid ECDSA signature, a valid nonce and sufficient "
"account balance to cover the cost of computation."
msgstr ""

#: src/ch04-05-03-auto-payments.md:33
msgid "AA proposes having more flexibility in the process for validating a transaction on the blockchain:"
msgstr ""

#: src/ch04-05-03-auto-payments.md:35
msgid "It enables multi-owner accounts via multisig signature verification."
msgstr ""

#: src/ch04-05-03-auto-payments.md:36
msgid "It enables the use of post-quantum signatures for the verification of transactions."
msgstr ""

#: src/ch04-05-03-auto-payments.md:37
msgid "It also allows for a so-called public account from which anyone could make a transaction, by removing signature verification entirely."
msgstr ""

#: src/ch04-05-03-auto-payments.md:39
msgid ""
"Essentially, AA allows for programmable validity to verify and validate any blockchain transaction. This means that instead of hard coding validity conditions into the Ethereum protocol that will "
"apply to all transactions in a generalized way, validity conditions can instead be programmed in a customizable way into a smart contract on a per-account basis. With AA, a user deploys an account "
"contract with any of the features described above, among others."
msgstr ""

#: src/ch04-05-03-auto-payments.md:41
msgid "And, most importantly for us in the use case described, AA enables auto payments as we can set up validity rules that no longer include signature verification. We will elaborate on this next."
msgstr ""

#: src/ch04-05-03-auto-payments.md:43
msgid "Delegable Accounts â€“ Account Abstraction Enables Auto Payments"
msgstr ""

#: src/ch04-05-03-auto-payments.md:45
msgid ""
"Our solution for auto payments is to leverage AA and create a new type of account contract â€“ a delegable account. Our main idea is to extend programmable validity rules for transactions to include a "
"pre-approved allow list. In essence, AA allows us to delegate the ability to instruct the userâ€™s account to initiate a push payment to a pre-approved auto payment smart contract."
msgstr ""

#: src/ch04-05-03-auto-payments.md:47
msgid ""
"First, a merchant deploys an auto payment smart contract. When a user with a delegable account visits the merchantâ€™s website, they will see a request to approve auto payments â€“ similar to Visa "
"acceptance for billers today. Here, the user can see the actions that the auto payment contract will do in the userâ€™s name. For example, it can only charge the user once per month, or it cannot charge "
"more than a maximum amount. Crucially, because this is a smart contract, a user can be confident that the auto payment contract cannot execute in a way other than how it is written."
msgstr ""

#: src/ch04-05-03-auto-payments.md:49
msgid "If the user agrees to approve auto payments, the wallet will add the auto payment contractâ€™s address to the list of allowed contracts on the userâ€™s delegable account."
msgstr ""

#: src/ch04-05-03-auto-payments.md:51
msgid "Implementing Auto-payment on Starknet"
msgstr ""

#: src/ch04-05-03-auto-payments.md:53
msgid "For a smart contract to be considered an account contract it must at least implement the interface defined by SNIP-6. Additional methods might be required for advanced account functionality."
msgstr ""

#: src/ch04-05-03-auto-payments.md:55
#, fuzzy
msgid ""
"```\n"
"// Cheat sheet\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"// Cheat sheet\n"
"\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"trait ISRC6 {\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"trait ISRC5 {\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"trait IAccountAddon {\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    fn public_key() -> felt252;\n"
"}\n"
"\n"
"```"

#: src/ch04-05-03-auto-payments.md:77
msgid ""
"Much has been said about the need to improve the user experience (UX) of web3 if we want to increase adoption. Account Abstraction (AA) is one of the most powerful tools on Starknet to improve UX as "
"it enables users to sign transactions with FaceID or TouchID, to execute multiple operations in a single transaction and to allow for third party services to perform operations on behalf of the user "
"with fine grain control. No wonder why Visa has been so interested in exploring Starknet for auto payments."
msgstr ""

#: src/ch04-05-03-auto-payments.md:79
msgid ""
"With Account Abstraction, and in contrast to Externally Owned Accounts (EOA), the signer is decoupled from the account. The signer is the piece of code that signs transactions using a private key and "
"elliptic curve cryptography to uniquely identify a user. The account is a smart contract on Starknet that defines how signature verification is performed, executes the transactions signed by the user "
"and ultimately owns the userâ€™s assets (aka tokens) on L2."
msgstr ""

#: src/ch04-05-03-auto-payments.md:81
msgid ""
"Note: Using an Elliptic Curve Digital Signature Algorithtm (ECDSA) is not the only way to authenticate a signer, other mechanisms are possible but they come with tradeoffs of performance, cost and "
"ecosystem support. ECDSA remains the most widely used algorithm on Starknet and different curves are supported."
msgstr ""

#: src/ch04-05-03-auto-payments.md:83
msgid "The contract will be create account, declared and deploy it to testnet using Starkli and then use it to interact with Starknet."
msgstr ""

#: src/ch04-05-03-auto-payments.md:87
msgid "For a smart contract to be considered an account (aka account contract) it must adhere to a specific public interface defined by the Starknet Improvement Proposal number 6 (SNIP-6)."
msgstr ""

#: src/ch04-05-03-auto-payments.md:89
#, fuzzy
msgid ""
"```\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// @title Represents a call to a target contract\n"
"/// @param to The target contract address\n"
"/// @param selector The target function selector\n"
"/// @param calldata The serialized function parameters\n"
"struct Call {\n"
"    to: ContractAddress,\n"
"    selector: felt252,\n"
"    calldata: Array<felt252>\n"
"}\n"
"\n"
"/// @title SRC-6 Standard Account\n"
"trait ISRC6 {\n"
"    /// @notice Execute a transaction through the account\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The list of each call's serialized return value\n"
"    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
"\n"
"    /// @notice Assert whether the transaction is valid to be executed\n"
"    /// @param calls The list of calls to execute\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate__(calls: Array<Call>) -> felt252;\n"
"\n"
"    /// @notice Assert whether a given signature for a given hash is valid\n"
"    /// @param hash The hash of the data\n"
"    /// @param signature The signature to validate\n"
"    /// @return The string 'VALID' represented as felt when the signature is valid\n"
"    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
"}\n"
"\n"
"/// @title SRC-5 Standard Interface Detection\n"
"trait ISRC5 {\n"
"    /// @notice Query if a contract implements an interface\n"
"    /// @param interface_id The interface identifier, as specified in SRC-5\n"
"    /// @return `true` if the contract implements `interface_id`, `false` otherwise\n"
"    fn supports_interface(interface_id: felt252) -> bool;\n"
"}\n"
"\n"
"```"

#: src/ch04-05-03-auto-payments.md:124
msgid "As you can see in the proposal, an account contract must implement at least the methods **execute**, **validate** and is_valid_signature."
msgstr ""

#: src/ch04-05-03-auto-payments.md:126
msgid ""
"The methods **execute** and **validate** are meant to be called by the Starknet protocol during different stages of the lifecycle of a transaction. This doesnâ€™t mean that only the Starknet protocol "
"can use those methods, as a matter of fact, anyone can call those methods even if the contract account doesnâ€™t belong to them. Something to keep an eye on when securing our account."
msgstr ""

#: src/ch04-05-03-auto-payments.md:128
msgid ""
"When a user sends an invoke transaction, the first thing that the protocol does is to call the **validate** method to check the signature of the transaction. In other words, to authenticate the signer "
"associated with the account. There are restrictions on what you can do inside the **validate** method to protect the Sequencer against Denial of Service (DoS) attacks \\[3\\]."
msgstr ""

#: src/ch04-05-03-auto-payments.md:130
msgid ""
"Notice that if the signature verification is successful, the **validate** method should return the short string VALID as opposed to a boolean. In Cairo, a short string is simply the ASCII "
"representation of a single felt and not a real string. This is why the return type of the method is felt252. If the signature verification fails, you can stop execution with an assert or return "
"literally any other felt that is not the aforementioned short string."
msgstr ""

#: src/ch04-05-03-auto-payments.md:132
msgid ""
"If the protocol is able to authenticate the signer, it will then call the function **execute** passing as an argument an array of all the operations or â€œcallsâ€ the user wants to perform as a "
"multicall. Each one of these calls define a target smart contract, a method to call (the â€œselectorâ€) and the arguments expected by the method."
msgstr ""

#: src/ch04-05-03-auto-payments.md:134
msgid ""
"The execution of each Call might result in a value being returned from the target smart contract. This value could be a simple scalar like a felt252 or a boolean, or a complex data structure like a "
"struct or an array. In any case, the Starknet protocol serializes the response using a Span of felt252 elements. Remember that Span represents a snapshot of an Array \\[4\\]. This is why the return "
"type of the **execute** method is an Array of Spans which represents a serialized response from each call in the multicall."
msgstr ""

#: src/ch04-05-03-auto-payments.md:136
msgid ""
"The method is_valid_signature is not defined or used by the Starknet protocol. It was instead an agreement between builders in the Starknet community as a way to allow web3 apps to perform user "
"authentication. Think of a user trying to authenticate to an NFT marketplace using their wallet. The web app will ask the user to sign a message and then it will call the function is_valid_signature "
"to verify that the connected wallet address belongs to the user."
msgstr ""

#: src/ch04-05-03-auto-payments.md:138
msgid ""
"To allow other smart contracts to know if your account contract adheres to the SNIP-6 interface, you should implement the method supports_interface from the SRC5 introspection standard. The "
"interface_id for the SNIP-6 interface is the combined hash of the traitâ€™s selectors as defined by Ethereumâ€™s ERC165 \\[5\\]. You can calculate the id yourself by using the src5-rs utility \\[6\\] or "
"you can take my word for it that the id is 1270010605630597976495846281167968799381097569185364931397797212080166453709. Additional Interface"
msgstr ""

#: src/ch04-05-03-auto-payments.md:141
msgid ""
"Although the interface defined by the SNIP-6 is enough to guarantee that a smart contract is in fact an account contract, it is the minimum requirement and not the whole story. For an account to be "
"able to declare other smart contracts and pay for the associated gas fees it will need to also implement the method **validate_declare**. If we also want to be able to deploy our account contract "
"using the counterfactual deployment method then it also needs to implement the **validate_deploy** method."
msgstr ""

#: src/ch04-05-03-auto-payments.md:143
msgid ""
"Counterfactual deployment is a mechanism to deploy an account contract without relying on another account contract to pay for the related gas fees. This is important if we donâ€™t want to associate a "
"new account contract with its deployer address and instead have a â€œpristineâ€ beginning."
msgstr ""

#: src/ch04-05-03-auto-payments.md:145
msgid ""
"This deployment process starts by calculating locally the would-be-address of our account contract without actually deploying it yet. This is possible to do with tools like Starkli \\[7\\]. Once we "
"know the address, we then send enough ETH to that address to cover the costs of deploying our account contract. Once the address is funded we can finally send a deploy_account transaction to Starknet "
"with the compiled code of our account contract. The Sequencer will deploy the account contract to the precalculated address and pay itself gas fees with the ETH we sent there. Thereâ€™s no need to "
"declare an account contract before deploying it."
msgstr ""

#: src/ch04-05-03-auto-payments.md:147
msgid ""
"To allow tools like Starkli to easily integrate with our smart contract in the future, it is recommended to expose the public_key of the signer as a view function as part of the public interface. With "
"all this in mind, the extended interface of an account contract is shown below."
msgstr ""

#: src/ch04-05-03-auto-payments.md:149
#, fuzzy
msgid ""
"```\n"
"/// @title IAccount Additional account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Assert whether a declare transaction is valid to be executed\n"
"    /// @param class_hash The class hash of the smart contract to be declared\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"    /// @notice Assert whether counterfactual deployment is valid to be executed\n"
"    /// @param class_hash The class hash of the account contract to be deployed\n"
"    /// @param salt Account address randomizer\n"
"    /// @param public_key The public key of the account signer\n"
"    /// @return The string 'VALID' represented as felt when is valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"    /// @notice Exposes the signer's public key\n"
"    /// @return The public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"
msgstr ""
"```rust\n"
"/// @title IAccountAddon - Extended account contract interface\n"
"trait IAccountAddon {\n"
"    /// @notice Validates if a declare transaction can proceed\n"
"    /// @param class_hash Hash of the smart contract under declaration\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_declare__(class_hash: felt252) -> felt252;\n"
"\n"
"    /// @notice Validates if counterfactual deployment can proceed\n"
"    /// @param class_hash Hash of the account contract under deployment\n"
"    /// @param salt Modifier for account address\n"
"    /// @param public_key Account signer's public key\n"
"    /// @return 'VALID' string as felt, if valid\n"
"    fn __validate_deploy__(class_hash: felt252, salt: felt252, public_key: felt252) -> felt252;\n"
"\n"
"    /// @notice Fetches the signer's public key\n"
"    /// @return Public key\n"
"    fn public_key() -> felt252;\n"
"}\n"
"```"

#: src/ch04-05-03-auto-payments.md:168
msgid "In summary, a fully fledged account contract should implement the SNIP-5, SNIP-6 and the Addon interface."
msgstr ""

#: src/ch04-05-03-auto-payments.md:170
#, fuzzy
msgid "References"
msgstr "## å‚è€ƒæ–‡çŒ®"

#: src/ch04-05-03-auto-payments.md:172
msgid "\\[1\\] Auto Payments for Self-Custodial Wallets"
msgstr ""

#: src/ch04-05-03-auto-payments.md:174
msgid "\\[2\\] SNIP-6 Standard Account Interface: <https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md>"
msgstr ""

#: src/ch04-05-03-auto-payments.md:176
msgid "\\[3\\] Starknet Docs: Limitations on the validate function: <https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/validate_and_execute/#validate_limitations>"
msgstr ""

#: src/ch04-05-03-auto-payments.md:178
msgid "\\[4\\] Cairo Book: The Span data type: <https://book.cairo-lang.org/ch02-02-data-types.html>"
msgstr ""

#: src/ch04-05-03-auto-payments.md:180
msgid "\\[5\\] ERC-165: Standard Interface Detection: <https://eips.ethereum.org/EIPS/eip-165>"
msgstr ""

#: src/ch04-05-03-auto-payments.md:182
msgid "\\[6\\] Github: src5-rs: <https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md>"
msgstr ""

#: src/ch04-05-03-auto-payments.md:184
msgid "\\[7\\] Github: starkli: <https://github.com/xJonathanLEI/starkli>"
msgstr ""

#: src/ch04-05-06-web-wallet.md:1
msgid "Web Wallet: Web2 Simplicity with self-custody"
msgstr ""

#: src/ch04-05-06-web-wallet.md:3
msgid ""
"Web Wallet, developed by Argent ([documentation](https://docs.argent.xyz/starknet/web-wallet-sdk)), is a tool that uses the full power and capacity of Account Abstraction. It's a self-custodial, "
"browser-based wallet that simplifies blockchain interactions. Unlike traditional wallets that often involve seed phrases and wallet downloads, Web Wallet utilizes a simple email and password setup. "
"This approach blends the ease of web2 interfaces with the advanced capabilities of web3, making Starknet more accessible and user-friendly."
msgstr ""

#: src/ch04-05-06-web-wallet.md:5
#, fuzzy
msgid "Key Features:"
msgstr "## å…³é”®ç‰¹æ€§"

#: src/ch04-05-06-web-wallet.md:7
msgid "**Simplified Seed Phrases**: Web Wallet eliminates the need for seed phrases. Access your wallet easily using your email and password. Accounts are easily recoverable if lost."
msgstr ""

#: src/ch04-05-06-web-wallet.md:8
msgid "**No Downloads Needed**: Access Starknet directly from your browser using your email. No need to download an application or extension to create a wallet."
msgstr ""

#: src/ch04-05-06-web-wallet.md:9
msgid "**Multi-Device Support**: Web Wallet can be used across various devices seamlessly, like any standard web2 application."
msgstr ""

#: src/ch04-05-06-web-wallet.md:11
msgid "dApps Integration Guide"
msgstr ""

#: src/ch04-05-06-web-wallet.md:13
msgid "To integrate Web Wallet in a dApp, start by installing `starknetkit`:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:19
msgid "Import necessary methods such as **`connect`** and **`disconnect`**:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:22
msgid "\"starknetkit\""
msgstr ""

#: src/ch04-05-06-web-wallet.md:25
msgid "Create a wallet connection using the `connect` method:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:31
msgid "Below is an example function that establishes a connection, then sets the connection, provider, and address states:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:45
msgid "**NOTE:** Web Wallet is currently available only on the mainnet. For testnet access, contact the Argent team."
msgstr ""

#: src/ch04-05-06-web-wallet.md:47
#, fuzzy
msgid "Transaction Signing Process"
msgstr "äº¤æ˜“"

#: src/ch04-05-06-web-wallet.md:49
msgid "Signing transactions with Web Wallet follows a process akin to the Argent X browser extension:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:53
msgid "//let's assume this is an erc20 contract\n"
msgstr ""

#: src/ch04-05-06-web-wallet.md:54 src/ch04-05-06-web-wallet.md:57
msgid "\"0x...\""
msgstr ""

#: src/ch04-05-06-web-wallet.md:58
msgid "// ...\n"
msgstr ""

#: src/ch04-05-06-web-wallet.md:63
msgid "Users will see a transaction confirmation request. Upon approval, the dApp receives a transaction hash:"
msgstr ""

#: src/ch04-05-06-web-wallet.md:67
msgid ""
"If the user's wallet is already funded it will ask the user to confirm the transaction. The dapp will get feedback if the user has confirmed or rejected the transaction request. If confirmed, the dapp "
"will get a transaction hash."
msgstr ""

#: src/ch04-05-06-web-wallet.md:69
msgid "Addressing Unfunded Wallets"
msgstr ""

#: src/ch04-05-06-web-wallet.md:71
msgid ""
"When users lack funds, they are guided through simple \"Add Funds\" steps. This includes access to on-ramps for easy funding. The process is streamlined with minimal KYC requirements, ensuring a user-"
"friendly experience. Once complete, the wallet is funded and prepared for deployment."
msgstr ""

#: src/ch04-05-06-web-wallet.md:73
#, fuzzy
msgid "Preparing for First Transaction"
msgstr "## è·Ÿè¸ªäº¤æ˜“"

#: src/ch04-05-06-web-wallet.md:75
msgid ""
"Once the wallet is funded, it's set for the initial transaction. Wallet deployment occurs simultaneously with this first transaction, typically unnoticed by the user. It's important to note that a "
"wallet may be connected but not yet deployed."
msgstr ""

#~ msgid "Nodes ğŸš§"
#~ msgstr "èŠ‚ç‚¹ ğŸš§"

#~ msgid "# The Starknet Book"
#~ msgstr "# Starknet ä¹‹ä¹¦"

#~ msgid ""
#~ "| Chapter                  | "
#~ "Description                                                                                                                                                                                           "
#~ "|\n"
#~ "| ------------------------ | "
#~ "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- "
#~ "|\n"
#~ "| 1: Starknet Introduction | Delve into the fundamental concepts of Starknet and acquaint yourself with the deployment of smart "
#~ "contracts.                                                                                         |\n"
#~ "| 2: Starknet Tooling      | Familiarize yourself with vital tools, such as Starkli, Katana, Scarb, Starknet-Foundry and more. Explore how languages like Javascript, Python, and Rust can be "
#~ "leveraged for Starknet interactions. |\n"
#~ "| 3: Starknet Architecture | Uncover Starknetâ€™s core structure, gaining insights into the transaction lifecycle and the interplay between the Sequencer, Prover, and "
#~ "Nodes.                                                        |\n"
#~ "| 4: Account Abstraction   | Delve deep into Starknetâ€™s unique approach to user accounts, and master the art of crafting custom "
#~ "accounts.                                                                                          |\n"
#~ "| 5: STARKs                | Dive into the intricacies of STARKs and their pivotal role in shaping Starknetâ€™s "
#~ "landscape.                                                                                                           |"
#~ msgstr ""
#~ "| ç« èŠ‚ | è¯´æ˜\n"
#~ "| ------------------------ | "
#~ "----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n"
#~ "| 1: Starknetç®€ä»‹ | æ·±å…¥äº†è§£Starknetçš„åŸºæœ¬æ¦‚å¿µï¼Œç†Ÿæ‚‰æ™ºèƒ½åˆçº¦çš„éƒ¨ç½²ã€‚                                                                 |\n"
#~ "| 2: Starknetå·¥å…· | ç†Ÿæ‚‰ Starkli, Katana, Scarb, Starknet-Foundryç­‰é‡è¦å·¥å…·ï¼Œæ¢ç´¢å¦‚ä½•åˆ©ç”¨ Javascriptã€Python å’Œ Rust ç­‰è¯­è¨€è¿›è¡ŒStarknetäº¤äº’ã€‚|\n"
#~ "| 3: Starknetæ¶æ„ | æ¢ç´¢Starknetçš„æ ¸å¿ƒç»“æ„ï¼Œæ·±å…¥äº†è§£äº‹åŠ¡ç”Ÿå‘½å‘¨æœŸä»¥åŠæ’åºå™¨ã€è¯æ˜å™¨å’ŒèŠ‚ç‚¹ä¹‹é—´çš„ç›¸äº’ä½œç”¨ã€‚                                |\n"
#~ "| 4: è´¦æˆ·æŠ½è±¡ | æ·±å…¥äº†è§£ Starknet ç‹¬ç‰¹çš„ç”¨æˆ·è´¦æˆ·æ–¹æ³•ï¼ŒæŒæ¡åˆ›å»ºè‡ªå®šä¹‰è´¦æˆ·çš„è‰ºæœ¯ã€‚                                                                  |\n"
#~ "| 5: STARKs | æ·±å…¥äº†è§£ STARKs çš„å¤æ‚æ€§åŠå…¶åœ¨å¡‘é€ Starknetæ ¼å±€ä¸­çš„å…³é”®ä½œç”¨ã€‚                                                                                   |"

#~ msgid ""
#~ "- If youâ€™re a **complete beginner** and want to start learning about\n"
#~ "  Cairo and Starknet from scratch, follow the book in its entirety,\n"
#~ "  starting with **Introduction to Starknet**.\n"
#~ "\n"
#~ "- If youâ€™re an **experienced developer** looking to quickly dive into\n"
#~ "  writing scalable and decentralized smart contracts, focus on the\n"
#~ "  Cairo Book, particularly **chapter 12: Starknet Smart Contracts**\n"
#~ "  ([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
#~ "\n"
#~ "- If youâ€™re a **frontend developer** wanting to integrate Starknet\n"
#~ "  with a React frontend using Javascript, prioritize the\n"
#~ "  **starknet-js** and **starknet-react** subchapters in **Starknet\n"
#~ "  Tooling**\n"
#~ "\n"
#~ "- If youâ€™re a **DevOps engineer** or **node operator** interested in\n"
#~ "  running a Starknet node and indexer, head straight to **Starknet\n"
#~ "  Architecture**.\n"
#~ "\n"
#~ "- If youâ€™re a **security researcher** or **smart contract auditor**\n"
#~ "  wanting to learn about the Account Abstraction feature and its\n"
#~ "  implications, go for **Account Abstraction**.\n"
#~ "\n"
#~ "- If youâ€™re a **blockchain enthusiast** curious about the underlying\n"
#~ "  architecture and mechanics of Starknet and Cairo, explore **Starknet\n"
#~ "  Architecture**.\n"
#~ "\n"
#~ "- If youâ€™re a **cryptography expert** or **researcher** eager to\n"
#~ "  understand the fundamentals of STARKs and their connection to the\n"
#~ "  Starknet ecosystem, delve into **STARKs**."
#~ msgstr ""
#~ "- å¦‚æœä½ æ˜¯ä¸€ä¸ª**å®Œå…¨çš„åˆå­¦è€…**ï¼Œæƒ³ä»å¤´å¼€å§‹å­¦ä¹ Cairoå’ŒStarknetï¼Œ\n"
#~ "  è¯·ä»**Starknetå…¥é—¨å¼€å§‹**ã€‚\n"
#~ "\n"
#~ "- å¦‚æœä½ æ˜¯ä¸€ä¸ª**æœ‰ç»éªŒçš„å¼€å‘è€…**ï¼Œå¸Œæœ›å¿«é€Ÿå¼€å§‹\n"
#~ "  ç¼–å†™å¯æ‰©å±•çš„å»ä¸­å¿ƒåŒ–æ™ºèƒ½åˆçº¦ï¼Œè¯·é‡ç‚¹é˜…è¯»\n"
#~ "  ã€ŠCairoä¹‹ä¹¦ã€‹ï¼Œå°¤å…¶æ˜¯**ç¬¬ 12ç« ï¼šStarknetæ™ºèƒ½åˆçº¦**\n"
#~ "  ([link](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)).\n"
#~ "\n"
#~ "- å¦‚æœä½ æ˜¯ä¸€å**å‰ç«¯å¼€å‘è€…**ï¼Œå¸Œæœ›ä½¿ç”¨ JavaScript å°† Starknet\n"
#~ "  ä¸ä½¿ç”¨ Javascript çš„ React å‰ç«¯é›†æˆï¼Œè¯·ä¼˜å…ˆå‚è€ƒ\n"
#~ "  **Starknetå·¥å…·**ä¸­çš„**starknet-js**å’Œ**starknet-react**å­ç« èŠ‚ã€‚\n"
#~ "\n"
#~ "- å¦‚æœæ‚¨æ˜¯ä¸€å**å¼€å‘è¿ç»´å·¥ç¨‹å¸ˆ**æˆ–**èŠ‚ç‚¹æ“ä½œè€…**ï¼Œæœ‰å…´è¶£\n"
#~ "  è¿è¡ŒStarknetèŠ‚ç‚¹å’Œç´¢å¼•å™¨ï¼Œè¯·ç›´æ¥è®¿é—® **Starknetæ¶æ„**ã€‚\n"
#~ "\n"
#~ "- å¦‚æœæ‚¨æ˜¯**å®‰å…¨ç ”ç©¶å‘˜**æˆ–**æ™ºèƒ½åˆçº¦å®¡è®¡å‘˜**\n"
#~ "  æƒ³äº†è§£è´¦æˆ·æŠ½è±¡åŠŸèƒ½åŠå…¶å½±å“ï¼Œè¯·æŸ¥çœ‹**è´¦æˆ·æŠ½è±¡**ã€‚\n"
#~ "\n"
#~ "- å¦‚æœæ‚¨æ˜¯**åŒºå—é“¾çˆ±å¥½è€…**ï¼Œå¯¹tarknetå’ŒCairoçš„åº•å±‚æ¶æ„å’Œæœºåˆ¶æ„Ÿåˆ°å¥½å¥‡ï¼Œ\n"
#~ "è¯·æµè§ˆ**Starknetæ¶æ„**ã€‚\n"
#~ "\n"
#~ "- å¦‚æœæ‚¨æ˜¯**åŠ å¯†ä¸“å®¶**æˆ–**ç ”ç©¶äººå‘˜**ï¼Œæ¸´æœ›äº†è§£ STARK çš„åŸºæœ¬åŸç†åŠå…¶ä¸Starknetç”Ÿæ€ç³»ç»Ÿçš„è”ç³»ï¼Œè¯·æ·±å…¥ç ”ç©¶**Starknetæ¶æ„**ã€‚"

#~ msgid ""
#~ "- Found an empty section? Fill it in!\n"
#~ "\n"
#~ "- Think we need a new section? Suggest one.\n"
#~ "\n"
#~ "- See room for improvement? Go ahead and tweak it.\n"
#~ "\n"
#~ "- Want to add code in a new programming language? Go for it.\n"
#~ "\n"
#~ "- Found a bug? Fix it.\n"
#~ "\n"
#~ "- Exercises unclear? Add explanations.\n"
#~ "\n"
#~ "- Show off your favorite Cairo features through new exercises."
#~ msgstr ""
#~ "- å‘ç°ç©ºç™½åŒºåŸŸï¼Ÿå¡«æ»¡å®ƒï¼\n"
#~ "\n"
#~ "- è®¤ä¸ºæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°æ ç›®ï¼Ÿè¯·æå‡ºå»ºè®®ã€‚\n"
#~ "\n"
#~ "- è®¤ä¸ºæœ‰æ”¹è¿›ä½™åœ°ï¼Ÿè¯·ç»§ç»­è°ƒæ•´ã€‚\n"
#~ "\n"
#~ "- æƒ³ç”¨æ–°çš„ç¼–ç¨‹è¯­è¨€æ·»åŠ ä»£ç ï¼Ÿå»åšå§ã€‚\n"
#~ "\n"
#~ "- å‘ç°ä¸€ä¸ªé”™è¯¯ï¼Ÿä¿®å¤å®ƒã€‚\n"
#~ "\n"
#~ "- ç»ƒä¹ ä¸æ¸…æ¥šï¼Ÿæ·»åŠ è§£é‡Šã€‚\n"
#~ "\n"
#~ "- é€šè¿‡æ–°ç»ƒä¹ å±•ç¤ºä½ æœ€å–œæ¬¢çš„CairoåŠŸèƒ½ã€‚"

#~ msgid ""
#~ "1.  **Starklings**: A resource specifically designed to guide you\n"
#~ "    through learning Cairo programming, ensuring that you reach a\n"
#~ "    proficient level. You can access it\n"
#~ "    [here](https://github.com/shramee/starklings-cairo1).\n"
#~ "\n"
#~ "2.  **Starknet Community Forum**: An online platform where you can\n"
#~ "    engage in discussions about the latest developments in Starknet.\n"
#~ "    Join the conversation [here](https://community.starknet.io/).\n"
#~ "\n"
#~ "3.  **Starknet Documentation**: You can browse through the documentation\n"
#~ "    [here](https://docs.starknet.io/).\n"
#~ "\n"
#~ "4.  **Cairo Documentation**: Explore it\n"
#~ "    [here](https://www.cairo-lang.org/docs).\n"
#~ "\n"
#~ "5.  **Starknet Developer Telegram (English)**: A community for\n"
#~ "    English-speaking Starknet developers. This is a great platform for\n"
#~ "    networking, sharing ideas, and troubleshooting together. Join us on\n"
#~ "    Telegram [here](https://t.me/starknetna)."
#~ msgstr ""
#~ "1.  **Starklings**ï¼šä¸“ä¸ºæŒ‡å¯¼æ‚¨å­¦ä¹ Cairoç¼–ç¨‹è€Œè®¾è®¡çš„èµ„æºï¼Œç¡®ä¿æ‚¨è¾¾åˆ°ç†Ÿç»ƒæ°´å¹³ã€‚\n"
#~ "    æ‚¨å¯ä»¥åœ¨[æ­¤å¤„](https://github.com/shramee/starklings-cairo1)è®¿é—®ã€‚\n"
#~ "\n"
#~ "2.  **Starknetç¤¾åŒºè®ºå›**ï¼šåœ¨çº¿å¹³å°ï¼Œæ‚¨å¯ä»¥\n"
#~ "    å‚ä¸è®¨è®ºStarknetçš„æœ€æ–°å‘å±•ã€‚\n"
#~ "    åœ¨[æ­¤å¤„](https://community.starknet.io/)åŠ å…¥å¯¹è¯ã€‚\n"
#~ "\n"
#~ "3.  **Starknetæ–‡æ¡£**ï¼šæ‚¨å¯ä»¥åœ¨[æ­¤å¤„](https://docs.starknet.io/)æµè§ˆæ–‡æ¡£ã€‚\n"
#~ "\n"
#~ "4.  **Cairoæ–‡æ¡£**ï¼šæ‚¨å¯ä»¥åœ¨[æ­¤å¤„](https://www.cairo-lang.org/docs)æµè§ˆæ–‡æ¡£ã€‚\n"
#~ "\n"
#~ "5.  **Starknetå¼€å‘è€…ç”µæŠ¥ï¼ˆè‹±æ–‡ï¼‰**ï¼šä¸€ä¸ªè‹±è¯­Starknetå¼€å‘äººå‘˜çš„ç¤¾åŒºã€‚è¿™æ˜¯ä¸€ä¸ªäº¤æµã€åˆ†äº«æƒ³æ³•å’Œå…±åŒæ’é™¤æ•…éšœçš„ç»ä½³å¹³å°ã€‚\n"
#~ "    åœ¨[è¿™é‡Œ](https://t.me/starknetna)åŠ å…¥æˆ‘ä»¬çš„Telegramã€‚\n"
#~ "\n"
#~ "6.  **Starknetå¼€å‘è€…ç”µæŠ¥ï¼ˆä¸­æ–‡ï¼‰**ï¼šé¢å‘ä¸­æ–‡å¼€å‘è€…çš„Starknetå’ŒCairoå¼€å‘è€…ç¤¾åŒºï¼Œç”±Starknet Astroè¿›è¡Œç»´æŠ¤ï¼Œä»¥åŠç”±Starknet Foundationæ”¯æŒã€‚\n"
#~ "    åœ¨[è¿™é‡Œ](https://t.me/StarknetAstro)åŠ å…¥æˆ‘ä»¬çš„Telegramã€‚å¦‚æœä½ æ›´ä¹ æƒ¯ä½¿ç”¨å¾®ä¿¡æ¥äº¤æµä¹Ÿå¯åœ¨è¯¥ç¾¤ç»„å†…æå‡ºåŠ å…¥å¾®ä¿¡ç¾¤çš„ç”³è¯·ã€‚"

#~ msgid ""
#~ "1. **Public Protocol:** The foundation of a Blockchain rests upon a protocol that is openly available. This transparency ensures that any interested party can understand its workings, fostering "
#~ "trust and enabling wider adoption.\n"
#~ "2. **Open P2P Network:** Instead of relying on a centralized entity, a Blockchain operates over a peer-to-peer (P2P) network. This decentralized approach ensures that operations are distributed "
#~ "across various participants or nodes, making the system more resilient to failures and censorship.\n"
#~ "3. **Value Distribution:** Central to the Blockchain's operation is the way it rewards its operators. The system autonomously distributes value in a manner that is wide-ranging and equitable. This "
#~ "incentivization not only motivates participants to maintain the system's integrity but also ensures a broader societal consensus."
#~ msgstr ""
#~ "1. **å…¬å¼€åè®®ï¼š** åŒºå—é“¾çš„åŸºç¡€æ˜¯å…¬å¼€å¯ç”¨çš„åè®®ã€‚è¿™ç§é€æ˜åº¦å¯ç¡®ä¿ä»»ä½•æ„Ÿå…´è¶£çš„äººéƒ½èƒ½äº†è§£å…¶å·¥ä½œåŸç†ï¼Œä»è€Œä¿ƒè¿›ä¿¡ä»»ï¼Œä½¿å…¶å¾—åˆ°æ›´å¹¿æ³›çš„é‡‡ç”¨ã€‚\n"
#~ "2. **å¼€æ”¾çš„ç‚¹å¯¹ç‚¹ç½‘ç»œï¼š** åŒºå—é“¾é€šè¿‡ç‚¹å¯¹ç‚¹ï¼ˆP2Pï¼‰ç½‘ç»œè¿è¡Œï¼Œè€Œä¸æ˜¯ä¾èµ–ä¸€ä¸ªä¸­å¤®å®ä½“ã€‚è¿™ç§å»ä¸­å¿ƒåŒ–çš„æ–¹æ³•å¯ç¡®ä¿æ“ä½œåˆ†å¸ƒåœ¨ä¸åŒçš„å‚ä¸è€…æˆ–èŠ‚ç‚¹ä¸Šï¼Œä½¿ç³»ç»Ÿæ›´èƒ½æŠµå¾¡æ•…éšœå’Œå®¡æŸ¥ã€‚\n"
#~ "3. **ä»·å€¼åˆ†é…ï¼š** åŒºå—é“¾è¿è¡Œçš„æ ¸å¿ƒæ˜¯å…¶å¥–åŠ±æ“ä½œè€…çš„æ–¹å¼ã€‚è¯¥ç³»ç»Ÿä»¥å¹¿æ³›å’Œå…¬å¹³çš„æ–¹å¼è‡ªä¸»åˆ†é…ä»·å€¼ã€‚è¿™ç§æ¿€åŠ±æ–¹å¼ä¸ä»…èƒ½æ¿€åŠ±å‚ä¸è€…ç»´æŠ¤ç³»ç»Ÿçš„å®Œæ•´æ€§ï¼Œè¿˜èƒ½ç¡®ä¿è¾¾æˆæ›´å¹¿æ³›çš„ç¤¾ä¼šå…±è¯†ã€‚"

#~ msgid ""
#~ "- **Lasting Broadness.** Starknet continuously resists power consolidation. Key points include:\n"
#~ "\n"
#~ "  - Broad power distribution underpins Starknet's legitimacy and must persist across operations and decision-making. While centralized operation may be necessary at times, it should be short-"
#~ "lived.\n"
#~ "  - Starknet's protocol and governance should always be open and transparent.\n"
#~ "  - Governance should bolster inclusivity, with a flexible structure that can evolve to ensure enduring inclusivity.\n"
#~ "\n"
#~ "- **Neutrality.** Starknet remains impartial to the societal functions it supports.\n"
#~ "\n"
#~ "  - The objectives and ethos of functions on Starknet lie with their creators.\n"
#~ "  - **Censorship resistance:** Starknet remains agnostic to the nature and meaning of user transactions.\n"
#~ "\n"
#~ "- **Individual Empowerment.** At its core, Starknet thrives on a well-informed and autonomous user base. This is achieved by fostering a culture rooted in its core mission and values, with a strong "
#~ "emphasis on education."
#~ msgstr ""
#~ "- ** æŒä¹…çš„å¹¿æ³›æ€§ã€‚** Starknetä¸æ–­æŠµåˆ¶æƒåŠ›æ•´åˆã€‚è¦ç‚¹åŒ…æ‹¬\n"
#~ "\n"
#~ "  - å¹¿æ³›çš„æƒåŠ›åˆ†é…æ˜¯Starknetåˆæ³•æ€§çš„åŸºç¡€ï¼Œå¿…é¡»åœ¨æ•´ä¸ªè¿è¥å’Œå†³ç­–è¿‡ç¨‹ä¸­åšæŒä¸‹å»ã€‚è™½ç„¶é›†ä¸­è¿ä½œæœ‰æ—¶æ˜¯å¿…è¦çš„ï¼Œä½†åº”è¯¥æ˜¯çŸ­æš‚çš„ã€‚\n"
#~ "  - Starknetçš„åè®®å’Œç®¡ç†åº”å§‹ç»ˆå…¬å¼€é€æ˜ã€‚\n"
#~ "  - ç®¡ç†åº”ä¿ƒè¿›åŒ…å®¹æ€§ï¼Œå…¶çµæ´»çš„ç»“æ„å¯ä»¥ä¸æ–­å‘å±•ï¼Œä»¥ç¡®ä¿æŒä¹…çš„åŒ…å®¹æ€§ã€‚\n"
#~ "\n"
#~ "- **ä¸­ç«‹æ€§ï¼š**Starknetå¯¹å…¶æ”¯æŒçš„ç¤¾ä¼šåŠŸèƒ½ä¿æŒä¸­ç«‹ã€‚\n"
#~ "\n"
#~ "  - åœ¨Starknetä¸Šè¢«åˆ›å»ºçš„åŠŸèƒ½çš„ç›®æ ‡å’Œç²¾ç¥åœ¨äºå…¶åˆ›å»ºè€…ã€‚\n"
#~ "  - **æŠµåˆ¶å®¡æŸ¥ï¼š** Starknetå¯¹ç”¨æˆ·äº¤æ˜“çš„æ€§è´¨å’Œæ„ä¹‰ä¿æŒä¸­ç«‹ã€‚\n"
#~ "\n"
#~ "- ** ä¸ªäººèµ‹æƒï¼š** Starknetçš„æ ¸å¿ƒæ˜¯å»ºç«‹ä¸€ä¸ªä¿¡æ¯çµé€šã€è‡ªä¸»çš„ç”¨æˆ·ç¾¤ã€‚è¿™æ˜¯é€šè¿‡åŸ¹å…»æ¤æ ¹äºå…¶æ ¸å¿ƒä½¿å‘½å’Œä»·å€¼è§‚çš„æ–‡åŒ–æ¥å®ç°çš„ï¼ŒåŒæ—¶ä¹Ÿéå¸¸é‡è§†æ•™è‚²ã€‚"

#~ msgid ""
#~ "- Low Costs: Transactions on Starknet cost less than on Ethereum.\n"
#~ "  Future updates like Volition and EIP 4844 will make it even cheaper.\n"
#~ "\n"
#~ "- Developer-Friendly: Starknet lets developers easily build\n"
#~ "  decentralized apps using its native language, Cairo.\n"
#~ "\n"
#~ "- Speed and Efficiency: Upcoming releases aim to make transactions\n"
#~ "  even faster and cheaper.\n"
#~ "\n"
#~ "- CVM: Thanks to Cairo, Starknet runs on itÂ´s own VM, called Cairo VM\n"
#~ "  (CVM), that allow us to innovate beyond the Ethereum Virtual Machine\n"
#~ "  (EVM) and create a new paradigm for decentralized applications."
#~ msgstr ""
#~ "- ä½æˆæœ¬ï¼šStarknetçš„äº¤æ˜“æˆæœ¬ä½äºä»¥å¤ªåŠã€‚\n"
#~ "  æœªæ¥çš„æ›´æ–°ï¼ˆå¦‚ Volition å’Œ EIP 4844ï¼‰å°†ä½¿å…¶æ›´åŠ ä¾¿å®œã€‚\n"
#~ "\n"
#~ "- å¼€å‘è€…å‹å¥½ï¼šStarknet å¯è®©å¼€å‘è€…ä½¿ç”¨å…¶æœ¬åœ°è¯­è¨€Cairoï¼ˆCairoï¼‰è½»æ¾åˆ›å»º\n"
#~ "  å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºã€‚\n"
#~ "\n"
#~ "- é€Ÿåº¦ä¸æ•ˆç‡ï¼šå³å°†å‘å¸ƒçš„ç‰ˆæœ¬æ—¨åœ¨ä½¿äº¤æ˜“\n"
#~ "  æ›´å¿«ã€æ›´ä¾¿å®œã€‚\n"
#~ "\n"
#~ "- CVMï¼šå¾—ç›ŠäºCairoï¼ŒStarknetè¿è¡Œåœ¨è‡ªå·±çš„è™šæ‹Ÿæœºä¸Šï¼Œç§°ä¸ºCairoè™šæ‹Ÿæœºï¼ˆCVM)ï¼Œ\n"
#~ "  å®ƒä½¿å¾—æˆ‘ä»¬å¯ä»¥è¶…è¶Šä»¥å¤ªåŠè™šæ‹Ÿæœºï¼ˆEVMï¼‰ï¼Œä¸ºå»ä¸­å¿ƒåŒ–åº”ç”¨åˆ›é€ æ–°çš„èŒƒå¼ã€‚"

#~ msgid "### Why Choose Cairo?"
#~ msgstr "ä¸ºä»€ä¹ˆé€‰æ‹©Cairoï¼Ÿ"

#~ msgid ""
#~ "Cairo is designed for _Provable Computation,_ a new paradigm that lets\n"
#~ "programs prove their correctness without re-running them. Hereâ€™s why it\n"
#~ "stands out:"
#~ msgstr "Cairo æ˜¯ä¸“ä¸º _å¯è¯æ˜è®¡ç®—_ è€Œè®¾è®¡çš„ï¼Œ _å¯è¯æ˜è®¡ç®—_ æ˜¯ä¸€ç§è®©ç¨‹åºæ— éœ€é‡æ–°è¿è¡Œå°±èƒ½è¯æ˜å…¶æ­£ç¡®æ€§çš„æ–°æ¨¡å¼ã€‚è¿™å°±æ˜¯å®ƒè„±é¢–è€Œå‡ºçš„åŸå› ï¼š"

#~ msgid ""
#~ "- Purpose-Built: Designed specifically for smart contracts.\n"
#~ "\n"
#~ "- No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do.\n"
#~ "\n"
#~ "- Flexibility: Uses traits for more flexibility than inheritance."
#~ msgstr ""
#~ "- ä¸“é—¨è®¾è®¡ï¼šä¸“ä¸ºæ™ºèƒ½åˆçº¦è®¾è®¡ã€‚\n"
#~ "\n"
#~ "- æ—  EVM é™åˆ¶ï¼šè¶…è¶Šä»¥å¤ªåŠè™šæ‹Ÿæœºçš„åŠŸèƒ½ã€‚\n"
#~ "\n"
#~ "- çµæ´»æ€§ï¼šä½¿ç”¨traitï¼Œæ¯”ç»§æ‰¿æ›´çµæ´»ã€‚"

#~ msgid ""
#~ "- Managing Starknetâ€™s development and operations\n"
#~ "\n"
#~ "- Overseeing the Starknet DAO, which enables community involvement\n"
#~ "\n"
#~ "- Setting rules to maintain network integrity"
#~ msgstr ""
#~ "- ç®¡ç†Starknetçš„å¼€å‘å’Œè¿è¥\n"
#~ "\n"
#~ "- ç›‘ç£Starknet DAOï¼Œè®©ç¤¾åŒºå‚ä¸å…¶ä¸­\n"
#~ "\n"
#~ "- åˆ¶å®šè§„åˆ™ï¼Œç»´æŠ¤ç½‘ç»œå®Œæ•´æ€§"

#~ msgid ""
#~ "1.  They are the main avenue for proposing new features or changes.\n"
#~ "\n"
#~ "2.  They act as a platform for technical discussions within the\n"
#~ "    community.\n"
#~ "\n"
#~ "3.  They document the decision-making process, offering a historical\n"
#~ "    view of how Starknet has evolved."
#~ msgstr ""
#~ "1.  å®ƒä»¬æ˜¯æå‡ºæ–°åŠŸèƒ½æˆ–å˜æ›´çš„ä¸»è¦é€”å¾„ã€‚\n"
#~ "\n"
#~ "2.  å®ƒä»¬æ˜¯ç¤¾åŒºå†…æŠ€æœ¯è®¨è®ºçš„å¹³å°ã€‚\n"
#~ "\n"
#~ "3.  å®ƒä»¬è®°å½•äº†å†³ç­–è¿‡ç¨‹ï¼Œæä¾›äº†Starknet çš„å‘å±•å†ç¨‹ã€‚"

#~ msgid ""
#~ "In decentralized technology, Starknet offers a solution to challenges that previous systems encountered. It's based on established _protocols_ and _registries_, following the initial concepts "
#~ "introduced by figures such as Satoshi. Through a specific mathematical method, Starknet seeks a balance between scalability and consensus. As this technology progresses, Starknet adheres to "
#~ "principles of inclusivity, neutrality, and user empowerment. It's poised for continuous adaptation and improvement in the field."
#~ msgstr ""
#~ "åœ¨å»ä¸­å¿ƒåŒ–æŠ€æœ¯ä¸­ï¼ŒStarknetä¸ºè§£å†³ä»¥å¾€ç³»ç»Ÿé‡åˆ°çš„éš¾é¢˜æä¾›äº†è§£å†³æ–¹æ¡ˆã€‚å®ƒåŸºäºæ—¢å®šçš„ _åè®®_ å’Œ _ç™»è®°æœºæ„_ ï¼Œæ²¿è¢­äº†ä¸­æœ¬èªç­‰äººæå‡ºçš„æœ€åˆæ¦‚å¿µã€‚é€šè¿‡ç‰¹å®šçš„æ•°å­¦æ–¹æ³•ï¼ŒStarknetå¯»æ±‚å¯æ‰©å±•æ€§å’Œå…±è¯†ä¹‹é—´çš„å¹³è¡¡ã€‚éšç€æŠ€"
#~ "æœ¯çš„è¿›æ­¥ï¼ŒStarknetåšæŒåŒ…å®¹æ€§ã€ä¸­ç«‹æ€§å’Œç”¨æˆ·æˆæƒçš„åŸåˆ™ã€‚å®ƒå°†åœ¨è¯¥é¢†åŸŸä¸æ–­é€‚åº”å’Œæ”¹è¿›ã€‚"

#~ msgid "# Getting Started"
#~ msgstr "# å…¥é—¨"

#~ msgid ""
#~ "1. Visit [The Remix Project](https://remix.ethereum.org/).\n"
#~ "2. Navigate to the â€˜Pluginsâ€™ section in the bottom left corner.\n"
#~ "3. Enable the â€œStarknetâ€ plugin."
#~ msgstr ""
#~ "1.è¯·è®¿é—® [The Remix Project](https://remix.ethereum.org/)ã€‚\n"
#~ "2.å¯¼èˆªè‡³å·¦ä¸‹è§’çš„â€˜Pluginsâ€™éƒ¨åˆ†ã€‚\n"
#~ "3.å¯ç”¨ \"Starknet \"æ’ä»¶ã€‚"

#~ msgid "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"
#~ msgstr "<img alt=\"Activate the Starknet Plugin\" src=\"img/ch01-starknet-plugin.png\" class=\"center\" style=\"width: 100%;\" />"

#~ msgid "<span class=\"caption\">Activate the Starknet Plugin</span>"
#~ msgstr "<span class=\"caption\">æ¿€æ´»Starknetæ’ä»¶</span>"

#~ msgid "4. After enabling, the Starknet logo appears on the left sidebar. Click it to interact with opened Cairo files."
#~ msgstr "4.å¯ç”¨åï¼ŒStarknet å¾½æ ‡ä¼šå‡ºç°åœ¨å·¦ä¾§è¾¹æ ã€‚ç‚¹å‡»å®ƒå³å¯ä¸æ‰“å¼€çš„Cairoæ–‡ä»¶è¿›è¡Œäº¤äº’ã€‚"

#~ msgid ""
#~ "- An ownership system.\n"
#~ "- A method to transfer ownership.\n"
#~ "- A method to check the current owner.\n"
#~ "- An event notification for ownership changes."
#~ msgstr ""
#~ "- æ‰€æœ‰æƒç³»ç»Ÿã€‚\n"
#~ "- æ‰€æœ‰æƒè½¬ç§»æ–¹æ³•ã€‚\n"
#~ "- æ£€æŸ¥å½“å‰æ‰€æœ‰è€…çš„æ–¹æ³•ã€‚\n"
#~ "- æ‰€æœ‰æƒå˜æ›´äº‹ä»¶é€šçŸ¥ã€‚"

#~ msgid ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait OwnableTrait<T> {\n"
#~ "    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
#~ "    fn get_owner(self: @T) -> ContractAddress;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Ownable {\n"
#~ "    use super::ContractAddress;\n"
#~ "    use starknet::get_caller_address;\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    #[derive(Drop, starknet::Event)]\n"
#~ "    enum Event {\n"
#~ "      OwnershipTransferred1: OwnershipTransferred1,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop, starknet::Event)]\n"
#~ "    struct OwnershipTransferred1 {\n"
#~ "        #[key]\n"
#~ "        prev_owner: ContractAddress,\n"
#~ "        #[key]\n"
#~ "        new_owner: ContractAddress,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        owner: ContractAddress,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
#~ "        self.owner.write(init_owner);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
#~ "        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
#~ "            self.only_owner();\n"
#~ "            let prev_owner = self.owner.read();\n"
#~ "            self.owner.write(new_owner);\n"
#~ "            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
#~ "                prev_owner: prev_owner,\n"
#~ "                new_owner: new_owner,\n"
#~ "            }));\n"
#~ "        }\n"
#~ "\n"
#~ "        fn get_owner(self: @ContractState) -> ContractAddress {\n"
#~ "            self.owner.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    #[generate_trait]\n"
#~ "    impl PrivateMethods of PrivateMethodsTrait {\n"
#~ "        fn only_owner(self: @ContractState) {\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait OwnableTrait<T> {\n"
#~ "    fn transfer_ownership(ref self: T, new_owner: ContractAddress);\n"
#~ "    fn get_owner(self: @T) -> ContractAddress;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Ownable {\n"
#~ "    use super::ContractAddress;\n"
#~ "    use starknet::get_caller_address;\n"
#~ "\n"
#~ "    #[event]\n"
#~ "    #[derive(Drop, starknet::Event)]\n"
#~ "    enum Event {\n"
#~ "      OwnershipTransferred1: OwnershipTransferred1,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[derive(Drop, starknet::Event)]\n"
#~ "    struct OwnershipTransferred1 {\n"
#~ "        #[key]\n"
#~ "        prev_owner: ContractAddress,\n"
#~ "        #[key]\n"
#~ "        new_owner: ContractAddress,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        owner: ContractAddress,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(ref self: ContractState, init_owner: ContractAddress) {\n"
#~ "        self.owner.write(init_owner);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl OwnableImpl of super::OwnableTrait<ContractState> {\n"
#~ "        fn transfer_ownership(ref self: ContractState, new_owner: ContractAddress) {\n"
#~ "            self.only_owner();\n"
#~ "            let prev_owner = self.owner.read();\n"
#~ "            self.owner.write(new_owner);\n"
#~ "            self.emit(Event::OwnershipTransferred1(OwnershipTransferred1 {\n"
#~ "                prev_owner: prev_owner,\n"
#~ "                new_owner: new_owner,\n"
#~ "            }));\n"
#~ "        }\n"
#~ "\n"
#~ "        fn get_owner(self: @ContractState) -> ContractAddress {\n"
#~ "            self.owner.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    #[generate_trait]\n"
#~ "    impl PrivateMethods of PrivateMethodsTrait {\n"
#~ "        fn only_owner(self: @ContractState) {\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(caller == self.owner.read(), 'Caller is not the owner');\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. **Dependencies and Interface**:\n"
#~ "   - **`starknet::ContractAddress`**: Represents a Starknet contract address.\n"
#~ "   - **`OwnableTrait`**: Specifies functions for transferring and getting ownership.\n"
#~ "2. **Events**:\n"
#~ "   - **`OwnershipTransferred1`**: Indicates ownership change with previous and new owner details.\n"
#~ "3. **Storage**:\n"
#~ "   - **`Storage`**: Holds the contract's state with the current owner's address.\n"
#~ "4. **Constructor**:\n"
#~ "   - Initializes the contract with a starting owner.\n"
#~ "5. **External Functions**:\n"
#~ "   - Functions for transferring ownership and retrieving the current owner's details.\n"
#~ "6. **Private Methods**:\n"
#~ "   - **`only_owner`**: Validates if the caller is the current owner."
#~ msgstr ""
#~ "1. **ä¾èµ–å…³ç³»å’Œæ¥å£**ï¼š\n"
#~ "   - **`starknet::ContractAddress`**ï¼šä»£è¡¨Starknetåˆçº¦åœ°å€ã€‚\n"
#~ "   - **`OwnableTrait`**ï¼šæŒ‡å®šè½¬ç§»å’Œè·å–æ‰€æœ‰æƒçš„å‡½æ•°ã€‚\n"
#~ "2. **äº‹ä»¶**ï¼š\n"
#~ "   - **`OwnershipTransferred1`**ï¼šè¡¨ç¤ºæ‰€æœ‰æƒå˜æ›´ï¼ŒåŒ…å«å‰æ‰€æœ‰è€…å’Œæ–°æ‰€æœ‰è€…çš„è¯¦ç»†ä¿¡æ¯ã€‚\n"
#~ "3. **å­˜å‚¨**ï¼š\n"
#~ "   - **`Storage`**ï¼šåŒ…å«åˆçº¦çŠ¶æ€å’Œå½“å‰æ‰€æœ‰è€…çš„åœ°å€ã€‚\n"
#~ "4. **æ„é€ å‡½æ•°**ï¼š\n"
#~ "   - ç”¨èµ·å§‹æ‰€æœ‰è€…åˆå§‹åŒ–åˆçº¦ã€‚\n"
#~ "5. **å¤–éƒ¨å‡½æ•°**ï¼š\n"
#~ "   - ç”¨äºè½¬ç§»æ‰€æœ‰æƒå’Œè·å–å½“å‰æ‰€æœ‰è€…è¯¦ç»†ä¿¡æ¯çš„å‡½æ•°ã€‚\n"
#~ "6. **ç§æœ‰æ–¹æ³•**ï¼š\n"
#~ "   - **`only_owner`**ï¼šéªŒè¯è°ƒç”¨è€…æ˜¯å¦ä¸ºå½“å‰æ‰€æœ‰è€…ã€‚"

#~ msgid "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"
#~ msgstr "<img alt=\"Artifacts folder after compilation\" src=\"img/ch01-remix-file.png\" class=\"center\" style=\"width: 100%;\" />"

#~ msgid ""
#~ "1. **Select the Appropriate Network**\n"
#~ "\n"
#~ "   - Go to the Environment selection tab.\n"
#~ "   - Choose \"Remote Devnet\" for deploying your inaugural contract on a development network.\n"
#~ "\n"
#~ "2. **Choose a Devnet Account**\n"
#~ "\n"
#~ "   - Under \"Devnet account selection\", a list of accounts specific to the chosen devnet is presented.\n"
#~ "   - Pick any account and copy its address.\n"
#~ "\n"
#~ "3. **Initiating Deployment**\n"
#~ "\n"
#~ "   - Navigate to the \"Starknet\" tab.\n"
#~ "   - Input the copied address into the `init_owner` variable.\n"
#~ "   - Click on \"Deploy ownable.cairo\"."
#~ msgstr ""
#~ "1. **é€‰æ‹©åˆé€‚çš„ç½‘ç»œ**\n"
#~ "\n"
#~ "   - è½¬åˆ° \"Environment selection\" é€‰é¡¹å¡ã€‚\n"
#~ "   - é€‰æ‹© \"Remote Devnet\"ï¼ˆè¿œç¨‹å¼€å‘ç½‘ç»œï¼‰ï¼Œä»¥ä¾¿åœ¨å¼€å‘ç½‘ç»œä¸Šéƒ¨ç½²ä½ çš„ç¬¬ä¸€ä¸ªåˆçº¦ã€‚\n"
#~ "\n"
#~ "2. **é€‰æ‹©ä¸€ä¸ª Devnet è´¦æˆ·**\n"
#~ "\n"
#~ "   - åœ¨ \"Devnet account selection\"ä¸‹ï¼Œå°†æ˜¾ç¤ºæ‰€é€‰ Devnet çš„ä¸“å±å¸æˆ·åˆ—è¡¨ã€‚\n"
#~ "   - é€‰æ‹©ä»»æ„è´¦æˆ·å¹¶å¤åˆ¶å…¶åœ°å€ã€‚\n"
#~ "\n"
#~ "3. **å¯åŠ¨éƒ¨ç½²**\n"
#~ "\n"
#~ "   - å¯¼èˆªè‡³ \"Starknet \"é€‰é¡¹å¡ã€‚\n"
#~ "   - åœ¨ `init_owner` å˜é‡ä¸­è¾“å…¥å¤åˆ¶çš„åœ°å€ã€‚\n"
#~ "   - ç‚¹å‡» \"Deploy ownable.cairo\"ã€‚"

#~ msgid ""
#~ "- `transaction_hash`: The unique hash of the transaction. This hash can be used to track the transaction's status.\n"
#~ "- `contract_address`: The address of the deployed contract. Use this address to interact with your contract.\n"
#~ "- `calldata`: Contains the `init_owner` address fed to the constructor."
#~ msgstr ""
#~ "- `transaction_hash`ï¼šäº¤æ˜“çš„å”¯ä¸€å“ˆå¸Œå€¼ã€‚æ­¤å“ˆå¸Œå€¼å¯ç”¨äºè·Ÿè¸ªäº¤æ˜“çŠ¶æ€ã€‚\n"
#~ "- `contract_address`ï¼šå·²éƒ¨ç½²åˆçº¦çš„åœ°å€ã€‚ä½¿ç”¨æ­¤åœ°å€ä¸æ‚¨çš„åˆçº¦è¿›è¡Œäº¤äº’ã€‚\n"
#~ "- `calldata`ï¼šåŒ…å«æä¾›ç»™æ„é€ å‡½æ•°çš„ `init_owner` åœ°å€ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "{\n"
#~ "  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
#~ "  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
#~ "    ...\n"
#~ "  \"calldata\": [\n"
#~ "    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
#~ "  ],\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "{\n"
#~ "  \"transaction_hash\": \"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
#~ "  \"contract_address\": \"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
#~ "    ...\n"
#~ "  \"calldata\": [\n"
#~ "    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
#~ "  ],\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "1. **Initiating Interaction**\n"
#~ "\n"
#~ "   - Navigate to the \"Starknet\" tab.\n"
#~ "   - Select the \"Interact\" option.\n"
#~ "\n"
#~ "2. **Calling the `get_owner` Function**\n"
#~ "\n"
#~ "   - Choose the `get_owner` function. Since this function doesn't require arguments, the calldata field remains blank. (This is a read function, hence calling it is termed as a \"call\".)\n"
#~ "   - Press the \"get_owner\" button. Your terminal will display the result, revealing the owner's address provided during the contract's deployment as calldata for the constructor:"
#~ msgstr ""
#~ "1. **å¯åŠ¨äº¤äº’**\n"
#~ "\n"
#~ "   - å¯¼èˆªè‡³ \"Starknet \"é€‰é¡¹å¡ã€‚\n"
#~ "   - é€‰æ‹© \"Interact\" é€‰é¡¹ã€‚\n"
#~ "\n"
#~ "2. **è°ƒç”¨ `get_owner` å‡½æ•°**\n"
#~ "\n"
#~ "   - é€‰æ‹© `get_owner` å‡½æ•°ã€‚ç”±äºè¯¥å‡½æ•°ä¸éœ€è¦å‚æ•°ï¼Œå› æ­¤ calldata å­—æ®µä¿æŒç©ºç™½ã€‚(è¿™æ˜¯ä¸€ä¸ªåªè¯»å‡½æ•°ï¼Œå› æ­¤è°ƒç”¨å®ƒè¢«ç§°ä¸º \"call\"ï¼‰ã€‚\n"
#~ "   - æŒ‰ä¸‹ \"get_owner \"æŒ‰é’®ã€‚æ‚¨çš„ç»ˆç«¯å°†æ˜¾ç¤ºç»“æœï¼Œæ­ç¤ºåœ¨éƒ¨ç½²åˆçº¦æ—¶ä½œä¸ºæ„é€ å‡½æ•° calldata æä¾›çš„æ‰€æœ‰è€…åœ°å€ï¼š"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"response\": {\n"
#~ "    \"result\": [\n"
#~ "      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"contract\": \"ownable.cairo\",\n"
#~ "  \"function\": \"get_owner\"\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"response\": {\n"
#~ "    \"result\": [\n"
#~ "      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"contract\": \"ownable.cairo\",\n"
#~ "  \"function\": \"get_owner\"\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"response\": {\n"
#~ "    \"result\": [\n"
#~ "      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"contract\": \"ownable.cairo\",\n"
#~ "  \"function\": \"get_owner\"\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"response\": {\n"
#~ "    \"result\": [\n"
#~ "      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"contract\": \"ownable.cairo\",\n"
#~ "  \"function\": \"get_owner\"\n"
#~ "}\n"
#~ "```"

#~ msgid "### Smart Wallet Setup"
#~ msgstr "### æ™ºèƒ½é’±åŒ…è®¾ç½®"

#~ msgid ""
#~ "1. Install the recommended chrome/brave extension for your chosen wallet.\n"
#~ "2. Follow your wallet provider's instructions to deploy your account.\n"
#~ "3. Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your account.\n"
#~ "4. Deploy the account to the network. This usually takes around 10 seconds."
#~ msgstr ""
#~ "1. ä¸ºæ‰€é€‰é’±åŒ…å®‰è£…æ¨èçš„ chrome/brave æ‰©å±•ç¨‹åºã€‚\n"
#~ "2. æŒ‰ç…§é’±åŒ…æä¾›å•†çš„è¯´æ˜éƒ¨ç½²è´¦æˆ·ã€‚\n"
#~ "3. ä½¿ç”¨ [Starknet Faucet](https://faucet.goerli.starknet.io/) ä¸ºè´¦æˆ·å……å€¼ã€‚\n"
#~ "4. å°†è´¦æˆ·éƒ¨ç½²åˆ°ç½‘ç»œã€‚è¿™é€šå¸¸éœ€è¦ 10 ç§’é’Ÿå·¦å³ã€‚"

#~ msgid ""
#~ "- Frameworks: Build using Starknet-Foundry\n"
#~ "\n"
#~ "- SDKs: Discover multi-language support through Starknet.js,\n"
#~ "  Starknet-rs, Starknet_py, and Caigo\n"
#~ "\n"
#~ "- Front-end Development: Use Starknet.js and React\n"
#~ "\n"
#~ "- Testing: Understand testing methods with Starknet-Foundry and the Devnet"
#~ msgstr ""
#~ "- æ¡†æ¶ï¼šä½¿ç”¨ Starknet-Foundry æ„å»º\n"
#~ "\n"
#~ "- SDKï¼šé€šè¿‡ Starknet.jsï¼ŒStarknet-rsï¼ŒStarknet_py å’Œ Caigo æä¾›å¤šè¯­è¨€æ”¯æŒ\n"
#~ "\n"
#~ "- å‰ç«¯å¼€å‘ï¼šä½¿ç”¨ Starknet.js å’Œ React\n"
#~ "\n"
#~ "- æµ‹è¯•ï¼šäº†è§£ä½¿ç”¨ Starknet-Foundry å’Œ Devnet çš„æµ‹è¯•æ–¹æ³•"

#~ msgid ""
#~ "1.  Scarb: A package manager that compiles your contracts.\n"
#~ "\n"
#~ "2.  Starkli: A CLI tool for interacting with the Starknet network.\n"
#~ "\n"
#~ "3.  Starknet Foundry: For contract testing.\n"
#~ "\n"
#~ "4.  Katana: Creates a local test node.\n"
#~ "\n"
#~ "5.  SDKs: starknet.js, Starknet.py, and starknet.rs interface with\n"
#~ "    Starknet using common programming languages.\n"
#~ "\n"
#~ "6.  Starknet-react: Builds front-end apps using React."
#~ msgstr ""
#~ "1.  Scarbï¼šç¼–è¯‘åˆçº¦çš„è½¯ä»¶åŒ…ç®¡ç†å™¨\n"
#~ "\n"
#~ "2.  Starkliï¼šç”¨äºä¸ Starknet ç½‘ç»œäº¤äº’çš„ CLI å·¥å…·ã€‚\n"
#~ "\n"
#~ "3.  Foundryï¼šç”¨äºåˆçº¦æµ‹è¯•ã€‚\n"
#~ "\n"
#~ "4.  Katanaï¼šåˆ›å»ºæœ¬åœ°æµ‹è¯•èŠ‚ç‚¹ã€‚\n"
#~ "\n"
#~ "5.  SDKï¼šstarknet.jsã€Starknet.py å’Œ starknet.rs ã€‚è¿™äº›æ˜¯ä½¿ç”¨æ™®é€šç¼–ç¨‹è¯­è¨€ä¸Starknet äº¤äº’çš„æ¥å£ã€‚\n"
#~ "\n"
#~ "6.  Starknet-reactï¼šä½¿ç”¨ React æ„å»ºå‰ç«¯åº”ç”¨ç¨‹åºã€‚"

#~ msgid ""
#~ "1.  [Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for\n"
#~ "    interacting with Starknet. More tools are discussed in Chapter 2.\n"
#~ "\n"
#~ "2.  [Scarb](https://github.com/software-mansion/scarb) - Cairoâ€™s package\n"
#~ "    manager that compiles code to Sierra, a mid-level language between\n"
#~ "    Cairo and CASM.\n"
#~ "\n"
#~ "3.  [Katana](https://github.com/dojoengine/dojo) - Katana is a Starknet node, built for local development."
#~ msgstr ""
#~ "1.  [Starkli](https://github.com/xJonathanLEI/starkli) - ä¸Starknetäº¤äº’çš„ CLI å·¥å…·ã€‚ç¬¬ 2 ç« å°†è®¨è®ºæ›´å¤šå·¥å…·ã€‚\n"
#~ "\n"
#~ "2.  [Scarb](https://github.com/software-mansion/scarb) - Cairo çš„è½¯ä»¶åŒ…ç®¡ç†å™¨ï¼Œå¯å°†ä»£ç ç¼–è¯‘ä¸º Sierraï¼Œä¸€ç§ä»‹äº Cairo å’Œ CASM ä¹‹é—´çš„ä¸­çº§è¯­è¨€ã€‚\n"
#~ "3.  [Katana](https://github.com/dojoengine/dojo) - Katana æ˜¯ä¸€ä¸ª StarknetèŠ‚ç‚¹ï¼Œç”¨äºæœ¬åœ°å¼€å‘ã€‚."

#~ msgid ""
#~ "```bash\n"
#~ "curl https://get.starkli.sh | sh\n"
#~ "starkliup\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "curl https://get.starkli.sh | sh\n"
#~ "starkliup\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli --version\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli --version\n"
#~ "```"

#~ msgid "We will get deeper into Scarb later in this chapter. For now, we will go over the installation process."
#~ msgstr "æœ¬ç« ç¨åæˆ‘ä»¬å°†æ·±å…¥ä»‹ç» Scarbã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä»‹ç»å®‰è£…è¿‡ç¨‹ã€‚"

#~ msgid "For macOS and Linux:"
#~ msgstr "å¯¹äº macOS å’Œ Linuxä¸Šï¼š"

#~ msgid "To upgrade Scarb, rerun the installation command."
#~ msgstr "è¦å‡çº§ Scarbï¼Œè¯·é‡æ–°è¿è¡Œå®‰è£…å‘½ä»¤ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "curl -L https://install.dojoengine.org | bash\n"
#~ "dojoup\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "curl -L https://install.dojoengine.org | bash\n"
#~ "dojoup\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "katana --version\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana --version\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    scarb --version  # For Cairo code compilation\n"
#~ "    starkli --version  # To interact with Starknet\n"
#~ "    katana --version # To declare and deploy on local development\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb --version  # For Cairo code compilation\n"
#~ "    starkli --version  # To interact with Starknet\n"
#~ "    katana --version # To declare and deploy on local development\n"
#~ "```"

#~ msgid "## [OPTIONAL] Checking Supported Compiler Versions"
#~ msgstr "## [å¯é€‰] æ£€æŸ¥æ”¯æŒçš„ç¼–è¯‘å™¨ç‰ˆæœ¬"

#~ msgid "If issues arise during the declare or deploy process, ensure that the Starkli compiler version aligns with the Scarb compiler version."
#~ msgstr "å¦‚æœåœ¨å£°æ˜æˆ–éƒ¨ç½²è¿‡ç¨‹ä¸­å‡ºç°é—®é¢˜ï¼Œè¯·ç¡®ä¿ Starkli ç¼–è¯‘å™¨ç‰ˆæœ¬ä¸ Scarb ç¼–è¯‘å™¨ç‰ˆæœ¬ä¸€è‡´ã€‚"

#~ msgid "To check the compiler versions Starkli supports, run:"
#~ msgstr "è¦æ£€æŸ¥ Starkli æ”¯æŒçš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œè¯·è¿è¡Œï¼š"

#~ msgid ""
#~ "```bash\n"
#~ "starkli declare --help\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli declare --help\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "Youâ€™ll see a list of possible compiler versions under the\n"
#~ "`--compiler-version` flag."
#~ msgstr "ä½ ä¼šåœ¨ `--compiler-version` æ ‡å¿—ä¸‹çœ‹åˆ°å¯ä½¿ç”¨çš„ç¼–è¯‘å™¨ç‰ˆæœ¬åˆ—è¡¨ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "    ...\n"
#~ "    --compiler-version <COMPILER_VERSION>\n"
#~ "              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
#~ "    ...\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    ...\n"
#~ "    --compiler-version <COMPILER_VERSION>\n"
#~ "              Statically-linked Sierra compiler version [possible values: [COMPILER VERSIONS]]]\n"
#~ "    ...\n"
#~ "```"

#~ msgid "Be aware: Scarb's compiler version may not match Starkliâ€™s. To verify Scarb's version:"
#~ msgstr "è¯·æ³¨æ„ï¼šScarb çš„ç¼–è¯‘å™¨ç‰ˆæœ¬å¯èƒ½ä¸ Starkli çš„ä¸ä¸€è‡´ã€‚è¦éªŒè¯ Scarb çš„ç‰ˆæœ¬è¯·å…è®¸ï¼š"

#~ msgid ""
#~ "```bash\n"
#~ "    scarb --version\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb --version\n"
#~ "```"

#~ msgid "The output displays the versions for scarb, cairo, and sierra:"
#~ msgstr "The output displays the versions for scarb, cairo, and sierra:"

#~ msgid ""
#~ "```bash\n"
#~ "    scarb <SCARB VERSION>\n"
#~ "    cairo: <COMPILER VERSION>\n"
#~ "    sierra: <SIERRA VERSION>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb <SCARB VERSION>\n"
#~ "    cairo: <COMPILER VERSION>\n"
#~ "    sierra: <SIERRA VERSION>\n"
#~ "```"

#~ msgid ""
#~ "If the versions don't match, consider installing a version of Scarb compatible with Starkli. Browse [Scarb's GitHub](https://github.com/software-mansion/scarb/releases) repo for earlier releases."
#~ msgstr "å¦‚æœç‰ˆæœ¬ä¸åŒ¹é…ï¼Œè¯·è€ƒè™‘å®‰è£…ä¸ Starkli å…¼å®¹çš„ Scarb ç‰ˆæœ¬ã€‚è¯·æµè§ˆ [Scarb's GitHub](https://github.com/software-mansion/scarb/releases) ä»“åº“ï¼ŒæŸ¥çœ‹æ—©æœŸç‰ˆæœ¬ã€‚"

#~ msgid "To install a specific version, such as `2.3.0`, run:"
#~ msgstr "è¦å®‰è£…ç‰¹å®šç‰ˆæœ¬ï¼Œå¦‚ `2.3.0`ï¼Œè¯·è¿è¡Œï¼š"

#~ msgid ""
#~ "```bash\n"
#~ "    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 2.3.0\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh -s -- -v 2.3.0\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "scarb new my_contract\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "scarb new my_contract\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    src/\n"
#~ "      lib.cairo\n"
#~ "    .gitignore\n"
#~ "    Scarb.toml\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    src/\n"
#~ "      lib.cairo\n"
#~ "    .gitignore\n"
#~ "    Scarb.toml\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "export STARKNET_ACCOUNT=katana-0\n"
#~ "export STARKNET_RPC=http://0.0.0.0:5050\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "export STARKNET_ACCOUNT=katana-0\n"
#~ "export STARKNET_RPC=http://0.0.0.0:5050\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod hello {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        name: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(ref self: ContractState, name: felt252) {\n"
#~ "        self.name.write(name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "        fn get_name(self: @ContractState) -> felt252 {\n"
#~ "            self.name.read()\n"
#~ "        }\n"
#~ "    #[external(v0)]\n"
#~ "        fn set_name(ref self: ContractState, name: felt252) {\n"
#~ "            let previous = self.name.read();\n"
#~ "            self.name.write(name);\n"
#~ "        }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod hello {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        name: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(ref self: ContractState, name: felt252) {\n"
#~ "        self.name.write(name);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "        fn get_name(self: @ContractState) -> felt252 {\n"
#~ "            self.name.read()\n"
#~ "        }\n"
#~ "    #[external(v0)]\n"
#~ "        fn set_name(ref self: ContractState, name: felt252) {\n"
#~ "            let previous = self.name.read();\n"
#~ "            self.name.write(name);\n"
#~ "        }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "scarb build\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "scarb build\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "source .env\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "source .env\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "katana\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli declare target/dev/my_contract_hello.contract_class.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli declare target/dev/my_contract_hello.contract_class.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Class hash declared: 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Not declaring class as its already declared. Class hash:\n"
#~ "0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Not declaring class as its already declared. Class hash:\n"
#~ "0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        <CLASS_HASH> \\\n"
#~ "        <CONSTRUCTOR_INPUTS>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        <CLASS_HASH> \\\n"
#~ "        <CONSTRUCTOR_INPUTS>\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli to-cairo-string <STRING>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli to-cairo-string <STRING>\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli to-cairo-string starknetbook\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli to-cairo-string starknetbook\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    0x737461726b6e6574626f6f6b\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    0x737461726b6e6574626f6f6b\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
#~ "        0x737461726b6e6574626f6f6b\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 \\\n"
#~ "        0x737461726b6e6574626f6f6b\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
#~ "    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
#~ "    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
#~ "    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Deploying class 0x00bfb49ff80fd7ef5e84662d6d256d49daf75e0c5bd279b20a786f058ca21418 with salt 0x054645c0d1e766ddd927b3bde150c0a3dc0081af7fb82160c1582e05f6018794...\n"
#~ "    The contract will be deployed at address 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
#~ "    Contract deployment transaction: 0x00413d9638fecb75eb07593b5c76d13a68e4af7962c368c5c2e810e7a310d54c\n"
#~ "    Contract deployed: 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli call \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        get_name\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli call \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        get_name\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli parse-cairo-string 0x737461726b6e6574626f6f6b\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starknetbook\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starknetbook\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli invoke \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        set_name \\\n"
#~ "        <felt252>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli invoke \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        set_name \\\n"
#~ "        <felt252>\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli to-cairo-string Omar\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli to-cairo-string Omar\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    0x4f6d6172\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    0x4f6d6172\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli invoke 0x07cdd583619462c2b14532eddb2b169b8f8d94b63bfb5271dae6090f95147a44 set_name 0x4f6d6172\n"
#~ "```"

#~ msgid "# Scarb: The Package Manager"
#~ msgstr "# Scarbï¼šè½¯ä»¶åŒ…ç®¡ç†å™¨"

#~ msgid ""
#~ "1.  **Initialize:** Use `scarb new` to set up a new project, generating\n"
#~ "    a `Scarb.toml` file and initial `src/lib.cairo`.\n"
#~ "\n"
#~ "2.  **Code:** Add your Cairo code in the `src` directory.\n"
#~ "\n"
#~ "3.  **Dependencies:** Add external libraries using `scarb add`.\n"
#~ "\n"
#~ "4.  **Compile:** Execute `scarb build` to convert your contract into\n"
#~ "    Sierra code."
#~ msgstr ""
#~ "1.  **åˆå§‹åŒ–ï¼š** ä½¿ç”¨ `scarb new` å»ºç«‹ä¸€ä¸ªæ–°é¡¹ç›®ï¼Œç”Ÿæˆ `Scarb.toml` æ–‡ä»¶å’Œåˆå§‹çš„ `src/lib.cairo` æ–‡ä»¶ã€‚\n"
#~ "\n"
#~ "2.  **ä»£ç ï¼š** åœ¨`src`ç›®å½•ä¸‹æ·»åŠ ä½ çš„Cairoä»£ç ã€‚\n"
#~ "\n"
#~ "3.  **ä¾èµ–ï¼š** ä½¿ç”¨ `scarb add` æ·»åŠ å¤–éƒ¨åº“ã€‚\n"
#~ "\n"
#~ "4.  **ç¼–è¯‘ï¼š** æ‰§è¡Œ `scarb build` å°†åˆçº¦è½¬æ¢ä¸ºSierra ä»£ç ã€‚"

#~ msgid ""
#~ "my_package/\n"
#~ "    â”œâ”€â”€ src/\n"
#~ "    â”‚   â”œâ”€â”€ module1.cairo\n"
#~ "    â”‚   â”œâ”€â”€ module2.cairo\n"
#~ "    â”‚   â””â”€â”€ lib.cairo\n"
#~ "    â”œâ”€â”€ snips/\n"
#~ "    â”‚   â”œâ”€â”€ src/\n"
#~ "    â”‚   â”‚   â”œâ”€â”€ lib.cairo\n"
#~ "    â”‚   â”œâ”€â”€ Scarb.toml\n"
#~ "    â””â”€â”€ Scarb.toml"
#~ msgstr ""
#~ "my_package/\n"
#~ "    â”œâ”€â”€ src/\n"
#~ "    â”‚   â”œâ”€â”€ module1.cairo\n"
#~ "    â”‚   â”œâ”€â”€ module2.cairo\n"
#~ "    â”‚   â””â”€â”€ lib.cairo\n"
#~ "    â”œâ”€â”€ snips/\n"
#~ "    â”‚   â”œâ”€â”€ src/\n"
#~ "    â”‚   â”‚   â”œâ”€â”€ lib.cairo\n"
#~ "    â”‚   â”œâ”€â”€ Scarb.toml\n"
#~ "    â””â”€â”€ Scarb.toml"

#~ msgid "$ scarb new hello_scarb"
#~ msgstr "$ scarb new hello_scarb"

#~ msgid ""
#~ "hello_scarb/\n"
#~ "    â”œâ”€â”€ src/\n"
#~ "    â”‚   â””â”€â”€ lib.cairo\n"
#~ "    â””â”€â”€ Scarb.toml"
#~ msgstr ""
#~ "hello_scarb/\n"
#~ "    â”œâ”€â”€ src/\n"
#~ "    â”‚   â””â”€â”€ lib.cairo\n"
#~ "    â””â”€â”€ Scarb.toml"

#~ msgid "scarb build"
#~ msgstr "scarb build"

#~ msgid ""
#~ "- `scarb new <project_name>`: Initialize a new project with the given\n"
#~ "  project name.\n"
#~ "\n"
#~ "- `scarb build`: Compile your Cairo code into Sierra code.\n"
#~ "\n"
#~ "- `scarb add <dependency> --git <repository>`: Add a dependency to\n"
#~ "  your project from a specified Git repository.\n"
#~ "\n"
#~ "- `scarb rm <dependency>`: Remove a dependency from your project.\n"
#~ "\n"
#~ "- `scarb run <script>`: Run a custom script defined in your\n"
#~ "  `Scarb.toml` file."
#~ msgstr ""
#~ "- `scarb new<project_name>`ï¼šç”¨ç»™å®šçš„é¡¹ç›®åç§°åˆå§‹åŒ–ä¸€ä¸ªæ–°é¡¹ç›®ã€‚\n"
#~ "\n"
#~ "- `scarb build`ï¼šå°† Cairo ä»£ç ç¼–è¯‘æˆ Sierra ä»£ç ã€‚\n"
#~ "\n"
#~ "- `scarb add<dependency> --git<repository>`ï¼šä»æŒ‡å®šçš„ Gitä»“åº“æ·»åŠ ä¸€ä¸ªä¾èµ–é¡¹ã€‚\n"
#~ "\n"
#~ "- `scarb rm<dependency>`ï¼šä»é¡¹ç›®ä¸­ç§»é™¤ä¾èµ–é¡¹ã€‚\n"
#~ "\n"
#~ "- `scarb run<script>`ï¼šè¿è¡Œæ‚¨åœ¨æ–‡ä»¶ä¸­å®šä¹‰çš„è‡ªå®šä¹‰è„šæœ¬ã€‚"

#~ msgid "# Katana: A Local Node"
#~ msgstr "# Katana: æœ¬åœ°èŠ‚ç‚¹"

#~ msgid ""
#~ "```bash\n"
#~ "katana --accounts 3 --seed 0 --gas-price 250\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "katana --accounts 3 --seed 0 --gas-price 250\n"
#~ "```"

#~ msgid "# Testnet Deployment"
#~ msgstr "# æµ‹è¯•ç½‘éƒ¨ç½²"

#~ msgid ""
#~ "```bash\n"
#~ "    scarb --version  # For Cairo code compilation\n"
#~ "    starkli --version  # To interact with Starknet\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb --version  # For Cairo code compilation\n"
#~ "    starkli --version  # To interact with Starknet\n"
#~ "```"

#~ msgid "Now youâ€™re ready to interact with Starknet smart contracts."
#~ msgstr "ç°åœ¨ï¼Œæ‚¨å·²ç»å‡†å¤‡å¥½ä¸Starknetæ™ºèƒ½åˆçº¦äº¤äº’äº†ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "    mkdir -p ~/.starkli-wallets/deployer\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    mkdir -p ~/.starkli-wallets/deployer\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
#~ "    Enter private key:\n"
#~ "    Enter password:\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli signer keystore from-key ~/.starkli-wallets/deployer/my_keystore_1.json\n"
#~ "    Enter private key:\n"
#~ "    Enter password:\n"
#~ "```"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"crypto\": {\n"
#~ "    \"cipher\": \"aes-128-ctr\",\n"
#~ "    \"cipherparams\": {\n"
#~ "      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
#~ "    },\n"
#~ "    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
#~ "    \"kdf\": \"scrypt\",\n"
#~ "    \"kdfparams\": {\n"
#~ "      \"dklen\": 32,\n"
#~ "      \"n\": 8192,\n"
#~ "      \"p\": 1,\n"
#~ "      \"r\": 8,\n"
#~ "      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
#~ "    },\n"
#~ "    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
#~ "  },\n"
#~ "  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
#~ "  \"version\": 3\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"crypto\": {\n"
#~ "    \"cipher\": \"aes-128-ctr\",\n"
#~ "    \"cipherparams\": {\n"
#~ "      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
#~ "    },\n"
#~ "    \"ciphertext\": \"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
#~ "    \"kdf\": \"scrypt\",\n"
#~ "    \"kdfparams\": {\n"
#~ "      \"dklen\": 32,\n"
#~ "      \"n\": 8192,\n"
#~ "      \"p\": 1,\n"
#~ "      \"r\": 8,\n"
#~ "      \"salt\": \"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
#~ "    },\n"
#~ "    \"mac\": \"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
#~ "  },\n"
#~ "  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
#~ "  \"version\": 3\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- **`version`**: The version of the smart wallet implementation.\n"
#~ "\n"
#~ "- **`id`**: A randomly generated identification string.\n"
#~ "\n"
#~ "- **`crypto`**: Houses all encryption details."
#~ msgstr ""
#~ "- **`version`**: æ™ºèƒ½é’±åŒ…çš„å®ç°ç‰ˆæœ¬ã€‚\n"
#~ "\n"
#~ "- **`id`**ï¼šéšæœºç”Ÿæˆçš„æ ‡è¯†å­—ç¬¦ä¸²ã€‚\n"
#~ "\n"
#~ "- **`crypto`**ï¼šåŒ…å«æ‰€æœ‰åŠ å¯†ç»†èŠ‚ã€‚"

#~ msgid ""
#~ "- **`cipher`**: Specifies the encryption algorithm used, which in this\n"
#~ "  case is AES-128-CTR.\n"
#~ "\n"
#~ "  - **AES (Advanced Encryption Standard)**: A globally accepted\n"
#~ "    encryption standard.\n"
#~ "\n"
#~ "  - **128**: Refers to the key size in bits, making it a 128-bit\n"
#~ "    key.\n"
#~ "\n"
#~ "  - **CTR (Counter Mode)**: A specific mode of operation for the AES\n"
#~ "    cipher.\n"
#~ "\n"
#~ "- **`cipherparams`**: Contains an Initialization Vector (IV), which\n"
#~ "  ensures that encrypting the same plaintext with the same key will\n"
#~ "  produce different ciphertexts.\n"
#~ "\n"
#~ "  - **`iv` (Initialization Vector)**: A 16-byte hex string that\n"
#~ "    serves as a random and unique starting point for each encryption\n"
#~ "    operation.\n"
#~ "\n"
#~ "- **`ciphertext`**: This is the private key after encryption, securely\n"
#~ "  stored so that only the correct password can reveal it.\n"
#~ "\n"
#~ "- **`kdf` and `kdfparams`**: KDF stands for Key Derivation Function.\n"
#~ "  This adds a layer of security by requiring computational work,\n"
#~ "  making brute-force attacks harder.\n"
#~ "\n"
#~ "  - **`dklen`**: The length (in bytes) of the derived key. Typically\n"
#~ "    32 bytes.\n"
#~ "\n"
#~ "  - **`n`**: A cost factor representing CPU/memory usage. A higher\n"
#~ "    value means more computational work is needed, thus increasing\n"
#~ "    security.\n"
#~ "\n"
#~ "  - **`p`**: Parallelization factor, affecting the computational\n"
#~ "    complexity.\n"
#~ "\n"
#~ "  - **`r`**: Block size for the hash function, again affecting\n"
#~ "    computational requirements.\n"
#~ "\n"
#~ "  - **`salt`**: A random value that is combined with the password to\n"
#~ "    deter dictionary attacks.\n"
#~ "\n"
#~ "- **`mac` (Message Authentication Code)**: This is a cryptographic\n"
#~ "  code that ensures the integrity of the message (the encrypted\n"
#~ "  private key in this case). It is generated using a hash of both the\n"
#~ "  ciphertext and a portion of the derived key."
#~ msgstr ""
#~ "- **`cipher`**ï¼šæŒ‡å®šæ‰€ä½¿ç”¨çš„åŠ å¯†ç®—æ³•ï¼Œæœ¬ä¾‹ä¸­ä¸º AES-128-CTRã€‚\n"
#~ "\n"
#~ "  - **AESï¼ˆé«˜çº§åŠ å¯†æ ‡å‡†ï¼‰**ï¼šå…¨çƒå…¬è®¤çš„åŠ å¯†æ ‡å‡†ã€‚\n"
#~ "\n"
#~ "  - **128**ï¼šæŒ‡å¯†é’¥å¤§å°ï¼ˆæ¯”ç‰¹ï¼‰ï¼Œå³ 128 ä½å¯†é’¥ã€‚\n"
#~ "\n"
#~ "  - **CTRï¼ˆè®¡æ•°å™¨æ¨¡å¼ï¼‰**ï¼šAESå¯†ç çš„ä¸€ç§ç‰¹å®šæ“ä½œæ¨¡å¼ã€‚\n"
#~ "\n"
#~ "- **`cipherparams`**ï¼šåŒ…å«åˆå§‹åŒ–å‘é‡ï¼ˆIVï¼‰ï¼Œå®ƒå¯ç¡®ä¿ç”¨ç›¸åŒçš„å¯†é’¥åŠ å¯†ç›¸åŒçš„æ˜æ–‡ä¼šäº§ç”Ÿä¸åŒçš„å¯†æ–‡ã€‚\n"
#~ "\n"
#~ "  - **`iv`ï¼ˆåˆå§‹åŒ–å‘é‡ï¼‰**ï¼šä¸€ä¸ª 16 å­—èŠ‚åå…­è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œ\n"
#~ "    ä½œä¸ºæ¯ä¸ªåŠ å¯†æ“ä½œçš„éšæœºå’Œå”¯ä¸€èµ·ç‚¹ã€‚\n"
#~ "\n"
#~ "- **`ciphertext`**ï¼šè¿™æ˜¯åŠ å¯†åçš„ç§äººå¯†é’¥ï¼Œè¢«å®‰å…¨åœ°\n"
#~ "  å­˜å‚¨ï¼Œå› æ­¤åªæœ‰æ­£ç¡®çš„å¯†ç æ‰èƒ½æ˜¾ç¤ºå®ƒã€‚\n"
#~ "\n"
#~ "- **`kdf` å’Œ`kdfparams`**ï¼šKDF ä»£è¡¨å¯†é’¥è¡ç”Ÿå‡½æ•°ã€‚\n"
#~ "  è§£å¼€å®ƒéœ€è¦å¤§é‡çš„è®¡ç®—å·¥ä½œï¼Œä»è€Œå¢åŠ äº†ä¸€å±‚å®‰å…¨æ€§ã€\n"
#~ "  ä½¿æš´åŠ›ç ´è§£æ›´åŠ å›°éš¾ã€‚\n"
#~ "\n"
#~ "  - **dklen`**ï¼šæ´¾ç”Ÿå¯†é’¥çš„é•¿åº¦ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ã€‚é€šå¸¸ä¸º32 å­—èŠ‚ã€‚\n"
#~ "\n"
#~ "  - **`n`**:ä»£è¡¨ CPU/å†…å­˜ä½¿ç”¨é‡çš„æˆæœ¬ç³»æ•°ã€‚å€¼è¶Šé«˜\n"
#~ "    æ„å‘³ç€éœ€è¦æ›´å¤šçš„è®¡ç®—å·¥ä½œï¼Œä»è€Œå¢åŠ äº†å®‰å…¨æ€§ã€‚\n"
#~ "\n"
#~ "  - **`p`**:å¹¶è¡ŒåŒ–ç³»æ•°ï¼Œå½±å“è®¡ç®—å¤æ‚åº¦ã€‚\n"
#~ "\n"
#~ "  - **`r`**:æ•£åˆ—å‡½æ•°çš„å—å¤§å°ï¼ŒåŒæ ·å½±å“è®¡ç®—è¦æ±‚ã€‚\n"
#~ "\n"
#~ "  - **`salt`**ï¼šéšæœºå€¼ï¼šä¸å¯†ç ç›¸ç»“åˆçš„éšæœºå€¼ï¼Œç”¨äºé˜²æŠ¤å­—å…¸æ”»å‡»ã€‚\n"
#~ "\n"
#~ "- **`mac`ï¼ˆä¿¡æ¯éªŒè¯ç ï¼‰**ï¼šè¿™æ˜¯ä¸€ä¸ªåŠ å¯†\n"
#~ "ä»£ç ï¼Œå¯ç¡®ä¿ä¿¡æ¯ï¼ˆæœ¬ä¾‹ä¸­ä¸ºåŠ å¯†ç§é’¥ï¼‰çš„å®Œæ•´æ€§ã€‚\n"
#~ "  å®ƒæ˜¯ä½¿ç”¨å¯†æ–‡å’Œéƒ¨åˆ†è¡ç”Ÿå¯†é’¥çš„å“ˆå¸Œå€¼ç”Ÿæˆçš„ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli account fetch <SMART_WALLET_ADDRESS> --output ~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Account contract type identified as: Braavos\n"
#~ "    Description: Braavos official proxy account\n"
#~ "    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Account contract type identified as: Braavos\n"
#~ "    Description: Braavos official proxy account\n"
#~ "    Downloaded new account config file: ~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Error: code=ContractNotFound, message=\"Contract with address {SMART_WALLET_ADDRESS} is not deployed.\"\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Error: code=ContractNotFound, message=\"Contract with address {SMART_WALLET_ADDRESS} is not deployed.\"\n"
#~ "```"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"braavos\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
#~ "    \"multisig\": {\n"
#~ "      \"status\": \"off\"\n"
#~ "    },\n"
#~ "    \"signers\": [\n"
#~ "      {\n"
#~ "        \"type\": \"stark\",\n"
#~ "        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
#~ "      }\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"deployed\",\n"
#~ "    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
#~ "    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"braavos\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"implementation\": \"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
#~ "    \"multisig\": {\n"
#~ "      \"status\": \"off\"\n"
#~ "    },\n"
#~ "    \"signers\": [\n"
#~ "      {\n"
#~ "        \"type\": \"stark\",\n"
#~ "        \"public_key\": \"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
#~ "      }\n"
#~ "    ]\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"deployed\",\n"
#~ "    \"class_hash\": \"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
#~ "    \"address\": \"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    export STARKNET_ACCOUNT=~/.starkli-wallets/deployer/my_account_1.json\n"
#~ "    export STARKNET_KEYSTORE=~/.starkli-wallets/deployer/my_keystore_1.json\n"
#~ "```"

#~ msgid ""
#~ "- Declare your contractâ€™s code.\n"
#~ "\n"
#~ "- Deploy an instance of the declared code."
#~ msgstr ""
#~ "- å£°æ˜æ‚¨çš„åˆçº¦ä»£ç ã€‚\n"
#~ "\n"
#~ "- éƒ¨ç½²å·²å£°æ˜ä»£ç çš„å®ä¾‹ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "    scarb build\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    scarb build\n"
#~ "```"

#~ msgid ""
#~ "With the smart contract compiled, weâ€™re ready to declare it using\n"
#~ "Starkli. Before declaring your contract, decide on an RPC provider."
#~ msgstr "ç¼–è¯‘å¥½æ™ºèƒ½åˆçº¦åï¼Œæˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨ Starkli å£°æ˜å®ƒäº†ã€‚åœ¨å£°æ˜åˆçº¦ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å†³å®šä½¿ç”¨å“ªä¸ª RPC æä¾›å•†ã€‚"

#~ msgid ""
#~ "1.  **Starknet Sequencerâ€™s Gateway**: The quickest option and itâ€™s the\n"
#~ "    default for Starkli for now. The sequencer gateway is deprecated and\n"
#~ "    will be disabled by StarkWare soon. Youâ€™re strongly recommended to\n"
#~ "    use a third-party JSON-RPC API provider like Infura, Alchemy, or\n"
#~ "    Chainstack.\n"
#~ "\n"
#~ "2.  **Infura or Alchemy**: A step up in complexity. Youâ€™ll need to set\n"
#~ "    up an API key and choose an endpoint. For Infura, it would look like\n"
#~ "    `https://starknet-goerli.infura.io/v3/<API_KEY>`. Learn more in the\n"
#~ "    [Infura\n"
#~ "    documentation](https://docs.infura.io/networks/starknet/how-to/choose-a-network).\n"
#~ "\n"
#~ "3.  **Your Own Node**: For those who want full control. Itâ€™s the most\n"
#~ "    complex but offers the most freedom. Check out [Chapter 4 of the\n"
#~ "    Starknet Book](https://book.starknet.io/chapter_4/node.html) or\n"
#~ "    [Kasar](https://www.kasar.io/) for setup guides."
#~ msgstr ""
#~ "1.  **Starknetæ’åºå™¨ç½‘å…³**ï¼šæœ€å¿«æ·çš„é€‰æ‹©ï¼ŒStarkli ç›®å‰çš„é»˜è®¤è®¾ç½®ã€‚ä½†æ’åºå™¨ç½‘å…³å·²è¢«å¼ƒç”¨ï¼Œå¾ˆå¿« StarkWare å°†å…³é—­å®ƒã€‚\n"
#~ "    å¼ºçƒˆå»ºè®®ä½¿ç”¨ç¬¬ä¸‰æ–¹ JSON-RPC API æä¾›å•†ï¼Œå¦‚ Infuraã€Alchemy æˆ–Chainstack ç­‰ã€‚\n"
#~ "\n"
#~ "2.  **Infuraæˆ–Alchemy**ï¼šå¤æ‚åº¦æ›´é«˜ã€‚æ‚¨éœ€è¦è®¾ç½®API å¯†é’¥å¹¶é€‰æ‹©ä¸€ä¸ªç«¯ç‚¹ã€‚å¯¹äº Infuraï¼Œå®ƒçœ‹èµ·æ¥åº”è¯¥æ˜¯\n"
#~ "    `https://starknet-goerli.infura.io/v3/<API_KEY>`ã€‚è¯·å‚é˜…[Infura æ–‡æ¡£](https://docs.infura.io/networks/starknet/how-to/choose-a-network)ä¸­äº†è§£æ›´å¤šä¿¡æ¯ã€‚\n"
#~ "\n"
#~ "3.  **æ‚¨è‡ªå·±çš„èŠ‚ç‚¹**ï¼šé€‚åˆæƒ³è¦å®Œå…¨æ§åˆ¶çš„ç”¨æˆ·ã€‚è¿™æ˜¯æœ€å¤æ‚ï¼Œä½†è‡ªç”±åº¦æœ€é«˜çš„é€‰é¡¹ã€‚\n"
#~ "     æŸ¥çœ‹[Starknetä¹‹ä¹¦ç¬¬ 4 ç« ](https://book.starknet.io/chapter_4/node.html) æˆ–[Kasar](https://www.kasar.io/) è·å–è®¾ç½®æŒ‡å—ã€‚"

#~ msgid ""
#~ "In this tutorial, we will use Alchemy. We can set the STARKNET_RPC\n"
#~ "environment variable to make command invocations easier:"
#~ msgstr "åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ Alchemyã€‚æˆ‘ä»¬å¯ä»¥è®¾ç½® `STARKNET_RPC` ç¯å¢ƒå˜é‡ï¼Œä½¿å‘½ä»¤è°ƒç”¨æ›´å®¹æ˜“ï¼š"

#~ msgid ""
#~ "```bash\n"
#~ "    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/<API_KEY>\"\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/<API_KEY>\"\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli declare target/dev/contracts_Ownable.sierra.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli declare target/dev/contracts_Ownable.sierra.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Class hash declared: 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Not declaring class as its already declared. Class hash:\n"
#~ "    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Not declaring class as its already declared. Class hash:\n"
#~ "    0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
#~ "        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli deploy \\\n"
#~ "        0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 \\\n"
#~ "        0x02cdAb749380950e7a7c0deFf5ea8eDD716fEb3a2952aDd4E5659655077B8510\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
#~ "    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
#~ "    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
#~ "    Contract deployed:\n"
#~ "    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Deploying class 0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8 with salt 0x065034b27a199cbb2a5b97b78a8a6a6c6edd027c7e398b18e5c0e5c0c65246b7...\n"
#~ "    The contract will be deployed at address 0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
#~ "    Contract deployment transaction: 0x0743de1e233d38c4f3e9fb13f1794276f7d4bf44af9eac66e22944ad1fa85f14\n"
#~ "    Contract deployed:\n"
#~ "    0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli call \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        get_owner\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli call \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        get_owner\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli invoke \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        transfer_ownership \\\n"
#~ "        <NEW_OWNER_ADDRESS>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli invoke \\\n"
#~ "        <CONTRACT_ADDRESS> \\\n"
#~ "        transfer_ownership \\\n"
#~ "        <NEW_OWNER_ADDRESS>\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    Execution was reverted; failure reason: [0x43616c6c6572206973206e6f7420746865206f776e6572].\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "    starkli parse-cairo-string <ENCODED_ERROR>\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "    starkli parse-cairo-string <ENCODED_ERROR>\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::interface]\n"
#~ "trait IHelloStarknet<TContractState> {\n"
#~ "    fn increase_balance(ref self: TContractState, amount: felt252);\n"
#~ "    fn get_balance(self: @TContractState) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod HelloStarknet {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        balance: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
#~ "        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
#~ "            assert(amount != 0, 'amount cannot be 0');\n"
#~ "            self.balance.write(self.balance.read() + amount);\n"
#~ "        }\n"
#~ "        fn get_balance(self: @ContractState) -> felt252 {\n"
#~ "            self.balance.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::interface]\n"
#~ "trait IHelloStarknet<TContractState> {\n"
#~ "    fn increase_balance(ref self: TContractState, amount: felt252);\n"
#~ "    fn get_balance(self: @TContractState) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod HelloStarknet {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        balance: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
#~ "        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
#~ "            assert(amount != 0, 'amount cannot be 0');\n"
#~ "            self.balance.write(self.balance.read() + amount);\n"
#~ "        }\n"
#~ "        fn get_balance(self: @ContractState) -> felt252 {\n"
#~ "            self.balance.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use learnsncast::IHelloStarknetDispatcherTrait;\n"
#~ "    use snforge_std::{declare, ContractClassTrait};\n"
#~ "    use super::{IHelloStarknetDispatcher};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn call_and_invoke() {\n"
#~ "        // Declare and deploy a contract\n"
#~ "        let contract = declare('HelloStarknet');\n"
#~ "        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
#~ "\n"
#~ "        // Create a Dispatcher object for interaction with the deployed contract\n"
#~ "        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
#~ "\n"
#~ "        // Query a contract view function\n"
#~ "        let balance = dispatcher.get_balance();\n"
#~ "        assert(balance == 0, 'balance == 0');\n"
#~ "\n"
#~ "        // Invoke a contract function to mutate state\n"
#~ "        dispatcher.increase_balance(100);\n"
#~ "\n"
#~ "        // Verify the transaction's effect\n"
#~ "        let balance = dispatcher.get_balance();\n"
#~ "        assert(balance == 100, 'balance == 100');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use learnsncast::IHelloStarknetDispatcherTrait;\n"
#~ "    use snforge_std::{declare, ContractClassTrait};\n"
#~ "    use super::{IHelloStarknetDispatcher};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn call_and_invoke() {\n"
#~ "        // Declare and deploy a contract\n"
#~ "        let contract = declare('HelloStarknet');\n"
#~ "        let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
#~ "\n"
#~ "        // Create a Dispatcher object for interaction with the deployed contract\n"
#~ "        let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
#~ "\n"
#~ "        // Query a contract view function\n"
#~ "        let balance = dispatcher.get_balance();\n"
#~ "        assert(balance == 0, 'balance == 0');\n"
#~ "\n"
#~ "        // Invoke a contract function to mutate state\n"
#~ "        dispatcher.increase_balance(100);\n"
#~ "\n"
#~ "        // Verify the transaction's effect\n"
#~ "        let balance = dispatcher.get_balance();\n"
#~ "        assert(balance == 100, 'balance == 100');\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```txt\n"
#~ "starknet = \"2.1.0-rc2\"\n"
#~ "snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.7.1\" }\n"
#~ "```"
#~ msgstr ""
#~ "```txt\n"
#~ "starknet = \"2.1.0-rc2\"\n"
#~ "snforge_std = { git = \"https://github.com/foundry-rs/starknet-foundry.git\", tag = \"v0.7.1\" }\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "snforge\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "snforge\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "starknet-devnet\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "starknet-devnet\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Predeployed FeeToken\n"
#~ "Address: 0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\n"
#~ "Class Hash: 0x6a22bf63c7bc07effa39a25dfbd21523d211db0100a0afd054d172b81840eaf\n"
#~ "Symbol: ETH\n"
#~ "\n"
#~ "Account #0:\n"
#~ "Address: 0x5fd5ef7f4b0e23a44a3670bd84f802f6cc37983c7766d562a8d4d72bb8360ba\n"
#~ "Public key: 0x6bd5d1d46a7f603f1106824a3b276fdb52168f55b595ba7ff6b2ded390161cd\n"
#~ "Private key: 0xc12927df61303656b3c066e65eda0acc\n"
#~ "...\n"
#~ "...\n"
#~ "...\n"
#~ " * Listening on http://127.0.0.1:5050/ (Press CTRL+C to quit)\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Predeployed FeeToken\n"
#~ "Address: 0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\n"
#~ "Class Hash: 0x6a22bf63c7bc07effa39a25dfbd21523d211db0100a0afd054d172b81840eaf\n"
#~ "Symbol: ETH\n"
#~ "\n"
#~ "Account #0:\n"
#~ "Address: 0x5fd5ef7f4b0e23a44a3670bd84f802f6cc37983c7766d562a8d4d72bb8360ba\n"
#~ "Public key: 0x6bd5d1d46a7f603f1106824a3b276fdb52168f55b595ba7ff6b2ded390161cd\n"
#~ "Private key: 0xc12927df61303656b3c066e65eda0acc\n"
#~ "...\n"
#~ "...\n"
#~ "...\n"
#~ " * Listening on http://127.0.0.1:5050/ (Press CTRL+C to quit)\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast --help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast --help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast account help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast account help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast account add --help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast account add --help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast [SNCAST_MAIN_OPTIONS] account add [SUBCOMMAND_OPTIONS] --name <NAME> --address <ADDRESS> --private-key <PRIVATE_KEY>\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast --url http://localhost:5050/rpc account create --name new_account --class-hash  0x19...8dd6 --add-profile\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Predeclared Starknet CLI account:\n"
#~ "Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Predeclared Starknet CLI account:\n"
#~ "Class hash: 0x195c984a44ae2b8ad5d49f48c0aaa0132c42521dcfc66513530203feca48dd6\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "{\"new_balance\":8646000000000,\"tx_hash\":\"0x48...1919\",\"unit\":\"wei\"}\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast --url http://localhost:5050/rpc account deploy --name new_account --max-fee 0x64a7168300\n"
#~ "```"

#~ msgid "### Declaring the Contract"
#~ msgstr "### å£°æ˜åˆçº¦"

#~ msgid ""
#~ "```sh\n"
#~ "scarb build\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "scarb build\n"
#~ "```"

#~ msgid ""
#~ "```toml\n"
#~ "[[target.starknet-contract]]\n"
#~ "sierra = true\n"
#~ "casm = true\n"
#~ "```"
#~ msgstr ""
#~ "```toml\n"
#~ "[[target.starknet-contract]]\n"
#~ "sierra = true\n"
#~ "casm = true\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "sncast declare [OPTIONS] --contract-name <CONTRACT>\n"
#~ "```"

#~ msgid ""
#~ "```\n"
#~ "sncast --profile account1 declare --contract-name HelloStarknet\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "sncast --profile account1 declare --contract-name HelloStarknet\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast declare --contract-name HelloStarknet\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast declare --contract-name HelloStarknet\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "command: declare\n"
#~ "class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
#~ "transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "command: declare\n"
#~ "class_hash: 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
#~ "transaction_hash: 0x7fbdcca80e7c666f1b5c4522fdad986ad3b731107001f7d8df5f3cb1ce8fd11\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast deploy --class-hash 0x20fe30f3990ecfb673d723944f28202db5acf107a359bfeef861b578c00f2a0\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "command: deploy\n"
#~ "contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
#~ "transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "command: deploy\n"
#~ "contract_address: 0x7e3fc427c2f085e7f8adeaec7501cacdfe6b350daef18d76755ddaa68b3b3f9\n"
#~ "transaction_hash: 0x6bdf6cfc8080336d9315f9b4df7bca5fb90135817aba4412ade6f942e9dbe60\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Usage: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract\n"
#~ "  -f, --function <FUNCTION>                  Name of the function\n"
#~ "  -c, --calldata <CALLDATA>                  Data for the function\n"
#~ "  -m, --max-fee <MAX_FEE>                    Maximum transaction fee (auto-estimated if absent)\n"
#~ "  -h, --help                                 Show help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Usage: sncast invoke [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract\n"
#~ "  -f, --function <FUNCTION>                  Name of the function\n"
#~ "  -c, --calldata <CALLDATA>                  Data for the function\n"
#~ "  -m, --max-fee <MAX_FEE>                    Maximum transaction fee (auto-estimated if absent)\n"
#~ "  -h, --help                                 Show help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast invoke --contract-address 0x7e...b3f9 --function increase_balance --calldata 4\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "command: invoke\n"
#~ "transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "command: invoke\n"
#~ "transaction_hash: 0x33248e393d985a28826e9fbb143d2cf0bb3342f1da85483cf253b450973b638\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast call --help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast call --help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Usage: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract (hex format)\n"
#~ "  -f, --function <FUNCTION>                  Name of the function to call\n"
#~ "  -c, --calldata <CALLDATA>                  Function arguments (list of hex values)\n"
#~ "  -b, --block-id <BLOCK_ID>                  Block identifier for the call. Accepts: pending, latest, block hash (with a 0x prefix), or block number (u64). Default is 'pending'.\n"
#~ "  -h, --help                                 Show help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Usage: sncast call [OPTIONS] --contract-address <CONTRACT_ADDRESS> --function <FUNCTION>\n"
#~ "\n"
#~ "Options:\n"
#~ "  -a, --contract-address <CONTRACT_ADDRESS>  Address of the contract (hex format)\n"
#~ "  -f, --function <FUNCTION>                  Name of the function to call\n"
#~ "  -c, --calldata <CALLDATA>                  Function arguments (list of hex values)\n"
#~ "  -b, --block-id <BLOCK_ID>                  Block identifier for the call. Accepts: pending, latest, block hash (with a 0x prefix), or block number (u64). Default is 'pending'.\n"
#~ "  -h, --help                                 Show help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast call --contract-address 0x7e...b3f9 --function get_balance\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "command: call\n"
#~ "response: [0x4]\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "command: call\n"
#~ "response: [0x4]\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast multicall --help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast multicall --help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Execute multiple calls\n"
#~ "\n"
#~ "Usage: sncast multicall <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  run   Execute multicall using a .toml file\n"
#~ "  new   Create a template for the multicall .toml file\n"
#~ "  help  Display help for subcommand(s)\n"
#~ "\n"
#~ "Options:\n"
#~ "  -h, --help  Show help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Execute multiple calls\n"
#~ "\n"
#~ "Usage: sncast multicall <COMMAND>\n"
#~ "\n"
#~ "Commands:\n"
#~ "  run   Execute multicall using a .toml file\n"
#~ "  new   Create a template for the multicall .toml file\n"
#~ "  help  Display help for subcommand(s)\n"
#~ "\n"
#~ "Options:\n"
#~ "  -h, --help  Show help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "Generate a template for the multicall .toml file\n"
#~ "\n"
#~ "Usage: sncast multicall new [OPTIONS]\n"
#~ "\n"
#~ "Options:\n"
#~ "  -p, --output-path <OUTPUT_PATH>  File path for saving the template\n"
#~ "  -o, --overwrite                  Overwrite file if it already exists at specified path\n"
#~ "  -h, --help                       Display help\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "Generate a template for the multicall .toml file\n"
#~ "\n"
#~ "Usage: sncast multicall new [OPTIONS]\n"
#~ "\n"
#~ "Options:\n"
#~ "  -p, --output-path <OUTPUT_PATH>  File path for saving the template\n"
#~ "  -o, --overwrite                  Overwrite file if it already exists at specified path\n"
#~ "  -h, --help                       Display help\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast multicall new --output-path ./call1.toml --overwrite\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast multicall new --output-path ./call1.toml --overwrite\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "sncast multicall run --path call1.toml\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "sncast multicall run --path call1.toml\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "command: multicall run\n"
#~ "transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "command: multicall run\n"
#~ "transaction_hash: 0x1ae4122266f99a5ede495ff50fdbd927c31db27ec601eb9f3eaa938273d4d61\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "command: call\n"
#~ "response: [0x9]\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "command: call\n"
#~ "response: [0x9]\n"
#~ "```"

#~ msgid "Disclaimer: This is an example. Use it as a foundation for your own work, adjusting as needed."
#~ msgstr "å…è´£å£°æ˜ï¼šè¿™åªæ˜¯ä¸€ä¸ªç¤ºä¾‹ã€‚è¯·ä»¥æ­¤ä¸ºåŸºç¡€ï¼Œæ ¹æ®éœ€è¦è¿›è¡Œè°ƒæ•´ã€‚"

#~ msgid ""
#~ "- In your project's root folder, create a file named **`script.sh`**. This will house the script.\n"
#~ "- Adjust permissions to make the file executable:"
#~ msgstr ""
#~ "- åœ¨é¡¹ç›®æ ¹æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º **`script.sh`** çš„æ–‡ä»¶ã€‚è¯¥æ–‡ä»¶å°†å­˜æ”¾è„šæœ¬ã€‚\n"
#~ "- è°ƒæ•´æƒé™ï¼Œä½¿æ–‡ä»¶å¯æ‰§è¡Œï¼š"

#~ msgid ""
#~ "```sh\n"
#~ "chmod +x script.sh\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "chmod +x script.sh\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "#!/usr/bin/env bash\n"
#~ "\n"
#~ "# Ensure the script stops on first error\n"
#~ "set -e\n"
#~ "\n"
#~ "# Global variables\n"
#~ "file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
#~ "CONTRACT_NAME=\"HelloStarknet\"\n"
#~ "PROFILE_NAME=\"account1\"\n"
#~ "MULTICALL_FILE=\"multicall.toml\"\n"
#~ "FAILED_TESTS=false\n"
#~ "\n"
#~ "# Addresses and Private keys as environment variables\n"
#~ "ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
#~ "ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
#~ "ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
#~ "ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
#~ "\n"
#~ "# Utility function to log messages\n"
#~ "function log_message() {\n"
#~ "    echo -e \"\\n$1\"\n"
#~ "}\n"
#~ "\n"
#~ "# Step 1: Clean previous environment\n"
#~ "if [ -e \"$file_path\" ]; then\n"
#~ "    log_message \"Removing existing accounts file...\"\n"
#~ "    rm -rf \"$file_path\"\n"
#~ "fi\n"
#~ "\n"
#~ "# Step 2: Define accounts for the smart contract\n"
#~ "accounts_json=$(cat <<EOF\n"
#~ "[\n"
#~ "    {\n"
#~ "        \"name\": \"account1\",\n"
#~ "        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
#~ "        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
#~ "    },\n"
#~ "    {\n"
#~ "        \"name\": \"account2\",\n"
#~ "        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
#~ "        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
#~ "    }\n"
#~ "]\n"
#~ "EOF\n"
#~ ")\n"
#~ "\n"
#~ "# Step 3: Run contract tests\n"
#~ "echo -e \"\\nTesting the contract...\"\n"
#~ "testing_result=$(snforge 2>&1)\n"
#~ "if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
#~ "    echo -e \"Tests failed!\\n\"\n"
#~ "    snforge\n"
#~ "    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
#~ "    FAILED_TESTS=true\n"
#~ "fi\n"
#~ "\n"
#~ "if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
#~ "    echo \"Tests passed successfully.\"\n"
#~ "\n"
#~ "    # Step 4: Create new account(s)\n"
#~ "    echo -e \"\\nCreating account(s)...\"\n"
#~ "    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
#~ "        name=$(echo \"${row}\" | jq -r '.name')\n"
#~ "        address=$(echo \"${row}\" | jq -r '.address')\n"
#~ "        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
#~ "\n"
#~ "        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
#~ "        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
#~ "            echo \"Account $name already exists.\"\n"
#~ "        else\n"
#~ "            echo \"Account $name created successfully.\"\n"
#~ "        fi\n"
#~ "    done\n"
#~ "\n"
#~ "    # Step 5: Build, declare, and deploy the contract\n"
#~ "    echo -e \"\\nBuilding the contract...\"\n"
#~ "    scarb build\n"
#~ "\n"
#~ "    echo -e \"\\nDeclaring the contract...\"\n"
#~ "    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
#~ "\n"
#~ "    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
#~ "        echo \"Class hash already declared.\"\n"
#~ "        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p')\n"
#~ "    else\n"
#~ "        echo \"New class hash declaration.\"\n"
#~ "        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
#~ "    fi\n"
#~ "\n"
#~ "    echo \"Class Hash: $CLASS_HASH\"\n"
#~ "\n"
#~ "    echo -e \"\\nDeploying the contract...\"\n"
#~ "    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
#~ "    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
#~ "    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
#~ "\n"
#~ "    # Step 6: Create and execute multicalls\n"
#~ "    echo -e \"\\nSetting up multicall...\"\n"
#~ "    cat >\"$MULTICALL_FILE\" <<-EOM\n"
#~ "[[call]]\n"
#~ "call_type = 'invoke'\n"
#~ "contract_address = '$CONTRACT_ADDRESS'\n"
#~ "function = 'increase_balance'\n"
#~ "inputs = ['0x1']\n"
#~ "\n"
#~ "[[call]]\n"
#~ "call_type = 'invoke'\n"
#~ "contract_address = '$CONTRACT_ADDRESS'\n"
#~ "function = 'increase_balance'\n"
#~ "inputs = ['0x2']\n"
#~ "EOM\n"
#~ "\n"
#~ "    echo \"Executing multicall...\"\n"
#~ "    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
#~ "\n"
#~ "    # Step 7: Query the contract state\n"
#~ "    echo -e \"\\nChecking balance...\"\n"
#~ "    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
#~ "\n"
#~ "    # Step 8: Clean up temporary files\n"
#~ "    echo -e \"\\nCleaning up...\"\n"
#~ "    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
#~ "\n"
#~ "    echo -e \"\\nScript completed successfully.\\n\"\n"
#~ "fi\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "#!/usr/bin/env bash\n"
#~ "\n"
#~ "# Ensure the script stops on first error\n"
#~ "set -e\n"
#~ "\n"
#~ "# Global variables\n"
#~ "file_path=\"$HOME/.starknet_accounts/starknet_open_zeppelin_accounts.json\"\n"
#~ "CONTRACT_NAME=\"HelloStarknet\"\n"
#~ "PROFILE_NAME=\"account1\"\n"
#~ "MULTICALL_FILE=\"multicall.toml\"\n"
#~ "FAILED_TESTS=false\n"
#~ "\n"
#~ "# Addresses and Private keys as environment variables\n"
#~ "ACCOUNT1_ADDRESS=${ACCOUNT1_ADDRESS:-\"0x7f61fa3893ad0637b2ff76fed23ebbb91835aacd4f743c2347716f856438429\"}\n"
#~ "ACCOUNT2_ADDRESS=${ACCOUNT2_ADDRESS:-\"0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551\"}\n"
#~ "ACCOUNT1_PRIVATE_KEY=${ACCOUNT1_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
#~ "ACCOUNT2_PRIVATE_KEY=${ACCOUNT2_PRIVATE_KEY:-\"CHANGE_ME\"}\n"
#~ "\n"
#~ "# Utility function to log messages\n"
#~ "function log_message() {\n"
#~ "    echo -e \"\\n$1\"\n"
#~ "}\n"
#~ "\n"
#~ "# Step 1: Clean previous environment\n"
#~ "if [ -e \"$file_path\" ]; then\n"
#~ "    log_message \"Removing existing accounts file...\"\n"
#~ "    rm -rf \"$file_path\"\n"
#~ "fi\n"
#~ "\n"
#~ "# Step 2: Define accounts for the smart contract\n"
#~ "accounts_json=$(cat <<EOF\n"
#~ "[\n"
#~ "    {\n"
#~ "        \"name\": \"account1\",\n"
#~ "        \"address\": \"$ACCOUNT1_ADDRESS\",\n"
#~ "        \"private_key\": \"$ACCOUNT1_PRIVATE_KEY\"\n"
#~ "    },\n"
#~ "    {\n"
#~ "        \"name\": \"account2\",\n"
#~ "        \"address\": \"$ACCOUNT2_ADDRESS\",\n"
#~ "        \"private_key\": \"$ACCOUNT2_PRIVATE_KEY\"\n"
#~ "    }\n"
#~ "]\n"
#~ "EOF\n"
#~ ")\n"
#~ "\n"
#~ "# Step 3: Run contract tests\n"
#~ "echo -e \"\\nTesting the contract...\"\n"
#~ "testing_result=$(snforge 2>&1)\n"
#~ "if echo \"$testing_result\" | grep -q \"Failure\"; then\n"
#~ "    echo -e \"Tests failed!\\n\"\n"
#~ "    snforge\n"
#~ "    echo -e \"\\nEnsure that your tests are passing before proceeding.\\n\"\n"
#~ "    FAILED_TESTS=true\n"
#~ "fi\n"
#~ "\n"
#~ "if [ \"$FAILED_TESTS\" != \"true\" ]; then\n"
#~ "    echo \"Tests passed successfully.\"\n"
#~ "\n"
#~ "    # Step 4: Create new account(s)\n"
#~ "    echo -e \"\\nCreating account(s)...\"\n"
#~ "    for row in $(echo \"${accounts_json}\" | jq -c '.[]'); do\n"
#~ "        name=$(echo \"${row}\" | jq -r '.name')\n"
#~ "        address=$(echo \"${row}\" | jq -r '.address')\n"
#~ "        private_key=$(echo \"${row}\" | jq -r '.private_key')\n"
#~ "\n"
#~ "        account_creation_result=$(sncast --url http://localhost:5050/rpc account add --name \"$name\" --address \"$address\" --private-key \"$private_key\" --add-profile 2>&1)\n"
#~ "        if echo \"$account_creation_result\" | grep -q \"error:\"; then\n"
#~ "            echo \"Account $name already exists.\"\n"
#~ "        else\n"
#~ "            echo \"Account $name created successfully.\"\n"
#~ "        fi\n"
#~ "    done\n"
#~ "\n"
#~ "    # Step 5: Build, declare, and deploy the contract\n"
#~ "    echo -e \"\\nBuilding the contract...\"\n"
#~ "    scarb build\n"
#~ "\n"
#~ "    echo -e \"\\nDeclaring the contract...\"\n"
#~ "    declaration_output=$(sncast --profile \"$PROFILE_NAME\" --wait declare --contract-name \"$CONTRACT_NAME\" 2>&1)\n"
#~ "\n"
#~ "    if echo \"$declaration_output\" | grep -q \"error: Class with hash\"; then\n"
#~ "        echo \"Class hash already declared.\"\n"
#~ "        CLASS_HASH=$(echo \"$declaration_output\" | sed -n 's/.*Class with hash \\([^ ]*\\).*/\\1/p')\n"
#~ "    else\n"
#~ "        echo \"New class hash declaration.\"\n"
#~ "        CLASS_HASH=$(echo \"$declaration_output\" | grep -o 'class_hash: 0x[^ ]*' | sed 's/class_hash: //')\n"
#~ "    fi\n"
#~ "\n"
#~ "    echo \"Class Hash: $CLASS_HASH\"\n"
#~ "\n"
#~ "    echo -e \"\\nDeploying the contract...\"\n"
#~ "    deployment_result=$(sncast --profile \"$PROFILE_NAME\" deploy --class-hash \"$CLASS_HASH\")\n"
#~ "    CONTRACT_ADDRESS=$(echo \"$deployment_result\" | grep -o \"contract_address: 0x[^ ]*\" | awk '{print $2}')\n"
#~ "    echo \"Contract address: $CONTRACT_ADDRESS\"\n"
#~ "\n"
#~ "    # Step 6: Create and execute multicalls\n"
#~ "    echo -e \"\\nSetting up multicall...\"\n"
#~ "    cat >\"$MULTICALL_FILE\" <<-EOM\n"
#~ "[[call]]\n"
#~ "call_type = 'invoke'\n"
#~ "contract_address = '$CONTRACT_ADDRESS'\n"
#~ "function = 'increase_balance'\n"
#~ "inputs = ['0x1']\n"
#~ "\n"
#~ "[[call]]\n"
#~ "call_type = 'invoke'\n"
#~ "contract_address = '$CONTRACT_ADDRESS'\n"
#~ "function = 'increase_balance'\n"
#~ "inputs = ['0x2']\n"
#~ "EOM\n"
#~ "\n"
#~ "    echo \"Executing multicall...\"\n"
#~ "    sncast --profile \"$PROFILE_NAME\" multicall run --path \"$MULTICALL_FILE\"\n"
#~ "\n"
#~ "    # Step 7: Query the contract state\n"
#~ "    echo -e \"\\nChecking balance...\"\n"
#~ "    sncast --profile \"$PROFILE_NAME\" call --contract-address \"$CONTRACT_ADDRESS\" --function get_balance\n"
#~ "\n"
#~ "    # Step 8: Clean up temporary files\n"
#~ "    echo -e \"\\nCleaning up...\"\n"
#~ "    [ -e \"$MULTICALL_FILE\" ] && rm \"$MULTICALL_FILE\"\n"
#~ "\n"
#~ "    echo -e \"\\nScript completed successfully.\\n\"\n"
#~ "fi\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "which bash\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "which bash\n"
#~ "```"

#~ msgid ""
#~ "```sh\n"
#~ "ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
#~ "```"
#~ msgstr ""
#~ "```sh\n"
#~ "ACCOUNT1_PRIVATE_KEY=\"0x259f4329e6f4590b\" ACCOUNT2_PRIVATE_KEY=\"0xb4862b21fb97d\" ./script.sh\n"
#~ "```"

#~ msgid ""
#~ "- The **`set -e`** directive in the script ensures it exits if any command fails, enhancing the reliability of the deployment and testing process.\n"
#~ "- Always secure private keys and sensitive information. Keep them away from logs and visible outputs.\n"
#~ "- For greater flexibility, consider moving hardcoded values like accounts or contract names to a configuration file. This approach simplifies updates and overall management."
#~ msgstr ""
#~ "- è„šæœ¬ä¸­çš„ **`set -e`** æŒ‡ä»¤å¯ç¡®ä¿åœ¨ä»»ä½•å‘½ä»¤å¤±è´¥æ—¶é€€å‡ºè„šæœ¬ï¼Œä»è€Œæé«˜éƒ¨ç½²å’Œæµ‹è¯•è¿‡ç¨‹çš„å¯é æ€§ã€‚\n"
#~ "- å§‹ç»ˆç¡®ä¿ç§é’¥å’Œæ•æ„Ÿä¿¡æ¯çš„å®‰å…¨ã€‚è®©å®ƒä»¬è¿œç¦»æ—¥å¿—å’Œå¯è§è¾“å‡ºã€‚\n"
#~ "- ä¸ºæé«˜çµæ´»æ€§ï¼Œå¯è€ƒè™‘å°†è´¦æˆ·æˆ–åˆçº¦åç§°ç­‰ç¡¬ç¼–ç å€¼è½¬ç§»åˆ°é…ç½®æ–‡ä»¶ä¸­ã€‚è¿™ç§æ–¹æ³•å¯ç®€åŒ–æ›´æ–°å’Œæ•´ä½“ç®¡ç†ã€‚"

#~ msgid "# Starknet Devnet ğŸš§"
#~ msgstr "# Starknet Devnet ğŸš§"

#~ msgid "# Starknet-js: Javascript SDK"
#~ msgstr "# Starknet-jsï¼šJavascript SDK"

#~ msgid "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Starknet-js in your dapp\" src=\"img/ch02-starknet-js.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<!-- -->"
#~ msgstr "<!-- -->"

#~ msgid "npm install starknet"
#~ msgstr "npm install starknet"

#~ msgid "npm install starknet@next"
#~ msgstr "npm install starknet@next"

#~ msgid "## Getting Started"
#~ msgstr "## å…¥é—¨"

#~ msgid "### Account"
#~ msgstr "### è´¦æˆ·"

#~ msgid ""
#~ "```ts\n"
#~ "async function connectWallet() {\n"
#~ "    const starknet = await connect();\n"
#~ "    console.log(starknet.account);\n"
#~ "\n"
#~ "    const nonce = await starknet.account.getNonce();\n"
#~ "    const message = await starknet.account.signMessage(...)\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```ts\n"
#~ "async function connectWallet() {\n"
#~ "    const starknet = await connect();\n"
#~ "    console.log(starknet.account);\n"
#~ "\n"
#~ "    const nonce = await starknet.account.getNonce();\n"
#~ "    const message = await starknet.account.signMessage(...)\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```ts\n"
#~ "const contract = new Contract(abi_erc20, contractAddress, provider);\n"
#~ "\n"
#~ "contract.connect(starknet.account);\n"
#~ "```"
#~ msgstr ""
#~ "```ts\n"
#~ "const contract = new Contract(abi_erc20, contractAddress, provider);\n"
#~ "\n"
#~ "contract.connect(starknet.account);\n"
#~ "```"

#~ msgid ""
#~ "In this subchapter, readers will find practical examples demonstrating the usage of `starknet-js`. It provides insight into real-world applications and serves as a guide for developers to "
#~ "understand and implement these tools effectively."
#~ msgstr "åœ¨æœ¬åˆ†ç« ä¸­ï¼Œè¯»è€…å°†çœ‹åˆ°æ¼”ç¤ºä½¿ç”¨ `starknet-js` çš„å®é™…ç¤ºä¾‹ã€‚å®ƒæä¾›äº†å¯¹çœŸå®ä¸–ç•Œåº”ç”¨çš„æ´å¯Ÿï¼Œå¯ä½œä¸ºå¼€å‘äººå‘˜ç†è§£å’Œæœ‰æ•ˆå®æ–½è¿™äº›å·¥å…·çš„æŒ‡å—ã€‚"

#~ msgid "We value the contribution of our developer community:"
#~ msgstr "æˆ‘ä»¬é‡è§†å¼€å‘äººå‘˜ç¤¾åŒºçš„è´¡çŒ®ï¼š"

#~ msgid ""
#~ "- We encourage developers to contribute additional examples.\n"
#~ "- Please inform us if you identify any mistakes or inaccuracies."
#~ msgstr ""
#~ "- æˆ‘ä»¬é¼“åŠ±å¼€å‘äººå‘˜æä¾›æ›´å¤šç¤ºä¾‹ã€‚\n"
#~ "- å¦‚æœæ‚¨å‘ç°ä»»ä½•é”™è¯¯æˆ–ä¸å‡†ç¡®ä¹‹å¤„ï¼Œè¯·é€šçŸ¥æˆ‘ä»¬ã€‚"

#~ msgid "Your insights and feedback are instrumental in making this resource more comprehensive and accurate."
#~ msgstr "æ‚¨çš„è§è§£å’Œåé¦ˆæœ‰åŠ©äºä½¿æœ¬èµ„æ–™æ›´åŠ å…¨é¢å’Œå‡†ç¡®ã€‚"

#~ msgid ""
#~ "- Connect the frontend to a smart contract.\n"
#~ "- Initiate transactions, such as incrementing or decrementing the counter.\n"
#~ "- Read and display data, such as showing the counter value on the frontend."
#~ msgstr ""
#~ "- å°†å‰ç«¯è¿æ¥åˆ°æ™ºèƒ½åˆçº¦ã€‚\n"
#~ "- å¯åŠ¨äº¤æ˜“ï¼Œå¦‚é€’å¢æˆ–é€’å‡è®¡æ•°å™¨ã€‚\n"
#~ "- è¯»å–å’Œæ˜¾ç¤ºæ•°æ®ï¼Œå¦‚åœ¨å‰ç«¯æ˜¾ç¤ºè®¡æ•°å™¨å€¼ã€‚"

#~ msgid ""
#~ "```bash\n"
#~ "cd basecamp-frontend-boilerplate\n"
#~ "npm install\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd basecamp-frontend-boilerplate\n"
#~ "npm install\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "yarn start\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "yarn start\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
#~ "const connectWallet = async () => {};\n"
#~ "\n"
#~ "// Terminate the connection\n"
#~ "const disconnectWallet = async () => {};\n"
#~ "\n"
#~ "// Trigger increment\n"
#~ "const increaseCounter = async () => {};\n"
#~ "\n"
#~ "// Trigger decrement\n"
#~ "const decreaseCounter = async () => {};\n"
#~ "\n"
#~ "// Retrieve current count\n"
#~ "const getCounter = async () => {};\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
#~ "const connectWallet = async () => {};\n"
#~ "\n"
#~ "// Terminate the connection\n"
#~ "const disconnectWallet = async () => {};\n"
#~ "\n"
#~ "// Trigger increment\n"
#~ "const increaseCounter = async () => {};\n"
#~ "\n"
#~ "// Trigger decrement\n"
#~ "const decreaseCounter = async () => {};\n"
#~ "\n"
#~ "// Retrieve current count\n"
#~ "const getCounter = async () => {};\n"
#~ "```"

#~ msgid ""
#~ "```JavaScript\n"
#~ "const connectWallet = async() => {\n"
#~ "    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
#~ "    if (connection && connection.isConnected) {\n"
#~ "      setConnection(connection);\n"
#~ "      setAccount(connection.account);\n"
#~ "      setAddress(connection.selectedAddress);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```JavaScript\n"
#~ "const connectWallet = async() => {\n"
#~ "    const connection = await connect({webWalletUrl: \"https://web.argent.xyz\"});\n"
#~ "    if (connection && connection.isConnected) {\n"
#~ "      setConnection(connection);\n"
#~ "      setAccount(connection.account);\n"
#~ "      setAddress(connection.selectedAddress);\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "const disconnectWallet = async() => {\n"
#~ "    await disconnect();\n"
#~ "    setConnection(undefined);\n"
#~ "    setAccount(undefined);\n"
#~ "    setAddress('');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "const disconnectWallet = async() => {\n"
#~ "    await disconnect();\n"
#~ "    setConnection(undefined);\n"
#~ "    setAccount(undefined);\n"
#~ "    setAddress('');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "- It utilizes the **`disconnect`** function, possibly from an external library, and handles the operation asynchronously with **`await`**.\n"
#~ "- Post-disconnection, the state of the React component is updated:\n"
#~ "  - **`setConnection`** is set to **`undefined`**.\n"
#~ "  - **`setAccount`** is set to **`undefined`**.\n"
#~ "  - **`setAddress`** is cleared with an empty string."
#~ msgstr ""
#~ "- å®ƒåˆ©ç”¨**`disconnect`**å‡½æ•°ï¼ˆå¯èƒ½æ¥è‡ªå¤–éƒ¨åº“ï¼‰ï¼Œå¹¶é€šè¿‡**`await`**å¼‚æ­¥å¤„ç†æ“ä½œã€‚\n"
#~ "- æ–­å¼€è¿æ¥åï¼ŒReact ç»„ä»¶çš„çŠ¶æ€ä¼šè¢«æ›´æ–°ï¼š\n"
#~ "  - **`setConnection`**è¢«è®¾ç½®ä¸º**`undefined`**ã€‚\n"
#~ "  - å°†**`setAccount`**è®¾ç½®ä¸º**`undefined`**ã€‚\n"
#~ "  - **`setAddress`**è¢«æ¸…é™¤ä¸ºç©ºå­—ç¬¦ä¸²ã€‚"

#~ msgid ""
#~ "```javascript\n"
#~ "useEffect(() => {\n"
#~ "  const connectToStarknet = async () => {\n"
#~ "    const connection = await connect({\n"
#~ "      modalMode: \"neverAsk\",\n"
#~ "      webWalletUrl: \"https://web.argent.xyz\",\n"
#~ "    });\n"
#~ "\n"
#~ "    if (connection && connection.isConnected) {\n"
#~ "      setConnection(connection);\n"
#~ "      setAccount(connection.account);\n"
#~ "      setAddress(connection.selectedAddress);\n"
#~ "    }\n"
#~ "  };\n"
#~ "  connectToStarknet();\n"
#~ "}, []);\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "useEffect(() => {\n"
#~ "  const connectToStarknet = async () => {\n"
#~ "    const connection = await connect({\n"
#~ "      modalMode: \"neverAsk\",\n"
#~ "      webWalletUrl: \"https://web.argent.xyz\",\n"
#~ "    });\n"
#~ "\n"
#~ "    if (connection && connection.isConnected) {\n"
#~ "      setConnection(connection);\n"
#~ "      setAccount(connection.account);\n"
#~ "      setAddress(connection.selectedAddress);\n"
#~ "    }\n"
#~ "  };\n"
#~ "  connectToStarknet();\n"
#~ "}, []);\n"
#~ "```"

#~ msgid ""
#~ "- Interacting with smart contracts on the blockchain.\n"
#~ "- Specifying the structure of functions, events, and variables for software applications.\n"
#~ "- Enabling smooth communication with the smart contract, detailing function signatures, input/output types, event formats, and variable types.\n"
#~ "- Facilitating invocation of functions and data retrieval from the contract."
#~ msgstr ""
#~ "- ä¸åŒºå—é“¾ä¸Šçš„æ™ºèƒ½åˆçº¦äº¤äº’ã€‚\n"
#~ "- ä¸ºè½¯ä»¶åº”ç”¨ç¨‹åºæŒ‡å®šå‡½æ•°ã€äº‹ä»¶å’Œå˜é‡çš„ç»“æ„ã€‚\n"
#~ "- å®ç°ä¸æ™ºèƒ½åˆçº¦çš„é¡ºç•…é€šä¿¡ï¼Œè¯¦ç»†è¯´æ˜å‡½æ•°ç­¾åã€è¾“å…¥/è¾“å‡ºç±»å‹ã€äº‹ä»¶æ ¼å¼å’Œå˜é‡ç±»å‹ã€‚\n"
#~ "- æ–¹ä¾¿è°ƒç”¨å‡½æ•°å’Œä»åˆçº¦ä¸­æ£€ç´¢æ•°æ®ã€‚"

#~ msgid ""
#~ "- Communication with the blockchain.\n"
#~ "- Creating transactions.\n"
#~ "- Fetching data from the blockchain."
#~ msgstr ""
#~ "- ä¸åŒºå—é“¾é€šä¿¡ã€‚\n"
#~ "- åˆ›å»ºäº¤æ˜“ã€‚\n"
#~ "- ä»åŒºå—é“¾è·å–æ•°æ®ã€‚"

#~ msgid ""
#~ "```javascript\n"
#~ "const increaseCounter = async () => {\n"
#~ "  try {\n"
#~ "    const contract = new Contract(contractAbi, contractAddress, account);\n"
#~ "    await contract.increment();\n"
#~ "    alert(\"You successfully incremented the counter!\");\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "const increaseCounter = async () => {\n"
#~ "  try {\n"
#~ "    const contract = new Contract(contractAbi, contractAddress, account);\n"
#~ "    await contract.increment();\n"
#~ "    alert(\"You successfully incremented the counter!\");\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "1. Establishes a new contract instance using the provided contract's ABI, its address, and the connected account. The account is essential since this write transaction alters the contract's state.\n"
#~ "2. Executes the contract's **`increment`** method. The **`await`** keyword ensures the program pauses until this action completes.\n"
#~ "3. On successful execution, the user receives a confirmation alert indicating the counter's increment.\n"
#~ "4. In case of any errors during the process, an alert displays the corresponding error message to the user."
#~ msgstr ""
#~ "1.ä½¿ç”¨æä¾›çš„åˆçº¦ ABIã€åˆçº¦åœ°å€å’Œè¿æ¥çš„è´¦æˆ·å»ºç«‹ä¸€ä¸ªæ–°åˆçº¦å®ä¾‹ã€‚è´¦æˆ·æ˜¯å¿…ä¸å¯å°‘çš„ï¼Œå› ä¸ºè¿™ä¸ªå†™å…¥äº‹åŠ¡ä¼šæ”¹å˜åˆçº¦çš„çŠ¶æ€ã€‚\n"
#~ "2.æ‰§è¡Œåˆçº¦çš„ **`increment`** æ–¹æ³•ã€‚**`await`**å…³é”®å­—ç¡®ä¿ç¨‹åºæš‚åœï¼Œç›´åˆ°è¯¥æ“ä½œå®Œæˆã€‚\n"
#~ "3.æ‰§è¡ŒæˆåŠŸåï¼Œç”¨æˆ·ä¼šæ”¶åˆ°è®¡æ•°å™¨é€’å¢çš„ç¡®è®¤æç¤ºã€‚\n"
#~ "4.å¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°ä»»ä½•é”™è¯¯ï¼Œè­¦æŠ¥ä¼šå‘ç”¨æˆ·æ˜¾ç¤ºç›¸åº”çš„é”™è¯¯ä¿¡æ¯ã€‚"

#~ msgid ""
#~ "```javascript\n"
#~ "const decreaseCounter = async () => {\n"
#~ "  try {\n"
#~ "    const contract = new Contract(contractAbi, contractAddress, account);\n"
#~ "    await contract.decrement();\n"
#~ "    alert(\"You successfully decremented the counter!\");\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "const decreaseCounter = async () => {\n"
#~ "  try {\n"
#~ "    const contract = new Contract(contractAbi, contractAddress, account);\n"
#~ "    await contract.decrement();\n"
#~ "    alert(\"You successfully decremented the counter!\");\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "1. Creates a new contract instance by utilizing the provided contract's ABI, its address, and the connected account. The account is vital as this write transaction modifies the contract's state.\n"
#~ "2. Initiates the contract's **`decrement`** method. With the use of the **`await`** keyword, the program ensures it waits for the decrement action to finalize.\n"
#~ "3. Upon successful execution, the user is notified with an alert indicating the counter's decrement.\n"
#~ "4. Should any errors arise during the interaction, the user is promptly alerted with the pertinent error message."
#~ msgstr ""
#~ "1.åˆ©ç”¨æä¾›çš„åˆçº¦ ABIã€åœ°å€å’Œè¿æ¥çš„è´¦æˆ·åˆ›å»ºæ–°åˆçº¦å®ä¾‹ã€‚è´¦æˆ·è‡³å…³é‡è¦ï¼Œå› ä¸ºè¯¥å†™å…¥äº‹åŠ¡ä¼šä¿®æ”¹åˆçº¦çš„çŠ¶æ€ã€‚\n"
#~ "2.å¯åŠ¨åˆçº¦çš„ **`decrement`** æ–¹æ³•ã€‚ä½¿ç”¨**`await`**å…³é”®å­—ï¼Œç¨‹åºå¯ç¡®ä¿ç­‰å¾…é€’å‡æ“ä½œæœ€ç»ˆå®Œæˆã€‚\n"
#~ "3.æ‰§è¡ŒæˆåŠŸåï¼Œç”¨æˆ·ä¼šæ”¶åˆ°è®¡æ•°å™¨é€’å‡çš„è­¦æŠ¥ã€‚\n"
#~ "4.å¦‚æœåœ¨äº¤äº’è¿‡ç¨‹ä¸­å‡ºç°ä»»ä½•é”™è¯¯ï¼Œç”¨æˆ·ä¼šç«‹å³æ”¶åˆ°ç›¸å…³é”™è¯¯ä¿¡æ¯çš„æç¤ºã€‚"

#~ msgid ""
#~ "```javascript\n"
#~ "const getCounter = async () => {\n"
#~ "  const provider = new Provider({\n"
#~ "    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
#~ "  });\n"
#~ "  try {\n"
#~ "    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
#~ "    const num = await mycontract.get_current_count();\n"
#~ "    setRetrievedValue(num.toString());\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "const getCounter = async () => {\n"
#~ "  const provider = new Provider({\n"
#~ "    sequencer: { network: constants.NetworkName.SN_MAIN },\n"
#~ "  });\n"
#~ "  try {\n"
#~ "    const mycontract = new Contract(contractAbi, contractAddress, provider);\n"
#~ "    const num = await mycontract.get_current_count();\n"
#~ "    setRetrievedValue(num.toString());\n"
#~ "  } catch (err) {\n"
#~ "    alert(err.message);\n"
#~ "  }\n"
#~ "};\n"
#~ "```"

#~ msgid ""
#~ "1. Establishes a provider instance, specifying the sequencer network â€“ in this instance, it's set to the **`mainnet`** through **`constants.NetworkName.SN_MAIN`**.\n"
#~ "2. With this provider, it then initiates a contract instance using the provided contract's ABI, its address, and the aforementioned provider.\n"
#~ "3. The function then invokes the **`get_current_count`** method of the contract to fetch the current count. This is an asynchronous action, and the program waits for its completion with the "
#~ "**`await`** keyword.\n"
#~ "4. Once successfully retrieved, the count, which is presumably a number, is converted to a string and stored using the **`setRetrievedValue`** function.\n"
#~ "5. In the event of any errors during the process, an alert provides the user with the relevant error message."
#~ msgstr ""
#~ "1.å»ºç«‹æä¾›å•†å®ä¾‹ï¼ŒæŒ‡å®šæ’åºå™¨ç½‘ç»œ--åœ¨æœ¬ä¾‹ä¸­ï¼Œé€šè¿‡**`constants.NetworkName.SN_MAIN`** å°†å…¶è®¾ç½®ä¸º**`mainnet`**ã€‚\n"
#~ "2.æœ‰äº†è¿™ä¸ªæä¾›å•†ï¼Œå®ƒå°±ä¼šä½¿ç”¨æ‰€æä¾›çš„åˆçº¦ ABIã€åˆçº¦åœ°å€å’Œä¸Šè¿°æä¾›å•†å¯åŠ¨åˆçº¦å®ä¾‹ã€‚\n"
#~ "3.ç„¶åï¼Œå‡½æ•°ä¼šè°ƒç”¨åˆçº¦çš„ **`get_current_count`** æ–¹æ³•æ¥è·å–å½“å‰è®¡æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼Œç¨‹åºä¼šä½¿ç”¨**`await`**å…³é”®å­—ç­‰å¾…å…¶å®Œæˆã€‚\n"
#~ "4.ä¸€æ—¦æˆåŠŸè·å–ï¼Œè®¡æ•°ï¼ˆå¯èƒ½æ˜¯ä¸€ä¸ªæ•°å­—ï¼‰å°†è¢«è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä½¿ç”¨ **`setRetrievedValue`** å‡½æ•°è¿›è¡Œå­˜å‚¨ã€‚\n"
#~ "5.å¦‚æœè¿‡ç¨‹ä¸­å‡ºç°ä»»ä½•é”™è¯¯ï¼Œç³»ç»Ÿä¼šå‘å‡ºè­¦æŠ¥ï¼Œå‘ç”¨æˆ·æä¾›ç›¸å…³çš„é”™è¯¯ä¿¡æ¯ã€‚"

#~ msgid ""
#~ "1. **Establishing Connection**: With the **`connectWallet`** function, we made seamless connections to the blockchain, paving the way for interactions with our smart contract.\n"
#~ "2. **Terminating Connection**: The **`disconnectWallet`** function ensures that users can safely terminate their active connections to the blockchain, maintaining security and control.\n"
#~ "3. **Interacting with the Smart Contract**: Using the **`increaseCounter`**, **`decreaseCounter`**, and **`getCounter`** functions, we explored how to:\n"
#~ "   - Initiate transactions\n"
#~ "   - Adjust the counter value (increment or decrement)\n"
#~ "   - Fetch data from the blockchain"
#~ msgstr ""
#~ "1. **å»ºç«‹è¿æ¥**ï¼šé€šè¿‡**`connectWallet`**å‡½æ•°ï¼Œæˆ‘ä»¬ä¸åŒºå—é“¾å»ºç«‹äº†æ— ç¼è¿æ¥ï¼Œä¸ºä¸æˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦è¿›è¡Œäº¤äº’é“ºå¹³äº†é“è·¯ã€‚\n"
#~ "2. **ç»ˆæ­¢è¿æ¥**ï¼šé€šè¿‡**`disconnectWallet`**å‡½æ•°ï¼Œç”¨æˆ·å¯ä»¥å®‰å…¨åœ°ç»ˆæ­¢ä¸åŒºå—é“¾çš„æ´»åŠ¨è¿æ¥ï¼Œä»è€Œç»´æŠ¤å®‰å…¨å’Œæ§åˆ¶ã€‚\n"
#~ "3. **ä¸æ™ºèƒ½åˆçº¦äº¤äº’**ï¼šä½¿ç”¨**`increaseCounter`**ã€**`decreaseCounter`**å’Œ**`getCounter`**å‡½æ•°ï¼Œæˆ‘ä»¬æ¢ç´¢äº†å¦‚ä½•ï¼š\n"
#~ "   - å¯åŠ¨äº¤æ˜“\n"
#~ "   - è°ƒæ•´è®¡æ•°å™¨å€¼ï¼ˆé€’å¢æˆ–é€’å‡ï¼‰\n"
#~ "   - ä»åŒºå—é“¾ä¸­è·å–æ•°æ®"

#~ msgid ""
#~ "- Understand how to implement the ERC20 interface\n"
#~ "- Learn how to deploy contracts on the Starknet network\n"
#~ "- Discover ways to engage with contracts within a React application\n"
#~ "- Design their own ERC20 token and initiate it on Starknet"
#~ msgstr ""
#~ "- äº†è§£å¦‚ä½•å®ç° ERC20 æ¥å£\n"
#~ "- äº†è§£å¦‚ä½•åœ¨ Starknet ç½‘ç»œä¸Šéƒ¨ç½²åˆçº¦\n"
#~ "- æ¢ç´¢åœ¨ React åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨åˆçº¦çš„æ–¹æ³•\n"
#~ "- è®¾è®¡è‡ªå·±çš„ ERC20 Tokenå¹¶åœ¨ Starknet ä¸Šå¯åŠ¨å®ƒ"

#~ msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- Scarb 0.7.0 with Cairo 2.2.0\n"
#~ "- Starkli 0.1.9\n"
#~ "- Oppenzeppelin libraries v0.7.0\n"
#~ "- StarknetJS v5.19.5\n"
#~ "- get-starknet v3.0.1\n"
#~ "- NodeJS v19.6.1\n"
#~ "- Next.js 13.5.5\n"
#~ "- Visual Studio Code\n"
#~ "- Vercel"
#~ msgstr ""
#~ "- Scarb 0.7.0 with Cairo 2.2.0\n"
#~ "- Starkli 0.1.9\n"
#~ "- Oppenzeppelin libraries v0.7.0\n"
#~ "- StarknetJS v5.19.5\n"
#~ "- get-starknet v3.0.1\n"
#~ "- NodeJS v19.6.1\n"
#~ "- Next.js 13.5.5\n"
#~ "- Visual Studio Code\n"
#~ "- Vercel"

#~ msgid ""
#~ "```bash\n"
#~ "mkdir erc20\n"
#~ "cd erc20\n"
#~ "scarb init --name erc20\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "mkdir erc20\n"
#~ "cd erc20\n"
#~ "scarb init --name erc20\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod erc20 {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: u256,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    #[generate_trait]\n"
#~ "    impl Ierc20Impl of Ierc20 {\n"
#~ "        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
#~ "            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
#~ "            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod erc20 {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: u256,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    #[generate_trait]\n"
#~ "    impl Ierc20Impl of Ierc20 {\n"
#~ "        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
#~ "            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
#~ "            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```rust\n"
#~ "mod erc20;\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "mod erc20;\n"
#~ "```"

#~ msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20_lib_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli declare target/dev/erc20_erc20.sierra.json --account ../../demo-account.json --keystore ../../demo-key.json --compiler-version 2.1.0 --network goerli-1 --watch\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Enter keystore password:\n"
#~ "Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
#~ "... [shortened for brevity]\n"
#~ "Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Enter keystore password:\n"
#~ "Declaring Cairo 1 class: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
#~ "... [shortened for brevity]\n"
#~ "Class hash declared: 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713\n"
#~ "```"

#~ msgid ""
#~ "- `Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 decimals (a standard of OpenZeppelin), the input required is 1,000,000 \\* 10^18 or 0xd3c21bcecceda1000000. Due to the "
#~ "contract's expectation of a u256 mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 respectively.\n"
#~ "- `Receiver address`: Use a preferred address who wiil be the initial recipient of 1,000,000 MKT. In this example: 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
#~ msgstr ""
#~ "- `Initial mint`ï¼šé“¸é€  1,000,000 ä¸ªä»£å¸ã€‚é‰´äº MKT ä»£å¸åŒ…å« 18 ä½å°æ•°ï¼ˆOpenZeppelin çš„æ ‡å‡†ï¼‰ï¼Œæ‰€éœ€çš„è¾“å…¥ä¸º 1,000,000 \\* 10^18 æˆ– 0xd3c21bcecceda1000000ã€‚ç”±äºåˆçº¦æœŸæœ›çš„æ˜¯ u256 ç±»å‹çš„é“¸å¸å€¼ï¼Œå› æ­¤éœ€è¦"
#~ "åŒæ—¶æä¾›ä½å€¼å’Œé«˜å€¼ï¼šåˆ†åˆ«ä¸º 0xd3c21bcecceda1000000 å’Œ 0ã€‚\n"
#~ "- `Receiver address`ï¼šæ¥æ”¶è€…åœ°å€å¯ä»¥ä½¿ç”¨ä»»ä½•ä½ æŒæ§çš„åœ°å€ã€‚ä¾‹å¦‚ï¼š0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#~ msgid ""
#~ "```bash\n"
#~ "starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
#~ "0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli deploy 0x04940154eae35788e899ceb0ef2794eaa5ea6818af5c1c726d6d278fd4979713 --account ../../demo-account.json --keystore ../../demo-key.json --network goerli-1 --watch 0xd3c21bcecceda1000000 "
#~ "0 0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Enter keystore password:\n"
#~ "... [shortened for brevity]\n"
#~ "Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Enter keystore password:\n"
#~ "... [shortened for brevity]\n"
#~ "Contract deployed: 0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "npx create-next-app@latest erc20_web --use-npm\n"
#~ "âœ” Would you like to use TypeScript? â€¦ Yes\n"
#~ "âœ” Would you like to use ESLint? â€¦ Yes\n"
#~ "âœ” Would you like to use Tailwind CSS? â€¦ Yes\n"
#~ "âœ” Would you like to use `src/` directory? â€¦ Yes\n"
#~ "âœ” Would you like to use App Router? (recommended) â€¦ Yes\n"
#~ "âœ” Would you like to customize the default import alias (@/*)? â€¦ No\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npx create-next-app@latest erc20_web --use-npm\n"
#~ "âœ” Would you like to use TypeScript? â€¦ Yes\n"
#~ "âœ” Would you like to use ESLint? â€¦ Yes\n"
#~ "âœ” Would you like to use Tailwind CSS? â€¦ Yes\n"
#~ "âœ” Would you like to use `src/` directory? â€¦ Yes\n"
#~ "âœ” Would you like to use App Router? (recommended) â€¦ Yes\n"
#~ "âœ” Would you like to customize the default import alias (@/*)? â€¦ No\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
#~ "Using npm.\n"
#~ "Initializing project with template: app-tw\n"
#~ "Installing dependencies:\n"
#~ "- react\n"
#~ "- react-dom\n"
#~ "- next\n"
#~ "\n"
#~ "... [shortened for brevity]\n"
#~ "\n"
#~ "Initialized a git repository.\n"
#~ "Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "Creating a new Next.js app in /home/kali/cairo/erc20_web.\n"
#~ "Using npm.\n"
#~ "Initializing project with template: app-tw\n"
#~ "Installing dependencies:\n"
#~ "- react\n"
#~ "- react-dom\n"
#~ "- next\n"
#~ "\n"
#~ "... [shortened for brevity]\n"
#~ "\n"
#~ "Initialized a git repository.\n"
#~ "Success! Created erc20_web at /home/kali/cairo/erc20_web\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "cd erc20_web\n"
#~ "npm install get-starknet\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd erc20_web\n"
#~ "npm install get-starknet\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
#~ "... [shortened for brevity]\n"
#~ "Run `npm audit` for details.\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "added 3 packages, changed 1 package, and audited 1549 packages in 7s\n"
#~ "... [shortened for brevity]\n"
#~ "Run `npm audit` for details.\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "npm install starknet\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npm install starknet\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "added 18 packages, and audited 1546 packages in 6s\n"
#~ "... [shortened for brevity]\n"
#~ "Run `npm audit` for details.\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "added 18 packages, and audited 1546 packages in 6s\n"
#~ "... [shortened for brevity]\n"
#~ "Run `npm audit` for details.\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "npm list starknet\n"
#~ "\n"
#~ "npm list get-starknet\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npm list starknet\n"
#~ "\n"
#~ "npm list get-starknet\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm run dev\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm run dev\n"
#~ "```"

#~ msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm i -g vercel\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm i -g vercel\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "vercel login\n"
#~ "Continue with Email (or select your preferent login method)\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel login\n"
#~ "Continue with Email (or select your preferent login method)\n"
#~ "```"

#~ msgid ""
#~ "<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
#~ "\n"
#~ "<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr ""
#~ "<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login_js.png\" class=\"center\" style=\"width: 75%;\" />\n"
#~ "\n"
#~ "<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "vercel link\n"
#~ "? Set up â€œ~/cairo/erc20_webâ€? [Y/n] y\n"
#~ "? Which scope should contain your project? (just press enter)\n"
#~ "? Link to existing project? [y/N] n\n"
#~ "? Whatâ€™s your projectâ€™s name? erc20-web\n"
#~ "? In which directory is your code located? ./\n"
#~ "? Want to modify these settings? [y/N] n\n"
#~ "âœ…  Linked erc20-web (created .vercel)\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel link\n"
#~ "? Set up â€œ~/cairo/erc20_webâ€? [Y/n] y\n"
#~ "? Which scope should contain your project? (just press enter)\n"
#~ "? Link to existing project? [y/N] n\n"
#~ "? Whatâ€™s your projectâ€™s name? erc20-web\n"
#~ "? In which directory is your code located? ./\n"
#~ "? Want to modify these settings? [y/N] n\n"
#~ "âœ…  Linked erc20-web (created .vercel)\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "vercel\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "vercel --prod\n"
#~ "âœ…  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel --prod\n"
#~ "âœ…  Production: https://erc20-ch3cn791b-devnet0x-gmailcom.vercel.app [1s]\n"
#~ "```"

#~ msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4_js.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
#~ "\n"
#~ "- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
#~ "network.\n"
#~ "\n"
#~ "- **React Application**: Built a React application powered by StarknetJS, featuring components dedicated to balance inquiries and token transactions.\n"
#~ "\n"
#~ "- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
#~ "transactions."
#~ msgstr ""
#~ "- **é¡¹ç›®åˆå§‹åŒ–**ï¼šä½¿ç”¨ Scarb å’Œ OpenZeppelin åº“å»ºç«‹Starkneté¡¹ç›®ã€‚\n"
#~ "\n"
#~ "- **åˆ›å»º ERC20 åˆçº¦**ï¼šä½¿ç”¨Cairoå¼€å‘äº†ä¸€ä¸ª ERC20 ä»£å¸ï¼Œå¹¶ä¸°å¯Œäº†ä½™é¢æ£€æŸ¥å’Œä»£å¸è½¬è´¦ç­‰åŠŸèƒ½ã€‚ç„¶åå°†å…¶ç¼–è¯‘å¹¶åœ¨Starknetä¸Šå‘å¸ƒã€‚\n"
#~ "\n"
#~ "- **React åº”ç”¨ç¨‹åº**ï¼šæ„å»ºäº†ä¸€ä¸ªç”± Starknet React æ”¯æŒçš„ React åº”ç”¨ç¨‹åºï¼Œå…¶ä¸­åŒ…å«ä¸“é—¨ç”¨äºä½™é¢æŸ¥è¯¢å’Œä»£å¸äº¤æ˜“çš„ç»„ä»¶ã€‚\n"
#~ "\n"
#~ "- **åœ¨çº¿éƒ¨ç½²**ï¼šé€šè¿‡åœ¨ Vercel ä¸Šéƒ¨ç½²ï¼Œå°†æ‚¨çš„åº”ç”¨ç¨‹åºå¸¦ç»™æ›´å¤šç”¨æˆ·ã€‚è¿™ä½¿å¾—ç”¨æˆ·èƒ½å¤Ÿè¿æ¥ä»–ä»¬çš„é’±åŒ…ï¼ŒæŸ¥çœ‹ä»–ä»¬çš„ä½™é¢ï¼Œå¹¶æ‰§è¡Œä»£å¸äº¤æ˜“ã€‚"

#~ msgid "# Starknet-React: React Integration"
#~ msgstr "# Starknet-React: React é›†æˆ"

#~ msgid ""
#~ "Several tools exist in the starknet ecosystem to build the front-end for\n"
#~ "your application. The most popular ones are:"
#~ msgstr ""
#~ "Starknetç”Ÿæ€ç³»ç»Ÿä¸­æœ‰å‡ ç§å·¥å…·å¯ä»¥ä¸ºæ‚¨çš„åº”ç”¨ç¨‹åºæ„å»ºå‰ç«¯ã€‚\n"
#~ "æœ€å—æ¬¢è¿çš„å·¥å…·æœ‰:"

#~ msgid ""
#~ "For Vue developers, vue-stark-boil, created by the team at [Donâ€™t Panic\n"
#~ "DAO](https://github.com/dontpanicdao), is a great option. For a deeper\n"
#~ "understanding of Vue, visit their [website](https://vuejs.org/). The\n"
#~ "vue-stark-boil boilerplate enables various functionalities, such as\n"
#~ "connecting to a wallet, listening for account changes, and calling a\n"
#~ "contract."
#~ msgstr ""
#~ "å¯¹äº Vue å¼€å‘äººå‘˜æ¥è¯´ï¼Œç”± [Don't Panic DAO](https://github.com/dontpanicdao)å›¢é˜Ÿåˆ›å»ºçš„ vue-stark-boil æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚è¦æ·±å…¥\n"
#~ "äº†è§£ Vueï¼Œè¯·è®¿é—®ä»–ä»¬çš„ [ç½‘ç«™](https://vuejs.org/)ã€‚\n"
#~ "vue-stark-boil æ¨¡æ¿å¯å®ç°å„ç§åŠŸèƒ½ï¼Œä¾‹å¦‚\n"
#~ "è¿æ¥åˆ°é’±åŒ…ã€ç›‘å¬è´¦æˆ·å˜æ›´ä»¥åŠè°ƒç”¨åˆçº¦ã€‚"

#~ msgid ""
#~ "To immerse in the real-world application of Starknet React, we recommend\n"
#~ "exploring the comprehensive example dApp project at\n"
#~ "[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)."
#~ msgstr ""
#~ "è¦æ·±å…¥äº†è§£ Starknet React çš„å®é™…åº”ç”¨ï¼Œæˆ‘ä»¬å»ºè®®æ‚¨\n"
#~ "æ¢ç´¢ä½äº[starknet-demo-dapp](https://github.com/finiam/starknet-demo-dapp/)ä¸Šçš„dAppé¡¹ç›®èŒƒä¾‹ã€‚"

#~ msgid ""
#~ "Embarking on your Starknet React journey necessitates the incorporation\n"
#~ "of vital dependencies. Letâ€™s start by adding them to your project."
#~ msgstr "è¦å¼€å§‹ Starknet React ä¹‹æ—…ï¼Œæˆ‘ä»¬å¿…é¡»æ·»åŠ ä¸€äº›é‡è¦çš„ä¾èµ–å…³ç³»ã€‚è®©æˆ‘ä»¬å…ˆå°†å®ƒä»¬æ·»åŠ åˆ°æ‚¨çš„é¡¹ç›®ä¸­ã€‚"

#~ msgid "yarn add @starknet-react/core starknet get-starknet"
#~ msgstr "yarn add @starknet-react/core starknet get-starknet"

#~ msgid ""
#~ "Proceed by swaddling your app within the `StarknetConfig` component.\n"
#~ "This enveloping action offers a degree of configuration, while\n"
#~ "simultaneously providing a React Context for the application beneath to\n"
#~ "utilize shared data and hooks. The `StarknetConfig` component accepts a\n"
#~ "connectors prop, allowing the definition of wallet connection options\n"
#~ "available to the user."
#~ msgstr ""
#~ "å°†åº”ç”¨ç¨‹åºè£¹åœ¨ `StarknetConfig`ç»„ä»¶ä¸­ã€‚\n"
#~ "è¿™ç§å°è£…æ–¹å¼æä¾›äº†ä¸€å®šç¨‹åº¦çš„é…ç½®ï¼Œ\n"
#~ "åŒæ—¶ä¸ºä¸‹é¢çš„åº”ç”¨ç¨‹åºæä¾› React ä¸Šä¸‹æ–‡ï¼Œä»¥ä¾¿åˆ©ç”¨å…±äº«æ•°æ®å’Œé’©å­ã€‚\n"
#~ "`StarknetConfig`ç»„ä»¶æ¥å—ä¸€ä¸ª\n"
#~ "è¿æ¥å™¨propï¼Œå…è®¸å®šä¹‰ç”¨æˆ·å¯ç”¨çš„é’±åŒ…è¿æ¥é€‰é¡¹ã€‚"

#~ msgid ""
#~ "const connectors = [\n"
#~ "      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "    ];\n"
#~ "\n"
#~ "    return (\n"
#~ "        <StarknetConfig\n"
#~ "          connectors={connectors}\n"
#~ "          autoConnect\n"
#~ "        >\n"
#~ "          <App />\n"
#~ "        </StarknetConfig>\n"
#~ "    )"
#~ msgstr ""
#~ "const connectors = [\n"
#~ "      new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "      new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "    ];\n"
#~ "\n"
#~ "    return (\n"
#~ "        <StarknetConfig\n"
#~ "          connectors={connectors}\n"
#~ "          autoConnect\n"
#~ "        >\n"
#~ "          <App />\n"
#~ "        </StarknetConfig>\n"
#~ "    )"

#~ msgid ""
#~ "export default function Connect() {\n"
#~ "      const { connect, connectors, disconnect } = useConnectors();\n"
#~ "\n"
#~ "      return (\n"
#~ "        <div>\n"
#~ "          {connectors.map((connector) => (\n"
#~ "            <button\n"
#~ "              key={connector.id}\n"
#~ "              onClick={() => connect(connector)}\n"
#~ "              disabled={!connector.available()}\n"
#~ "            >\n"
#~ "              Connect with {connector.id}\n"
#~ "            </button>\n"
#~ "          ))}\n"
#~ "        </div>\n"
#~ "      );\n"
#~ "    }"
#~ msgstr ""
#~ "export default function Connect() {\n"
#~ "      const { connect, connectors, disconnect } = useConnectors();\n"
#~ "\n"
#~ "      return (\n"
#~ "        <div>\n"
#~ "          {connectors.map((connector) => (\n"
#~ "            <button\n"
#~ "              key={connector.id}\n"
#~ "              onClick={() => connect(connector)}\n"
#~ "              disabled={!connector.available()}\n"
#~ "            >\n"
#~ "              Connect with {connector.id}\n"
#~ "            </button>\n"
#~ "          ))}\n"
#~ "        </div>\n"
#~ "      );\n"
#~ "    }"

#~ msgid ""
#~ "Observe the `disconnect` function that terminates the connection when\n"
#~ "invoked. Post connection, access to the connected account is provided\n"
#~ "through the `useAccount` hook, offering insight into the current state\n"
#~ "of connection:"
#~ msgstr ""
#~ "è§‚å¯Ÿ`disconnect`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šåœ¨è°ƒç”¨æ—¶ç»ˆæ­¢è¿æ¥ã€‚\n"
#~ "è¿æ¥åï¼Œå¯é€šè¿‡ `useAccount` é’©å­è®¿é—®å·²è¿æ¥çš„è´¦æˆ·ï¼Œä»¥äº†è§£å½“å‰çš„è¿æ¥çŠ¶æ€ï¼š"

#~ msgid ""
#~ "const { address, isConnected, isReconnecting, account } = useAccount();\n"
#~ "\n"
#~ "    return (\n"
#~ "        <div>\n"
#~ "          {isConnected ? (\n"
#~ "              <p>Hello, {address}</p>\n"
#~ "          ) : (\n"
#~ "            <Connect />\n"
#~ "          )}\n"
#~ "        </div>\n"
#~ "    );"
#~ msgstr ""
#~ "const { address, isConnected, isReconnecting, account } = useAccount();\n"
#~ "\n"
#~ "    return (\n"
#~ "        <div>\n"
#~ "          {isConnected ? (\n"
#~ "              <p>Hello, {address}</p>\n"
#~ "          ) : (\n"
#~ "            <Connect />\n"
#~ "          )}\n"
#~ "        </div>\n"
#~ "    );"

#~ msgid ""
#~ "const { data, signTypedData } = useSignTypedData(typedMessage)\n"
#~ "\n"
#~ "    return (\n"
#~ "      <>\n"
#~ "        <p>\n"
#~ "          <button onClick={signTypedData}>Sign</button>\n"
#~ "        </p>\n"
#~ "        {data && <p>Signed: {JSON.stringify(data)}</p>}\n"
#~ "      </>\n"
#~ "    )"
#~ msgstr ""
#~ "const { data, signTypedData } = useSignTypedData(typedMessage)\n"
#~ "\n"
#~ "    return (\n"
#~ "      <>\n"
#~ "        <p>\n"
#~ "          <button onClick={signTypedData}>Sign</button>\n"
#~ "        </p>\n"
#~ "        {data && <p>Signed: {JSON.stringify(data)}</p>}\n"
#~ "      </>\n"
#~ "    )"

#~ msgid ""
#~ "const { data, isError, isLoading, status } = useStarkName({ address });\n"
#~ "    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    return <p>Account: {isError ? address : data}</p>"
#~ msgstr ""
#~ "const { data, isError, isLoading, status } = useStarkName({ address });\n"
#~ "    // You can track the status of the request with the status variable ('idle' | 'error' | 'loading' | 'success')\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    return <p>Account: {isError ? address : data}</p>"

#~ msgid ""
#~ "You also have additional information you can get from this hook â†’\n"
#~ "**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
#~ "**isFetchedAfterMount**, **isRefetching**, **refetch** which can give\n"
#~ "you more precise information on what is happening."
#~ msgstr ""
#~ "æ‚¨è¿˜å¯ä»¥ä»è¯¥é’©å­è·å–å…¶ä»–ä¿¡æ¯ â†’ \n"
#~ "**error**, **isIdle**, **isFetching**, **isSuccess**, **isFetched**,\n"
#~ "**isFetchedAfterMount**, **isRefetching**, **refetch**ï¼Œè¿™å¯ä»¥ä¸ºæ‚¨æä¾›æ›´ç²¾ç¡®çš„ä¿¡æ¯ã€‚"

#~ msgid ""
#~ "const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    if (isError) return <p>Something went wrong</p>\n"
#~ "    return <p>Address: {data}</p>"
#~ msgstr ""
#~ "const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n"
#~ "\n"
#~ "    if (isLoading) return <p>Loading...</p>\n"
#~ "    if (isError) return <p>Something went wrong</p>\n"
#~ "    return <p>Address: {data}</p>"

#~ msgid ""
#~ "const { data, isError, isFetching } = useBlock({\n"
#~ "        refetchInterval: 10_000,\n"
#~ "        blockIdentifier: \"latest\",\n"
#~ "    });\n"
#~ "\n"
#~ "    if (isError) {\n"
#~ "      return (\n"
#~ "        <p>Something went wrong</p>\n"
#~ "      )\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "        <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
#~ "    )"
#~ msgstr ""
#~ "const { data, isError, isFetching } = useBlock({\n"
#~ "        refetchInterval: 10_000,\n"
#~ "        blockIdentifier: \"latest\",\n"
#~ "    });\n"
#~ "\n"
#~ "    if (isError) {\n"
#~ "      return (\n"
#~ "        <p>Something went wrong</p>\n"
#~ "      )\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "        <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
#~ "    )"

#~ msgid ""
#~ "To improve your dApp User Experience, you can track the user wallet\n"
#~ "changes, especially when the user changes the wallet account (or\n"
#~ "connects/disconnects). But also when the user changes the network. You\n"
#~ "could want to reload correct balances when the user changes the account,\n"
#~ "or to reset the state of your dApp when the user changes the network. To\n"
#~ "do so, you can use a previous hook we already looked at: `useAccount`\n"
#~ "and a new one `useNetwork`."
#~ msgstr ""
#~ "ä¸ºæ”¹å–„æ‚¨çš„ dApp ç”¨æˆ·ä½“éªŒï¼Œæ‚¨å¯ä»¥è·Ÿè¸ªç”¨æˆ·é’±åŒ…\\çš„å˜åŒ–ï¼Œå°¤å…¶æ˜¯å½“ç”¨æˆ·æ›´æ¢é’±åŒ…è´¦æˆ·ï¼ˆæˆ– è¿æ¥/æ–­å¼€è¿æ¥æ—¶ï¼‰ã€‚\n"
#~ "ç”¨æˆ·æ›´æ¢ç½‘ç»œæ—¶ä¹Ÿæ˜¯å¦‚æ­¤ã€‚å½“ç”¨æˆ·æ›´æ¢è´¦æˆ·æ—¶ï¼Œæ‚¨å¯èƒ½å¸Œæœ›é‡æ–°åŠ è½½æ­£ç¡®çš„ä½™é¢ã€\n"
#~ "æˆ–åœ¨ç”¨æˆ·æ›´æ¢ç½‘ç»œæ—¶é‡ç½® dApp çš„çŠ¶æ€ã€‚\n"
#~ "ä¸ºæ­¤æ‚¨å¯ä»¥ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰ä»‹ç»è¿‡çš„é’©å­ï¼š`useAccount`å’Œä¸€ä¸ªæ–°é’©å­ `useNetwork`ã€‚"

#~ msgid ""
#~ "const { chain: {id, name} } = useNetwork();\n"
#~ "\n"
#~ "    return (\n"
#~ "        <>\n"
#~ "            <p>Connected chain: {name}</p>\n"
#~ "            <p>Connected chain id: {id}</p>\n"
#~ "        </>\n"
#~ "    )"
#~ msgstr ""
#~ "const { chain: {id, name} } = useNetwork();\n"
#~ "\n"
#~ "    return (\n"
#~ "        <>\n"
#~ "            <p>Connected chain: {name}</p>\n"
#~ "            <p>Connected chain id: {id}</p>\n"
#~ "        </>\n"
#~ "    )"

#~ msgid ""
#~ "You also have additional information you can get from this hook â†’\n"
#~ "**blockExplorer**, **testnet** which can give you more precise\n"
#~ "information about the current network being used."
#~ msgstr ""
#~ "æ‚¨è¿˜å¯ä»¥ä»è¯¥é’©å­è·å–æ›´å¤šä¿¡æ¯ â†’ \n"
#~ "**blockExplorer**ã€**testnet**ï¼Œå®ƒä»¬å¯ä»¥ä¸ºæ‚¨æä¾›æ›´ç²¾ç¡®çš„å½“å‰ä½¿ç”¨çš„ç½‘ç»œçš„ä¿¡æ¯ã€‚"

#~ msgid ""
#~ "After knowing this you have all you need to track user interaction on\n"
#~ "the using account and network. You can use the `useEffect` hook to do\n"
#~ "some work on changes."
#~ msgstr ""
#~ "äº†è§£è¿™äº›ä¿¡æ¯åï¼Œä½ å°±å¯ä»¥è·Ÿè¸ªç”¨æˆ·åœ¨ä½¿ç”¨è´¦æˆ·å’Œç½‘ç»œä¸Šçš„äº¤äº’æƒ…å†µäº†ã€‚\n"
#~ "å½“ç½‘ç»œå‘ç”Ÿå˜æ›´æ—¶ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ `useEffect` é’©å­ã€‚"

#~ msgid ""
#~ "const { chain } = useNetwork();\n"
#~ "    const { address } = useAccount();\n"
#~ "\n"
#~ "    useEffect(() => {\n"
#~ "        if(address) {\n"
#~ "            // Do some work when the user changes the account on the wallet\n"
#~ "            // Like reloading the balances\n"
#~ "        }else{\n"
#~ "            // Do some work when the user disconnects the wallet\n"
#~ "            // Like reseting the state of your dApp\n"
#~ "        }\n"
#~ "    }, [address]);\n"
#~ "\n"
#~ "    useEffect(() => {\n"
#~ "        // Do some work when the user changes the network on the wallet\n"
#~ "        // Like reseting the state of your dApp\n"
#~ "    }, [chain]);"
#~ msgstr ""
#~ "const { chain } = useNetwork();\n"
#~ "    const { address } = useAccount();\n"
#~ "\n"
#~ "    useEffect(() => {\n"
#~ "        if(address) {\n"
#~ "            // Do some work when the user changes the account on the wallet\n"
#~ "            // Like reloading the balances\n"
#~ "        }else{\n"
#~ "            // Do some work when the user disconnects the wallet\n"
#~ "            // Like reseting the state of your dApp\n"
#~ "        }\n"
#~ "    }, [address]);\n"
#~ "\n"
#~ "    useEffect(() => {\n"
#~ "        // Do some work when the user changes the network on the wallet\n"
#~ "        // Like reseting the state of your dApp\n"
#~ "    }, [chain]);"

#~ msgid ""
#~ "const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
#~ "        abi: abi_erc20,\n"
#~ "        address: CONTRACT_ADDRESS,\n"
#~ "        functionName: \"allowance\",\n"
#~ "        args: [owner, spender],\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "    });"
#~ msgstr ""
#~ "const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
#~ "        abi: abi_erc20,\n"
#~ "        address: CONTRACT_ADDRESS,\n"
#~ "        functionName: \"allowance\",\n"
#~ "        args: [owner, spender],\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "    });"

#~ msgid ""
#~ "For ERC20 operations, Starknet React offers a convenient useBalance\n"
#~ "hook. This hook exempts you from passing an ABI and returns a suitably\n"
#~ "formatted balance value."
#~ msgstr ""
#~ "å¯¹äº ERC20 æ“ä½œï¼ŒStarknet React æä¾›äº†æ–¹ä¾¿çš„ `useBalance`é’©å­ã€‚\n"
#~ "è¯¥é’©å­æ— éœ€ä¼ é€’ ABIï¼Œå¹¶è¿”å›ä¸€ä¸ªè¢«æ ¼å¼åŒ–çš„ä½™é¢å€¼ã€‚"

#~ msgid ""
#~ "  const { data, isLoading } = useBalance({\n"
#~ "        address,\n"
#~ "        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "      });\n"
#~ "\n"
#~ "      return (\n"
#~ "        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
#~ "      )"
#~ msgstr ""
#~ "  const { data, isLoading } = useBalance({\n"
#~ "        address,\n"
#~ "        token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
#~ "        // watch: true <- refresh at every block\n"
#~ "      });\n"
#~ "\n"
#~ "      return (\n"
#~ "        <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
#~ "      )"

#~ msgid ""
#~ "The useContractWrite hook, designed for write operations, deviates\n"
#~ "slightly from wagmi. The unique architecture of Starknet facilitates\n"
#~ "multicall transactions natively at the account level. This feature\n"
#~ "enhances the user experience when executing multiple transactions,\n"
#~ "eliminating the need to approve each transaction individually. Starknet\n"
#~ "React capitalizes on this functionality through the useContractWrite\n"
#~ "hook. Below is a demonstration of its usage:"
#~ msgstr ""
#~ "ç”¨äºå†™æ“ä½œçš„ `useContractWrite` é’©å­ä¸ wagmi ç¨æœ‰ä¸åŒã€‚\n"
#~ "Starknetçš„ç‹¬ç‰¹æ¶æ„æœ‰åˆ©äºå¤šé‡è°ƒç”¨äº¤æ˜“ã€‚\n"
#~ "è¯¥åŠŸèƒ½åœ¨æ‰§è¡Œå¤šç¬”äº¤æ˜“æ—¶å¢å¼ºç”¨æˆ·ä½“éªŒã€æ— éœ€é€ç¬”å®¡æ‰¹ã€‚\n"
#~ "Starknet React é€šè¿‡ `useContractWrite`\n"
#~ "é’©å­åˆ©ç”¨äº†è¿™ä¸€åŠŸèƒ½ã€‚ä¸‹é¢æ˜¯å…¶ç”¨æ³•æ¼”ç¤ºï¼š"

#~ msgid ""
#~ "const calls = useMemo(() => {\n"
#~ "        // compile the calldata to send\n"
#~ "        const calldata = stark.compileCalldata({\n"
#~ "          argName: argValue,\n"
#~ "        });\n"
#~ "\n"
#~ "        // return a single object for single transaction,\n"
#~ "        // or an array of objects for multicall**\n"
#~ "        return {\n"
#~ "          contractAddress: CONTRACT_ADDRESS,\n"
#~ "          entrypoint: functionName,\n"
#~ "          calldata,\n"
#~ "        };\n"
#~ "    }, [argValue]);\n"
#~ "\n"
#~ "\n"
#~ "    // Returns a function to trigger the transaction\n"
#~ "    // and state of tx after being sent\n"
#~ "    const { write, isLoading, data } = useContractWrite({\n"
#~ "        calls,\n"
#~ "    });\n"
#~ "\n"
#~ "    function execute() {\n"
#~ "      // trigger the transaction\n"
#~ "      write();\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "      <button type=\"button\" onClick={execute}>\n"
#~ "        Make a transaction\n"
#~ "      </button>\n"
#~ "    )"
#~ msgstr ""
#~ "const calls = useMemo(() => {\n"
#~ "        // compile the calldata to send\n"
#~ "        const calldata = stark.compileCalldata({\n"
#~ "          argName: argValue,\n"
#~ "        });\n"
#~ "\n"
#~ "        // return a single object for single transaction,\n"
#~ "        // or an array of objects for multicall**\n"
#~ "        return {\n"
#~ "          contractAddress: CONTRACT_ADDRESS,\n"
#~ "          entrypoint: functionName,\n"
#~ "          calldata,\n"
#~ "        };\n"
#~ "    }, [argValue]);\n"
#~ "\n"
#~ "\n"
#~ "    // Returns a function to trigger the transaction\n"
#~ "    // and state of tx after being sent\n"
#~ "    const { write, isLoading, data } = useContractWrite({\n"
#~ "        calls,\n"
#~ "    });\n"
#~ "\n"
#~ "    function execute() {\n"
#~ "      // trigger the transaction\n"
#~ "      write();\n"
#~ "    }\n"
#~ "\n"
#~ "    return (\n"
#~ "      <button type=\"button\" onClick={execute}>\n"
#~ "        Make a transaction\n"
#~ "      </button>\n"
#~ "    )"

#~ msgid ""
#~ "The code snippet begins by compiling the calldata using the\n"
#~ "compileCalldata utility provided by Starknet.js. This calldata, along\n"
#~ "with the contract address and entry point, are passed to the\n"
#~ "useContractWrite hook. The hook returns a write function that is\n"
#~ "subsequently used to execute the transaction. The hook also provides the\n"
#~ "transactionâ€™s hash and state."
#~ msgstr ""
#~ "ä»£ç ç‰‡æ®µé¦–å…ˆä½¿ç”¨ Starknet.js æä¾›çš„`compileCalldata`ã€‚\n"
#~ "è¿™äº› calldataä»¥åŠåˆçº¦åœ°å€å’Œå…¥å£ç‚¹ä¸€èµ·ä¼ é€’ç»™`useContractWrite` é’©å­ã€‚\n"
#~ "è¯¥é’©å­ä¼šè¿”å›ä¸€ä¸ªå†™å…¥å‡½æ•°,éšåç”¨äºæ‰§è¡Œäº‹åŠ¡ã€‚\n"
#~ "è¯¥é’©å­è¿˜æä¾›äº†äº‹åŠ¡çš„å“ˆå¸Œå€¼å’ŒçŠ¶æ€ã€‚"

#~ msgid ""
#~ "The useTransaction hook allows for the tracking of transaction states\n"
#~ "given a transaction hash. This hook maintains a cache of all\n"
#~ "transactions, thereby minimizing redundant network requests."
#~ msgstr ""
#~ "ä½¿ç”¨`useTransaction`é’©å­å¯ä»¥è·Ÿè¸ªç»™å®šå“ˆå¸Œå€¼äº¤æ˜“çš„çŠ¶æ€ã€‚\n"
#~ "è¯¥é’©å­ä¼šç¼“å­˜æ‰€æœ‰äº¤æ˜“ï¼Œä»è€Œæœ€å¤§é™åº¦åœ°å‡å°‘å†—ä½™ç½‘ç»œè¯·æ±‚ã€‚"

#~ msgid ""
#~ "const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
#~ "\n"
#~ "    return (\n"
#~ "      <pre>\n"
#~ "        {JSON.stringify(data?.calldata)}\n"
#~ "      </pre>\n"
#~ "    )"
#~ msgstr ""
#~ "const { data, isLoading, error } = useTransaction({ hash: txHash });\n"
#~ "\n"
#~ "    return (\n"
#~ "      <pre>\n"
#~ "        {JSON.stringify(data?.calldata)}\n"
#~ "      </pre>\n"
#~ "    )"

#~ msgid ""
#~ "Through the diligent work of dedicated developers and contributors,\n"
#~ "Starknet React continues to evolve. New features and optimizations are\n"
#~ "regularly added, fostering a dynamic and growing ecosystem of\n"
#~ "decentralized applications."
#~ msgstr ""
#~ "é€šè¿‡æ•¬ä¸šçš„å¼€å‘äººå‘˜å’Œè´¡çŒ®è€…çš„è¾›å‹¤å·¥ä½œã€Starknet React ä¸æ–­å‘å±•ã€‚\n"
#~ "æ–°åŠŸèƒ½å’Œä¼˜åŒ–ä¼šè¢«å®šæœŸæ·»åŠ ï¼Œä¿ƒè¿›äº†ä¸€ä¸ªå……æ»¡æ´»åŠ›ã€ä¸æ–­å‘å±•çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ç”Ÿæ€ç³»ç»Ÿã€‚"

#~ msgid ""
#~ "Itâ€™s a fascinating journey, filled with innovative technology, endless\n"
#~ "opportunities, and a growing community of passionate individuals. As a\n"
#~ "developer, youâ€™re not only building applications, but contributing to\n"
#~ "the advancement of a global, decentralized network."
#~ msgstr ""
#~ "è¿™æ˜¯ä¸€æ®µä»¤äººç¥å¾€çš„æ—…ç¨‹ï¼Œå……æ»¡äº†åˆ›æ–°çš„æŠ€æœ¯ã€æ— å°½çš„æœºé‡ï¼Œä»¥åŠç”±å……æ»¡æ¿€æƒ…çš„ä¸ªäººç»„æˆçš„ä¸æ–­å£®å¤§çš„ç¤¾åŒºã€‚\n"
#~ "ä½œä¸ºä¸€åå¼€å‘äººå‘˜ï¼Œä½ ä¸ä»…è¦å¼€å‘åº”ç”¨ç¨‹åºï¼Œè¿˜è¦ä¸ºæ¨åŠ¨å…¨çƒå»ä¸­å¿ƒåŒ–ç½‘ç»œçš„å‘å±•åšå‡ºè´¡çŒ®ã€‚"

#~ msgid ""
#~ "Have questions or need help? The Starknet community is always ready to\n"
#~ "assist. Join the [Starknet Discord](https://discord.gg/starknet) or\n"
#~ "explore the [StarknetBookâ€™s GitHub\n"
#~ "repository](https://github.com/starknet-edu/starknetbook) for resources\n"
#~ "and support."
#~ msgstr ""
#~ "æœ‰é—®é¢˜æˆ–éœ€è¦å¸®åŠ©ï¼ŸStarknetç¤¾åŒºéšæ—¶å‡†å¤‡å¸®åŠ©ã€‚\n"
#~ "åŠ å…¥ [Starknet Discord](https://discord.gg/starknet) æˆ–\n"
#~ "æ¢ç´¢[StarknetBook çš„ GitHub èµ„æºåº“](https://github.com/starknet-edu/starknetbook) è·å–èµ„æºå’Œæ”¯æŒã€‚"

#~ msgid "## Further Reading"
#~ msgstr "## è¿›ä¸€æ­¥é˜…è¯»"

#~ msgid ""
#~ "- [Starknet.js](https://starknet.js.org)\n"
#~ "\n"
#~ "- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
#~ "\n"
#~ "- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
#~ "\n"
#~ "- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"
#~ msgstr ""
#~ "- [Starknet.js](https://starknet.js.org)\n"
#~ "\n"
#~ "- [Starknet React Docs](https://www.apibara.com/starknet-react-docs)\n"
#~ "\n"
#~ "- [Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)\n"
#~ "\n"
#~ "- [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"

#~ msgid ""
#~ "In this subchapter, readers will find practical examples demonstrating the usage of `starknet-react`. It provides insight into real-world applications and serves as a guide for developers to "
#~ "understand and implement these tools effectively."
#~ msgstr "åœ¨æœ¬åˆ†ç« ä¸­ï¼Œè¯»è€…å°†çœ‹åˆ°æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ `starknet-react` çš„å®é™…ç¤ºä¾‹ã€‚å®ƒæä¾›äº†å¯¹çœŸå®ä¸–ç•Œåº”ç”¨çš„æ´å¯Ÿï¼Œå¯ä½œä¸ºå¼€å‘äººå‘˜ç†è§£å’Œæœ‰æ•ˆå®æ–½è¿™äº›å·¥å…·çš„æŒ‡å—ã€‚"

#~ msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-screenshot.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- Scarb 0.7.0 with Cairo 2.2.0\n"
#~ "- Starkli 0.1.9\n"
#~ "- Oppenzeppelin libraries v0.7.0\n"
#~ "- Starknet React v1.0.4\n"
#~ "- NodeJS v19.6.1\n"
#~ "- Next.js 13.1.6\n"
#~ "- Visual Studio Code\n"
#~ "- Vercel"
#~ msgstr ""
#~ "- Scarb 0.7.0 with Cairo 2.2.0\n"
#~ "- Starkli 0.1.9\n"
#~ "- Oppenzeppelin libraries v0.7.0\n"
#~ "- Starknet React v1.0.4\n"
#~ "- NodeJS v19.6.1\n"
#~ "- Next.js 13.1.6\n"
#~ "- Visual Studio Code\n"
#~ "- Vercel"

#~ msgid "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20\" src=\"img/ch02-basic-dapp-erc20.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "npm add @starknet-react/core\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npm add @starknet-react/core\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "npm list @starknet-react/core\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npm list @starknet-react/core\n"
#~ "```"

#~ msgid "Starknet React library provides the `create-starknet` script that streamlines the setup of a Starknet application using TypeScript:"
#~ msgstr "Starknet React åº“æä¾›äº†`create-starknet` è„šæœ¬ï¼Œå¯ä½¿ç”¨ TypeScript ç®€åŒ– Starknet åº”ç”¨ç¨‹åºçš„è®¾ç½®ï¼š"

#~ msgid ""
#~ "```bash\n"
#~ "npx create-starknet erc20_web --use-npm\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "npx create-starknet erc20_web --use-npm\n"
#~ "```"

#~ msgid "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Basic Dapp ERC20 React Files\" src=\"img/ch02-basic-dapp-react-files.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "1. At the root of your project, create a new directory named `assets/`.\n"
#~ "2. Inside the `assets/` directory, create an empty JSON file named `erc20.json`.\n"
#~ "3. Go back to your ERC20 Cairo project folder and locate the `erc20/target/erc20_erc20_sierra.json` file."
#~ msgstr ""
#~ "1.åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ–°å»ºä¸€ä¸ªåä¸º `assets/` çš„ç›®å½•ã€‚\n"
#~ "2.åœ¨ `assets/` ç›®å½•ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªåä¸º `erc20.json` çš„ç©º JSON æ–‡ä»¶ã€‚\n"
#~ "3.è¿”å› ERC20 Cairo é¡¹ç›®æ–‡ä»¶å¤¹ï¼Œæ‰¾åˆ° `erc20/target/erc20_erc20_sierra.json` æ–‡ä»¶ã€‚"

#~ msgid "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"ABI Original\" src=\"img/ch02-basic-dapp-abi.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"ABI Updated\" src=\"img/ch02-basic-dapp-abi-new.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Localhost\" src=\"img/ch02-basic-dapp-localhost.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm i -g vercel\n"
#~ "vercel init\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd erc20_web/\n"
#~ "npm i -g vercel\n"
#~ "vercel init\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "vercel login\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel login\n"
#~ "```"

#~ msgid ""
#~ "<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
#~ "\n"
#~ "<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr ""
#~ "<img alt=\"Vercel login\" src=\"img/ch02-basic-dapp-vercel-login.png\" class=\"center\" style=\"width: 75%;\" />\n"
#~ "\n"
#~ "<img alt=\"Vercel verify\" src=\"img/ch02-basic-dapp-vercel-verify.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```bash\n"
#~ "vercel link\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel link\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "vercel --prod\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "vercel --prod\n"
#~ "```"

#~ msgid "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication\" src=\"img/ch02-basic-dapp-pub1.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 2\" src=\"img/ch02-basic-dapp-pub2.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 3\" src=\"img/ch02-basic-dapp-pub3.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Vercel publication 4\" src=\"img/ch02-basic-dapp-pub4.png\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- **Project Initialization**: Set up a Starknet project with Scarb and incorporated OpenZeppelin libraries.\n"
#~ "- **Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, enriched with functionalities like balance checks and token transfers. This was then compiled and launched on the Starknet "
#~ "network.\n"
#~ "\n"
#~ "- **React Application**: Built a React application powered by Starknet React, featuring components dedicated to balance inquiries and token transactions.\n"
#~ "\n"
#~ "- **ABI Creation**: Produced the ABI for the MKT token, a critical component to liaise with the contract.\n"
#~ "\n"
#~ "- **Online Deployment**: Brought your application to a wider audience by deploying it on Vercel. This empowered users to connect their wallets, scrutinize their balances, and execute token "
#~ "transactions."
#~ msgstr ""
#~ "- **é¡¹ç›®åˆå§‹åŒ–**ï¼šä½¿ç”¨ Scarb å’Œ OpenZeppelin åº“å»ºç«‹Starkneté¡¹ç›®ã€‚\n"
#~ "- **åˆ›å»º ERC20 åˆçº¦**ï¼šä½¿ç”¨Cairoå¼€å‘äº†ä¸€ä¸ª ERC20 ä»£å¸ï¼Œå¹¶ä¸°å¯Œäº†ä½™é¢æ£€æŸ¥å’Œä»£å¸è½¬è´¦ç­‰åŠŸèƒ½ã€‚ç„¶åå°†å…¶ç¼–è¯‘å¹¶åœ¨Starknetä¸Šå‘å¸ƒã€‚\n"
#~ "\n"
#~ "- **React åº”ç”¨ç¨‹åº**ï¼šæ„å»ºäº†ä¸€ä¸ªç”± Starknet React æ”¯æŒçš„ React åº”ç”¨ç¨‹åºï¼Œå…¶ä¸­åŒ…å«ä¸“é—¨ç”¨äºä½™é¢æŸ¥è¯¢å’Œä»£å¸äº¤æ˜“çš„ç»„ä»¶ã€‚\n"
#~ "\n"
#~ "- **åˆ›å»ºABI**ï¼šåˆ¶ä½œ MKT ä»£å¸çš„ ABIï¼Œè¿™æ˜¯é“¾æ¥åˆçº¦çš„å…³é”®ç»„ä»¶ã€‚\n"
#~ "\n"
#~ "- **åœ¨çº¿éƒ¨ç½²**ï¼šé€šè¿‡åœ¨ Vercel ä¸Šéƒ¨ç½²ï¼Œå°†æ‚¨çš„åº”ç”¨ç¨‹åºå¸¦ç»™æ›´å¤šç”¨æˆ·ã€‚è¿™ä½¿å¾—ç”¨æˆ·èƒ½å¤Ÿè¿æ¥ä»–ä»¬çš„é’±åŒ…ï¼ŒæŸ¥çœ‹ä»–ä»¬çš„ä½™é¢ï¼Œå¹¶æ‰§è¡Œä»£å¸äº¤æ˜“ã€‚"

#~ msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage.jpg\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- [Starknet-react](https://github.com/apibara/starknet-react)\n"
#~ "- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
#~ "- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
#~ "- [MaterialUI](https://mui.com/material-ui/)"
#~ msgstr ""
#~ "- [Starknet-react](https://github.com/apibara/starknet-react)\n"
#~ "- [Starknet.js](https://github.com/0xs34n/starknet.js)\n"
#~ "- [OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-contracts)\n"
#~ "- [MaterialUI](https://mui.com/material-ui/)"

#~ msgid ""
#~ "```shell\n"
#~ "npx create-starknet\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "npx create-starknet\n"
#~ "```"

#~ msgid ""
#~ "```javascript\n"
#~ "const connectors = [\n"
#~ "  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "];\n"
#~ "const provider = new Provider({\n"
#~ "  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
#~ "});\n"
#~ "return (\n"
#~ "  <StarknetConfig\n"
#~ "    autoConnect\n"
#~ "    defaultProvider={provider}\n"
#~ "    connectors={connectors}\n"
#~ "  >\n"
#~ "    <CacheProvider value={emotionCache}>\n"
#~ "      <ThemeProvider theme={theme}>\n"
#~ "        <Component {...pageProps} />\n"
#~ "      </ThemeProvider>\n"
#~ "    </CacheProvider>\n"
#~ "  </StarknetConfig>\n"
#~ ");\n"
#~ "```"
#~ msgstr ""
#~ "```javascript\n"
#~ "const connectors = [\n"
#~ "  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
#~ "  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
#~ "];\n"
#~ "const provider = new Provider({\n"
#~ "  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
#~ "});\n"
#~ "return (\n"
#~ "  <StarknetConfig\n"
#~ "    autoConnect\n"
#~ "    defaultProvider={provider}\n"
#~ "    connectors={connectors}\n"
#~ "  >\n"
#~ "    <CacheProvider value={emotionCache}>\n"
#~ "      <ThemeProvider theme={theme}>\n"
#~ "        <Component {...pageProps} />\n"
#~ "      </ThemeProvider>\n"
#~ "    </CacheProvider>\n"
#~ "  </StarknetConfig>\n"
#~ ");\n"
#~ "```"

#~ msgid ""
#~ "- Wallet connectivity\n"
#~ "- Grid for displaying existing tokens\n"
#~ "- Cell selection capability\n"
#~ "- Multicall function for token approval and minting\n"
#~ "- Dropdown to view owned tokens\n"
#~ "- On-chain representation of the entire 1 million pixel grid"
#~ msgstr ""
#~ "- é’±åŒ…è¿æ¥\n"
#~ "- ç”¨äºæ˜¾ç¤ºç°æœ‰ä»£å¸çš„ç½‘æ ¼\n"
#~ "- å•å…ƒé€‰æ‹©åŠŸèƒ½\n"
#~ "- ç”¨äºä»£å¸ä½¿ç”¨è®¸å¯å’Œé“¸å¸çš„å¤šé‡è°ƒç”¨åŠŸèƒ½\n"
#~ "- ä¸‹æ‹‰èœå•å¯æŸ¥çœ‹æ‹¥æœ‰çš„ä»£å¸\n"
#~ "- åœ¨é“¾ä¸Šæ˜¾ç¤ºæ•´ä¸ª 100 ä¸‡åƒç´ ç½‘æ ¼"

#~ msgid ""
#~ "```rust\n"
#~ "impl StoreFelt252Array of Store<Array<felt252>> {\n"
#~ "    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
#~ "        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
#~ "    }\n"
#~ "    fn write(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
#~ "    ) -> SyscallResult<()> {\n"
#~ "        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
#~ "    }\n"
#~ "    fn read_at_offset(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
#~ "    ) -> SyscallResult<Array<felt252>> {\n"
#~ "        let mut arr: Array<felt252> = ArrayTrait::new();\n"
#~ "        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
#~ "        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
#~ "            .expect('Storage Span too large');\n"
#~ "\n"
#~ "        offset += 1;\n"
#~ "\n"
#~ "        // Sequentially read all stored elements and append them to the array.\n"
#~ "        let exit = len + offset;\n"
#~ "        loop {\n"
#~ "            if offset >= exit {\n"
#~ "                break;\n"
#~ "            }\n"
#~ "            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
#~ "            arr.append(value);\n"
#~ "            offset += Store::<felt252>::size();\n"
#~ "        };\n"
#~ "        Result::Ok(arr)\n"
#~ "    }\n"
#~ "    fn write_at_offset(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
#~ "    ) -> SyscallResult<()> {\n"
#~ "        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
#~ "        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
#~ "        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
#~ "        offset += 1;\n"
#~ "        // Store the array elements sequentially\n"
#~ "        loop {\n"
#~ "            match value.pop_front() {\n"
#~ "                Option::Some(element) => {\n"
#~ "                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
#~ "                    offset += Store::<felt252>::size();\n"
#~ "                },\n"
#~ "                Option::None => {\n"
#~ "                    break Result::Ok(());\n"
#~ "                }\n"
#~ "            };\n"
#~ "        }\n"
#~ "    }\n"
#~ "    fn size() -> u8 {\n"
#~ "        255 / Store::<felt252>::size()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "impl StoreFelt252Array of Store<Array<felt252>> {\n"
#~ "    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {\n"
#~ "        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
#~ "    }\n"
#~ "    fn write(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
#~ "    ) -> SyscallResult<()> {\n"
#~ "        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
#~ "    }\n"
#~ "    fn read_at_offset(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
#~ "    ) -> SyscallResult<Array<felt252>> {\n"
#~ "        let mut arr: Array<felt252> = ArrayTrait::new();\n"
#~ "        // Read the stored array's length. If the length is superior to 255, the read will fail.\n"
#~ "        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)\n"
#~ "            .expect('Storage Span too large');\n"
#~ "\n"
#~ "        offset += 1;\n"
#~ "\n"
#~ "        // Sequentially read all stored elements and append them to the array.\n"
#~ "        let exit = len + offset;\n"
#~ "        loop {\n"
#~ "            if offset >= exit {\n"
#~ "                break;\n"
#~ "            }\n"
#~ "            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();\n"
#~ "            arr.append(value);\n"
#~ "            offset += Store::<felt252>::size();\n"
#~ "        };\n"
#~ "        Result::Ok(arr)\n"
#~ "    }\n"
#~ "    fn write_at_offset(\n"
#~ "        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>\n"
#~ "    ) -> SyscallResult<()> {\n"
#~ "        // // Store the length of the array in the first storage slot. 255 of elements is max\n"
#~ "        let len: u8 = value.len().try_into().expect('Storage - Span too large');\n"
#~ "        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
#~ "        offset += 1;\n"
#~ "        // Store the array elements sequentially\n"
#~ "        loop {\n"
#~ "            match value.pop_front() {\n"
#~ "                Option::Some(element) => {\n"
#~ "                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);\n"
#~ "                    offset += Store::<felt252>::size();\n"
#~ "                },\n"
#~ "                Option::None => {\n"
#~ "                    break Result::Ok(());\n"
#~ "                }\n"
#~ "            };\n"
#~ "        }\n"
#~ "    }\n"
#~ "    fn size() -> u8 {\n"
#~ "        255 / Store::<felt252>::size()\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Cell {\n"
#~ "    token_id: u256,\n"
#~ "    xpos: u8,\n"
#~ "    ypos: u8,\n"
#~ "    width: u8,\n"
#~ "    height: u8,\n"
#~ "    img: Array<felt252>,\n"
#~ "    link: Array<felt252>,\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Cell {\n"
#~ "    token_id: u256,\n"
#~ "    xpos: u8,\n"
#~ "    ypos: u8,\n"
#~ "    width: u8,\n"
#~ "    height: u8,\n"
#~ "    img: Array<felt252>,\n"
#~ "    link: Array<felt252>,\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod MyToken {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: u256,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
#~ "    }\n"
#~ "    #[external(v0)]\n"
#~ "    fn name(self: @ContractState) -> felt252 {\n"
#~ "        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::ERC20Impl::name(@unsafe_state)\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod MyToken {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: u256,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);\n"
#~ "    }\n"
#~ "    #[external(v0)]\n"
#~ "    fn name(self: @ContractState) -> felt252 {\n"
#~ "        let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::ERC20Impl::name(@unsafe_state)\n"
#~ "    }\n"
#~ "    ...\n"
#~ "}\n"
#~ "```"

#~ msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-select.jpg\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"Wallets\" src=\"img/ch02-starknet-homepage-wallets.jpg\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "```typescript\n"
#~ "const { address } = useAccount();\n"
#~ "\n"
#~ "return (\n"
#~ "    ...\n"
#~ "    <WalletBar account={address} />\n"
#~ "    ...\n"
#~ ")\n"
#~ "```"
#~ msgstr ""
#~ "```typescript\n"
#~ "const { address } = useAccount();\n"
#~ "\n"
#~ "return (\n"
#~ "    ...\n"
#~ "    <WalletBar account={address} />\n"
#~ "    ...\n"
#~ ")\n"
#~ "```"

#~ msgid "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"
#~ msgstr "<img alt=\"homepage\" src=\"img/ch02-starknet-homepage-edit.jpg\" class=\"center\" style=\"width: 75%;\" />"

#~ msgid ""
#~ "- **Grid Component**: Represents a 100x100 matrix, allowing users to select cells and mint corresponding tokens. It fetches existing tokens using the `getAllTokens` function from the contract and "
#~ "displays them.\n"
#~ "- **Modals**: Serve as the user interface for actions like wallet connection, token minting, and token editing.\n"
#~ "- **Token Dropdown**: Displays tokens associated with a connected wallet. It retrieves these tokens using the `getTokensByOwner` function.\n"
#~ "- **Multicall Contract Interaction**: Enables token minting and editing. This process utilizes conditional multicalls based on user preferences, especially for editing token attributes."
#~ msgstr ""
#~ "- **ç½‘æ ¼ç»„ä»¶**ï¼šä»£è¡¨ä¸€ä¸ª 100x100 çš„çŸ©é˜µï¼Œå…è®¸ç”¨æˆ·é€‰æ‹©å•å…ƒæ ¼å’Œç›¸åº”çš„ä»£å¸ã€‚å®ƒä½¿ç”¨ `getAllTokens`å‡½æ•°ä»åˆçº¦ä¸­è·å–ç°æœ‰ä»£å¸å¹¶æ˜¾ç¤ºå‡ºæ¥ã€‚\n"
#~ "- **æ¨¡ç‰ˆ**ï¼šä½œä¸ºé’±åŒ…è¿æ¥ã€ä»£å¸é“¸é€ å’Œä»£å¸ç¼–è¾‘ç­‰æ“ä½œçš„ç”¨æˆ·ç•Œé¢ã€‚\n"
#~ "- **ä»£å¸ä¸‹æ‹‰èœå•**ï¼šæ˜¾ç¤ºä¸å·²è¿æ¥é’±åŒ…ç›¸å…³çš„ä»£å¸ã€‚å®ƒä½¿ç”¨ `getTokensByOwner`å‡½æ•°æ£€ç´¢è¿™äº›ä»£å¸ã€‚\n"
#~ "- **å¤šè°ƒç”¨åˆçº¦äº¤äº’**ï¼šå¯ç”¨ä»£å¸é“¸é€ å’Œç¼–è¾‘ã€‚æ­¤è¿‡ç¨‹æ ¹æ®ç”¨æˆ·åå¥½ä½¿ç”¨æœ‰æ¡ä»¶å¤šé’±åŒ…ï¼Œå°¤å…¶æ˜¯åœ¨ç¼–è¾‘ä»£å¸å±æ€§æ—¶ã€‚"

#~ msgid "# Starknet-py: Python SDK ğŸš§"
#~ msgstr "# Starknet-py: Python SDK ğŸš§"

#~ msgid "# Starknet-rs: Rust SDK ğŸš§"
#~ msgstr "# Starknet-rs: Rust SDK ğŸš§"

#~ msgid "# Starkli: A CLI interface ğŸš§"
#~ msgstr "# Starkliï¼šCLI ç•Œé¢ ğŸš§"

#~ msgid "# Foundry Forge: Testing"
#~ msgstr "# Foundry Forge: æµ‹è¯•å·¥å…·"

#~ msgid ""
#~ "```shell\n"
#~ "snforge --init project_name\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge --init project_name\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "cd project_name\n"
#~ "tree . -L 1\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "cd project_name\n"
#~ "tree . -L 1\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ ".\n"
#~ "â”œâ”€â”€ README.md\n"
#~ "â”œâ”€â”€ Scarb.toml\n"
#~ "â”œâ”€â”€ src\n"
#~ "â””â”€â”€ tests\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ ".\n"
#~ "â”œâ”€â”€ README.md\n"
#~ "â”œâ”€â”€ Scarb.toml\n"
#~ "â”œâ”€â”€ src\n"
#~ "â””â”€â”€ tests\n"
#~ "```"

#~ msgid ""
#~ "- `src/` holds your contract source code.\n"
#~ "- `tests/` is the location of your test files.\n"
#~ "- `Scarb.toml` is for project and **`snforge`** configurations."
#~ msgstr ""
#~ "- `src/` holds your contract source code.\n"
#~ "- `tests/` is the location of your test files.\n"
#~ "- `Scarb.toml` is for project and **`snforge`** configurations."

#~ msgid ""
#~ "```shell\n"
#~ "# ...\n"
#~ "[[target.starknet-contract]]\n"
#~ "casm = true\n"
#~ "# ...\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "# ...\n"
#~ "[[target.starknet-contract]]\n"
#~ "casm = true\n"
#~ "# ...\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "snforge\n"
#~ "\n"
#~ "Collected 2 test(s) from the `test_name` package\n"
#~ "Running 0 test(s) from `src/`\n"
#~ "Running 2 test(s) from `tests/`\n"
#~ "[PASS] tests::test_contract::test_increase_balance\n"
#~ "[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
#~ "Tests: 2 passed, 0 failed, 0 skipped\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge\n"
#~ "\n"
#~ "Collected 2 test(s) from the `test_name` package\n"
#~ "Running 0 test(s) from `src/`\n"
#~ "Running 2 test(s) from `tests/`\n"
#~ "[PASS] tests::test_contract::test_increase_balance\n"
#~ "[PASS] tests::test_contract::test_cannot_increase_balance_with_zero_value\n"
#~ "Tests: 2 passed, 0 failed, 0 skipped\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "snforge\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "Collected 3 test(s) from `package_name` package\n"
#~ "Running 3 test(s) from `src/`\n"
#~ "[PASS] package_name::executing\n"
#~ "[PASS] package_name::calling\n"
#~ "[PASS] package_name::calling_another\n"
#~ "Tests: 3 passed, 0 failed, 0 skipped\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "Collected 3 test(s) from `package_name` package\n"
#~ "Running 3 test(s) from `src/`\n"
#~ "[PASS] package_name::executing\n"
#~ "[PASS] package_name::calling\n"
#~ "[PASS] package_name::calling_another\n"
#~ "Tests: 3 passed, 0 failed, 0 skipped\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::interface]\n"
#~ "trait IHelloStarknet<TContractState> {\n"
#~ "    fn increase_balance(ref self: TContractState, amount: felt252);\n"
#~ "    fn get_balance(self: @TContractState) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod HelloStarknet {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        balance: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
#~ "        // Increases the balance by the specified amount.\n"
#~ "        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
#~ "            self.balance.write(self.balance.read() + amount);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Returns the balance.\n"
#~ "\n"
#~ "        fn get_balance(self: @ContractState) -> felt252 {\n"
#~ "            self.balance.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::interface]\n"
#~ "trait IHelloStarknet<TContractState> {\n"
#~ "    fn increase_balance(ref self: TContractState, amount: felt252);\n"
#~ "    fn get_balance(self: @TContractState) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod HelloStarknet {\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        balance: felt252,\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl HelloStarknetImpl of super::IHelloStarknet<ContractState> {\n"
#~ "        // Increases the balance by the specified amount.\n"
#~ "        fn increase_balance(ref self: ContractState, amount: felt252) {\n"
#~ "            self.balance.write(self.balance.read() + amount);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Returns the balance.\n"
#~ "\n"
#~ "        fn get_balance(self: @ContractState) -> felt252 {\n"
#~ "            self.balance.read()\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use snforge_std::{ declare, ContractClassTrait };\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn call_and_invoke() {\n"
#~ "    // Declare and deploy the contract\n"
#~ "    let contract = declare('HelloStarknet');\n"
#~ "    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
#~ "\n"
#~ "    // Instantiate a Dispatcher object for contract interactions\n"
#~ "    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
#~ "\n"
#~ "    // Invoke a contract's view function\n"
#~ "    let balance = dispatcher.get_balance();\n"
#~ "    assert(balance == 0, 'balance == 0');\n"
#~ "\n"
#~ "    // Invoke another function to modify the storage state\n"
#~ "    dispatcher.increase_balance(100);\n"
#~ "\n"
#~ "    // Validate the transaction's effect\n"
#~ "    let balance = dispatcher.get_balance();\n"
#~ "    assert(balance == 100, 'balance == 100');\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use snforge_std::{ declare, ContractClassTrait };\n"
#~ "\n"
#~ "#[test]\n"
#~ "fn call_and_invoke() {\n"
#~ "    // Declare and deploy the contract\n"
#~ "    let contract = declare('HelloStarknet');\n"
#~ "    let contract_address = contract.deploy(@ArrayTrait::new()).unwrap();\n"
#~ "\n"
#~ "    // Instantiate a Dispatcher object for contract interactions\n"
#~ "    let dispatcher = IHelloStarknetDispatcher { contract_address };\n"
#~ "\n"
#~ "    // Invoke a contract's view function\n"
#~ "    let balance = dispatcher.get_balance();\n"
#~ "    assert(balance == 0, 'balance == 0');\n"
#~ "\n"
#~ "    // Invoke another function to modify the storage state\n"
#~ "    dispatcher.increase_balance(100);\n"
#~ "\n"
#~ "    // Validate the transaction's effect\n"
#~ "    let balance = dispatcher.get_balance();\n"
#~ "    assert(balance == 100, 'balance == 100');\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "Collected 1 test(s) from using_dispatchers package\n"
#~ "Running 1 test(s) from src/\n"
#~ "[PASS] using_dispatchers::call_and_invoke\n"
#~ "Tests: 1 passed, 0 failed, 0 skipped\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "Collected 1 test(s) from using_dispatchers package\n"
#~ "Running 1 test(s) from src/\n"
#~ "[PASS] using_dispatchers::call_and_invoke\n"
#~ "Tests: 1 passed, 0 failed, 0 skipped\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait Ierc20<TContractState> {\n"
#~ "    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
#~ "    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod erc20 {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: felt252,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
#~ "        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
#~ "            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
#~ "            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use starknet::ContractAddress;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait Ierc20<TContractState> {\n"
#~ "    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;\n"
#~ "    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod erc20 {\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use openzeppelin::token::erc20::ERC20;\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {}\n"
#~ "\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(\n"
#~ "        ref self: ContractState,\n"
#~ "        initial_supply: felt252,\n"
#~ "        recipient: ContractAddress\n"
#~ "    ) {\n"
#~ "        let name = 'MyToken';\n"
#~ "        let symbol = 'MTK';\n"
#~ "\n"
#~ "        let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);\n"
#~ "        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply.into());\n"
#~ "    }\n"
#~ "\n"
#~ "    #[external(v0)]\n"
#~ "    impl Ierc20Impl of super::Ierc20<ContractState> {\n"
#~ "        fn balance_of(self: @ContractState, account: ContractAddress) -> u256 {\n"
#~ "            let unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::balance_of(@unsafe_state, account)\n"
#~ "        }\n"
#~ "\n"
#~ "        fn transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) -> bool {\n"
#~ "            let mut unsafe_state = ERC20::unsafe_new_contract_state();\n"
#~ "            ERC20::ERC20Impl::transfer(ref unsafe_state, recipient, amount)\n"
#~ "        }\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use result::ResultTrait;\n"
#~ "    use option::OptionTrait;\n"
#~ "    use traits::TryInto;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use starknet::Felt252TryIntoContractAddress;\n"
#~ "    use snforge_std::{declare, ContractClassTrait};\n"
#~ "    // Additional code here.\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[cfg(test)]\n"
#~ "mod tests {\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use result::ResultTrait;\n"
#~ "    use option::OptionTrait;\n"
#~ "    use traits::TryInto;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use starknet::Felt252TryIntoContractAddress;\n"
#~ "    use snforge_std::{declare, ContractClassTrait};\n"
#~ "    // Additional code here.\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use snforge_std::{declare, ContractClassTrait};\n"
#~ "\n"
#~ "fn deploy_contract(name: felt252) -> ContractAddress {\n"
#~ "    let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "    let supply: felt252 = 20000000;\n"
#~ "    let contract = declare(name);\n"
#~ "    let mut calldata = array![supply, recipient.into()];\n"
#~ "    contract.deploy(@calldata).unwrap()\n"
#~ "}\n"
#~ "// Additional code here.\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use snforge_std::{declare, ContractClassTrait};\n"
#~ "\n"
#~ "fn deploy_contract(name: felt252) -> ContractAddress {\n"
#~ "    let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "    let supply: felt252 = 20000000;\n"
#~ "    let contract = declare(name);\n"
#~ "    let mut calldata = array![supply, recipient.into()];\n"
#~ "    contract.deploy(@calldata).unwrap()\n"
#~ "}\n"
#~ "// Additional code here.\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    // ...\n"
#~ "    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
#~ "    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(3000000000000000)]\n"
#~ "    fn test_balance_of() {\n"
#~ "        let contract_address = deploy_contract('erc20');\n"
#~ "        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "        let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
#~ "        assert(balance == 20000000, 'Invalid Balance');\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    // ...\n"
#~ "    use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
#~ "    use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(3000000000000000)]\n"
#~ "    fn test_balance_of() {\n"
#~ "        let contract_address = deploy_contract('erc20');\n"
#~ "        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "        let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "        let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
#~ "        assert(balance == 20000000, 'Invalid Balance');\n"
#~ "    }\n"
#~ "```"

#~ msgid "Execute `snforge` to verify:"
#~ msgstr "æ‰§è¡Œ `snforge` è¿›è¡ŒéªŒè¯ï¼š"

#~ msgid ""
#~ "```shell\n"
#~ "Collected 1 test from erc20_contract package\n"
#~ "[PASS] tests::test_erc20::test_balance_of\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "Collected 1 test from erc20_contract package\n"
#~ "[PASS] tests::test_erc20::test_balance_of\n"
#~ "```"

#~ msgid "#### Utilizing Foundry Cheat Codes"
#~ msgstr "#### ä½¿ç”¨Foundryä½œå¼Šç "

#~ msgid ""
#~ "When testing smart contracts, simulating different conditions is essential. `Foundry Cheat Codes` from the `snforge_std` library offer these simulation capabilities for Starknet smart contracts."
#~ msgstr "åœ¨æµ‹è¯•æ™ºèƒ½åˆçº¦æ—¶ï¼Œæ¨¡æ‹Ÿä¸åŒçš„æ¡ä»¶æ˜¯å¿…ä¸å¯å°‘çš„ã€‚`snforge_std`åº“ä¸­çš„ `Foundry Cheat Codes`ä¸ºStarknetæ™ºèƒ½åˆçº¦æä¾›äº†è¿™äº›æ¨¡æ‹ŸåŠŸèƒ½ã€‚"

#~ msgid ""
#~ "These cheat codes consist of helper functions that adjust the smart contract's environment. They allow developers to modify parameters or conditions to examine contract behavior in specific "
#~ "scenarios."
#~ msgstr "è¿™äº›ä½œå¼Šç ç”±è°ƒæ•´æ™ºèƒ½åˆçº¦ç¯å¢ƒçš„è¾…åŠ©å‡½æ•°ç»„æˆã€‚å®ƒä»¬å…è®¸å¼€å‘äººå‘˜ä¿®æ”¹å‚æ•°æˆ–æ¡ä»¶ï¼Œä»¥æ£€æŸ¥ç‰¹å®šåœºæ™¯ä¸‹çš„åˆçº¦è¡Œä¸ºã€‚"

#~ msgid ""
#~ "Using `snforge_std`'s cheat codes, you can change elements like block numbers, timestamps, or even the caller of a function. This guide focuses on `start_prank` and `stop_prank`. You can find a "
#~ "reference to available cheat codes [here](https://foundry-rs.github.io/starknet-foundry/appendix/cheatcodes.html)"
#~ msgstr ""
#~ "ä½¿ç”¨ `snforge_std` çš„ä½œå¼Šä»£ç ï¼Œæ‚¨å¯ä»¥æ›´æ”¹å—ç¼–å·ã€æ—¶é—´æˆ³ç”šè‡³å‡½æ•°çš„è°ƒç”¨è€…ç­‰å…ƒç´ ã€‚æœ¬æŒ‡å—çš„é‡ç‚¹æ˜¯ `start_prank` å’Œ `stop_prank`ã€‚æ‚¨å¯ä»¥åœ¨ [æ­¤å¤„](https://foundry-rs.github.io/starknet-foundry/appendix/"
#~ "cheatcodes.html) æ‰¾åˆ°å¯ç”¨çš„ä½œå¼Šä»£ç å‚è€ƒã€‚"

#~ msgid "Below is a transfer test example:"
#~ msgstr "ä¸‹é¢æ˜¯ä¸€ä¸ªè½¬ç§»æµ‹è¯•ç¤ºä¾‹ï¼š"

#~ msgid ""
#~ "```rust\n"
#~ "    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(3000000000000000)]\n"
#~ "    fn test_transfer() {\n"
#~ "        let contract_address = deploy_contract('erc20');\n"
#~ "        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "\n"
#~ "        let sender = starknet::contract_address_const::<0x01>();\n"
#~ "        let receiver = starknet::contract_address_const::<0x02>();\n"
#~ "        let amount : felt252 = 10000000;\n"
#~ "\n"
#~ "        // Set the function's caller\n"
#~ "        start_prank(contract_address, sender);\n"
#~ "        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
#~ "\n"
#~ "        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
#~ "        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
#~ "\n"
#~ "        // End the prank\n"
#~ "        stop_prank(contract_address);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    #[available_gas(3000000000000000)]\n"
#~ "    fn test_transfer() {\n"
#~ "        let contract_address = deploy_contract('erc20');\n"
#~ "        let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "\n"
#~ "        let sender = starknet::contract_address_const::<0x01>();\n"
#~ "        let receiver = starknet::contract_address_const::<0x02>();\n"
#~ "        let amount : felt252 = 10000000;\n"
#~ "\n"
#~ "        // Set the function's caller\n"
#~ "        start_prank(contract_address, sender);\n"
#~ "        safe_dispatcher.transfer(receiver.into(), amount.into());\n"
#~ "\n"
#~ "        let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
#~ "        assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
#~ "\n"
#~ "        // End the prank\n"
#~ "        stop_prank(contract_address);\n"
#~ "    }\n"
#~ "```"

#~ msgid "Executing `snforge` for the tests displays:"
#~ msgstr "ä¸ºæµ‹è¯•æ‰§è¡Œ `snforge` åä¼šæ˜¾ç¤ºï¼š"

#~ msgid ""
#~ "```shell\n"
#~ "Collected 2 tests from erc20_contract package\n"
#~ "[PASS] tests::test_erc20::test_balance_of\n"
#~ "[PASS] tests::test_erc20::test_transfer\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "Collected 2 tests from erc20_contract package\n"
#~ "[PASS] tests::test_erc20::test_balance_of\n"
#~ "[PASS] tests::test_erc20::test_transfer\n"
#~ "```"

#~ msgid "In this example, `start_prank` determines the transfer function's caller, while `stop_prank` concludes the prank."
#~ msgstr "åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ`start_prank`å†³å®šäº†è½¬ç§»å‡½æ•°çš„è°ƒç”¨è€…ï¼Œè€Œ `stop_prank` åˆ™ç»“æŸäº†prankã€‚"

#~ msgid ""
#~ "<details>\n"
#~ "<summary>Full `ERC20 test example` file</summary>\n"
#~ "        #[cfg(test)]\n"
#~ "        mod tests {\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use result::ResultTrait;\n"
#~ "        use option::OptionTrait;\n"
#~ "        use traits::TryInto;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use starknet::Felt252TryIntoContractAddress;"
#~ msgstr ""
#~ "<details>\n"
#~ "<summary>Full `ERC20 test example` file</summary>\n"
#~ "        #[cfg(test)]\n"
#~ "        mod tests {\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use result::ResultTrait;\n"
#~ "        use option::OptionTrait;\n"
#~ "        use traits::TryInto;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use starknet::Felt252TryIntoContractAddress;"

#~ msgid ""
#~ "    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
#~ "        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
#~ "        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
#~ "\n"
#~ "        fn deploy_contract(name: felt252) -> ContractAddress {\n"
#~ "            let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "            let supply : felt252 = 20000000;\n"
#~ "            let contract = declare(name);\n"
#~ "            let mut calldata = array![supply, recipient.into()];\n"
#~ "            contract.deploy(@calldata).unwrap()\n"
#~ "        }\n"
#~ "\n"
#~ "        #[test]\n"
#~ "        #[available_gas(3000000000000000)]\n"
#~ "        fn test_balance_of() {\n"
#~ "            let contract_address = deploy_contract('erc20');\n"
#~ "            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "            let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
#~ "            assert(balance == 20000000, 'Invalid Balance');\n"
#~ "        }\n"
#~ "\n"
#~ "        #[test]\n"
#~ "        #[available_gas(3000000000000000)]\n"
#~ "        fn test_transfer() {\n"
#~ "            let contract_address = deploy_contract('erc20');\n"
#~ "            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "\n"
#~ "            let sender = starknet::contract_address_const::<0x01>();\n"
#~ "            let receiver = starknet::contract_address_const::<0x02>();\n"
#~ "            let amount : felt252 = 10000000;\n"
#~ "\n"
#~ "            start_prank(contract_address, sender);\n"
#~ "            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
#~ "            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
#~ "            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
#~ "            stop_prank(contract_address);\n"
#~ "        }\n"
#~ "        }"
#~ msgstr ""
#~ "    use snforge_std::{declare, ContractClassTrait, start_prank, stop_prank};\n"
#~ "        use erc20_contract::erc20::Ierc20SafeDispatcher;\n"
#~ "        use erc20_contract::erc20::Ierc20SafeDispatcherTrait;\n"
#~ "\n"
#~ "        fn deploy_contract(name: felt252) -> ContractAddress {\n"
#~ "            let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "            let supply : felt252 = 20000000;\n"
#~ "            let contract = declare(name);\n"
#~ "            let mut calldata = array![supply, recipient.into()];\n"
#~ "            contract.deploy(@calldata).unwrap()\n"
#~ "        }\n"
#~ "\n"
#~ "        #[test]\n"
#~ "        #[available_gas(3000000000000000)]\n"
#~ "        fn test_balance_of() {\n"
#~ "            let contract_address = deploy_contract('erc20');\n"
#~ "            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "            let recipient = starknet::contract_address_const::<0x01>();\n"
#~ "            let balance = safe_dispatcher.balance_of(recipient).unwrap();\n"
#~ "            assert(balance == 20000000, 'Invalid Balance');\n"
#~ "        }\n"
#~ "\n"
#~ "        #[test]\n"
#~ "        #[available_gas(3000000000000000)]\n"
#~ "        fn test_transfer() {\n"
#~ "            let contract_address = deploy_contract('erc20');\n"
#~ "            let safe_dispatcher = Ierc20SafeDispatcher { contract_address };\n"
#~ "\n"
#~ "            let sender = starknet::contract_address_const::<0x01>();\n"
#~ "            let receiver = starknet::contract_address_const::<0x02>();\n"
#~ "            let amount : felt252 = 10000000;\n"
#~ "\n"
#~ "            start_prank(contract_address, sender);\n"
#~ "            safe_dispatcher.transfer(receiver.into(), amount.into());\n"
#~ "            let balance_after_transfer = safe_dispatcher.balance_of(receiver).unwrap();\n"
#~ "            assert(balance_after_transfer == 10000000, 'Incorrect Amount');\n"
#~ "            stop_prank(contract_address);\n"
#~ "        }\n"
#~ "        }"

#~ msgid "</details>"
#~ msgstr "</details>"

#~ msgid ""
#~ "```rust\n"
#~ "    fn mul(a: felt252, b: felt252) -> felt252 {\n"
#~ "        return a * b;\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
#~ "        assert(mul(x, y) == x * y, 'incorrect');\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    fn mul(a: felt252, b: felt252) -> felt252 {\n"
#~ "        return a * b;\n"
#~ "    }\n"
#~ "\n"
#~ "    #[test]\n"
#~ "    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
#~ "        assert(mul(x, y) == x * y, 'incorrect');\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    Collected 1 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 1 test(s) from tests/\n"
#~ "    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
#~ "    Tests: 1 passed, 0 failed, 0 skipped\n"
#~ "    Fuzzer seed: 6375310854403272271\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "    Collected 1 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 1 test(s) from tests/\n"
#~ "    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
#~ "    Tests: 1 passed, 0 failed, 0 skipped\n"
#~ "    Fuzzer seed: 6375310854403272271\n"
#~ "```"

#~ msgid ""
#~ "- u8\n"
#~ "- u16\n"
#~ "- u32\n"
#~ "- u64\n"
#~ "- u128\n"
#~ "- u256\n"
#~ "- felt252"
#~ msgstr ""
#~ "- u8\n"
#~ "- u16\n"
#~ "- u32\n"
#~ "- u64\n"
#~ "- u128\n"
#~ "- u256\n"
#~ "- felt252"

#~ msgid "You can set the number of runs and the seed for a test:"
#~ msgstr "æ‚¨å¯ä»¥è®¾ç½®æµ‹è¯•çš„è¿è¡Œæ¬¡æ•°å’Œç§å­æ•°ï¼š"

#~ msgid ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    #[fuzzer(runs: 100, seed: 38)]\n"
#~ "    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
#~ "        assert(mul(x, y) == x * y, 'incorrect');\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[test]\n"
#~ "    #[fuzzer(runs: 100, seed: 38)]\n"
#~ "    fn test_fuzz_sum(x: felt252, y: felt252) {\n"
#~ "        assert(mul(x, y) == x * y, 'incorrect');\n"
#~ "    }\n"
#~ "```"

#~ msgid "Or, use the command line:"
#~ msgstr "æˆ–è€…ä½¿ç”¨å‘½ä»¤è¡Œï¼š"

#~ msgid ""
#~ "```shell\n"
#~ "    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "    $ snforge --fuzzer-runs 500 --fuzzer-seed 4656\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    # ...\n"
#~ "    [tool.snforge]\n"
#~ "    fuzzer_runs = 500\n"
#~ "    fuzzer_seed = 4656\n"
#~ "    # ...\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "    # ...\n"
#~ "    [tool.snforge]\n"
#~ "    fuzzer_runs = 500\n"
#~ "    fuzzer_seed = 4656\n"
#~ "    # ...\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    Collected 3 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 3 test(s) from tests/\n"
#~ "    [PASS] tests::test_erc20::tests::test_balance_of\n"
#~ "    [PASS] tests::test_erc20::tests::test_transfer\n"
#~ "    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
#~ "    Tests: 3 passed, 0 failed, 0 skipped\n"
#~ "    Fuzzer seed: 10426315620495146768\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "    Collected 3 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 3 test(s) from tests/\n"
#~ "    [PASS] tests::test_erc20::tests::test_balance_of\n"
#~ "    [PASS] tests::test_erc20::tests::test_transfer\n"
#~ "    [PASS] tests::test_fuzz::test_fuzz_sum (fuzzer runs = 256)\n"
#~ "    Tests: 3 passed, 0 failed, 0 skipped\n"
#~ "    Fuzzer seed: 10426315620495146768\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "snforge test_fuzz_sum\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge test_fuzz_sum\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "snforge package_name::test_name --exact\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge package_name::test_name --exact\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "snforge --exit-first\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "snforge --exit-first\n"
#~ "```"

#~ msgid ""
#~ "```shell\n"
#~ "    Collected 3 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 3 test(s) from tests/\n"
#~ "    [FAIL] tests::test_erc20::tests::test_balance_of\n"
#~ "\n"
#~ "    Failure data:\n"
#~ "    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
#~ "\n"
#~ "    [SKIP] tests::test_erc20::tests::test_transfer\n"
#~ "    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
#~ "    Tests: 0 passed, 1 failed, 2 skipped\n"
#~ "\n"
#~ "    Failures:\n"
#~ "        tests::test_erc20::tests::test_balance_of\n"
#~ "```"
#~ msgstr ""
#~ "```shell\n"
#~ "    Collected 3 test(s) from erc20_contract package\n"
#~ "    Running 0 test(s) from src/\n"
#~ "    Running 3 test(s) from tests/\n"
#~ "    [FAIL] tests::test_erc20::tests::test_balance_of\n"
#~ "\n"
#~ "    Failure data:\n"
#~ "    original value: [381278114803728420489684244530881381], converted to a string: [Invalid Balance]\n"
#~ "\n"
#~ "    [SKIP] tests::test_erc20::tests::test_transfer\n"
#~ "    [SKIP] tests::test_fuzz::test_fuzz_sum\n"
#~ "    Tests: 0 passed, 1 failed, 2 skipped\n"
#~ "\n"
#~ "    Failures:\n"
#~ "        tests::test_erc20::tests::test_balance_of\n"
#~ "```"

#~ msgid "### Conclusion"
#~ msgstr "### æ€»ç»“"

#, fuzzy
#~ msgid ""
#~ "This is an introduction to Starknetâ€™s Layer 2 architecture, designed for\n"
#~ "both beginners and experienced users. It focuses on the key components:\n"
#~ "Sequencers, Provers, and nodes."
#~ msgstr ""
#~ "æœ¬æ–‡ä»‹ç»äº†Starknetçš„ç¬¬ 2 å±‚æ¶æ„ï¼Œä¸“ä¸ºåˆå­¦è€…å’Œæœ‰ç»éªŒçš„ç”¨æˆ·è®¾è®¡ã€‚\n"
#~ "åˆå­¦è€…å’Œæœ‰ç»éªŒçš„ç”¨æˆ·ã€‚å®ƒä¾§é‡äºå…³é”®ç»„ä»¶ï¼š\n"
#~ "åºåˆ—å™¨ã€è¯æ˜å™¨å’ŒèŠ‚ç‚¹ã€‚"

#~ msgid "<img alt=\"Starknet Architecture\" src=\"img/ch03-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Starknet Architecture\" src=\"img/ch03-architecture.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Starknet architecture</span>"
#~ msgstr "<span class=\"caption\">Starknet architecture</span>"

#, fuzzy
#~ msgid ""
#~ "- The Sequencer is responsible for receiving transactions, ordering\n"
#~ "  them, and producing blocks. It operates similarly to validators in\n"
#~ "  Ethereum or Bitcoin.\n"
#~ "\n"
#~ "- The Prover is tasked with generating proofs for the created blocks\n"
#~ "  and transactions. It uses Cairoâ€™s Virtual Machine to run provable\n"
#~ "  programs, thereby creating execution traces necessary for generating\n"
#~ "  STARK proofs.\n"
#~ "\n"
#~ "- Layer 1 (L1), in this case Ethereum, hosts a smart contract capable\n"
#~ "  of verifying these STARK proofs. If the proofs are valid, Starknetâ€™s\n"
#~ "  state root on L1 is updated."
#~ msgstr ""
#~ "- åºåˆ—å™¨è´Ÿè´£æ¥æ”¶äº‹åŠ¡ã€æ’åºäº‹åŠ¡å’Œç”ŸæˆåŒºå—ã€‚\n"
#~ "  å¹¶ç”ŸæˆåŒºå—ã€‚å®ƒçš„æ“ä½œç±»ä¼¼äº\n"
#~ "  ä»¥å¤ªåŠæˆ–æ¯”ç‰¹å¸ä¸­çš„éªŒè¯å™¨ç±»ä¼¼ã€‚\n"
#~ "\n"
#~ "- è¯æ˜è€…çš„ä»»åŠ¡æ˜¯ä¸ºåˆ›å»ºçš„åŒºå—å’Œäº¤æ˜“ç”Ÿæˆè¯æ˜\n"
#~ "  å’Œäº¤æ˜“ã€‚å®ƒä½¿ç”¨Cairoè™šæ‹Ÿæœºè¿è¡Œå¯è¯æ˜çš„\n"
#~ "  ç¨‹åºï¼Œä»è€Œåˆ›å»ºç”Ÿæˆ\n"
#~ "  STARK è¯æ˜ã€‚\n"
#~ "\n"
#~ "- ç¬¬ 1 å±‚ï¼ˆL1ï¼‰ï¼Œåœ¨æœ¬ä¾‹ä¸­ä¸ºä»¥å¤ªåŠï¼Œæ‰¿è½½ç€ä¸€ä¸ªæ™ºèƒ½åˆçº¦ï¼Œè¯¥åˆçº¦èƒ½å¤Ÿ\n"
#~ "  èƒ½å¤ŸéªŒè¯è¿™äº› STARK è¯æ˜ã€‚å¦‚æœè¯æ˜æœ‰æ•ˆï¼ŒStarknetåœ¨ L1 ä¸Šçš„\n"
#~ "  åœ¨ L1 ä¸Šçš„çŠ¶æ€æ ¹å°±ä¼šè¢«æ›´æ–°ã€‚"

#, fuzzy
#~ msgid "## Sequencers"
#~ msgstr "æ’åºå™¨"

#, fuzzy
#~ msgid ""
#~ "1.  Sequencing: They collect transactions from users and order\n"
#~ "    (sequence) them.\n"
#~ "\n"
#~ "2.  Executing: Sequencers then process these transactions.\n"
#~ "\n"
#~ "3.  Batching: Transactions are grouped together in batches or blocks for\n"
#~ "    efficiency.\n"
#~ "\n"
#~ "4.  Block Production: Sequencers produce blocks that contain batches of\n"
#~ "    processed transactions."
#~ msgstr ""
#~ "1.  æ’åºï¼šå®ƒä»¬æ”¶é›†ç”¨æˆ·çš„äº¤æ˜“å¹¶å¯¹å…¶è¿›è¡Œæ’åº\n"
#~ "    (æ’åºï¼‰ã€‚\n"
#~ "\n"
#~ "2.  æ‰§è¡Œï¼šæ’åºå™¨éšåå¤„ç†è¿™äº›äº‹åŠ¡ã€‚\n"
#~ "\n"
#~ "3.  æ‰¹å¤„ç†ï¼šå°†äº‹åŠ¡åˆ†æ‰¹æˆ–åˆ†å—å¤„ç†ï¼Œä»¥æé«˜æ•ˆç‡ã€‚\n"
#~ "    æ•ˆç‡ã€‚\n"
#~ "\n"
#~ "4.  åŒºå—ç”Ÿäº§ï¼šæ’åºå™¨äº§ç”ŸåŒ…å«æˆæ‰¹\n"
#~ "    å·²å¤„ç†çš„äº¤æ˜“ã€‚"

#, fuzzy
#~ msgid "## Provers"
#~ msgstr "è¯æ˜å™¨ ğŸš§"

#, fuzzy
#~ msgid ""
#~ "1.  Receiving Blocks: Provers obtain blocks of processed transactions\n"
#~ "    from Sequencers.\n"
#~ "\n"
#~ "2.  Processing: Provers process these blocks a second time, ensuring\n"
#~ "    that all transactions within the block have been correctly handled.\n"
#~ "\n"
#~ "3.  Proof Generation: After processing, Provers generate a proof of\n"
#~ "    correct transaction processing.\n"
#~ "\n"
#~ "4.  Sending Proof to Ethereum: Finally, the proof is sent to the\n"
#~ "    Ethereum network for validation. If the proof is correct, the\n"
#~ "    Ethereum network accepts the block of transactions."
#~ msgstr ""
#~ "1.  æ¥æ”¶åŒºå—ï¼šè¯æ˜è€…ä»åºåˆ—å™¨è·å–å·²å¤„ç†çš„äº¤æ˜“å—\n"
#~ "    ä»åºåˆ—å™¨ä¸­è·å–ã€‚\n"
#~ "\n"
#~ "2.  å¤„ç†ï¼šè¯æ˜è€…å¯¹è¿™äº›äº¤æ˜“å—è¿›è¡Œç¬¬äºŒæ¬¡å¤„ç†ï¼Œç¡®ä¿\n"
#~ "    åŒºå—å†…çš„æ‰€æœ‰äº¤æ˜“éƒ½å¾—åˆ°æ­£ç¡®å¤„ç†ã€‚\n"
#~ "\n"
#~ "3.  ç”Ÿæˆè¯æ˜ï¼šå¤„ç†å®Œæˆåï¼Œè¯æ˜è€…ä¼šç”Ÿæˆè¯æ˜\n"
#~ "    äº¤æ˜“å¤„ç†æ­£ç¡®æ€§çš„è¯æ˜ã€‚\n"
#~ "\n"
#~ "4.  å‘ä»¥å¤ªåŠå‘é€è¯æ˜ï¼šæœ€åï¼Œè¯æ˜ä¼šè¢«å‘é€åˆ°\n"
#~ "    ä»¥å¤ªåŠç½‘ç»œè¿›è¡ŒéªŒè¯ã€‚å¦‚æœè¯æ˜æ­£ç¡®\n"
#~ "    ä»¥å¤ªåŠç½‘ç»œæ¥å—è¯¥äº¤æ˜“å—ã€‚"

#, fuzzy
#~ msgid "## Nodes"
#~ msgstr "èŠ‚ç‚¹ ğŸš§"

#, fuzzy
#~ msgid ""
#~ "1.  **Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can\n"
#~ "    take all the transactions and re-execute them. Although this\n"
#~ "    approach is accurate, it isnâ€™t scalable unless you have a powerful\n"
#~ "    machine thatâ€™s capable of handling the load. If you can replay all\n"
#~ "    transactions, you can become a Sequencer.\n"
#~ "\n"
#~ "2.  **Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to\n"
#~ "    execute the network correctly. When the Sequencer updates the state\n"
#~ "    and adds a new block, nodes accept the update as accurate.\n"
#~ "\n"
#~ "3.  **Checking Proof Validation on L1**: Nodes can monitor the state of\n"
#~ "    the network by observing L1 and ensuring that every time a proof is\n"
#~ "    sent, they receive the updated state. This way, they donâ€™t have to\n"
#~ "    trust anyone and only need to keep track of the latest valid\n"
#~ "    transaction for Starknet."
#~ msgstr ""
#~ "1.  **é‡æ”¾æ—§äº¤æ˜“**ï¼šä¸ä»¥å¤ªåŠæˆ–æ¯”ç‰¹å¸ä¸€æ ·ï¼ŒèŠ‚ç‚¹å¯ä»¥\n"
#~ "    è·å–æ‰€æœ‰äº¤æ˜“å¹¶é‡æ–°æ‰§è¡Œã€‚è™½ç„¶è¿™ç§\n"
#~ "    æ–¹æ³•æ˜¯å‡†ç¡®çš„ï¼Œä½†å®ƒä¸å…·å¤‡å¯æ‰©å±•æ€§ï¼Œé™¤éä½ æœ‰ä¸€å°å¼ºå¤§çš„\n"
#~ "    çš„æœºå™¨ã€‚å¦‚æœå¯ä»¥é‡æ”¾æ‰€æœ‰\n"
#~ "    äº‹åŠ¡ï¼Œå°±å¯ä»¥æˆä¸ºåºåˆ—å™¨ã€‚\n"
#~ "\n"
#~ "2.  **ä¾é äºŒçº§å…±è¯†**ï¼šèŠ‚ç‚¹å¯ä»¥ä¿¡èµ–åºåˆ—å™¨æ¥æ­£ç¡®æ‰§è¡Œç½‘ç»œã€‚\n"
#~ "    æ­£ç¡®æ‰§è¡Œç½‘ç»œã€‚å½“åºåˆ—å™¨æ›´æ–°çŠ¶æ€\n"
#~ "    å¹¶æ·»åŠ æ–°åŒºå—æ—¶ï¼ŒèŠ‚ç‚¹ä¼šè®¤ä¸ºæ›´æ–°æ˜¯å‡†ç¡®çš„ã€‚\n"
#~ "\n"
#~ "3.  **åœ¨ L1 ä¸Šæ£€æŸ¥è¯æ˜éªŒè¯**ï¼šèŠ‚ç‚¹å¯é€šè¿‡è§‚å¯Ÿ L1\n"
#~ "    èŠ‚ç‚¹å¯ä»¥é€šè¿‡è§‚å¯Ÿ L1 æ¥ç›‘æ§ç½‘ç»œçŠ¶æ€ï¼Œç¡®ä¿æ¯æ¬¡å‘é€è¯æ˜æ—¶ï¼ŒèŠ‚ç‚¹éƒ½èƒ½æ”¶åˆ°æ›´æ–°çš„çŠ¶æ€ã€‚\n"
#~ "    èŠ‚ç‚¹éƒ½èƒ½æ”¶åˆ°æ›´æ–°çš„çŠ¶æ€ã€‚è¿™æ ·ï¼ŒèŠ‚ç‚¹å°±ä¸å¿…\n"
#~ "    ä¿¡ä»»ä»»ä½•äººï¼Œåªéœ€è·Ÿè¸ªStarknetçš„æœ€æ–°æœ‰æ•ˆäº¤æ˜“ã€‚\n"
#~ "    äº¤æ˜“ã€‚"

#, fuzzy
#~ msgid "# Transactions Lifecycle"
#~ msgstr "Starknetç­¾åè€…åœ¨ç¡®ä¿äº¤æ˜“å®‰å…¨æ–¹é¢å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚è®©æˆ‘ä»¬æ¥æ­å¼€å®ƒçš„ç¥ç§˜é¢çº±ã€‚"

#~ msgid "<img alt=\"Transaction Overview\" src=\"img/ch03-transaction-overview.png\" class=\"center\" style=\"width: 100%;\" />"
#~ msgstr "<img alt=\"Transaction Overview\" src=\"img/ch03-transaction-overview.png\" class=\"center\" style=\"width: 100%;\" />"

#~ msgid ""
#~ "```python\n"
#~ "import asyncio\n"
#~ "from starknet_py.net.gateway_client import GatewayClient\n"
#~ "\n"
#~ "async def fetch_transaction_receipt(transaction_id: str, network: str = \"testnet\"):\n"
#~ "    client = GatewayClient(network)\n"
#~ "    call_result = await client.get_transaction_receipt(transaction_id)\n"
#~ "    return call_result\n"
#~ "\n"
#~ "receipt = asyncio.run(fetch_transaction_receipt(\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\"))\n"
#~ "print(receipt)\n"
#~ "```"
#~ msgstr ""
#~ "```python\n"
#~ "import asyncio\n"
#~ "from starknet_py.net.gateway_client import GatewayClient\n"
#~ "\n"
#~ "async def fetch_transaction_receipt(transaction_id: str, network: str = \"testnet\"):\n"
#~ "    client = GatewayClient(network)\n"
#~ "    call_result = await client.get_transaction_receipt(transaction_id)\n"
#~ "    return call_result\n"
#~ "\n"
#~ "receipt = asyncio.run(fetch_transaction_receipt(\"0x6d6e6575b85913ee8dfb170fe0db418f58f9422a0c6115350a79f9b38a1f5b8\"))\n"
#~ "print(receipt)\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "python3 get_transaction_receipt.py\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "python3 get_transaction_receipt.py\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "execution_status=<TransactionExecutionStatus.REJECTED: 'REJECTED'>, finality_status=<TransactionFinalityStatus.RECEIVED: 'RECEIVED'>,\n"
#~ "block_number=None,\n"
#~ "actual_fee=0\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "execution_status=<TransactionExecutionStatus.REJECTED: 'REJECTED'>, finality_status=<TransactionFinalityStatus.RECEIVED: 'RECEIVED'>,\n"
#~ "block_number=None,\n"
#~ "actual_fee=0\n"
#~ "```"

#~ msgid "<img alt=\"Transaction flow\" src=\"img/ch03-transaction_flow.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Transaction flow\" src=\"img/ch03-transaction_flow.png\" class=\"center\" style=\"width: 50%;\" />"

#, fuzzy
#~ msgid "# Fee Mechanism"
#~ msgstr "è´¹ç”¨æœºåˆ¶ ğŸš§"

#, fuzzy
#~ msgid ""
#~ "```\n"
#~ "expected_fee = gas_estimate * gas_price;\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "expected_fee = gas_estimate * gas_priceï¼›\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "- **Built-In**: These are predefined operations in your code, simplifying common tasks or calculations. The following are built-ins:\n"
#~ "\n"
#~ "  - **Cairo Steps**: These building blocks in Cairo facilitate various program operations. Essential for running smart contracts and apps on blockchain platforms, the steps used influence a "
#~ "program's cost and efficiency.\n"
#~ "  - **Pedersen Hashes**: A method to convert data into a distinct code, similar to a data fingerprint, ensuring data integrity on blockchains.\n"
#~ "  - **Range Checks**: Safety measures in programs, ensuring numbers or values stay within designated limits to avoid errors.\n"
#~ "  - **Signature Verifications**: These confirm that a digital signature matches the anticipated one, verifying the sender's authenticity.\n"
#~ "\n"
#~ "- **Weight**: Indicates the significance or cost of an operation, showing how resource-intensive an action is in the program."
#~ msgstr ""
#~ "- **å†…ç½®**ï¼šè¿™äº›æ˜¯ä»£ç ä¸­çš„é¢„å®šä¹‰æ“ä½œï¼Œå¯ç®€åŒ–å¸¸è§ä»»åŠ¡æˆ–è®¡ç®—ã€‚ä»¥ä¸‹æ˜¯å†…ç½®æ“ä½œï¼š\n"
#~ "\n"
#~ "  - **Cairoæ­¥éª¤**ï¼šCairoä¸­çš„è¿™äº›æ„ä»¶å¯ä¿ƒè¿›å„ç§ç¨‹åºè¿è¡Œã€‚å¯¹äºåœ¨åŒºå—é“¾å¹³å°ä¸Šè¿è¡Œæ™ºèƒ½åˆçº¦å’Œåº”ç”¨ç¨‹åºè‡³å…³é‡è¦ï¼Œæ‰€ä½¿ç”¨çš„æ­¥éª¤ä¼šå½±å“ç¨‹åºçš„æˆæœ¬å’Œæ•ˆç‡ã€‚\n"
#~ "  - **Pedersen Hashes**ï¼šä¸€ç§å°†æ•°æ®è½¬æ¢ä¸ºç‹¬ç‰¹ä»£ç çš„æ–¹æ³•ï¼Œç±»ä¼¼äºæ•°æ®æŒ‡çº¹ï¼Œå¯ç¡®ä¿åŒºå—é“¾ä¸Šçš„æ•°æ®å®Œæ•´æ€§ã€‚\n"
#~ "  - **èŒƒå›´æ£€æŸ¥**ï¼šç¨‹åºä¸­çš„å®‰å…¨æªæ–½ï¼Œç¡®ä¿æ•°å­—æˆ–æ•°å€¼ä¿æŒåœ¨æŒ‡å®šèŒƒå›´å†…ï¼Œä»¥é¿å…é”™è¯¯ã€‚\n"
#~ "  - **ç­¾åéªŒè¯**ï¼šç¡®è®¤æ•°å­—ç­¾åæ˜¯å¦ä¸é¢„æœŸç›¸ç¬¦ï¼ŒéªŒè¯å‘é€è€…çš„çœŸå®æ€§ã€‚\n"
#~ "\n"
#~ "- **æƒé‡**ï¼šè¡¨ç¤ºæ“ä½œçš„é‡è¦æ€§æˆ–æˆæœ¬ï¼Œæ˜¾ç¤ºç¨‹åºä¸­æŸé¡¹æ“ä½œçš„èµ„æºå¯†é›†ç¨‹åº¦ã€‚"

#, fuzzy
#~ msgid ""
#~ "| Component               | Limit       |\n"
#~ "| ----------------------- | ----------- |\n"
#~ "| Cairo Steps             | 200,000,000 |\n"
#~ "| Pedersen Hashes         | 5,000,000   |\n"
#~ "| Signature Verifications | 1,000,000   |\n"
#~ "| Range Checks            | 2,500,000   |"
#~ msgstr ""
#~ "| ç»„ä»¶ | æé™\n"
#~ "| ----------------------- | ----------- |\n"
#~ "| Cairoæ­¥éª¤\n"
#~ "| Pedersen å“ˆå¸Œå€¼ | 5,000,000 | ç­¾åéªŒè¯\n"
#~ "| ç­¾åéªŒè¯ 1,000,000\n"
#~ "| èŒƒå›´æ£€æŸ¥ 2,500,000"

#, fuzzy
#~ msgid ""
#~ "```\n"
#~ "maxk[CairoResourceUsagek * CairoResourceFeeWeightsk]\n"
#~ "```"
#~ msgstr ""
#~ "```\n"
#~ "maxk[CairoResourceUsagek * CairoResourceFeeWeightsk] æœ€å¤§å€¼\n"
#~ "```"

#, fuzzy
#~ msgid ""
#~ "| Component   | Gas Cost       | Range           |\n"
#~ "| ----------- | -------------- | --------------- |\n"
#~ "| Cairo Step  | 0.01 gwei/gas  | per step        |\n"
#~ "| Pedersen    | 0.32 gwei/gas  | per application |\n"
#~ "| Poseidon    | 0.32 gwei/gas  | per application |\n"
#~ "| Range Check | 0.16 gwei/gas  | per application |\n"
#~ "| ECDSA       | 20.48 gwei/gas | per application |\n"
#~ "| Keccak      | 20.48 gwei/gas | per application |\n"
#~ "| Bitwise     | 0.64 gwei/gas  | per application |\n"
#~ "| EC_OP       | 10.24 gwei/gas | per application |"
#~ msgstr ""
#~ "| ç»„ä»¶ | ç‡ƒæ°”æˆæœ¬ | èŒƒå›´\n"
#~ "| ----------- | -------------- | --------------- |\n"
#~ "| Cairo Step | 0.01 gwei/gas | æ¯ä¸ªæ­¥éª¤\n"
#~ "Pedersen | 0.32 gwei/gas | æ¯ä¸ªåº”ç”¨ | Poseidon | 0.01 gwei/gas | æ¯ä¸ªæ­¥éª¤\n"
#~ "| Poseidon | 0.32 gwei/gas | æ¯æ¬¡ä½¿ç”¨\n"
#~ "| èŒƒå›´æ£€æŸ¥ | 0.16 gwei/gas | æ¯ä¸ªåº”ç”¨ç¨‹åº\n"
#~ "| ECDSA | 20.48 gwei/gas | æ¯ä¸ªåº”ç”¨ç¨‹åº\n"
#~ "| Keccak | 20.48 gwei/gas | æ¯ä¸ªåº”ç”¨ç¨‹åº\n"
#~ "| Bitwise | 0.64 gwei/gas | æ¯ä¸ªåº”ç”¨ç¨‹åº\n"
#~ "| EC_OP | 10.24 gwei/gas | æ¯ä¸ªåº”ç”¨ç¨‹åº"

#, fuzzy
#~ msgid ""
#~ "Before diving in, make sure to check out the [\"Understanding Starknet:\n"
#~ "Sequencers, Provers, and\n"
#~ "Nodes\"](https://book.starknet.io/chapter_3/topology.html) chapter for a\n"
#~ "quick rundown of Starknetâ€™s architecture."
#~ msgstr ""
#~ "åœ¨æ·±å…¥äº†è§£ä¹‹å‰ï¼Œè¯·åŠ¡å¿…æŸ¥çœ‹[\"äº†è§£Starknetï¼š\n"
#~ "åºåˆ—å™¨ã€è¯æ˜å™¨å’Œ\n"
#~ "èŠ‚ç‚¹\"](https://book.starknet.io/chapter_3/topology.html) ç« èŠ‚ï¼Œå¿«é€Ÿäº†è§£Starknetçš„æ¶æ„ã€‚\n"
#~ "Starknetæ¶æ„çš„ç®€è¦ä»‹ç»ã€‚"

#~ msgid "<img alt=\"Sequencer role in the Starknet network\" src=\"img/ch03-sequencer.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Sequencer role in the Starknet network\" src=\"img/ch03-sequencer.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid ""
#~ "<table style=\"width:100%;\">\n"
#~ "<colgroup>\n"
#~ "<col style=\"width: 42%\" />\n"
#~ "<col style=\"width: 28%\" />\n"
#~ "<col style=\"width: 28%\" />\n"
#~ "</colgroup>\n"
#~ "<thead>\n"
#~ "<tr class=\"header\">\n"
#~ "<th style=\"text-align: left;\">Feature</th>\n"
#~ "<th style=\"text-align: left;\"><a\n"
#~ "href=\"https://github.com/keep-starknet-strange/madara\">Madara</a></th>\n"
#~ "<th style=\"text-align: left;\"><a\n"
#~ "href=\"https://github.com/lambdaclass/starknet_stack/tree/main/sequencer\">Kraken</a></th>\n"
#~ "</tr>\n"
#~ "</thead>\n"
#~ "<tbody>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Ordering\n"
#~ "Method</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>FCFS, PGA, Narwhall &amp;\n"
#~ "Bullshark</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Narwhall &amp; Bullshark</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"even\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Mempool\n"
#~ "Management</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Managed by Madara</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Managed using Narwhall &amp;\n"
#~ "Bullshark</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Consensus\n"
#~ "Options</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Developerâ€™s choice through\n"
#~ "Substrate</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Bullshark, Tendermint or\n"
#~ "Hotstuff</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"even\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Execution\n"
#~ "Crates</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/starkware-libs/blockifier/tree/main\">Blockifier</a>,\n"
#~ "Starknet_in_rust</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Starknet_in_rust</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Execution\n"
#~ "Framework</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/lambdaclass/cairo_native\">Cairo Native</a> or\n"
#~ "<a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
#~ "</tr>\n"
#~ "</tbody>\n"
#~ "</table>"
#~ msgstr ""
#~ "<table style=\"width:100%;\">\n"
#~ "<colgroup>\n"
#~ "<col style=\"width: 42%\" />\n"
#~ "<col style=\"width: 28%\" />\n"
#~ "<col style=\"width: 28%\" />\n"
#~ "</colgroup>\n"
#~ "<thead>\n"
#~ "<tr class=\"header\">\n"
#~ "<th style=\"text-align: left;\">Feature</th>\n"
#~ "<th style=\"text-align: left;\"><a\n"
#~ "href=\"https://github.com/keep-starknet-strange/madara\">Madara</a></th>\n"
#~ "<th style=\"text-align: left;\"><a\n"
#~ "href=\"https://github.com/lambdaclass/starknet_stack/tree/main/sequencer\">Kraken</a></th>\n"
#~ "</tr>\n"
#~ "</thead>\n"
#~ "<tbody>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Ordering\n"
#~ "Method</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>FCFS, PGA, Narwhall &amp;\n"
#~ "Bullshark</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Narwhall &amp; Bullshark</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"even\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Mempool\n"
#~ "Management</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Managed by Madara</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Managed using Narwhall &amp;\n"
#~ "Bullshark</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Consensus\n"
#~ "Options</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Developerâ€™s choice through\n"
#~ "Substrate</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Bullshark, Tendermint or\n"
#~ "Hotstuff</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"even\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Execution\n"
#~ "Crates</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/starkware-libs/blockifier/tree/main\">Blockifier</a>,\n"
#~ "Starknet_in_rust</p></td>\n"
#~ "<td style=\"text-align: left;\"><p>Starknet_in_rust</p></td>\n"
#~ "</tr>\n"
#~ "<tr class=\"odd\">\n"
#~ "<td style=\"text-align: left;\"><p><strong>Execution\n"
#~ "Framework</strong></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
#~ "<td style=\"text-align: left;\"><p><a\n"
#~ "href=\"https://github.com/lambdaclass/cairo_native\">Cairo Native</a> or\n"
#~ "<a href=\"https://github.com/lambdaclass/cairo-vm\">Cairo VM</a></p></td>\n"
#~ "</tr>\n"
#~ "</tbody>\n"
#~ "</table>"

#, fuzzy
#~ msgid ""
#~ "- [Blockifier](https://github.com/starkware-libs/blockifier/tree/main),\n"
#~ "  a Rust component in Starknet Sequencers, generates state diffs and\n"
#~ "  blocks. It uses [Cairo VM](https://github.com/lambdaclass/cairo-vm).\n"
#~ "  Its goal is to become a full Starknet Sequencer.\n"
#~ "\n"
#~ "- Starknet_in_Rust is another Rust component for Starknet that also\n"
#~ "  generates state diffs and blocks. It uses [Cairo\n"
#~ "  VM](https://github.com/lambdaclass/cairo-vm).\n"
#~ "\n"
#~ "- [Cairo Native](https://github.com/lambdaclass/cairo_native) stands\n"
#~ "  out by converting Cairoâ€™s Sierra code to MLIR. See an example\n"
#~ "  [here](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)."
#~ msgstr ""
#~ "- [Blockifier](https://github.com/starkware-libs/blockifier/tree/main)ã€\n"
#~ "  Starknetæ—¶åºå™¨ä¸­çš„ Rust ç»„ä»¶ï¼Œå¯ç”ŸæˆçŠ¶æ€å·®å¼‚å’Œå—ã€‚\n"
#~ "  å—ã€‚å®ƒä½¿ç”¨ [Cairo VM](https://github.com/lambdaclass/cairo-vm)ã€‚\n"
#~ "  å®ƒçš„ç›®æ ‡æ˜¯æˆä¸ºä¸€ä¸ªå®Œæ•´çš„ Starknet åºåˆ—å™¨ã€‚\n"
#~ "\n"
#~ "- Starknet_in_Rustæ˜¯Starknetçš„å¦ä¸€ä¸ªRustç»„ä»¶ï¼Œå®ƒä¹Ÿèƒ½\n"
#~ "  ç”ŸæˆçŠ¶æ€å·®å¼‚å’Œå—ã€‚å®ƒä½¿ç”¨ [Cairo\n"
#~ "  VM](https://github.com/lambdaclass/cairo-vm)ã€‚\n"
#~ "\n"
#~ "- [Cairoæœ¬åœ°](https://github.com/lambdaclass/cairo_native)\n"
#~ "  é€šè¿‡å°† Cairo çš„ Sierra ä»£ç è½¬æ¢ä¸º MLIR è€Œè„±é¢–è€Œå‡ºã€‚è¯·çœ‹ç¤ºä¾‹\n"
#~ "  [è¿™é‡Œ](https://github.com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)ã€‚"

#, fuzzy
#~ msgid ""
#~ "- User Interaction & Selection: Users send transactions to a\n"
#~ "  centralized Sequencer, which selects and orders them.\n"
#~ "\n"
#~ "- Block Formation: The Sequencer packages these ordered transactions\n"
#~ "  into a block.\n"
#~ "\n"
#~ "- Proof & Verification: The block is sent to a proving service, which\n"
#~ "  generates a proof and posts it to Layer 1 (L1) for verification.\n"
#~ "\n"
#~ "- Verification: Once verified on L1, the transactions are considered\n"
#~ "  finalized and integrated into the L1 blockchain."
#~ msgstr ""
#~ "- ç”¨æˆ·äº¤äº’ä¸é€‰æ‹©ï¼šç”¨æˆ·å°†äº¤æ˜“å‘é€ç»™\n"
#~ "  ä¸­å¤®æ’åºå™¨ï¼Œç”±å…¶è¿›è¡Œé€‰æ‹©å’Œæ’åºã€‚\n"
#~ "\n"
#~ "- åŒºå—å½¢æˆï¼šæ’åºå™¨å°†è¿™äº›å·²æ’åºçš„äº¤æ˜“\n"
#~ "  æ‰“åŒ…æˆä¸€ä¸ªåŒºå—ã€‚\n"
#~ "\n"
#~ "- è¯æ˜ä¸éªŒè¯ï¼šåŒºå—è¢«å‘é€åˆ°è¯æ˜æœåŠ¡ï¼Œç”±å…¶ç”Ÿæˆè¯æ˜å¹¶å‘å¸ƒåˆ°ç¬¬ä¸€å±‚ï¼ˆL1ï¼‰è¿›è¡ŒéªŒè¯ã€‚\n"
#~ "  ç”Ÿæˆè¯æ˜å¹¶å‘å¸ƒåˆ°ç¬¬ä¸€å±‚ï¼ˆL1ï¼‰è¿›è¡ŒéªŒè¯ã€‚\n"
#~ "\n"
#~ "- éªŒè¯ï¼šä¸€æ—¦åœ¨ L1 å±‚å¾—åˆ°éªŒè¯ï¼Œäº¤æ˜“å³è¢«è§†ä¸º\n"
#~ "  æœ€ç»ˆå®Œæˆå¹¶æ•´åˆåˆ° L1 åŒºå—é“¾ä¸­ã€‚"

#~ msgid "<img alt=\"Centralized rollup\" src=\"img/ch03-centralized-rollup.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Centralized rollup\" src=\"img/ch03-centralized-rollup.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Centralized rollup</span>"
#~ msgstr "<span class=\"caption\">Centralized rollup</span>"

#, fuzzy
#~ msgid ""
#~ "     Generated Proofs\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "    STARK Verifier program (in Cairo)\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "            Cairo Job\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "                Prover\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "      New Proof Generated\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "           Repeat Process\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "     Trigger Reached (last proof)\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "        Solidity Verifier"
#~ msgstr ""
#~ "     ç”Ÿæˆçš„è¯æ˜\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "    STARK éªŒè¯ç¨‹åºï¼ˆCairoè¯­ï¼‰\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "            Cairoå·¥ä½œ\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "                è¯æ˜è€…\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "      ç”Ÿæˆæ–°è¯æ˜\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "           é‡å¤è¿‡ç¨‹\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "     è¾¾åˆ°è§¦å‘å™¨ï¼ˆæœ€åä¸€æ¬¡è¯æ˜ï¼‰\n"
#~ "                 |\n"
#~ "                 V\n"
#~ "        ç¨³å›ºæ€§éªŒè¯å™¨"

#, fuzzy
#~ msgid ""
#~ "1.  **Parallelization**: Recursive proofs allow for work\n"
#~ "    parallelization, reducing user latency and improving SHARP\n"
#~ "    efficiency.\n"
#~ "\n"
#~ "2.  **Cheaper on-chain costs**: Parallelization enables SHARP to create\n"
#~ "    larger proofs, which would have previously been limited by the\n"
#~ "    availability of large cloud machines (which are rare and limited).\n"
#~ "    As a result, on-chain costs are reduced.\n"
#~ "\n"
#~ "3.  **Lower cloud costs**: Since each job is shorter, the required\n"
#~ "    memory for processing is reduced, resulting in lower cloud costs.\n"
#~ "\n"
#~ "4.  **Optimization**: Recursive proofs enable SHARP to optimize for\n"
#~ "    various factors, including latency, on-chain costs, and time to\n"
#~ "    proof.\n"
#~ "\n"
#~ "5.  **Cairo support**: Recursive proofs only require support in Cairo,\n"
#~ "    without the need to add support in the Solidity Verifier."
#~ msgstr ""
#~ "1.  **å¹¶è¡ŒåŒ–**ï¼šé€’å½’è¯æ˜å…è®¸å·¥ä½œ\n"
#~ "    å¹¶è¡ŒåŒ–ï¼Œå‡å°‘ç”¨æˆ·å»¶è¿Ÿï¼Œæé«˜ SHARP\n"
#~ "    æ•ˆç‡ã€‚\n"
#~ "\n"
#~ "2.  **é™ä½é“¾ä¸Šæˆæœ¬**ï¼šå¹¶è¡ŒåŒ–ä½¿ SHARP èƒ½å¤Ÿåˆ›å»º\n"
#~ "    æ›´å¤§çš„è¯æ˜ï¼Œè€Œè¿™åœ¨ä»¥å‰æ˜¯å—é™äº\n"
#~ "    å¤§å‹äº‘è®¡ç®—æœºå™¨çš„å¯ç”¨æ€§ï¼ˆäº‘è®¡ç®—æœºå™¨ç¨€å°‘ä¸”æœ‰é™ï¼‰ã€‚\n"
#~ "    å› æ­¤ï¼Œé“¾ä¸Šæˆæœ¬å¾—ä»¥é™ä½ã€‚\n"
#~ "\n"
#~ "3.  **é™ä½äº‘æˆæœ¬**ï¼šç”±äºæ¯ä¸ªä½œä¸šçš„æ—¶é—´è¾ƒçŸ­ï¼Œå¤„ç†æ‰€éœ€çš„\n"
#~ "    å†…å­˜ï¼Œä»è€Œé™ä½äº†äº‘æˆæœ¬ã€‚\n"
#~ "\n"
#~ "4.  **ä¼˜åŒ–**ï¼šé€’å½’è¯æ˜ä½¿ SHARP èƒ½å¤Ÿé’ˆå¯¹å„ç§å› ç´ è¿›è¡Œä¼˜åŒ–ã€‚\n"
#~ "    å„ç§å› ç´ è¿›è¡Œä¼˜åŒ–ï¼ŒåŒ…æ‹¬å»¶è¿Ÿã€é“¾ä¸Šæˆæœ¬å’Œè¯æ˜æ—¶é—´ã€‚\n"
#~ "    è¯æ˜ã€‚\n"
#~ "\n"
#~ "5.  **Cairoæ”¯æŒ**ï¼šé€’å½’è¯æ˜åªéœ€Cairoæ”¯æŒã€\n"
#~ "    æ— éœ€åœ¨ Solidity æ ¡éªŒå™¨ä¸­æ·»åŠ æ”¯æŒã€‚"

#, fuzzy
#~ msgid ""
#~ "1.  **Gateway**: Cairo jobs enter SHARP through the gateway.\n"
#~ "\n"
#~ "2.  **Job Creator**: It prevents job duplication and ensures that the\n"
#~ "    system operates consistently, regardless of multiple identical\n"
#~ "    requests.\n"
#~ "\n"
#~ "3.  **Validator**: This is the first important step. The validator\n"
#~ "    service runs validation checks on each job, ensuring they meet the\n"
#~ "    requirements and can fit within the prover machines. Invalid jobs\n"
#~ "    are tagged as such and do not proceed to the Prover.\n"
#~ "\n"
#~ "4.  **Scheduler**: The scheduler service creates \"trains\" that aggregate\n"
#~ "    jobs and send them to the Prover. Recursive jobs are paired and sent\n"
#~ "    to the Prover together.\n"
#~ "\n"
#~ "5.  **Cairo Runner**: This service runs Cairo for the Proverâ€™s needs.\n"
#~ "    The Cairo Runner service runs Cairo programs, executing the\n"
#~ "    necessary computations and generating the execution trace as an\n"
#~ "    intermediate result. The Prover then uses this execution trace.\n"
#~ "\n"
#~ "6.  **Prover**: The Prover computes the proofs for each train (that\n"
#~ "    contains a few jobs).\n"
#~ "\n"
#~ "7.  **Dispatcher**: The Dispatcher serves two functions in the SHARP\n"
#~ "    system.\n"
#~ "\n"
#~ "    1.  In the case of a recursive proof, the Dispatcher runs the Cairo\n"
#~ "        Verifier program on the proof it has received from the Prover,\n"
#~ "        resulting in a new Cairo job that goes back to the Validator.\n"
#~ "\n"
#~ "    2.  In the case of a proof that needs to go on chain (e.g., to\n"
#~ "        Ethereum), the Dispatcher creates \"packages\" from the proof,\n"
#~ "        which can then be sent to the Blockchain Writer.\n"
#~ "\n"
#~ "8.  **Blockchain Writer**: Once the packages have been created by the\n"
#~ "    Dispatcher, they are sent to the Blockchain Writer. The Blockchain\n"
#~ "    Writer is responsible for sending the packages to the appropriate\n"
#~ "    blockchain (e.g., Ethereum) for verification. This is an important\n"
#~ "    step in the SHARP system, as it ensures that the proofs are properly\n"
#~ "    verified and that the transactions are securely recorded on the\n"
#~ "    blockchain.\n"
#~ "\n"
#~ "9.  **Catcher**: The Catcher monitors blockchain (e.g., Ethereum)\n"
#~ "    transactions to ensure that they have been accepted. While the\n"
#~ "    Catcher is relevant for internal monitoring purposes, it is\n"
#~ "    important to note that if a transaction fails, the fact wonâ€™t be\n"
#~ "    registered on-chain in the fact registry. As a result, the soundness\n"
#~ "    of the system is still preserved even without the catcher."
#~ msgstr ""
#~ "1.  **ç½‘å…³**ï¼šCairoä½œä¸šé€šè¿‡ç½‘å…³è¿›å…¥å¤æ™®ã€‚\n"
#~ "\n"
#~ "2.  **Job Creator**ï¼šå®ƒå¯é˜²æ­¢ä½œä¸šé‡å¤ï¼Œå¹¶ç¡®ä¿\n"
#~ "    ç³»ç»Ÿè¿è¡Œçš„ä¸€è‡´æ€§ï¼Œæ— è®ºæ˜¯å¦æœ‰å¤šä¸ªç›¸åŒçš„\n"
#~ "    è¯·æ±‚ã€‚\n"
#~ "\n"
#~ "3.  **éªŒè¯å™¨**ï¼šè¿™æ˜¯é‡è¦çš„ç¬¬ä¸€æ­¥ã€‚éªŒè¯å™¨\n"
#~ "    æœåŠ¡å¯¹æ¯ä¸ªä»»åŠ¡è¿›è¡ŒéªŒè¯æ£€æŸ¥ï¼Œç¡®ä¿å®ƒä»¬ç¬¦åˆ\n"
#~ "    è¦æ±‚ï¼Œå¹¶èƒ½é€‚åº”éªŒè¯å™¨æœºå™¨ã€‚æ— æ•ˆä½œä¸š\n"
#~ "    å°†è¢«æ ‡è®°ä¸ºæ— æ•ˆï¼Œå¹¶ä¸ä¼šè¿›å…¥éªŒè¯å™¨ã€‚\n"
#~ "\n"
#~ "4.  **è°ƒåº¦ç¨‹åº**ï¼šè°ƒåº¦å™¨æœåŠ¡åˆ›å»º \"åˆ—è½¦\"ï¼Œå°†ä½œä¸šæ±‡æ€»å¹¶å‘é€åˆ°éªŒè¯å™¨ã€‚\n"
#~ "    ä½œä¸šï¼Œå¹¶å°†å®ƒä»¬å‘é€åˆ°éªŒè¯ç¨‹åºã€‚é€’å½’ä½œä¸šé…å¯¹å\n"
#~ "    ä¸€èµ·å‘é€åˆ°éªŒè¯å™¨ã€‚\n"
#~ "\n"
#~ "5.  **Cairoè¿è¡Œç¨‹åº**ï¼šè¯¥æœåŠ¡æ ¹æ®éªŒè¯è€…çš„éœ€è¦è¿è¡ŒCairoç¨‹åºã€‚\n"
#~ "    Cairo Runner æœåŠ¡è¿è¡Œ Cairo ç¨‹åºï¼Œæ‰§è¡Œå¿…è¦çš„è®¡ç®—ï¼Œå¹¶ä»¥\n"
#~ "    å¿…è¦çš„è®¡ç®—ï¼Œå¹¶ç”Ÿæˆæ‰§è¡Œè½¨è¿¹ä½œä¸ºä¸­é—´ç»“æœã€‚\n"
#~ "    ä½œä¸ºä¸­é—´ç»“æœã€‚éªŒè¯è€…éšåä½¿ç”¨è¯¥æ‰§è¡Œè·Ÿè¸ªã€‚\n"
#~ "\n"
#~ "6.  **è¯æ˜è€…**ï¼šè¯æ˜è€…**ï¼šè¯æ˜è€…ä¸ºæ¯ä¸€åˆ—ç«è½¦ï¼ˆåŒ…å«å‡ ä¸ªä½œä¸šï¼‰è®¡ç®—è¯æ˜ã€‚\n"
#~ "    åŒ…å«å‡ ä¸ªä½œä¸šï¼‰çš„è¯æ˜ã€‚\n"
#~ "\n"
#~ "7.  **è°ƒåº¦å™¨**ï¼šè°ƒåº¦ç¨‹åºåœ¨ SHARP\n"
#~ "    ç³»ç»Ÿä¸­çš„ä¸¤ä¸ªåŠŸèƒ½ã€‚\n"
#~ "\n"
#~ "    1.  åœ¨é€’å½’è¯æ˜çš„æƒ…å†µä¸‹ï¼Œè°ƒåº¦å™¨åœ¨ä»è¯æ˜è€…æ”¶åˆ°çš„è¯æ˜ä¸Šè¿è¡ŒCairo\n"
#~ "        éªŒè¯ç¨‹åºã€\n"
#~ "        ä»è€Œäº§ç”Ÿä¸€ä¸ªæ–°çš„Cairoä½œä¸šï¼Œå¹¶è¿”å›éªŒè¯å™¨ã€‚\n"
#~ "\n"
#~ "    2.  å¦‚æœè¯æ˜éœ€è¦ä¸Šé“¾ï¼ˆä¾‹å¦‚ï¼Œä¸Šé“¾åˆ°\n"
#~ "        ä»¥å¤ªåŠï¼‰ï¼Œè°ƒåº¦ç¨‹åºä¼šæ ¹æ®è¯æ˜åˆ›å»º \"åŒ…\"ã€\n"
#~ "        ç„¶åå‘é€ç»™åŒºå—é“¾å†™å…¥å™¨ã€‚\n"
#~ "\n"
#~ "8.  **åŒºå—é“¾å†™å…¥å™¨**ï¼šä¸€æ—¦\n"
#~ "    è°ƒåº¦å™¨åˆ›å»ºåï¼Œå°±ä¼šå°†å…¶å‘é€ç»™åŒºå—é“¾å†™å…¥å™¨ã€‚åŒºå—é“¾\n"
#~ "    å†™å…¥å™¨è´Ÿè´£å°†æ•°æ®åŒ…å‘é€åˆ°ç›¸åº”çš„\n"
#~ "    åŒºå—é“¾ï¼ˆå¦‚ä»¥å¤ªåŠï¼‰è¿›è¡ŒéªŒè¯ã€‚è¿™æ˜¯ SHARP ç³»ç»Ÿçš„ä¸€ä¸ªé‡è¦\n"
#~ "    è¿™ä¸€æ­¥åœ¨ SHARP ç³»ç»Ÿä¸­éå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒå¯ä»¥ç¡®ä¿è¯æ˜å¾—åˆ°æ­£ç¡®çš„\n"
#~ "    éªŒè¯ï¼Œå¹¶ç¡®ä¿äº¤æ˜“å®‰å…¨åœ°è®°å½•åœ¨åŒºå—é“¾ä¸Šã€‚\n"
#~ "    åŒºå—é“¾ä¸Šã€‚\n"
#~ "\n"
#~ "9.  **æ•è·å™¨**ï¼šæ•è·å™¨ç›‘æ§åŒºå—é“¾ï¼ˆå¦‚ä»¥å¤ªåŠï¼‰ä¸Šçš„\n"
#~ "    äº¤æ˜“ï¼Œä»¥ç¡®ä¿å®ƒä»¬å·²è¢«æ¥å—ã€‚è™½ç„¶\n"
#~ "    æ•è·å™¨ä¸å†…éƒ¨ç›‘æ§ç›®çš„ç›¸å…³ï¼Œä½†é‡è¦çš„æ˜¯\n"
#~ "    éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœäº¤æ˜“å¤±è´¥ï¼Œäº‹å®å°†ä¸ä¼šåœ¨é“¾ä¸Šçš„äº‹å®æ³¨å†Œä¸­å¿ƒæ³¨å†Œã€‚\n"
#~ "    åœ¨é“¾ä¸Šçš„äº‹å®æ³¨å†Œè¡¨ä¸­æ³¨å†Œã€‚å› æ­¤\n"
#~ "    å› æ­¤ï¼Œå³ä½¿æ²¡æœ‰æ•è·å™¨ï¼Œç³»ç»Ÿçš„ç¨³å¥æ€§ä»ç„¶å¯ä»¥ä¿æŒã€‚"

#, fuzzy
#~ msgid ""
#~ "- Exploring more efficient hash functions: SHARP is constantly\n"
#~ "  exploring more efficient hash functions for Cairo, the Prover, and\n"
#~ "  Solidity.\n"
#~ "\n"
#~ "- Investigating smaller fields: Investigating smaller fields for\n"
#~ "  recursive proof steps could lead to more efficient computations.\n"
#~ "\n"
#~ "- Adjusting various parameters: SHARP is continually adjusting various\n"
#~ "  parameters of the STARK protocol, such as FRI parameters and block\n"
#~ "  factors.\n"
#~ "\n"
#~ "- Optimizing the Cairo code: SHARP is optimizing the Cairo code to\n"
#~ "  make it faster, resulting in a faster recursive prover.\n"
#~ "\n"
#~ "- Developing dynamic layouts: This will allow Cairo programs to scale\n"
#~ "  resources depending on their needs.\n"
#~ "\n"
#~ "- Improving scheduling algorithm: This is another optimization path\n"
#~ "  that can be taken. It is not within the Prover itself."
#~ msgstr ""
#~ "- æ¢ç´¢æ›´é«˜æ•ˆçš„æ•£åˆ—å‡½æ•°å¤æ™®ä¸æ–­\n"
#~ "  ä¸º Cairoã€Prover å’Œ\n"
#~ "  Solidityã€‚\n"
#~ "\n"
#~ "- ç ”ç©¶æ›´å°çš„å­—æ®µï¼šç ”ç©¶æ›´å°çš„å­—æ®µ\n"
#~ "  å¯ä»¥æé«˜è®¡ç®—æ•ˆç‡ã€‚\n"
#~ "\n"
#~ "- è°ƒæ•´å„ç§å‚æ•°ï¼šSHARP æ­£åœ¨ä¸æ–­è°ƒæ•´ STARK åè®®çš„å„ç§\n"
#~ "  STARKåè®®çš„å„ç§å‚æ•°ï¼Œå¦‚FRIå‚æ•°å’Œå—\n"
#~ "  ç³»æ•°ã€‚\n"
#~ "\n"
#~ "- ä¼˜åŒ–Cairoä»£ç ï¼šå¤æ™®æ­£åœ¨ä¼˜åŒ–Cairoä»£ç ï¼Œä½¿å…¶æ›´å¿«\n"
#~ "  ä½¿å…¶æ›´å¿«ï¼Œä»è€ŒåŠ å¿«é€’å½’è¯æ˜å™¨çš„é€Ÿåº¦ã€‚\n"
#~ "\n"
#~ "- å¼€å‘åŠ¨æ€å¸ƒå±€ï¼šè¿™å°†ä½¿Cairoç¨‹åºèƒ½å¤Ÿæ ¹æ®éœ€è¦\n"
#~ "  èµ„æºã€‚\n"
#~ "\n"
#~ "- æ”¹è¿›è°ƒåº¦ç®—æ³•ï¼šè¿™æ˜¯å¦ä¸€æ¡ä¼˜åŒ–é€”å¾„\n"
#~ "  å¯ä»¥é‡‡å–çš„å¦ä¸€æ¡ä¼˜åŒ–é€”å¾„ã€‚å®ƒä¸å±äº Prover æœ¬èº«ã€‚"

#, fuzzy
#~ msgid ""
#~ "This chapter will guide you through setting up and running a Starknet\n"
#~ "node, illustrating the layered tech stack concept, and explaining how to\n"
#~ "operate these protocols locally. Starknet, as a Layer 2 Validity Rollup,\n"
#~ "operates on top of Ethereum Layer 1, creating a protocol stack that each\n"
#~ "addresses different functionalities, similar to the OSI model for\n"
#~ "internet connections. This chapter is an edit of\n"
#~ "[drspacemn](https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4)'s\n"
#~ "blog."
#~ msgstr ""
#~ "æœ¬ç« å°†æŒ‡å¯¼æ‚¨è®¾ç½®å’Œè¿è¡Œä¸€ä¸ªStarknetèŠ‚ç‚¹ã€‚\n"
#~ "èŠ‚ç‚¹ï¼Œè¯´æ˜åˆ†å±‚æŠ€æœ¯æ ˆæ¦‚å¿µï¼Œå¹¶è§£é‡Šå¦‚ä½•åœ¨æœ¬åœ°æ“ä½œè¿™äº›åè®®ã€‚\n"
#~ "å¦‚ä½•åœ¨æœ¬åœ°è¿è¡Œè¿™äº›åè®®ã€‚Starknet ä½œä¸ºç¬¬äºŒå±‚æœ‰æ•ˆæ€§å·ç§¯ï¼ˆLayer 2 Validity Rollupï¼‰ã€\n"
#~ "åœ¨ä»¥å¤ªåŠç¬¬ä¸€å±‚ä¹‹ä¸Šè¿è¡Œï¼Œåˆ›å»ºäº†ä¸€ä¸ªåè®®æ ˆï¼Œæ¯ä¸ªåè®®æ ˆéƒ½\n"
#~ "è§£å†³ä¸åŒçš„åŠŸèƒ½ï¼Œç±»ä¼¼äºäº’è”ç½‘è¿æ¥çš„ OSI æ¨¡å‹ã€‚\n"
#~ "äº’è”ç½‘è¿æ¥ã€‚æœ¬ç« æ˜¯å¯¹\n"
#~ "[drspacemn](https://medium.com/starknet-edu/the-starknet-stack-7b0d70a7e1d4)çš„\n"
#~ "åšå®¢çš„ç¼–è¾‘ã€‚"

#, fuzzy
#~ msgid ""
#~ "CONTRIBUTE: This guide shows how to run a Starknet node locally with a\n"
#~ "particular setup. You can contribute to this guide by adding more\n"
#~ "options for hardware and software, as well as other ways to run a\n"
#~ "Starknet nod (for example using\n"
#~ "[Beerus](https://github.com/keep-starknet-strange/beerus)). You can also\n"
#~ "contribute by adding more information about the Starknet stack and the\n"
#~ "different layers. Feel free to [open a\n"
#~ "PR](https://github.com/starknet-edu/starknetbook)."
#~ msgstr ""
#~ "è´¡çŒ®ï¼š æœ¬æŒ‡å—ä»‹ç»äº†å¦‚ä½•åœ¨æœ¬åœ°è¿è¡Œä¸€ä¸ª Starknet èŠ‚ç‚¹ï¼Œå¹¶è¿›è¡Œç‰¹å®šè®¾ç½®ã€‚\n"
#~ "ç‰¹å®šè®¾ç½®è¿è¡ŒStarknetèŠ‚ç‚¹ã€‚æ‚¨å¯ä»¥ä¸ºæœ¬æŒ‡å—æ·»åŠ æ›´å¤š\n"
#~ "ç¡¬ä»¶å’Œè½¯ä»¶é€‰é¡¹ï¼Œä»¥åŠè¿è¡ŒStarknetèŠ‚ç‚¹çš„å…¶ä»–æ–¹æ³•ï¼ˆä¾‹å¦‚ä½¿ç”¨\n"
#~ "StarknetèŠ‚ç‚¹çš„å…¶ä»–æ–¹æ³•ï¼ˆä¾‹å¦‚ä½¿ç”¨\n"
#~ "[Beerus](https://github.com/keep-starknet-strange/beerus)).æ‚¨è¿˜å¯ä»¥\n"
#~ "æ·»åŠ æ›´å¤šæœ‰å…³Starknetå †æ ˆå’Œä¸åŒå±‚çš„ä¿¡æ¯ã€‚\n"
#~ "å±‚çš„æ›´å¤šä¿¡æ¯ã€‚è¯·éšæ—¶åœ¨\n"
#~ "PR](https://github.com/starknet-edu/starknetbook)."

#, fuzzy
#~ msgid "## What is a Node in the Context of Ethereum and Blockchain?"
#~ msgstr "##ä»¥å¤ªåŠå’ŒåŒºå—é“¾èƒŒæ™¯ä¸‹çš„èŠ‚ç‚¹æ˜¯ä»€ä¹ˆï¼Ÿ"

#, fuzzy
#~ msgid ""
#~ "In the context of Ethereum and blockchain, a node is an integral part of\n"
#~ "the network that validates and relays transactions. Nodes download a\n"
#~ "copy of the entire blockchain and are interconnected with other nodes to\n"
#~ "maintain and update the blockchain state. There are different types of\n"
#~ "nodes, such as full nodes, light nodes, and mining nodes, each having\n"
#~ "different roles and responsibilities within the network."
#~ msgstr ""
#~ "åœ¨ä»¥å¤ªåŠå’ŒåŒºå—é“¾ä¸­ï¼ŒèŠ‚ç‚¹æ˜¯ç½‘ç»œä¸å¯åˆ†å‰²çš„ä¸€éƒ¨åˆ†ã€‚\n"
#~ "åœ¨ä»¥å¤ªåŠå’ŒåŒºå—é“¾ä¸­ï¼ŒèŠ‚ç‚¹æ˜¯éªŒè¯å’Œè½¬å‘äº¤æ˜“çš„ç½‘ç»œç»„æˆéƒ¨åˆ†ã€‚èŠ‚ç‚¹ä¸‹è½½æ•´ä¸ªåŒºå—é“¾çš„\n"
#~ "æ•´ä¸ªåŒºå—é“¾çš„å‰¯æœ¬ï¼Œå¹¶ä¸å…¶ä»–èŠ‚ç‚¹äº’è”ï¼Œä»¥ç»´æŠ¤å’Œæ›´æ–°åŒºå—é“¾çŠ¶æ€ã€‚\n"
#~ "ç»´æŠ¤å’Œæ›´æ–°åŒºå—é“¾çŠ¶æ€ã€‚æœ‰ä¸åŒç±»å‹çš„\n"
#~ "èŠ‚ç‚¹ï¼Œæ¯ç§èŠ‚ç‚¹åœ¨ç½‘ç»œä¸­éƒ½æœ‰ä¸åŒçš„è§’è‰²å’Œè´£ä»»ã€‚\n"
#~ "åœ¨ç½‘ç»œä¸­æ‰®æ¼”ä¸åŒçš„è§’è‰²ï¼Œæ‰¿æ‹…ä¸åŒçš„è´£ä»»ã€‚"

#, fuzzy
#~ msgid ""
#~ "Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for\n"
#~ "full decentralization. It enables developers to build scalable\n"
#~ "decentralized applications (dApps) and utilizes Ethereumâ€™s Layer 1 for\n"
#~ "proof verification and data availability. Key aspects of Starknet\n"
#~ "include:"
#~ msgstr ""
#~ "Starknetæ˜¯ä¸€ä¸ªæ— æƒé™ã€åŸºäº zk-STARK çš„ç¬¬ 2 å±‚ç½‘ç»œï¼Œæ—¨åœ¨å®ç°å®Œå…¨çš„å»ä¸­å¿ƒåŒ–ã€‚\n"
#~ "å®Œå…¨å»ä¸­å¿ƒåŒ–ã€‚å®ƒä½¿å¼€å‘è€…èƒ½å¤Ÿæ„å»ºå¯æ‰©å±•çš„\n"
#~ "å»ä¸­å¿ƒåŒ–åº”ç”¨ç¨‹åºï¼ˆdAppsï¼‰ï¼Œå¹¶åˆ©ç”¨ä»¥å¤ªåŠçš„ç¬¬ 1 å±‚è¿›è¡Œ\n"
#~ "è¯æ˜éªŒè¯å’Œæ•°æ®å¯ç”¨æ€§ã€‚Starknetçš„ä¸»è¦æ–¹é¢\n"
#~ "åŒ…æ‹¬"

#, fuzzy
#~ msgid ""
#~ "- **Cairo execution environment**: Cairo, the execution environment of\n"
#~ "  Starknet, facilitates writing and execution of complex smart\n"
#~ "  contracts.\n"
#~ "\n"
#~ "- **Scalability**: Starknet achieves scalability through zk-STARK\n"
#~ "  proofs, minimizing the data needed to be posted on-chain.\n"
#~ "\n"
#~ "- **Node network**: The Starknet network comprises nodes that\n"
#~ "  synchronize and process transactions, contributing to the networkâ€™s\n"
#~ "  overall security and decentralization."
#~ msgstr ""
#~ "- **Cairoçš„æ‰§è¡Œç¯å¢ƒ**ï¼šCairoæ˜¯Starknetçš„æ‰§è¡Œç¯å¢ƒã€‚\n"
#~ "  Cairoæ˜¯Starknetçš„æ‰§è¡Œç¯å¢ƒï¼Œæœ‰åŠ©äºç¼–å†™å’Œæ‰§è¡Œå¤æ‚çš„æ™ºèƒ½åˆçº¦ã€‚\n"
#~ "  åˆçº¦ã€‚\n"
#~ "\n"
#~ "- **å¯æ‰©å±•æ€§**ï¼šStarkneté€šè¿‡zk-STARK\n"
#~ "  è¯æ˜æ¥å®ç°å¯æ‰©å±•æ€§ï¼Œä»è€Œæœ€å¤§é™åº¦åœ°å‡å°‘éœ€è¦åœ¨é“¾ä¸Šå‘å¸ƒçš„æ•°æ®ã€‚\n"
#~ "\n"
#~ "- **èŠ‚ç‚¹ç½‘ç»œ**ï¼šStarknetç”±èŠ‚ç‚¹ç»„æˆï¼Œè¿™äº›èŠ‚ç‚¹å¯\n"
#~ "  èŠ‚ç‚¹åŒæ­¥å’Œå¤„ç†äº¤æ˜“ï¼Œæœ‰åŠ©äºç½‘ç»œçš„\n"
#~ "  æ•´ä½“å®‰å…¨æ€§å’Œå»ä¸­å¿ƒåŒ–ã€‚"

#, fuzzy
#~ msgid "## Starknet Stack"
#~ msgstr "## Starknetå †æ ˆ"

#, fuzzy
#~ msgid ""
#~ "The Starknet stack can be divided into various layers, similar to OSI or\n"
#~ "TCP/IP models. The most appropriate model depends on your understanding\n"
#~ "and requirements. A simplified version of the modular blockchain stack\n"
#~ "might look like this:"
#~ msgstr ""
#~ "Starknetå †æ ˆå¯åˆ†ä¸ºä¸åŒçš„å±‚ï¼Œç±»ä¼¼äº OSI æˆ–\n"
#~ "TCP/IP æ¨¡å‹ã€‚æœ€åˆé€‚çš„æ¨¡å‹å–å†³äºæ‚¨å¯¹\n"
#~ "å’Œè¦æ±‚è€Œå®šã€‚æ¨¡å—åŒ–åŒºå—é“¾å †æ ˆçš„ç®€åŒ–ç‰ˆ\n"
#~ "å¯èƒ½æ˜¯è¿™æ ·çš„"

#, fuzzy
#~ msgid ""
#~ "- Layer 1: Data Layer\n"
#~ "\n"
#~ "- Layer 2: Execution Layer\n"
#~ "\n"
#~ "- Layer 3: Application Layer\n"
#~ "\n"
#~ "- Layer 4: Transport Layer"
#~ msgstr ""
#~ "- ç¬¬ 1 å±‚ï¼šæ•°æ®å±‚\n"
#~ "\n"
#~ "- ç¬¬ 2 å±‚ï¼šæ‰§è¡Œå±‚\n"
#~ "\n"
#~ "- ç¬¬ 3 å±‚ï¼šåº”ç”¨å±‚\n"
#~ "\n"
#~ "- ç¬¬ 4 å±‚ï¼šä¼ è¾“å±‚"

#~ msgid "<img alt=\"Modular blockchain layers\" src=\"img/ch03-modular-blockcahain-layers.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Modular blockchain layers\" src=\"img/ch03-modular-blockcahain-layers.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Modular blockchain layers</span>"
#~ msgstr "<span class=\"caption\">Modular blockchain layers</span>"

#, fuzzy
#~ msgid ""
#~ "There are various hardware specifications, including packaged options,\n"
#~ "that will enable you to run an Ethereum node from home. The goal here is\n"
#~ "to build the most cost-efficient Starknet stack possible ([see here more\n"
#~ "options](https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md))."
#~ msgstr ""
#~ "æœ‰å„ç§ç¡¬ä»¶è§„æ ¼ï¼ŒåŒ…æ‹¬æ‰“åŒ…é€‰é¡¹ã€\n"
#~ "å¯ä»¥è®©ä½ åœ¨å®¶é‡Œè¿è¡Œä»¥å¤ªåŠèŠ‚ç‚¹ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯\n"
#~ "æ„å»ºæœ€å…·æˆæœ¬æ•ˆç›Šçš„Starknetå †æ ˆï¼ˆ[æŸ¥çœ‹æ­¤å¤„çš„æ›´å¤š\n"
#~ "é€‰é¡¹](https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md)ï¼‰ã€‚"

#, fuzzy
#~ msgid ""
#~ "- CPU: 2+ cores\n"
#~ "\n"
#~ "- RAM: 4 GB\n"
#~ "\n"
#~ "- Disk: 600 GB\n"
#~ "\n"
#~ "- Connection Speed: 8 mbps/sec"
#~ msgstr ""
#~ "- CPUï¼š2+ å†…æ ¸\n"
#~ "\n"
#~ "- å†…å­˜ï¼š 4 GB\n"
#~ "\n"
#~ "- ç£ç›˜ï¼š 600 GB\n"
#~ "\n"
#~ "- è¿æ¥é€Ÿåº¦ï¼š 8 mbps/ç§’"

#, fuzzy
#~ msgid ""
#~ "- CPU: 4+ cores\n"
#~ "\n"
#~ "- RAM: 16 GB+\n"
#~ "\n"
#~ "- Disk 2 TB\n"
#~ "\n"
#~ "- Connection Speed: 25+ mbps/sec"
#~ msgstr ""
#~ "- CPUï¼š4+ å†…æ ¸\n"
#~ "\n"
#~ "- å†…å­˜ï¼š 16 GB+\n"
#~ "\n"
#~ "- ç£ç›˜ 2 TB\n"
#~ "\n"
#~ "- è¿æ¥é€Ÿåº¦ï¼š 25+ mbps/ç§’"

#, fuzzy
#~ msgid "**You can refer to these links for the hardware:**"
#~ msgstr "**æ‚¨å¯ä»¥å‚è€ƒè¿™äº›ç¡¬ä»¶é“¾æ¥ï¼š**"

#, fuzzy
#~ msgid ""
#~ "- [CPU](https://a.co/d/iAWpTzQ) â€” $193\n"
#~ "\n"
#~ "- [Board](https://a.co/d/cTUk9Kd) (can attempt w/ Raspberry Pi) â€” $110\n"
#~ "\n"
#~ "- [Disk](https://a.co/d/0US61Y5) â€” $100\n"
#~ "\n"
#~ "- [RAM](https://a.co/d/br867sk) â€” $60\n"
#~ "\n"
#~ "- [PSU](https://a.co/d/2k3Gn40) â€” $40\n"
#~ "\n"
#~ "- [Case](https://a.co/d/apCBGwF) â€” $50"
#~ msgstr ""
#~ "- [CPU](https://a.co/d/iAWpTzQ) - 193 ç¾å…ƒ\n"
#~ "\n"
#~ "- [ç”µè·¯æ¿](https://a.co/d/cTUk9Kd) ï¼ˆå¯å°è¯•ä½¿ç”¨ Raspberry Piï¼‰ - $110\n"
#~ "\n"
#~ "- [ç£ç›˜](https://a.co/d/0US61Y5) - $100\n"
#~ "\n"
#~ "- [å†…å­˜](https://a.co/d/br867sk) - $60\n"
#~ "\n"
#~ "- [PSU](https://a.co/d/2k3Gn40) - $40\n"
#~ "\n"
#~ "- [æœºç®±](https://a.co/d/apCBGwF) - $50"

#, fuzzy
#~ msgid "Total â€” $553"
#~ msgstr "å…±è®¡ - 553 ç¾å…ƒ"

#, fuzzy
#~ msgid "sudo apt install -y jq curl net-tools"
#~ msgstr "sudo apt install -y jq curl net-tools"

#, fuzzy
#~ msgid "## Layer 1: Data Layer"
#~ msgstr "## ç¬¬ 1 å±‚ï¼šæ•°æ®å±‚"

#, fuzzy
#~ msgid ""
#~ "The bottom-most layer of the stack is the data layer. Here, Starknetâ€™s\n"
#~ "L2 leverages Ethereumâ€™s L1 for proof verification and data availability.\n"
#~ "Starknet utilizes Ethereum as its L1, so the first step is setting up an\n"
#~ "Ethereum Full Node. As this is the data layer, the hardware bottleneck\n"
#~ "is usually the disk storage. Itâ€™s crucial to have a high capacity I/O\n"
#~ "SSD over an HDD because Ethereum Nodes require both an Execution Client\n"
#~ "and a Consensus Client for communication."
#~ msgstr ""
#~ "å †æ ˆçš„æœ€åº•å±‚æ˜¯æ•°æ®å±‚ã€‚åœ¨è¿™é‡Œï¼ŒStarknetçš„\n"
#~ "L2 åˆ©ç”¨ä»¥å¤ªåŠçš„ L1 è¿›è¡Œè¯æ˜éªŒè¯å’Œæ•°æ®å¯ç”¨æ€§ã€‚\n"
#~ "Starknet åˆ©ç”¨ä»¥å¤ªåŠä½œä¸ºå…¶ L1ï¼Œå› æ­¤ç¬¬ä¸€æ­¥æ˜¯å»ºç«‹ä¸€ä¸ª\n"
#~ "ä»¥å¤ªåŠå…¨èŠ‚ç‚¹ã€‚ç”±äºè¿™æ˜¯æ•°æ®å±‚ï¼Œç¡¬ä»¶ç“¶é¢ˆ\n"
#~ "é€šå¸¸æ˜¯ç£ç›˜å­˜å‚¨ã€‚æ‹¥æœ‰ä¸€ä¸ªå¤§å®¹é‡ I/O\n"
#~ "å›ºæ€ç¡¬ç›˜æ¯”ç¡¬ç›˜æ›´é‡è¦ï¼Œå› ä¸ºä»¥å¤ªåŠèŠ‚ç‚¹æ—¢éœ€è¦æ‰§è¡Œå®¢æˆ·ç«¯\n"
#~ "å’Œå…±è¯†å®¢æˆ·ç«¯è¿›è¡Œé€šä¿¡ã€‚"

#, fuzzy
#~ msgid ""
#~ "Ethereum provides several options for Execution and Consensus clients.\n"
#~ "Execution clients include Geth, Erigon, Besu (used here), Nethermind,\n"
#~ "and Akula. Consensus clients include Prysm, Lighthouse (used here),\n"
#~ "Lodestar, Nimbus, and Teku."
#~ msgstr ""
#~ "ä»¥å¤ªåŠä¸ºæ‰§è¡Œå’Œå…±è¯†å®¢æˆ·ç«¯æä¾›äº†å¤šç§é€‰æ‹©ã€‚\n"
#~ "æ‰§è¡Œå®¢æˆ·ç«¯åŒ…æ‹¬ Gethã€Erigonã€Besuï¼ˆæ­¤å¤„ä½¿ç”¨ï¼‰ã€Nethermindã€\n"
#~ "å’Œ Akulaã€‚å…±è¯†å®¢æˆ·ç«¯åŒ…æ‹¬ Prysmã€Lighthouseï¼ˆæ­¤å¤„ä½¿ç”¨ï¼‰ã€\n"
#~ "Lodestarã€Nimbus å’Œ Tekuã€‚"

#, fuzzy
#~ msgid ""
#~ "Your Besu/Lighthouse node will take approximately 600 GB of disk space.\n"
#~ "Navigate to a partition on your machine with sufficient capacity and run\n"
#~ "the following commands:"
#~ msgstr ""
#~ "Besu/LighthouseèŠ‚ç‚¹å°†å ç”¨å¤§çº¦600 GBçš„ç£ç›˜ç©ºé—´ã€‚\n"
#~ "å¯¼èˆªåˆ°è®¡ç®—æœºä¸Šå®¹é‡è¶³å¤Ÿå¤§çš„åˆ†åŒºï¼Œè¿è¡Œ\n"
#~ "å‘½ä»¤ï¼š"

#, fuzzy
#~ msgid ""
#~ "git clone https://github.com/starknet-edu/starknet-stack.git\n"
#~ "    cd starknet-stack\n"
#~ "    docker-compose -f dc-l1.yaml up -d"
#~ msgstr ""
#~ "git clone https://github.com/starknet-edu/starknet-stack.git\n"
#~ "    cd starknet-stack\n"
#~ "    docker-compose -f dc-l1.yaml up -d"

#, fuzzy
#~ msgid ""
#~ "This will begin the fairly long process of spinning up our Consensus\n"
#~ "Client, Execution Client, and syncing them to the current state of the\n"
#~ "Goerli Testnet. If you would like to see the logs from either process\n"
#~ "you can run:"
#~ msgstr ""
#~ "è¿™å°†å¼€å§‹ä¸€ä¸ªç›¸å½“æ¼«é•¿çš„è¿‡ç¨‹ï¼Œå³å¯åŠ¨æˆ‘ä»¬çš„å…±è¯†\n"
#~ "å®¢æˆ·ç«¯ã€æ‰§è¡Œå®¢æˆ·ç«¯ï¼Œå¹¶å°†å®ƒä»¬åŒæ­¥åˆ° Goerli æµ‹è¯•ç½‘çš„å½“å‰çŠ¶æ€ã€‚\n"
#~ "Goerli Testnet çš„å½“å‰çŠ¶æ€ã€‚å¦‚æœæ‚¨æƒ³æŸ¥çœ‹è¿™ä¸¤ä¸ªè¿‡ç¨‹çš„æ—¥å¿—\n"
#~ "æ‚¨å¯ä»¥è¿è¡Œ"

#, fuzzy
#~ msgid ""
#~ "# tail besu logs\n"
#~ "    docker container logs -f $(docker ps | grep besu | awk '{print $1}')\n"
#~ "\n"
#~ "    # tail lighthouse logs\n"
#~ "    docker container logs -f $(docker ps | grep lighthouse | awk '{print $1}')"
#~ msgstr ""
#~ "# tail besu logs\n"
#~ "    docker container logs -f $(docker ps | grep besu | awk '{print $1}')\n"
#~ "\n"
#~ "    # å°¾éšç¯å¡”æ—¥å¿—\n"
#~ "    docker å®¹å™¨æ—¥å¿— -f $(docker ps | grep lighthouse | awk '{print $1}')"

#, fuzzy
#~ msgid "Lets make sure that everything that should be listening is listening:"
#~ msgstr "è®©æˆ‘ä»¬ç¡®ä¿æ‰€æœ‰åº”è¯¥å€¾å¬çš„ä¸œè¥¿éƒ½åœ¨å€¾å¬ï¼š"

#, fuzzy
#~ msgid ""
#~ "# should see all ports in command output\n"
#~ "\n"
#~ "    # besu ports\n"
#~ "    sudo netstat -lpnut | grep -E '30303|8551|8545'\n"
#~ "\n"
#~ "    # lighthouse ports\n"
#~ "    sudo netstat -lpnut | grep -E '5054|9000'"
#~ msgstr ""
#~ "# å‘½ä»¤è¾“å‡ºä¸­åº”æ˜¾ç¤ºæ‰€æœ‰ç«¯å£\n"
#~ "\n"
#~ "    # besu ç«¯å£\n"
#~ "    sudo netstat -lpnut | grep -E \"30303|8551|8545\n"
#~ "\n"
#~ "    # ç¯å¡”ç«¯å£\n"
#~ "    sudo netstat -lpnut | grep -E '5054|9000' # lighthouse ç«¯å£"

#, fuzzy
#~ msgid ""
#~ "Weâ€™ve used docker to abstract a lot of the nuance of running an Eth L1\n"
#~ "node, but the important things to note are how the two processes EL/CL\n"
#~ "point to each other and communicate via JSON-RPC:"
#~ msgstr ""
#~ "æˆ‘ä»¬ä½¿ç”¨ docker æ¥æŠ½è±¡è¿è¡Œ Eth L1\n"
#~ "èŠ‚ç‚¹ï¼Œä½†éœ€è¦æ³¨æ„çš„æ˜¯ä¸¤ä¸ªè¿›ç¨‹ EL/CL\n"
#~ "æ˜¯å¦‚ä½•ç›¸äº’æŒ‡å‘å¹¶é€šè¿‡ JSON-RPC è¿›è¡Œé€šä¿¡çš„ï¼š"

#, fuzzy
#~ msgid ""
#~ "services:\n"
#~ "      lighthouse:\n"
#~ "          image: sigp/lighthouse:latest\n"
#~ "          container_name: lighthouse\n"
#~ "          volumes:\n"
#~ "            - ./l1_consensus/data:/root/.lighthouse\n"
#~ "            - ./secret:/root/secret\n"
#~ "          network_mode: \"host\"\n"
#~ "          command:\n"
#~ "            - lighthouse\n"
#~ "            - beacon\n"
#~ "            - --network=goerli\n"
#~ "            - --metrics\n"
#~ "            - --checkpoint-sync-url=https://goerli.beaconstate.info\n"
#~ "            - --execution-endpoint=http://127.0.0.1:8551\n"
#~ "            - --execution-jwt=/root/secret/jwt.hex\n"
#~ "\n"
#~ "      besu:\n"
#~ "        image: hyperledger/besu:latest\n"
#~ "        container_name: besu\n"
#~ "        volumes:\n"
#~ "          - ./l1_execution/data:/var/lib/besu\n"
#~ "          - ./secret:/var/lib/besu/secret\n"
#~ "        network_mode: \"host\"\n"
#~ "        command:\n"
#~ "          - --network=goerli\n"
#~ "          - --rpc-http-enabled=true\n"
#~ "          - --data-path=/var/lib/besu\n"
#~ "          - --data-storage-format=BONSAI\n"
#~ "          - --sync-mode=X_SNAP\n"
#~ "          - --engine-rpc-enabled=true\n"
#~ "          - --engine-jwt-enabled=true\n"
#~ "          - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex"
#~ msgstr ""
#~ "æœåŠ¡ï¼š\n"
#~ "      lighthouseï¼š\n"
#~ "          image: sigp/lighthouse:latest\n"
#~ "          container_name: ç¯å¡”\n"
#~ "          å·\n"
#~ "            - ./l1_consensus/data:/root/.lighthouse\n"
#~ "            - ./secret:/root/secret\n"
#~ "          network_modeï¼šä¸»æœº\n"
#~ "          commandï¼š\n"
#~ "            - ç¯å¡”\n"
#~ "            - ä¿¡æ ‡\n"
#~ "            - --ç½‘ç»œ=goerli\n"
#~ "            - --å‚æ•°\n"
#~ "            - --æ£€æŸ¥ç‚¹åŒæ­¥url=https://goerli.beaconstate.info\n"
#~ "            - --execution-endpoint=http://127.0.0.1:8551\n"
#~ "            - --æ‰§è¡Œ-jwt=/root/secret/jwt.hex\n"
#~ "\n"
#~ "      besuï¼š\n"
#~ "        é•œåƒï¼š hyperledger/besu:latest\n"
#~ "        container_name: besu\n"
#~ "        volumesï¼š\n"
#~ "          - ./l1_execution/data:/var/lib/besu\n"
#~ "          - ./secret:/var/lib/besu/secret\n"
#~ "        network_modeï¼šä¸»æœº\n"
#~ "        commandï¼š\n"
#~ "          - --network=goerli\n"
#~ "          - --rpc-http-enabled=true\n"
#~ "          - --æ•°æ®è·¯å¾„=/var/lib/besu\n"
#~ "          - --æ•°æ®å­˜å‚¨æ ¼å¼=BONSAI\n"
#~ "          - --åŒæ­¥æ¨¡å¼=X_SNAP\n"
#~ "          - --engine-rpc-enabled=true\n"
#~ "          - --engine-jwt-enabled=true\n"
#~ "          - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex"

#, fuzzy
#~ msgid ""
#~ "Once this is done, your Ethereum node should be up and running, and it\n"
#~ "will start syncing with the Ethereum network."
#~ msgstr ""
#~ "å®Œæˆè¿™äº›æ“ä½œåï¼Œä½ çš„ä»¥å¤ªåŠèŠ‚ç‚¹å°±å¯ä»¥å¼€å§‹è¿è¡Œäº†ï¼Œå¹¶ä¸”\n"
#~ "å°†å¼€å§‹ä¸ä»¥å¤ªåŠç½‘ç»œåŒæ­¥ã€‚"

#, fuzzy
#~ msgid "## Layer 2: Execution Layer"
#~ msgstr "## ç¬¬ 2 å±‚ï¼šæ‰§è¡Œå±‚"

#, fuzzy
#~ msgid ""
#~ "The next layer in our Starknet stack is the Execution Layer. This layer\n"
#~ "is responsible for running the Cairo VM, which executes Starknet smart\n"
#~ "contracts. The Cairo VM is a deterministic virtual machine that allows\n"
#~ "developers to write complex smart contracts in the Cairo language.\n"
#~ "Starknet uses a similar [JSON-RPC\n"
#~ "spec](https://github.com/starkware-libs/starknet-specs) as\n"
#~ "[Ethereum](https://ethereum.org/en/developers/docs/apis/json-rpc) in\n"
#~ "order to interact with the execution layer."
#~ msgstr ""
#~ "Starknetå †æ ˆçš„ä¸‹ä¸€å±‚æ˜¯æ‰§è¡Œå±‚ã€‚è¿™ä¸€å±‚\n"
#~ "è´Ÿè´£è¿è¡ŒCairoè™šæ‹Ÿæœºï¼ŒCairoè™šæ‹Ÿæœºæ‰§è¡ŒStarknetæ™ºèƒ½\n"
#~ "åˆçº¦ã€‚Cairoè™šæ‹Ÿæœºæ˜¯ä¸€ä¸ªç¡®å®šæ€§è™šæ‹Ÿæœºï¼Œå…è®¸\n"
#~ "å¼€å‘äººå‘˜ä½¿ç”¨Cairoè¯­è¨€ç¼–å†™å¤æ‚çš„æ™ºèƒ½åˆçº¦ã€‚\n"
#~ "Starknet ä½¿ç”¨ç±»ä¼¼äº [JSON-RPC\n"
#~ "è§„èŒƒ](https://github.com/starkware-libs/starknet-specs)\n"
#~ "[ä»¥å¤ªåŠ](https://ethereum.org/en/developers/docs/apis/json-rpc)\n"
#~ "ä¸æ‰§è¡Œå±‚è¿›è¡Œäº¤äº’ã€‚"

#, fuzzy
#~ msgid ""
#~ "In order to stay current with the propagation of the Starknet blockchain\n"
#~ "we need a client similar to Besu that we are using for L1. The efforts\n"
#~ "to provide full nodes for the Starknet ecosystem are:\n"
#~ "[Pathfinder](https://github.com/eqlabs/pathfinder) (used here),\n"
#~ "[Papyrus](https://github.com/starkware-libs/papyrus), and\n"
#~ "[Juno](https://github.com/NethermindEth/juno). However, different\n"
#~ "implementations are still in development and not yet ready for\n"
#~ "production."
#~ msgstr ""
#~ "ä¸ºäº†ä¸StarknetåŒºå—é“¾çš„ä¼ æ’­ä¿æŒåŒæ­¥\n"
#~ "æˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»ä¼¼äºç”¨äº L1 çš„ Besu çš„å®¢æˆ·ç«¯ã€‚æˆ‘ä»¬\n"
#~ "ä¸º Starknet ç”Ÿæ€ç³»ç»Ÿæä¾›å®Œæ•´èŠ‚ç‚¹çš„æœ‰\n"
#~ "[Pathfinder](https://github.com/eqlabs/pathfinder) ï¼ˆæ­¤å¤„ä½¿ç”¨ï¼‰ã€\n"
#~ "[Papyrus](https://github.com/starkware-libs/papyrus) å’Œ\n"
#~ "[Juno](https://github.com/NethermindEth/juno)ã€‚ç„¶è€Œï¼Œä¸åŒçš„\n"
#~ "å®ç°ä»åœ¨å¼€å‘ä¸­ï¼Œå°šæœªå‡†å¤‡å¥½æŠ•å…¥ç”Ÿäº§ã€‚\n"
#~ "ç”Ÿäº§ã€‚"

#, fuzzy
#~ msgid "Check that your L1 has completed its sync:"
#~ msgstr "æ£€æŸ¥ L1 æ˜¯å¦å·²å®ŒæˆåŒæ­¥ï¼š"

#, fuzzy
#~ msgid ""
#~ "# check goerli etherscan to make sure you have the latest block https://goerli.etherscan.io\n"
#~ "\n"
#~ "    curl --location --request POST 'http://localhost:8545' \\\n"
#~ "    --header 'Content-Type: application/json' \\\n"
#~ "    --data-raw '{\n"
#~ "        \"jsonrpc\":\"2.0\",\n"
#~ "        \"method\":\"eth_blockNumber\",\n"
#~ "        \"params\":[],\n"
#~ "        \"id\":83\n"
#~ "    }'\n"
#~ "\n"
#~ "    # Convert the result, which is hex (remove 0x) to decimal. Example:\n"
#~ "    echo $(( 16#246918 ))"
#~ msgstr ""
#~ "# æ£€æŸ¥ goerli etherscanï¼Œç¡®ä¿æœ‰æœ€æ–°çš„å— https://goerli.etherscan.io\n"
#~ "\n"
#~ "    curl --location --request POST 'http://localhost:8545'\\\n"
#~ "    --header 'Content-Type: application/json' ï¼ˆå†…å®¹ç±»å‹ï¼šåº”ç”¨ç¨‹åº/json\n"
#~ "    --data-raw '{\n"
#~ "        \"jsonrpc\": \"2.0\"ã€\n"
#~ "        \"method\": \"eth_blockNumber\"ã€\n"
#~ "        \"params\":[]ã€\n"
#~ "        \"id\":83\n"
#~ "    }'\n"
#~ "\n"
#~ "    # å°†ç»“æœï¼ˆåå…­è¿›åˆ¶ï¼Œå»æ‰ 0xï¼‰è½¬æ¢ä¸ºåè¿›åˆ¶ã€‚ä¾‹å¦‚\n"
#~ "    echo $(( 16#246918 ))"

#, fuzzy
#~ msgid ""
#~ "Start your L2 Execution Client and note that we are syncing Starknetâ€™s\n"
#~ "state from our LOCAL ETH L1 NODE!"
#~ msgstr ""
#~ "å¯åŠ¨æ‚¨çš„ L2 æ‰§è¡Œå®¢æˆ·ç«¯ï¼Œæ³¨æ„æˆ‘ä»¬æ­£åœ¨ä»æœ¬åœ° ETH L1 èŠ‚ç‚¹åŒæ­¥ Starknet çš„çŠ¶æ€ã€‚\n"
#~ "çŠ¶æ€ï¼"

#, fuzzy
#~ msgid "PATHFINDER_ETHEREUM_API_URL=http://127.0.0.1:8545"
#~ msgstr "pathfinder_ethereum_api_url=http://127.0.0.1:8545"

#, fuzzy
#~ msgid ""
#~ "# from starknet-stack project root\n"
#~ "    docker-compose -f dc-l2.yaml up -d"
#~ msgstr ""
#~ "# ä» starknet-stack é¡¹ç›®æ ¹ç›®å½•\n"
#~ "    docker-compose -f dc-l2.yaml up -d"

#, fuzzy
#~ msgid "To follow the sync:"
#~ msgstr "è·ŸéšåŒæ­¥ï¼š"

#, fuzzy
#~ msgid "docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}')"
#~ msgstr "docker container logs -f $(docker ps | grep pathfinder | awk '{print $1}')"

#, fuzzy
#~ msgid ""
#~ "Starknet [Testnet_1](https://testnet.starkscan.co) currently comprises\n"
#~ "800,000+ blocks so this will take some time (days) to sync fully. To\n"
#~ "check L2 sync:"
#~ msgstr ""
#~ "Starknet [Testnet_1](https://testnet.starkscan.co)ç›®å‰åŒ…æ‹¬\n"
#~ "800,000 å¤šä¸ªåŒºå—ï¼Œå› æ­¤éœ€è¦ä¸€äº›æ—¶é—´ï¼ˆå‡ å¤©ï¼‰æ‰èƒ½å®Œå…¨åŒæ­¥ã€‚è¦\n"
#~ "æ£€æŸ¥ L2 åŒæ­¥ï¼š"

#, fuzzy
#~ msgid ""
#~ "# compare `current_block_num` with `highest_block_num`\n"
#~ "\n"
#~ "    curl --location --request POST 'http://localhost:9545' \\\n"
#~ "    --header 'Content-Type: application/json' \\\n"
#~ "    --data-raw '{\n"
#~ "     \"jsonrpc\":\"2.0\",\n"
#~ "     \"method\":\"starknet_syncing\",\n"
#~ "     \"params\":[],\n"
#~ "     \"id\":1\n"
#~ "    }'"
#~ msgstr ""
#~ "# å°† `current_block_num` ä¸ `highest_block_num` è¿›è¡Œæ¯”è¾ƒ\n"
#~ "\n"
#~ "    curl --location --request POST 'http://localhost:9545'\\\n"
#~ "    --header 'Content-Type: application/json' ï¼ˆå†…å®¹ç±»å‹ï¼šåº”ç”¨ç¨‹åº/json\n"
#~ "    --data-raw '{\n"
#~ "     \"jsonrpc\": \"2.0\"ã€\n"
#~ "     \"method\": \"starknet_syncing\"ã€\n"
#~ "     \"params\":[]ã€\n"
#~ "     \"id\":1\n"
#~ "    }'"

#, fuzzy
#~ msgid "To check data sizes:"
#~ msgstr "æ£€æŸ¥æ•°æ®å¤§å°ï¼š"

#, fuzzy
#~ msgid "sudo du -sh ./* | sort -rh"
#~ msgstr "sudo du -sh ./* | sort -rh"

#, fuzzy
#~ msgid "## Layer 3: Application Layer"
#~ msgstr "## ç¬¬ 3 å±‚ï¼šåº”ç”¨å±‚"

#, fuzzy
#~ msgid ""
#~ "We see the same need for data refinement as we did in the OSI model. On\n"
#~ "L1 packets come over the wire in a raw stream of bytes and are then\n"
#~ "processed and filtered by higher-level protocols. When designing a\n"
#~ "decentralized application Bob will need to be cognizant of interactions\n"
#~ "with his contract on chain, but doesnâ€™t need to be aware of all the\n"
#~ "information occurring on Starknet."
#~ msgstr ""
#~ "æˆ‘ä»¬è®¤ä¸ºï¼Œä¸ OSI æ¨¡å‹ä¸€æ ·ï¼Œä¹Ÿéœ€è¦å¯¹æ•°æ®è¿›è¡Œç»†åŒ–ã€‚åœ¨\n"
#~ "L1 æ•°æ®åŒ…æ˜¯ä»¥åŸå§‹å­—èŠ‚æµçš„å½¢å¼é€šè¿‡ç½‘ç»œä¼ è¾“çš„ï¼Œç„¶åç”±æ›´é«˜çº§åˆ«çš„åè®®è¿›è¡Œå¤„ç†å’Œè¿‡æ»¤ã€‚\n"
#~ "ç”±æ›´é«˜çº§åˆ«çš„åè®®è¿›è¡Œå¤„ç†å’Œè¿‡æ»¤ã€‚åœ¨è®¾è®¡åˆ†æ•£å¼åº”ç”¨æ—¶\n"
#~ "åœ¨è®¾è®¡å»ä¸­å¿ƒåŒ–åº”ç”¨æ—¶ï¼Œé²å‹ƒéœ€è¦è€ƒè™‘åˆ°ä¸ä»–åœ¨é“¾ä¸Šçš„åˆçº¦çš„äº¤äº’ã€‚\n"
#~ "ä¸é“¾ä¸Šåˆçº¦çš„äº¤äº’ï¼Œä½†ä¸éœ€è¦äº†è§£Starknetä¸Šå‘ç”Ÿçš„æ‰€æœ‰ä¿¡æ¯ã€‚\n"
#~ "ä¿¡æ¯ã€‚"

#, fuzzy
#~ msgid ""
#~ "This is the role of an indexer. To process and filter useful information\n"
#~ "for an application. Information that an application MUST be opinionated\n"
#~ "about and the underlying layer MUST NOT be opinionated about."
#~ msgstr ""
#~ "è¿™å°±æ˜¯ç´¢å¼•å™¨çš„ä½œç”¨ã€‚å¤„ç†å’Œè¿‡æ»¤æœ‰ç”¨ä¿¡æ¯\n"
#~ "ä¿¡æ¯ã€‚åº”ç”¨ç¨‹åºå¿…é¡»å¯¹ä¿¡æ¯æœ‰è‡ªå·±çš„çœ‹æ³•\n"
#~ "è€Œåº•å±‚ä¸å¾—æœ‰æ„è§çš„ä¿¡æ¯ã€‚"

#, fuzzy
#~ msgid ""
#~ "Indexers provide applications flexibility as they can be written in any\n"
#~ "programming language and have any data layout that suits the\n"
#~ "application."
#~ msgstr ""
#~ "ç´¢å¼•å™¨ä¸ºåº”ç”¨ç¨‹åºæä¾›äº†çµæ´»æ€§ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥ç”¨ä»»ä½•ç¼–ç¨‹è¯­è¨€ç¼–å†™ï¼Œä¹Ÿå¯ä»¥æœ‰ä»»ä½•é€‚åˆçš„æ•°æ®å¸ƒå±€ã€‚\n"
#~ "ç¼–ç¨‹è¯­è¨€ç¼–å†™ï¼Œå¹¶æ‹¥æœ‰é€‚åˆåº”ç”¨ç¨‹åºçš„ä»»ä½•æ•°æ®å¸ƒå±€ã€‚\n"
#~ "åº”ç”¨ã€‚"

#, fuzzy
#~ msgid ""
#~ "To start our toy\n"
#~ "[indexer](https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh)\n"
#~ "run:"
#~ msgstr ""
#~ "å¯åŠ¨æˆ‘ä»¬çš„ç©å…·\n"
#~ "[ç´¢å¼•å™¨](https://github.com/starknet-edu/starknet-stack/blob/main/indexer/indexer.sh)\n"
#~ "è¿è¡Œï¼š"

#, fuzzy
#~ msgid "./indexer/indexer.sh"
#~ msgstr "./indexer/indexer.sh"

#, fuzzy
#~ msgid ""
#~ "Again notice that we donâ€™t need to leave our local setup for these\n"
#~ "interactions (<http://localhost:9545>)."
#~ msgstr ""
#~ "è¯·å†æ¬¡æ³¨æ„ï¼Œæˆ‘ä»¬ä¸éœ€è¦ç¦»å¼€æœ¬åœ°è®¾ç½®æ¥è¿›è¡Œè¿™äº›\n"
#~ "äº¤äº’ (<http://localhost:9545>)ã€‚"

#, fuzzy
#~ msgid "## Layer 4: Transport Layer"
#~ msgstr "## ç¬¬ 4 å±‚ï¼šä¼ è¾“å±‚"

#, fuzzy
#~ msgid ""
#~ "The transport layer comes into play when the application has parsed and\n"
#~ "indexed critical information, often leading to some state change based\n"
#~ "on this information. This is where the application communicates the\n"
#~ "desired state change to the Layer 2 sequencer to get that change into a\n"
#~ "block. This is achieved using the same full-node/RPC spec\n"
#~ "implementation, in our case, Pathfinder."
#~ msgstr ""
#~ "å½“åº”ç”¨ç¨‹åºå¯¹å…³é”®ä¿¡æ¯è¿›è¡Œè§£æå’Œç´¢å¼•æ—¶ï¼Œä¼ è¾“å±‚å°±ä¼šå‘æŒ¥ä½œç”¨ã€‚\n"
#~ "ç´¢å¼•å…³é”®ä¿¡æ¯æ—¶ï¼Œä¼ è¾“å±‚å°±ä¼šå‘æŒ¥ä½œç”¨ã€‚\n"
#~ "çŠ¶æ€å˜åŒ–ã€‚è¿™æ—¶ï¼Œåº”ç”¨ç¨‹åºå°†\n"
#~ "å°†æ‰€éœ€çš„çŠ¶æ€å˜åŒ–ä¼ é€’ç»™ç¬¬ 2 å±‚å®šåºå™¨ï¼Œä»¥ä¾¿å°†è¯¥å˜åŒ–è½¬åŒ–ä¸ºæ•°æ®å—ã€‚\n"
#~ "å—ã€‚è¿™æ˜¯ä½¿ç”¨ç›¸åŒçš„å…¨èŠ‚ç‚¹/RPC è§„èŒƒå®ç°çš„ã€‚\n"
#~ "å®ç°çš„ï¼Œåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œä½¿ç”¨çš„æ˜¯ Pathfinderã€‚"

#, fuzzy
#~ msgid ""
#~ "When working with our local Starknet stack, invoking a transaction\n"
#~ "locally might look like this:"
#~ msgstr ""
#~ "ä½¿ç”¨æœ¬åœ° Starknet å †æ ˆæ—¶ï¼Œåœ¨æœ¬åœ°è°ƒç”¨äº‹åŠ¡\n"
#~ "æ—¶ï¼Œæœ¬åœ°è°ƒç”¨çš„äº‹åŠ¡å¯èƒ½æ˜¯è¿™æ ·çš„"

#, fuzzy
#~ msgid ""
#~ "curl --location --request POST 'http://localhost:9545' \\\n"
#~ "    --header 'Content-Type: application/json' \\\n"
#~ "    --data-raw '{\n"
#~ "        \"jsonrpc\": \"2.0\",\n"
#~ "        \"method\": \"starknet_addInvokeTransaction\",\n"
#~ "        \"params\": {\n"
#~ "            \"invoke_transaction\": {\n"
#~ "                \"type\": \"INVOKE\",\n"
#~ "                \"max_fee\": \"0x4f388496839\",\n"
#~ "                \"version\": \"0x0\",\n"
#~ "                \"signature\": [\n"
#~ "                    \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
#~ "                    \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
#~ "                ],\n"
#~ "                \"contract_address\": \"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
#~ "                \"calldata\": [\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
#~ "                    \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
#~ "                    \"0x0\",\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x2b\",\n"
#~ "                    \"0x0\"\n"
#~ "                ],\n"
#~ "                \"entry_point_selector\": \"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
#~ "            }\n"
#~ "        },\n"
#~ "        \"id\": 0\n"
#~ "    }'"
#~ msgstr ""
#~ "curl --location --request POST 'http://localhost:9545'\\\n"
#~ "    --header 'Content-Type: application/json' ï¼ˆå†…å®¹ç±»å‹ï¼šåº”ç”¨ç¨‹åº/json\n"
#~ "    --data-raw '{\n"
#~ "        \"jsonrpc\"ï¼š\"2.0\",\n"
#~ "        \"method\"ï¼š\"starknet_addInvokeTransaction\"ã€\n"
#~ "        å‚æ•°{\n"
#~ "            \"invoke_transaction\"ï¼š{\n"
#~ "                \"ç±»å‹\"ï¼š\"INVOKE\"ã€\n"
#~ "                \"max_fee\"ï¼š\"0x4f388496839\"ã€\n"
#~ "                \"ç‰ˆæœ¬\"ï¼š\"0x0\",\n"
#~ "                \"ç­¾å\"ï¼š[\n"
#~ "                    \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
#~ "                    \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
#~ "                ],\n"
#~ "                \"åˆçº¦åœ°å€\"ï¼š\"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
#~ "                \"calldata\"ï¼š[\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
#~ "                    \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
#~ "                    \"0x0\",\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x1\",\n"
#~ "                    \"0x2b\"ã€\"0x0\n"
#~ "                    \"0x0\"\n"
#~ "                ],\n"
#~ "                \"entry_point_selector\"ï¼ˆè¾“å…¥ç‚¹é€‰æ‹©å™¨ï¼‰ï¼š\"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
#~ "            }\n"
#~ "        },\n"
#~ "        \"id\"ï¼š0\n"
#~ "    }'"

#, fuzzy
#~ msgid ""
#~ "However, this process involves setting up a local wallet and signing the\n"
#~ "transaction. For simplicity, we will use a browser wallet and StarkScan."
#~ msgstr ""
#~ "ä¸è¿‡ï¼Œè¿™ä¸ªè¿‡ç¨‹æ¶‰åŠåˆ°å»ºç«‹æœ¬åœ°é’±åŒ…å’Œç­¾ç½²\n"
#~ "äº¤æ˜“ã€‚ä¸ºç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æµè§ˆå™¨é’±åŒ…å’Œ StarkScanã€‚"

#~ msgid "Steps:"
#~ msgstr "æ­¥éª¤:"

#, fuzzy
#~ msgid ""
#~ "1.  Navigate to the contract on StarkScan and connect to your wallet.\n"
#~ "\n"
#~ "2.  Enter a new value and write the transaction:"
#~ msgstr ""
#~ "1.  å¯¼èˆªåˆ° StarkScan ä¸Šçš„åˆçº¦å¹¶è¿æ¥åˆ°æ‚¨çš„é’±åŒ…ã€‚\n"
#~ "\n"
#~ "2.  è¾“å…¥æ–°å€¼å¹¶å†™å…¥äº¤æ˜“ï¼š"

#~ msgid "<img alt=\"Starkscan block explorer\" src=\"img/ch03-starkscan-block-explorer.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Starkscan block explorer\" src=\"img/ch03-starkscan-block-explorer.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Starkscan block explorer</span>"
#~ msgstr "<span class=\"caption\">Starkscan block explorer</span>"

#, fuzzy
#~ msgid ""
#~ "Once the transaction is accepted on the Layer 2 execution layer, the\n"
#~ "event data should come through our application layer indexer."
#~ msgstr ""
#~ "ä¸€æ—¦äº‹åŠ¡åœ¨ç¬¬ 2 å±‚æ‰§è¡Œå±‚è¢«æ¥å—ï¼Œäº‹ä»¶æ•°æ®å°±ä¼šé€šè¿‡æˆ‘ä»¬çš„åº”ç”¨å±‚ç´¢å¼•å™¨ä¼ è¾“ã€‚\n"
#~ "äº‹ä»¶æ•°æ®åº”é€šè¿‡æˆ‘ä»¬çš„åº”ç”¨å±‚ç´¢å¼•å™¨ä¼ è¾“ã€‚"

#, fuzzy
#~ msgid "Example Indexer Output:"
#~ msgstr "ç´¢å¼•å™¨è¾“å‡ºç¤ºä¾‹ï¼š"

#, fuzzy
#~ msgid ""
#~ "Pulled Block #: 638703\n"
#~ "    Found transaction: 0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
#~ "    Events to Index:\n"
#~ "    [\n"
#~ "      {\n"
#~ "        \"from_address\": \"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
#~ "        \"keys\": [\n"
#~ "          \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
#~ "        ],\n"
#~ "        \"data\": [\n"
#~ "          \"0xa\"\n"
#~ "        ]\n"
#~ "      },\n"
#~ "      {\n"
#~ "        \"from_address\": \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
#~ "        \"keys\": [\n"
#~ "          \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
#~ "        ],\n"
#~ "        \"data\": [\n"
#~ "          \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
#~ "          \"0x0\"\n"
#~ "        ]\n"
#~ "      },\n"
#~ "      {\n"
#~ "        \"from_address\": \"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
#~ "        \"keys\": [\n"
#~ "          \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
#~ "        ],\n"
#~ "        \"data\": [\n"
#~ "          \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
#~ "          \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
#~ "          \"0x17c1e31c270\",\n"
#~ "          \"0x0\"\n"
#~ "        ]\n"
#~ "      }\n"
#~ "    ]"
#~ msgstr ""
#~ "æå–çš„åŒºå—ç¼–å·ï¼š 638703\n"
#~ "    æ‰¾åˆ°äº¤æ˜“0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
#~ "    äº‹ä»¶ç´¢å¼•ï¼š\n"
#~ "    [\n"
#~ "      {\n"
#~ "        \"from_address\"ï¼š\"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
#~ "        \"é”®\"ï¼š[\n"
#~ "          \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
#~ "        ],\n"
#~ "        \"æ•°æ®\"ï¼š[\n"
#~ "          \"0xa\n"
#~ "        ]\n"
#~ "      },\n"
#~ "      {\n"
#~ "        \"æ¥è‡ªåœ°å€\"ï¼š\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
#~ "        \"é”®\"ï¼š[\n"
#~ "          \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
#~ "        ],\n"
#~ "        \"æ•°æ®\"ï¼š[\n"
#~ "          \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
#~ "          \"0x0\"\n"
#~ "        ]\n"
#~ "      },\n"
#~ "      {\n"
#~ "        \"from_address\"ï¼š\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
#~ "        \"é”®\"ï¼š[\n"
#~ "          \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
#~ "        ],\n"
#~ "        \"æ•°æ®\"ï¼š[\n"
#~ "          \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
#~ "          \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
#~ "          \"0x17c1e31c270\"ã€\n"
#~ "          \"0x0\"\n"
#~ "        ]\n"
#~ "      }\n"
#~ "    ]"

#, fuzzy
#~ msgid ""
#~ "Once the transaction is accepted on Layer 1, we can query the Starknet\n"
#~ "Core Contracts from our Layer 1 node to see the storage keys that have\n"
#~ "been updated on our data layer!"
#~ msgstr ""
#~ "ä¸€æ—¦ç¬¬ä¸€å±‚æ¥å—äº†äº¤æ˜“ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä»ç¬¬ä¸€å±‚èŠ‚ç‚¹æŸ¥è¯¢ Starknet\n"
#~ "æ ¸å¿ƒåˆçº¦ï¼Œä»¥æŸ¥çœ‹æ•°æ®å±‚ä¸Šå·²æ›´æ–°çš„å­˜å‚¨å¯†é’¥\n"
#~ "æ•°æ®å±‚ä¸Šå·²æ›´æ–°çš„å­˜å‚¨å¯†é’¥ï¼"

#, fuzzy
#~ msgid ""
#~ "You have successfully navigated through the entire Starknet stack, from\n"
#~ "setting up your node, through executing and monitoring a transaction, to\n"
#~ "inspecting its effects on the data layer. This journey has equipped you\n"
#~ "with the understanding and the skills to interact with Starknet on a\n"
#~ "deeper level."
#~ msgstr ""
#~ "æ‚¨å·²æˆåŠŸæµè§ˆäº†æ•´ä¸ª Starknet å †æ ˆï¼Œä»\n"
#~ "è®¾ç½®èŠ‚ç‚¹ã€æ‰§è¡Œå’Œç›‘æ§äº‹åŠ¡ï¼Œåˆ°\n"
#~ "æ£€æŸ¥å…¶å¯¹æ•°æ®å±‚çš„å½±å“ã€‚è¿™æ®µæ—…ç¨‹ä½¿æ‚¨\n"
#~ "ä¸ Starknet è¿›è¡Œæ›´æ·±å±‚æ¬¡äº¤äº’çš„ç†è§£å’ŒæŠ€èƒ½ã€‚\n"
#~ "æ›´æ·±å±‚æ¬¡çš„äº¤äº’ã€‚"

#, fuzzy
#~ msgid "## Conclusion: Understanding the Modular Nature of Starknet"
#~ msgstr "## ç»“è®ºï¼šäº†è§£Starknetçš„æ¨¡å—æ€§è´¨"

#, fuzzy
#~ msgid ""
#~ "Conceptual models, such as the ones used in this guide, are incredibly\n"
#~ "useful in helping us understand complex systems. They can be refactored,\n"
#~ "reformed, and nested to provide a clear and comprehensive view of how a\n"
#~ "platform like Starknet operates. For instance, the OSI Model, a\n"
#~ "foundational model for understanding network interactions, underpins our\n"
#~ "modular stack."
#~ msgstr ""
#~ "æ¦‚å¿µæ¨¡å‹ï¼Œå¦‚æœ¬æŒ‡å—ä¸­ä½¿ç”¨çš„æ¦‚å¿µæ¨¡å‹ï¼Œåœ¨å¸®åŠ©æˆ‘ä»¬ç†è§£å¤æ‚ç³»ç»Ÿæ–¹é¢éå¸¸æœ‰ç”¨ã€‚\n"
#~ "åœ¨å¸®åŠ©æˆ‘ä»¬ç†è§£å¤æ‚ç³»ç»Ÿæ–¹é¢éå¸¸æœ‰ç”¨ã€‚å®ƒä»¬å¯ä»¥è¢«é‡æ„\n"
#~ "é‡æ„å’ŒåµŒå¥—ï¼Œä»¥æä¾›ä¸€ä¸ªæ¸…æ™°è€Œå…¨é¢çš„è§†å›¾ï¼Œè®©æˆ‘ä»¬äº†è§£åƒ Starknet è¿™æ ·çš„å¹³å°æ˜¯å¦‚ä½•è¿è¡Œçš„ã€‚\n"
#~ "åƒStarknetè¿™æ ·çš„å¹³å°æ˜¯å¦‚ä½•è¿è¡Œçš„ã€‚ä¾‹å¦‚ï¼ŒOSI æ¨¡å‹æ˜¯\n"
#~ "ä¾‹å¦‚ï¼ŒOSI æ¨¡å‹æ˜¯ç†è§£ç½‘ç»œäº¤äº’çš„åŸºç¡€æ¨¡å‹ï¼Œå®ƒæ˜¯æˆ‘ä»¬æ¨¡å—åŒ–å †æ ˆçš„åŸºç¡€ã€‚\n"
#~ "æ¨¡å—åŒ–å †æ ˆçš„åŸºç¡€ã€‚"

#, fuzzy
#~ msgid ""
#~ "A key concept to grasp is _Fractal Scaling._ This concept allows us to\n"
#~ "extend our model to include additional layers beyond Layer 2, such as\n"
#~ "Layer 3. In this extended model, the entire stack recurs above our\n"
#~ "existing stack, as shown in the following diagram:"
#~ msgstr ""
#~ "è¦æŒæ¡çš„ä¸€ä¸ªå…³é”®æ¦‚å¿µæ˜¯_åˆ†å½¢ç¼©æ”¾ã€‚\n"
#~ "è¿™ä¸€æ¦‚å¿µä½¿æˆ‘ä»¬èƒ½å¤Ÿæ‰©å±•æˆ‘ä»¬çš„æ¨¡å‹ï¼Œä½¿å…¶åŒ…æ‹¬ç¬¬ 2 å±‚ä»¥å¤–çš„å…¶ä»–å±‚ï¼Œä¾‹å¦‚ç¬¬\n"
#~ "ç¬¬ 3 å±‚ã€‚åœ¨è¿™ä¸ªæ‰©å±•æ¨¡å‹ä¸­ï¼Œæ•´ä¸ªå †æ ˆåœ¨æˆ‘ä»¬ç°æœ‰çš„å †æ ˆä¹‹ä¸Šé‡å¤å‡ºç°ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤º\n"
#~ "å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š"

#~ msgid "<img alt=\"Fractal scaling in a modular blockchain environment\" src=\"img/ch03-fractal-scaling.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Fractal scaling in a modular blockchain environment\" src=\"img/ch03-fractal-scaling.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Fractal scaling in a modular blockchain environment</span>"
#~ msgstr "<span class=\"caption\">Fractal scaling in a modular blockchain environment</span>"

#, fuzzy
#~ msgid ""
#~ "This concludes our journey into running a Starknet node and traversing\n"
#~ "its layered architecture. We hope that you now feel equipped to explore,\n"
#~ "experiment with, and innovate within the Starknet ecosystem."
#~ msgstr ""
#~ "è‡³æ­¤ï¼Œæˆ‘ä»¬ç»“æŸäº†è¿è¡ŒStarknetèŠ‚ç‚¹å’Œç©¿è¶Šå…¶åˆ†å±‚æ¶æ„çš„æ—…ç¨‹ã€‚\n"
#~ "åˆ†å±‚æ¶æ„çš„æ—…ç¨‹ã€‚æˆ‘ä»¬å¸Œæœ›æ‚¨ç°åœ¨å·²ç»å…·å¤‡äº†åœ¨ Starknet ç”Ÿæ€ç³»ç»Ÿä¸­æ¢ç´¢ã€å®éªŒå’Œåˆ›æ–°çš„èƒ½åŠ›ã€\n"
#~ "å®éªŒå’Œåˆ›æ–°ã€‚"

#~ msgid "<img alt=\"Example of an environment with a Layers 3 and 4\" src=\"img/ch03-layer-3-ecosystem.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Example of an environment with a Layers 3 and 4\" src=\"img/ch03-layer-3-ecosystem.png\" class=\"center\" style=\"width: 50%;\" />"

#, fuzzy
#~ msgid "# Solidity Verifier"
#~ msgstr "Solidity éªŒè¯å™¨ ğŸš§"

#~ msgid "<img alt=\"Sharp workflow\" src=\"img/ch03-06-shared-prover.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Sharp workflow\" src=\"img/ch03-06-shared-prover.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Sharp Workflow</span>"
#~ msgstr "<span class=\"caption\">Sharp Workflow</span>"

#, fuzzy
#~ msgid "## Solidity Verifiers"
#~ msgstr "Solidity éªŒè¯å™¨ ğŸš§"

#~ msgid "<img alt=\"Previous Architecture\" src=\"img/ch03-06-prehistoric-architecture.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Previous Architecture\" src=\"img/ch03-06-prehistoric-architecture.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<span class=\"caption\">Previous Architecture</span>"
#~ msgstr "<span class=\"caption\">Previous Architecture</span>"

#~ msgid "<img alt=\"Verifier Layouts\" src=\"img/ch03-06-verifier-layouts.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Verifier Layouts\" src=\"img/ch03-06-verifier-layouts.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-1.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-1.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-2.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Sharp Verifier Contract Map\" src=\"img/ch03-06-sharp-contrat-map-2.png\" class=\"center\" style=\"width: 50%;\" />"

#~ msgid ""
#~ "<img alt=\"Constructor Parameters\" src=\"img/ch03-06-constructor-params.png\" class=\"center\" style=\"width: 50%;\" />\n"
#~ "<span class=\"caption\">Constructor Parameters</span>"
#~ msgstr ""
#~ "<img alt=\"Constructor Parameters\" src=\"img/ch03-06-constructor-params.png\" class=\"center\" style=\"width: 50%;\" />\n"
#~ "<span class=\"caption\">Constructor Parameters</span>"

#~ msgid "<img alt=\"Sharp Verification Flow\" src=\"img/ch03-06-new-sharp-flow.png\" class=\"center\" style=\"width: 50%;\" />"
#~ msgstr "<img alt=\"Sharp Verification Flow\" src=\"img/ch03-06-new-sharp-flow.png\" class=\"center\" style=\"width: 50%;\" />"

#, fuzzy
#~ msgid "# Decentralization ğŸš§"
#~ msgstr "å»ä¸­å¿ƒåŒ– ğŸš§"

#, fuzzy
#~ msgid "### UserOperation Component"
#~ msgstr "### è½¬è´¦ç»„ä»¶"

#~ msgid "`UserOperation` is a structured definition that encapsulates user transaction details. Unlike a conventional transaction, it encompasses several fields:"
#~ msgstr "`UserOperation` is a structured definition that encapsulates user transaction details. Unlike a conventional transaction, it encompasses several fields:"

#~ msgid ""
#~ "`UserOperation` objects are submitted by users, encapsulating their intended actions, signatures, and required validation data. Bundlers collect these objects into bundles, which are then "
#~ "incorporated into Ethereum blocks as singular transactions."
#~ msgstr ""
#~ "`UserOperation` objects are submitted by users, encapsulating their intended actions, signatures, and required validation data. Bundlers collect these objects into bundles, which are then "
#~ "incorporated into Ethereum blocks as singular transactions."

#~ msgid "<img width=\"837\" alt=\"image\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/037cdd3a-ec80-41a1-84d4-f71bce5bda0e\">"
#~ msgstr "<img width=\"837\" alt=\"image\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/037cdd3a-ec80-41a1-84d4-f71bce5bda0e\">"

#, fuzzy
#~ msgid "### Bundler Component"
#~ msgstr "### ä½™é¢ç»„ä»¶"

#~ msgid "`UserOperation` objects are ABI-encoded structures containing:"
#~ msgstr "`UserOperation` objects are ABI-encoded structures containing:"

#, fuzzy
#~ msgid "## Wallet Component"
#~ msgstr "### ä½™é¢ç»„ä»¶"

#~ msgid "<img width=\"647\" alt=\"image2\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/02fb5b75-2169-4bc2-bf96-47ae8be9d190\">"
#~ msgstr "<img width=\"647\" alt=\"image2\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/02fb5b75-2169-4bc2-bf96-47ae8be9d190\">"

#, fuzzy
#~ msgid "### Paymaster Component"
#~ msgstr "### è½¬è´¦ç»„ä»¶"

#~ msgid "<img width=\"676\" alt=\"Paymaster Flow\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/b7deae91-56a8-4361-9697-ca4793546b1e\">"
#~ msgstr "<img width=\"676\" alt=\"Paymaster Flow\" src=\"https://github.com/starknet-edu/starknetbook/assets/125284347/b7deae91-56a8-4361-9697-ca4793546b1e\">"

#~ msgid ""
#~ "```rust\n"
#~ "    trait ISRC5 {\n"
#~ "        fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    trait ISRC5 {\n"
#~ "        fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "\n"
#~ "    ....\n"
#~ "\n"
#~ "    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "\n"
#~ "    ....\n"
#~ "\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "\n"
#~ "    ....\n"
#~ "\n"
#~ "    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "\n"
#~ "    ....\n"
#~ "\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "    // Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC5 {\n"
#~ "    fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "    // Implementations for __execute__, __validate__, and is_valid_signature go here.\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC5 {\n"
#~ "    fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "    fn __validate__(calls: Array<Call>) -> felt252;\n"
#~ "    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC5 {\n"
#~ "    fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "struct Call {\n"
#~ "    to: ContractAddress,\n"
#~ "    selector: felt252,\n"
#~ "    calldata: Array<felt252>\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC6 {\n"
#~ "    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "    fn __validate__(calls: Array<Call>) -> felt252;\n"
#~ "    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "trait ISRC5 {\n"
#~ "    fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "scarb new aa\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "scarb new aa\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "$ tree .\n"
#~ ".\n"
#~ "â””â”€â”€ aa\n"
#~ "    â”œâ”€â”€ Scarb.toml\n"
#~ "    â””â”€â”€ src\n"
#~ "        â””â”€â”€ lib.cairo\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "$ tree .\n"
#~ ".\n"
#~ "â””â”€â”€ aa\n"
#~ "    â”œâ”€â”€ Scarb.toml\n"
#~ "    â””â”€â”€ src\n"
#~ "        â””â”€â”€ lib.cairo\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        public_key: felt252\n"
#~ "    }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "\n"
#~ "    #[storage]\n"
#~ "    struct Storage {\n"
#~ "        public_key: felt252\n"
#~ "    }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[storage]\n"
#~ "struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[storage]\n"
#~ "struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "trait ISRC6 {\n"
#~ "  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "  fn __validate__(calls: Array<Call>) -> felt252;\n"
#~ "  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "trait ISRC6 {\n"
#~ "  fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;\n"
#~ "  fn __validate__(calls: Array<Call>) -> felt252;\n"
#~ "  fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use starknet::account::Call;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use super::Call;\n"
#~ "\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl for super::IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
#~ "  }\n"
#~ "\n"
#~ "  // These functions are protocol-specific and not intended for direct external use.\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl for ProtocolTrait {\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use starknet::account::Call;\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use super::Call;\n"
#~ "\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl for super::IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 { ... }\n"
#~ "  }\n"
#~ "\n"
#~ "  // These functions are protocol-specific and not intended for direct external use.\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl for ProtocolTrait {\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> { ... }\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 { ... }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use starknet::get_caller_address;\n"
#~ "  use zeroable::Zeroable;\n"
#~ "\n"
#~ "  // Enforces Starknet protocol-only access to specific functions\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Executes protocol-specific operations\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Verifies protocol-level caller\n"
#~ "      // ... (implementation details)\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates protocol-specific operations\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol(); // Verifies protocol-level caller\n"
#~ "      // ... (implementation details)\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Defines a private function to check for protocol-level access\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      // ... (access validation logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use starknet::get_caller_address;\n"
#~ "  use zeroable::Zeroable;\n"
#~ "\n"
#~ "  // Enforces Starknet protocol-only access to specific functions\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Executes protocol-specific operations\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Verifies protocol-level caller\n"
#~ "      // ... (implementation details)\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates protocol-specific operations\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol(); // Verifies protocol-level caller\n"
#~ "      // ... (implementation details)\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Defines a private function to check for protocol-level access\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      // ... (access validation logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use starknet::get_caller_address;\n"
#~ "  use zeroable::Zeroable;\n"
#~ "\n"
#~ "  // Implements function access control for Starknet protocol\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function is a protocol-exclusive operation\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Validates the caller as the Starknet protocol\n"
#~ "      // ... (execution logic)\n"
#~ "    }\n"
#~ "\n"
#~ "    // The __validate__ function ensures the integrity of protocol-level calls\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol(); // Ensures the caller is the Starknet protocol\n"
#~ "      // ... (validation logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // A private function, only_protocol, to enforce protocol-level access\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // only_protocol checks the caller's address against the zero address\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      // If the caller is not the zero address, access is denied\n"
#~ "      // This guarantees that only the Starknet protocol can call the function\n"
#~ "      // ... (access control logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use starknet::get_caller_address;\n"
#~ "  use zeroable::Zeroable;\n"
#~ "\n"
#~ "  // Implements function access control for Starknet protocol\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function is a protocol-exclusive operation\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Validates the caller as the Starknet protocol\n"
#~ "      // ... (execution logic)\n"
#~ "    }\n"
#~ "\n"
#~ "    // The __validate__ function ensures the integrity of protocol-level calls\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol(); // Ensures the caller is the Starknet protocol\n"
#~ "      // ... (validation logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // A private function, only_protocol, to enforce protocol-level access\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // only_protocol checks the caller's address against the zero address\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      // If the caller is not the zero address, access is denied\n"
#~ "      // This guarantees that only the Starknet protocol can call the function\n"
#~ "      // ... (access control logic)\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Persistent storage for account-related data\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252  // Stores the public key for signature validation\n"
#~ "  }\n"
#~ "\n"
#~ "  // Sets the public key during contract deployment\n"
#~ "  #[constructor]\n"
#~ "  fn constructor(ref self: ContractState, public_key: felt252) {\n"
#~ "    self.public_key.write(public_key);  // Records the signer's public key\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Persistent storage for account-related data\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252  // Stores the public key for signature validation\n"
#~ "  }\n"
#~ "\n"
#~ "  // Sets the public key during contract deployment\n"
#~ "  #[constructor]\n"
#~ "  fn constructor(ref self: ContractState, public_key: felt252) {\n"
#~ "    self.public_key.write(public_key);  // Records the signer's public key\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import relevant cryptographic and data handling modules\n"
#~ "  use array::ArrayTrait;\n"
#~ "  use ecdsa::check_ecdsa_signature;\n"
#~ "  use array::SpanTrait;  // Facilitates the use of the span() method\n"
#~ "\n"
#~ "  // External function to validate the transaction signature\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
#~ "      // Converts the signature array into a span for processing\n"
#~ "      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
#~ "      if is_valid { 'VALID' } else { 0 }  // Returns 'VALID' or '0' based on signature validity\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private function to check the signature validity and return a Boolean\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Validates the signature using a span of elements\n"
#~ "    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
#~ "      // Checks if the signature has the correct length\n"
#~ "      let is_valid_length = signature.len() == 2_u32;\n"
#~ "\n"
#~ "      // If the signature length is incorrect, returns false\n"
#~ "      if !is_valid_length {\n"
#~ "        return false;\n"
#~ "      }\n"
#~ "\n"
#~ "      // Verifies the signature using the stored public key\n"
#~ "      check_ecdsa_signature(\n"
#~ "        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
#~ "      )\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import relevant cryptographic and data handling modules\n"
#~ "  use array::ArrayTrait;\n"
#~ "  use ecdsa::check_ecdsa_signature;\n"
#~ "  use array::SpanTrait;  // Facilitates the use of the span() method\n"
#~ "\n"
#~ "  // External function to validate the transaction signature\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
#~ "      // Converts the signature array into a span for processing\n"
#~ "      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
#~ "      if is_valid { 'VALID' } else { 0 }  // Returns 'VALID' or '0' based on signature validity\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private function to check the signature validity and return a Boolean\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Validates the signature using a span of elements\n"
#~ "    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
#~ "      // Checks if the signature has the correct length\n"
#~ "      let is_valid_length = signature.len() == 2_u32;\n"
#~ "\n"
#~ "      // If the signature length is incorrect, returns false\n"
#~ "      if !is_valid_length {\n"
#~ "        return false;\n"
#~ "      }\n"
#~ "\n"
#~ "      // Verifies the signature using the stored public key\n"
#~ "      check_ecdsa_signature(\n"
#~ "        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
#~ "      )\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import modules for transaction information retrieval\n"
#~ "  use box::BoxTrait;\n"
#~ "  use starknet::get_tx_info;\n"
#~ "\n"
#~ "  // Protocol implementation for transaction validation\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Validates the signature of a transaction\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures protocol-only access\n"
#~ "\n"
#~ "      // Retrieves transaction information and unpacks it\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      // Validates the signature and asserts its correctness\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');  // Stops execution if the signature is invalid\n"
#~ "      'VALID'  // Indicates a valid signature\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import modules for transaction information retrieval\n"
#~ "  use box::BoxTrait;\n"
#~ "  use starknet::get_tx_info;\n"
#~ "\n"
#~ "  // Protocol implementation for transaction validation\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Validates the signature of a transaction\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures protocol-only access\n"
#~ "\n"
#~ "      // Retrieves transaction information and unpacks it\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      // Validates the signature and asserts its correctness\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');  // Stops execution if the signature is invalid\n"
#~ "      'VALID'  // Indicates a valid signature\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Protocol implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "\n"
#~ "    // Validates general contract function calls\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      self.validate_transaction()  // Centralized validation logic\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates the 'declare' function signature\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      self.validate_transaction()  // Reuses the validation logic\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates counterfactual contract deployment\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      // Even though public_key is provided, it uses the one stored from the constructor\n"
#~ "      self.validate_transaction()  // Applies the same validation logic\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private trait implementation that contains shared validation logic\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Abstracted core logic for validating transactions\n"
#~ "    fn validate_transaction(self: @ContractState) -> felt252 {\n"
#~ "      let tx_info = get_tx_info().unbox();  // Extracts transaction information\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      // Validates the transaction signature using an internal boolean function\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');  // Ensures signature correctness\n"
#~ "      'VALID'  // Returns 'VALID' if the signature checks out\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Protocol implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "\n"
#~ "    // Validates general contract function calls\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      self.validate_transaction()  // Centralized validation logic\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates the 'declare' function signature\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      self.validate_transaction()  // Reuses the validation logic\n"
#~ "    }\n"
#~ "\n"
#~ "    // Validates counterfactual contract deployment\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();  // Ensures only the Starknet protocol can call\n"
#~ "      // Even though public_key is provided, it uses the one stored from the constructor\n"
#~ "      self.validate_transaction()  // Applies the same validation logic\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private trait implementation that contains shared validation logic\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Abstracted core logic for validating transactions\n"
#~ "    fn validate_transaction(self: @ContractState) -> felt252 {\n"
#~ "      let tx_info = get_tx_info().unbox();  // Extracts transaction information\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      // Validates the transaction signature using an internal boolean function\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');  // Ensures signature correctness\n"
#~ "      'VALID'  // Returns 'VALID' if the signature checks out\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "````rust\n"
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Protocol implementation to handle execution of calls\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function processes an array of calls\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Ensures Starknet protocol level access\n"
#~ "      self.execute_multiple_calls(calls) // Invokes batch processing of calls\n"
#~ "    }\n"
#~ "    // ... Additional implementation details\n"
#~ "  }\n"
#~ "}\n"
#~ "````"
#~ msgstr ""
#~ "````rust\n"
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Protocol implementation to handle execution of calls\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function processes an array of calls\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Ensures Starknet protocol level access\n"
#~ "      self.execute_multiple_calls(calls) // Invokes batch processing of calls\n"
#~ "    }\n"
#~ "    // ... Additional implementation details\n"
#~ "  }\n"
#~ "}\n"
#~ "````"

#~ msgid ""
#~ "```rust\n"
#~ "// Data structure encapsulating a contract call\n"
#~ "#[derive(Drop, Serde)]\n"
#~ "struct Call {\n"
#~ "  to: ContractAddress,       // The target contract address\n"
#~ "  selector: felt252,         // The function selector\n"
#~ "  calldata: Array<felt252>   // The parameters for the function call\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// Data structure encapsulating a contract call\n"
#~ "#[derive(Drop, Serde)]\n"
#~ "struct Call {\n"
#~ "  to: ContractAddress,       // The target contract address\n"
#~ "  selector: felt252,         // The function selector\n"
#~ "  calldata: Array<felt252>   // The parameters for the function call\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import syscall for contract function invocation\n"
#~ "  use starknet::call_contract_syscall;\n"
#~ "\n"
#~ "  // Private trait implementation for individual call execution\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Executes a single call to another contract\n"
#~ "    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
#~ "      let Call{to, selector, calldata} = call; // Destructures the Call struct\n"
#~ "      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall() // Performs the contract call\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Import syscall for contract function invocation\n"
#~ "  use starknet::call_contract_syscall;\n"
#~ "\n"
#~ "  // Private trait implementation for individual call execution\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Executes a single call to another contract\n"
#~ "    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
#~ "      let Call{to, selector, calldata} = call; // Destructures the Call struct\n"
#~ "      call_contract_syscall(to, selector, calldata.span()).unwrap_syscall() // Performs the contract call\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Private trait implementation for batch call execution\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Handles an array of calls and accumulates the results\n"
#~ "    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      let mut res = ArrayTrait::new(); // Initializes the result array\n"
#~ "      loop {\n"
#~ "        match calls.pop_front() {\n"
#~ "          Option::Some(call) => {\n"
#~ "            let response = self.execute_single_call(call); // Executes each call individually\n"
#~ "            res.append(response); // Appends the result of the call to the result array\n"
#~ "          },\n"
#~ "          Option::None(_) => {\n"
#~ "            break (); // Exits the loop when no more calls are left\n"
#~ "          },\n"
#~ "        };\n"
#~ "      };\n"
#~ "      res // Returns the array of results\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Private trait implementation for batch call execution\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Handles an array of calls and accumulates the results\n"
#~ "    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      let mut res = ArrayTrait::new(); // Initializes the result array\n"
#~ "      loop {\n"
#~ "        match calls.pop_front() {\n"
#~ "          Option::Some(call) => {\n"
#~ "            let response = self.execute_single_call(call); // Executes each call individually\n"
#~ "            res.append(response); // Appends the result of the call to the result array\n"
#~ "          },\n"
#~ "          Option::None(_) => {\n"
#~ "            break (); // Exits the loop when no more calls are left\n"
#~ "          },\n"
#~ "        };\n"
#~ "      };\n"
#~ "      res // Returns the array of results\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional implementation details\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // External function definition within the protocol implementation\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function takes an array of Call structures and processes them\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Verifies that the function caller is the Starknet protocol\n"
#~ "      self.execute_multiple_calls(calls) // Delegates to a function for processing multiple calls\n"
#~ "    }\n"
#~ "    // ... Additional implementation details may follow\n"
#~ "  }\n"
#~ "  // ... Further module code may be present\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // External function definition within the protocol implementation\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // The __execute__ function takes an array of Call structures and processes them\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Verifies that the function caller is the Starknet protocol\n"
#~ "      self.execute_multiple_calls(calls) // Delegates to a function for processing multiple calls\n"
#~ "    }\n"
#~ "    // ... Additional implementation details may follow\n"
#~ "  }\n"
#~ "  // ... Further module code may be present\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// Module defining supported transaction versions\n"
#~ "mod SUPPORTED_TX_VERSION {\n"
#~ "  // Constants representing the supported versions\n"
#~ "  const DEPLOY_ACCOUNT: felt252 = 1;  // Supported version for deploy_account transactions\n"
#~ "  const DECLARE: felt252 = 2;         // Supported version for declare transactions\n"
#~ "  const INVOKE: felt252 = 1;          // Supported version for invoke transactions\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // The rest of the account contract module code\n"
#~ "  ...\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// Module defining supported transaction versions\n"
#~ "mod SUPPORTED_TX_VERSION {\n"
#~ "  // Constants representing the supported versions\n"
#~ "  const DEPLOY_ACCOUNT: felt252 = 1;  // Supported version for deploy_account transactions\n"
#~ "  const DECLARE: felt252 = 2;         // Supported version for declare transactions\n"
#~ "  const INVOKE: felt252 = 1;          // Supported version for invoke transactions\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // The rest of the account contract module code\n"
#~ "  ...\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Importing constants from the SUPPORTED_TX_VERSION module\n"
#~ "  use super::SUPPORTED_TX_VERSION;\n"
#~ "\n"
#~ "  // Protocol implementation for Starknet functions\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Function to execute multiple calls with version check\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Checks if the function caller is the Starknet protocol\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE); // Ensures the transaction is the supported version\n"
#~ "      self.execute_multiple_calls(calls) // Processes the calls if version check passes\n"
#~ "    }\n"
#~ "\n"
#~ "    // Each of the following functions also includes the version check to ensure compatibility\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private implementation for checking supported transaction versions\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Function to assert the transaction version is supported\n"
#~ "    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
#~ "      let tx_info = get_tx_info().unbox(); // Retrieves transaction details\n"
#~ "      let version = tx_info.version; // Extracts the version from the transaction\n"
#~ "      assert(\n"
#~ "        version == supported_tx_version,\n"
#~ "        'Account: Unsupported tx version' // Error message for unsupported versions\n"
#~ "      );\n"
#~ "    }\n"
#~ "    // ... Additional private functions\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Importing constants from the SUPPORTED_TX_VERSION module\n"
#~ "  use super::SUPPORTED_TX_VERSION;\n"
#~ "\n"
#~ "  // Protocol implementation for Starknet functions\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    // Function to execute multiple calls with version check\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol(); // Checks if the function caller is the Starknet protocol\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE); // Ensures the transaction is the supported version\n"
#~ "      self.execute_multiple_calls(calls) // Processes the calls if version check passes\n"
#~ "    }\n"
#~ "\n"
#~ "    // Each of the following functions also includes the version check to ensure compatibility\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  // Private implementation for checking supported transaction versions\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    // Function to assert the transaction version is supported\n"
#~ "    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
#~ "      let tx_info = get_tx_info().unbox(); // Retrieves transaction details\n"
#~ "      let version = tx_info.version; // Extracts the version from the transaction\n"
#~ "      assert(\n"
#~ "        version == supported_tx_version,\n"
#~ "        'Account: Unsupported tx version' // Error message for unsupported versions\n"
#~ "      );\n"
#~ "    }\n"
#~ "    // ... Additional private functions\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "// SRC-5 trait defining the introspection method\n"
#~ "trait ISRC5 {\n"
#~ "  // Function to check interface support\n"
#~ "  fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "// Extension of the account contract's interface for SRC-5 compliance\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  // ... Additional methods\n"
#~ "  // Method to validate interface support\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Constant identifier for the SRC-6 trait\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
#~ "\n"
#~ "  // Public interface implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    // ... Other function implementations\n"
#~ "    // Implementation of the interface support check\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      // Compares the provided interface ID with the SRC-6 trait ID\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional account contract code\n"
#~ "}\n"
#~ "// SRC-5 trait defining the introspection method\n"
#~ "trait ISRC5 {\n"
#~ "  // Function to check interface support\n"
#~ "  fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "// Extension of the account contract's interface for SRC-5 compliance\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  // ... Additional methods\n"
#~ "  // Method to validate interface support\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Constant identifier for the SRC-6 trait\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
#~ "\n"
#~ "  // Public interface implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    // ... Other function implementations\n"
#~ "    // Implementation of the interface support check\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      // Compares the provided interface ID with the SRC-6 trait ID\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional account contract code\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "// SRC-5 trait defining the introspection method\n"
#~ "trait ISRC5 {\n"
#~ "  // Function to check interface support\n"
#~ "  fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "// Extension of the account contract's interface for SRC-5 compliance\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  // ... Additional methods\n"
#~ "  // Method to validate interface support\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Constant identifier for the SRC-6 trait\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
#~ "\n"
#~ "  // Public interface implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    // ... Other function implementations\n"
#~ "    // Implementation of the interface support check\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      // Compares the provided interface ID with the SRC-6 trait ID\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional account contract code\n"
#~ "}\n"
#~ "// SRC-5 trait defining the introspection method\n"
#~ "trait ISRC5 {\n"
#~ "  // Function to check interface support\n"
#~ "  fn supports_interface(interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "// Extension of the account contract's interface for SRC-5 compliance\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  // ... Additional methods\n"
#~ "  // Method to validate interface support\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  // Constant identifier for the SRC-6 trait\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709;\n"
#~ "\n"
#~ "  // Public interface implementation for the account contract\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of super::IAccount<ContractState> {\n"
#~ "    // ... Other function implementations\n"
#~ "    // Implementation of the interface support check\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      // Compares the provided interface ID with the SRC-6 trait ID\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "  }\n"
#~ "  // ... Additional account contract code\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "...\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  ...\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of IAccount<ContractState> {\n"
#~ "    ...\n"
#~ "    fn public_key(self: @ContractState) -> felt252 {\n"
#~ "      self.public_key.read()\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "...\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  ...\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of IAccount<ContractState> {\n"
#~ "    ...\n"
#~ "    fn public_key(self: @ContractState) -> felt252 {\n"
#~ "      self.public_key.read()\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "use starknet::account::Call;\n"
#~ "\n"
#~ "mod SUPPORTED_TX_VERSION {\n"
#~ "  const DEPLOY_ACCOUNT: felt252 = 1;\n"
#~ "  const DECLARE: felt252 = 2;\n"
#~ "  const INVOKE: felt252 = 1;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "  fn public_key(self: @T) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use super::{Call, IAccount, SUPPORTED_TX_VERSION};\n"
#~ "  use starknet::{get_caller_address, call_contract_syscall, get_tx_info, VALIDATED};\n"
#~ "  use zeroable::Zeroable;\n"
#~ "  use array::{ArrayTrait, SpanTrait};\n"
#~ "  use ecdsa::check_ecdsa_signature;\n"
#~ "  use box::BoxTrait;\n"
#~ "\n"
#~ "  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
#~ "\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "  }\n"
#~ "\n"
#~ "  #[constructor]\n"
#~ "  fn constructor(ref self: ContractState, public_key: felt252) {\n"
#~ "    self.public_key.write(public_key);\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
#~ "      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
#~ "      if is_valid { VALIDATED } else { 0 }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "\n"
#~ "    fn public_key(self: @ContractState) -> felt252 {\n"
#~ "      self.public_key.read()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.execute_multiple_calls(calls)\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      let sender = get_caller_address();\n"
#~ "      assert(sender.is_zero(), 'Account: invalid caller');\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
#~ "      let is_valid_length = signature.len() == 2_u32;\n"
#~ "\n"
#~ "      if !is_valid_length {\n"
#~ "        return false;\n"
#~ "      }\n"
#~ "\n"
#~ "      check_ecdsa_signature(\n"
#~ "        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
#~ "      )\n"
#~ "    }\n"
#~ "\n"
#~ "    fn validate_transaction(self: @ContractState) -> felt252 {\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');\n"
#~ "      VALIDATED\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
#~ "      let Call{to, selector, calldata} = call;\n"
#~ "      call_contract_syscall(to, selector, calldata.span()).unwrap()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      let mut res = ArrayTrait::new();\n"
#~ "      loop {\n"
#~ "        match calls.pop_front() {\n"
#~ "          Option::Some(call) => {\n"
#~ "            let _res = self.execute_single_call(call);\n"
#~ "            res.append(_res);\n"
#~ "          },\n"
#~ "          Option::None(_) => {\n"
#~ "            break ();\n"
#~ "          },\n"
#~ "        };\n"
#~ "      };\n"
#~ "      res\n"
#~ "    }\n"
#~ "\n"
#~ "    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let version = tx_info.version;\n"
#~ "      assert(\n"
#~ "        version == supported_tx_version ||\n"
#~ "        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
#~ "        'Account: Unsupported tx version'\n"
#~ "      );\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "use starknet::account::Call;\n"
#~ "\n"
#~ "mod SUPPORTED_TX_VERSION {\n"
#~ "  const DEPLOY_ACCOUNT: felt252 = 1;\n"
#~ "  const DECLARE: felt252 = 2;\n"
#~ "  const INVOKE: felt252 = 1;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::interface]\n"
#~ "trait IAccount<T> {\n"
#~ "  fn is_valid_signature(self: @T, hash: felt252, signature: Array<felt252>) -> felt252;\n"
#~ "  fn supports_interface(self: @T, interface_id: felt252) -> bool;\n"
#~ "  fn public_key(self: @T) -> felt252;\n"
#~ "}\n"
#~ "\n"
#~ "#[starknet::contract]\n"
#~ "mod Account {\n"
#~ "  use super::{Call, IAccount, SUPPORTED_TX_VERSION};\n"
#~ "  use starknet::{get_caller_address, call_contract_syscall, get_tx_info, VALIDATED};\n"
#~ "  use zeroable::Zeroable;\n"
#~ "  use array::{ArrayTrait, SpanTrait};\n"
#~ "  use ecdsa::check_ecdsa_signature;\n"
#~ "  use box::BoxTrait;\n"
#~ "\n"
#~ "  const SIMULATE_TX_VERSION_OFFSET: felt252 = 340282366920938463463374607431768211456; // 2**128\n"
#~ "  const SRC6_TRAIT_ID: felt252 = 1270010605630597976495846281167968799381097569185364931397797212080166453709; // hash of SNIP-6 trait\n"
#~ "\n"
#~ "  #[storage]\n"
#~ "  struct Storage {\n"
#~ "    public_key: felt252\n"
#~ "  }\n"
#~ "\n"
#~ "  #[constructor]\n"
#~ "  fn constructor(ref self: ContractState, public_key: felt252) {\n"
#~ "    self.public_key.write(public_key);\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  impl AccountImpl of IAccount<ContractState> {\n"
#~ "    fn is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) -> felt252 {\n"
#~ "      let is_valid = self.is_valid_signature_bool(hash, signature.span());\n"
#~ "      if is_valid { VALIDATED } else { 0 }\n"
#~ "    }\n"
#~ "\n"
#~ "    fn supports_interface(self: @ContractState, interface_id: felt252) -> bool {\n"
#~ "      interface_id == SRC6_TRAIT_ID\n"
#~ "    }\n"
#~ "\n"
#~ "    fn public_key(self: @ContractState) -> felt252 {\n"
#~ "      self.public_key.read()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  #[external(v0)]\n"
#~ "  #[generate_trait]\n"
#~ "  impl ProtocolImpl of ProtocolTrait {\n"
#~ "    fn __execute__(ref self: ContractState, calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.execute_multiple_calls(calls)\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate__(self: @ContractState, calls: Array<Call>) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::INVOKE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_declare__(self: @ContractState, class_hash: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DECLARE);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn __validate_deploy__(self: @ContractState, class_hash: felt252, salt: felt252, public_key: felt252) -> felt252 {\n"
#~ "      self.only_protocol();\n"
#~ "      self.only_supported_tx_version(SUPPORTED_TX_VERSION::DEPLOY_ACCOUNT);\n"
#~ "      self.validate_transaction()\n"
#~ "    }\n"
#~ "  }\n"
#~ "\n"
#~ "  #[generate_trait]\n"
#~ "  impl PrivateImpl of PrivateTrait {\n"
#~ "    fn only_protocol(self: @ContractState) {\n"
#~ "      let sender = get_caller_address();\n"
#~ "      assert(sender.is_zero(), 'Account: invalid caller');\n"
#~ "    }\n"
#~ "\n"
#~ "    fn is_valid_signature_bool(self: @ContractState, hash: felt252, signature: Span<felt252>) -> bool {\n"
#~ "      let is_valid_length = signature.len() == 2_u32;\n"
#~ "\n"
#~ "      if !is_valid_length {\n"
#~ "        return false;\n"
#~ "      }\n"
#~ "\n"
#~ "      check_ecdsa_signature(\n"
#~ "        hash, self.public_key.read(), *signature.at(0_u32), *signature.at(1_u32)\n"
#~ "      )\n"
#~ "    }\n"
#~ "\n"
#~ "    fn validate_transaction(self: @ContractState) -> felt252 {\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let tx_hash = tx_info.transaction_hash;\n"
#~ "      let signature = tx_info.signature;\n"
#~ "\n"
#~ "      let is_valid = self.is_valid_signature_bool(tx_hash, signature);\n"
#~ "      assert(is_valid, 'Account: Incorrect tx signature');\n"
#~ "      VALIDATED\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute_single_call(self: @ContractState, call: Call) -> Span<felt252> {\n"
#~ "      let Call{to, selector, calldata} = call;\n"
#~ "      call_contract_syscall(to, selector, calldata.span()).unwrap()\n"
#~ "    }\n"
#~ "\n"
#~ "    fn execute_multiple_calls(self: @ContractState, mut calls: Array<Call>) -> Array<Span<felt252>> {\n"
#~ "      let mut res = ArrayTrait::new();\n"
#~ "      loop {\n"
#~ "        match calls.pop_front() {\n"
#~ "          Option::Some(call) => {\n"
#~ "            let _res = self.execute_single_call(call);\n"
#~ "            res.append(_res);\n"
#~ "          },\n"
#~ "          Option::None(_) => {\n"
#~ "            break ();\n"
#~ "          },\n"
#~ "        };\n"
#~ "      };\n"
#~ "      res\n"
#~ "    }\n"
#~ "\n"
#~ "    fn only_supported_tx_version(self: @ContractState, supported_tx_version: felt252) {\n"
#~ "      let tx_info = get_tx_info().unbox();\n"
#~ "      let version = tx_info.version;\n"
#~ "      assert(\n"
#~ "        version == supported_tx_version ||\n"
#~ "        version == SIMULATE_TX_VERSION_OFFSET + supported_tx_version,\n"
#~ "        'Account: Unsupported tx version'\n"
#~ "      );\n"
#~ "    }\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "tree ~/.starkli-wallets\n"
#~ "\n"
#~ ".starkli-wallets\n"
#~ "â”œâ”€â”€ wallet-a\n"
#~ "â”‚   â”œâ”€â”€ account.json\n"
#~ "â”‚   â”œâ”€â”€ envars.sh\n"
#~ "â”‚   â””â”€â”€ keystore.json\n"
#~ "â””â”€â”€ wallet-b\n"
#~ "    â”œâ”€â”€ account.json\n"
#~ "    â”œâ”€â”€ envars.sh\n"
#~ "    â””â”€â”€ keystore.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "tree ~/.starkli-wallets\n"
#~ "\n"
#~ ".starkli-wallets\n"
#~ "â”œâ”€â”€ wallet-a\n"
#~ "â”‚   â”œâ”€â”€ account.json\n"
#~ "â”‚   â”œâ”€â”€ envars.sh\n"
#~ "â”‚   â””â”€â”€ keystore.json\n"
#~ "â””â”€â”€ wallet-b\n"
#~ "    â”œâ”€â”€ account.json\n"
#~ "    â”œâ”€â”€ envars.sh\n"
#~ "    â””â”€â”€ keystore.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "mkdir ~/.starkli-wallets/custom\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "mkdir ~/.starkli-wallets/custom\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "touch ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "touch ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "source ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "source ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli account oz init ~/.starkli-wallets/custom/account.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli account oz init ~/.starkli-wallets/custom/account.json\n"
#~ "```"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"open_zeppelin\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
#~ "    \"legacy\": false\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"undeployed\",\n"
#~ "    \"class_hash\": \"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\",\n"
#~ "    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"open_zeppelin\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
#~ "    \"legacy\": false\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"undeployed\",\n"
#~ "    \"class_hash\": \"0x4c6d6cf894f8bc96bb9c525e6853e5483177841f7388f74a46cfda6f028c755\",\n"
#~ "    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "cd aa\n"
#~ "scarb build\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "cd aa\n"
#~ "scarb build\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli class-hash target/dev/aa_Account.sierra.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli class-hash target/dev/aa_Account.sierra.json\n"
#~ "```"

#~ msgid ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"open_zeppelin\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
#~ "    \"legacy\": false\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"undeployed\",\n"
#~ "    \"class_hash\": \"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\",\n"
#~ "    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"
#~ msgstr ""
#~ "```json\n"
#~ "{\n"
#~ "  \"version\": 1,\n"
#~ "  \"variant\": {\n"
#~ "    \"type\": \"open_zeppelin\",\n"
#~ "    \"version\": 1,\n"
#~ "    \"public_key\": \"0x1445385497364c73fabf223c55b7b323586b61c42942c99715d842c6f0a781c\",\n"
#~ "    \"legacy\": false\n"
#~ "  },\n"
#~ "  \"deployment\": {\n"
#~ "    \"status\": \"undeployed\",\n"
#~ "    \"class_hash\": \"0x03480253c19b447b1d7e7a6422acf80b73866522de03126fa55796a712d9f092\",\n"
#~ "    \"salt\": \"0x36cb2427f99a75b7d4c4ceeca1e412cd94b1fc396e09fec8adca14f8dc33374\"\n"
#~ "  }\n"
#~ "}\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "code ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "code ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "aa $ code ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "aa $ code ~/.starkli-wallets/custom/envars.sh\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "#!/bin/bash\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "tree .\n"
#~ "\n"
#~ ".\n"
#~ "â”œâ”€â”€ custom\n"
#~ "â”‚Â Â  â”œâ”€â”€ account.json\n"
#~ "â”‚Â Â  â”œâ”€â”€ envars.sh\n"
#~ "â”‚Â Â  â””â”€â”€ keystore.json\n"
#~ "â””â”€â”€ deployer\n"
#~ "    â”œâ”€â”€ account.json\n"
#~ "    â”œâ”€â”€ envars.sh\n"
#~ "    â””â”€â”€ keystore.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "tree .\n"
#~ "\n"
#~ ".\n"
#~ "â”œâ”€â”€ custom\n"
#~ "â”‚Â Â  â”œâ”€â”€ account.json\n"
#~ "â”‚Â Â  â”œâ”€â”€ envars.sh\n"
#~ "â”‚Â Â  â””â”€â”€ keystore.json\n"
#~ "â””â”€â”€ deployer\n"
#~ "    â”œâ”€â”€ account.json\n"
#~ "    â”œâ”€â”€ envars.sh\n"
#~ "    â””â”€â”€ keystore.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "source ~/.starkli-wallets/deployer/envars.sh\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "source ~/.starkli-wallets/deployer/envars.sh\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli declare target/dev/aa_Account.sierra.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli declare target/dev/aa_Account.sierra.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli account deploy ~/.starkli-wallets/custom/account.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli account deploy ~/.starkli-wallets/custom/account.json\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "...\n"
#~ "Deployment transaction confirmed\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "...\n"
#~ "Deployment transaction confirmed\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "starkli invoke eth transfer 0x070a012... u256:100\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "starkli invoke eth transfer 0x070a012... u256:100\n"
#~ "```"

#~ msgid ""
#~ "```bash\n"
#~ "# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
#~ "\n"
#~ "# [1] Set up environment variables in envars.sh\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
#~ "\n"
#~ "# [2] Generate keystore.json\n"
#~ "starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
#~ "\n"
#~ "# [3] Initialize account.json\n"
#~ "starkli account oz init ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [4] Build the contract with Scarb\n"
#~ "scarb build\n"
#~ "\n"
#~ "# [5] Get the class hash\n"
#~ "starkli class-hash target/dev/aa_Account.sierra.json\n"
#~ "\n"
#~ "# [6] Update account.json with the real class hash\n"
#~ "code ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [7] Set deployer wallet environment\n"
#~ "source ~/.starkli-wallets/deployer/envars.sh\n"
#~ "\n"
#~ "# [8] Declare the contract using the deployer\n"
#~ "starkli declare target/dev/aa_Account.sierra.json\n"
#~ "\n"
#~ "# [9] Switch to the custom wallet\n"
#~ "source ~/.starkli-wallets/custom/envars.sh\n"
#~ "\n"
#~ "# [10] Deploy the contract\n"
#~ "starkli account deploy ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [11] Test the contract by transferring ETH\n"
#~ "starkli invoke eth transfer 0x070a012... u256:100\n"
#~ "\n"
#~ "# [bonus] Recommended directory structure\n"
#~ ".\n"
#~ "â”œâ”€â”€ account.json\n"
#~ "â”œâ”€â”€ envars.sh\n"
#~ "â””â”€â”€ keystore.json\n"
#~ "```"
#~ msgstr ""
#~ "```bash\n"
#~ "# Quick Guide: Declare, Deploy, and Interact with a Custom Account Contract\n"
#~ "\n"
#~ "# [1] Set up environment variables in envars.sh\n"
#~ "export STARKNET_KEYSTORE=~/.starkli-wallets/custom/keystore.json\n"
#~ "export STARKNET_ACCOUNT=~/.starkli-wallets/custom/account.json\n"
#~ "export STARKNET_RPC=https://starknet-goerli.g.alchemy.com/v2/your-api-key\n"
#~ "\n"
#~ "# [2] Generate keystore.json\n"
#~ "starkli signer keystore new ~/.starkli-wallets/custom/keystore.json\n"
#~ "\n"
#~ "# [3] Initialize account.json\n"
#~ "starkli account oz init ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [4] Build the contract with Scarb\n"
#~ "scarb build\n"
#~ "\n"
#~ "# [5] Get the class hash\n"
#~ "starkli class-hash target/dev/aa_Account.sierra.json\n"
#~ "\n"
#~ "# [6] Update account.json with the real class hash\n"
#~ "code ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [7] Set deployer wallet environment\n"
#~ "source ~/.starkli-wallets/deployer/envars.sh\n"
#~ "\n"
#~ "# [8] Declare the contract using the deployer\n"
#~ "starkli declare target/dev/aa_Account.sierra.json\n"
#~ "\n"
#~ "# [9] Switch to the custom wallet\n"
#~ "source ~/.starkli-wallets/custom/envars.sh\n"
#~ "\n"
#~ "# [10] Deploy the contract\n"
#~ "starkli account deploy ~/.starkli-wallets/custom/account.json\n"
#~ "\n"
#~ "# [11] Test the contract by transferring ETH\n"
#~ "starkli invoke eth transfer 0x070a012... u256:100\n"
#~ "\n"
#~ "# [bonus] Recommended directory structure\n"
#~ ".\n"
#~ "â”œâ”€â”€ account.json\n"
#~ "â”œâ”€â”€ envars.sh\n"
#~ "â””â”€â”€ keystore.json\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    // Import necessary modules and traits\n"
#~ "    use serde::Serde;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use array::SpanTrait;\n"
#~ "    use option::OptionTrait;\n"
#~ "\n"
#~ "    // Define the Account contract\n"
#~ "    #[account_contract]\n"
#~ "    mod Account {\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use array::SpanTrait;\n"
#~ "        use box::BoxTrait;\n"
#~ "        use ecdsa::check_ecdsa_signature;\n"
#~ "        use option::OptionTrait;\n"
#~ "        use super::Call;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use zeroable::Zeroable;\n"
#~ "        use serde::ArraySerde;\n"
#~ "\n"
#~ "        // Define the contract's storage variables\n"
#~ "        struct Storage {\n"
#~ "            public_key: felt252\n"
#~ "        }\n"
#~ "\n"
#~ "        // Constructor function for initializing the contract\n"
#~ "        #[constructor]\n"
#~ "        fn constructor(public_key_: felt252) {\n"
#~ "            public_key::write(public_key_);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Internal function to validate the transaction signature\n"
#~ "        fn validate_transaction() -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            let signature = tx_info.signature; // Extract signature\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
#~ "\n"
#~ "            // Verify ECDSA signature\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED // Return validation status\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract deployment\n"
#~ "        #[external]\n"
#~ "        fn __validate_deploy__(\n"
#~ "            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract declaration\n"
#~ "        #[external]\n"
#~ "        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract execution\n"
#~ "        #[external]\n"
#~ "        fn __validate__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array<felt252>\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Execute a contract call\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
#~ "            // Validate caller\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
#~ "            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
#~ "\n"
#~ "            // Call the target contract\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // Define the Call struct\n"
#~ "    #[derive(Drop, Serde)]\n"
#~ "    struct Call {\n"
#~ "        to: ContractAddress,\n"
#~ "        selector: felt252,\n"
#~ "        calldata: Array<felt252>\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    // Import necessary modules and traits\n"
#~ "    use serde::Serde;\n"
#~ "    use starknet::ContractAddress;\n"
#~ "    use array::ArrayTrait;\n"
#~ "    use array::SpanTrait;\n"
#~ "    use option::OptionTrait;\n"
#~ "\n"
#~ "    // Define the Account contract\n"
#~ "    #[account_contract]\n"
#~ "    mod Account {\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use array::SpanTrait;\n"
#~ "        use box::BoxTrait;\n"
#~ "        use ecdsa::check_ecdsa_signature;\n"
#~ "        use option::OptionTrait;\n"
#~ "        use super::Call;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use zeroable::Zeroable;\n"
#~ "        use serde::ArraySerde;\n"
#~ "\n"
#~ "        // Define the contract's storage variables\n"
#~ "        struct Storage {\n"
#~ "            public_key: felt252\n"
#~ "        }\n"
#~ "\n"
#~ "        // Constructor function for initializing the contract\n"
#~ "        #[constructor]\n"
#~ "        fn constructor(public_key_: felt252) {\n"
#~ "            public_key::write(public_key_);\n"
#~ "        }\n"
#~ "\n"
#~ "        // Internal function to validate the transaction signature\n"
#~ "        fn validate_transaction() -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            let signature = tx_info.signature; // Extract signature\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
#~ "\n"
#~ "            // Verify ECDSA signature\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED // Return validation status\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract deployment\n"
#~ "        #[external]\n"
#~ "        fn __validate_deploy__(\n"
#~ "            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract declaration\n"
#~ "        #[external]\n"
#~ "        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Validate contract execution\n"
#~ "        #[external]\n"
#~ "        fn __validate__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array<felt252>\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction()\n"
#~ "        }\n"
#~ "\n"
#~ "        // Execute a contract call\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
#~ "            // Validate caller\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
#~ "            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
#~ "\n"
#~ "            // Call the target contract\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "    }\n"
#~ "\n"
#~ "    // Define the Call struct\n"
#~ "    #[derive(Drop, Serde)]\n"
#~ "    struct Call {\n"
#~ "        to: ContractAddress,\n"
#~ "        selector: felt252,\n"
#~ "        calldata: Array<felt252>\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    struct Storage {\n"
#~ "        public_key: felt252\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    struct Storage {\n"
#~ "        public_key: felt252\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(public_key_: felt252) {\n"
#~ "        public_key::write(public_key_);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[constructor]\n"
#~ "    fn constructor(public_key_: felt252) {\n"
#~ "        public_key::write(public_key_);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    fn validate_transaction() -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            let signature = tx_info.signature; // Extract signature\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
#~ "\n"
#~ "            // Verify ECDSA signature\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED // Return validation status\n"
#~ "        }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    fn validate_transaction() -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            let signature = tx_info.signature; // Extract signature\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // Check signature length\n"
#~ "\n"
#~ "            // Verify ECDSA signature\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key::read(),\n"
#~ "                    signature_r: *signature[0_u32],\n"
#~ "                    signature_s: *signature[1_u32],\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED // Return validation status\n"
#~ "        }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[derive(Drop, Serde)]\n"
#~ "    struct Call {\n"
#~ "        to: ContractAddress,\n"
#~ "        selector: felt252,\n"
#~ "        calldata: Array<felt252>\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[derive(Drop, Serde)]\n"
#~ "    struct Call {\n"
#~ "        to: ContractAddress,\n"
#~ "        selector: felt252,\n"
#~ "        calldata: Array<felt252>\n"
#~ "    }\n"
#~ "```"

#, fuzzy
#~ msgid "### execute"
#~ msgstr "æ‰§è¡Œ"

#~ msgid ""
#~ "```rust\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
#~ "            // Validate caller\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
#~ "            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
#~ "\n"
#~ "            // Call the target contract\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
#~ "            // Validate caller\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            let tx_info = starknet::get_tx_info().unbox(); // Unbox transaction info\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only single calls are supported\n"
#~ "            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
#~ "\n"
#~ "            // Call the target contract\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                address: to, entry_point_selector: selector, calldata: calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    fn _execute_calls(mut calls: Array<AccountCall>, mut res:Array::<Array::<felt>>) -> Array::<Array::<felt>> {\n"
#~ "        match calls.pop_front() {\n"
#~ "            Option::Some(call) => {\n"
#~ "                let _res = _call_contract(call);\n"
#~ "                res.append(_res);\n"
#~ "                return _execute_calls(calls, res);\n"
#~ "            },\n"
#~ "            Option::None(_) => {\n"
#~ "                return res;\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    fn _execute_calls(mut calls: Array<AccountCall>, mut res:Array::<Array::<felt>>) -> Array::<Array::<felt>> {\n"
#~ "        match calls.pop_front() {\n"
#~ "            Option::Some(call) => {\n"
#~ "                let _res = _call_contract(call);\n"
#~ "                res.append(_res);\n"
#~ "                return _execute_calls(calls, res);\n"
#~ "            },\n"
#~ "            Option::None(_) => {\n"
#~ "                return res;\n"
#~ "            },\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    fn _call_contract(call: AccountCall) -> Array::<felt> {\n"
#~ "        starknet::call_contract_syscall(\n"
#~ "            call.to, call.selector, call.calldata\n"
#~ "        ).unwrap_syscall()\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    fn _call_contract(call: AccountCall) -> Array::<felt> {\n"
#~ "        starknet::call_contract_syscall(\n"
#~ "            call.to, call.selector, call.calldata\n"
#~ "        ).unwrap_syscall()\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[account_contract]\n"
#~ "    mod MultisigAccount {\n"
#~ "        use ecdsa::check_ecdsa_signature;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use zeroable::Zeroable;\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use starknet::get_caller_address;\n"
#~ "        use box::BoxTrait;\n"
#~ "        use array::SpanTrait;\n"
#~ "\n"
#~ "        struct Storage {\n"
#~ "            index_to_owner: LegacyMap::<u32, felt252>,\n"
#~ "            owner_to_index: LegacyMap::<felt252, u32>,\n"
#~ "            num_owners: usize,\n"
#~ "            threshold: usize,\n"
#~ "            curr_tx_index: felt252,\n"
#~ "            //Mapping between tx_index and num of confirmations\n"
#~ "            tx_confirms: LegacyMap<felt252, usize>,\n"
#~ "            //Mapping between tx_index and its execution state\n"
#~ "            tx_is_executed: LegacyMap<felt252, bool>,\n"
#~ "            //Mapping between a transaction index and its hash\n"
#~ "            transactions: LegacyMap<felt252, felt252>,\n"
#~ "            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
#~ "        }\n"
#~ "\n"
#~ "        #[constructor]\n"
#~ "        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
#~ "            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
#~ "            num_owners::write(public_keys.len());\n"
#~ "            threshold::write(_threshold);\n"
#~ "            _set_owners(public_keys.len(), public_keys);\n"
#~ "        }\n"
#~ "\n"
#~ "        //GETTERS\n"
#~ "        //Get number of confirmations for a given transaction index\n"
#~ "        #[view]\n"
#~ "        fn get_confirmations(tx_index : felt252) -> usize {\n"
#~ "            tx_confirms::read(tx_index)\n"
#~ "        }\n"
#~ "\n"
#~ "        //Get the number of owners of this account\n"
#~ "        #[view]\n"
#~ "        fn get_num_owners() -> usize {\n"
#~ "            num_owners::read()\n"
#~ "        }\n"
#~ "\n"
#~ "\n"
#~ "        //Get the public key of the owners\n"
#~ "        //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled\n"
#~ "\n"
#~ "\n"
#~ "        //EXTERNAL FUNCTIONS\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn submit_tx(public_key: felt252) {\n"
#~ "\n"
#~ "            //Need to check if caller is one of the owners.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "            //Updating the transaction index\n"
#~ "            let tx_index = curr_tx_index::read();\n"
#~ "\n"
#~ "            //`true` if a signature is valid and `false` otherwise.\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            transactions::write(tx_index, tx_info.transaction_hash);\n"
#~ "            curr_tx_index::write(tx_index + 1);\n"
#~ "\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
#~ "\n"
#~ "            let transaction_hash = transactions::read(tx_index);\n"
#~ "            //TBD: Assert that tx_hash is not null\n"
#~ "\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let executed = tx_is_executed::read(tx_index);\n"
#~ "\n"
#~ "            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
#~ "\n"
#~ "            let caller = get_caller_address();\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "\n"
#~ "             assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            let confirmed = has_confirmed::read((caller, tx_index));\n"
#~ "\n"
#~ "            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
#~ "            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
#~ "            has_confirmed::write((caller, tx_index), true);\n"
#~ "\n"
#~ "\n"
#~ "        }\n"
#~ "\n"
#~ "        //An example function to validate that there are at least two signatures\n"
#~ "        fn validate_transaction(public_key: felt252) -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "            //`true` if a signature is valid and `false` otherwise.\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED\n"
#~ "        }\n"
#~ "\n"
#~ "        //INTERNAL FUNCTION\n"
#~ "        //Function to add the public keys of the multisig in permanent storage\n"
#~ "        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
#~ "            if owners_len == 0_usize {\n"
#~ "            }\n"
#~ "\n"
#~ "            index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
#~ "            owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
#~ "            _set_owners(owners_len - 1_u32, public_keys);\n"
#~ "        }\n"
#~ "\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate_deploy__(\n"
#~ "            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
#~ "            tx_index: felt252\n"
#~ "        ) -> Span::<felt252> {\n"
#~ "            // Validate caller.\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            //Multisig check here\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let owners_len = num_owners::read();\n"
#~ "            //Subtracting one for the submitter\n"
#~ "            let required_confirmations = threshold::read() - 1_usize;\n"
#~ "            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
#~ "\n"
#~ "            tx_is_executed::write(tx_index, true);\n"
#~ "\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                contract_address, entry_point_selector, calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[account_contract]\n"
#~ "    mod MultisigAccount {\n"
#~ "        use ecdsa::check_ecdsa_signature;\n"
#~ "        use starknet::ContractAddress;\n"
#~ "        use zeroable::Zeroable;\n"
#~ "        use array::ArrayTrait;\n"
#~ "        use starknet::get_caller_address;\n"
#~ "        use box::BoxTrait;\n"
#~ "        use array::SpanTrait;\n"
#~ "\n"
#~ "        struct Storage {\n"
#~ "            index_to_owner: LegacyMap::<u32, felt252>,\n"
#~ "            owner_to_index: LegacyMap::<felt252, u32>,\n"
#~ "            num_owners: usize,\n"
#~ "            threshold: usize,\n"
#~ "            curr_tx_index: felt252,\n"
#~ "            //Mapping between tx_index and num of confirmations\n"
#~ "            tx_confirms: LegacyMap<felt252, usize>,\n"
#~ "            //Mapping between tx_index and its execution state\n"
#~ "            tx_is_executed: LegacyMap<felt252, bool>,\n"
#~ "            //Mapping between a transaction index and its hash\n"
#~ "            transactions: LegacyMap<felt252, felt252>,\n"
#~ "            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
#~ "        }\n"
#~ "\n"
#~ "        #[constructor]\n"
#~ "        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
#~ "            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
#~ "            num_owners::write(public_keys.len());\n"
#~ "            threshold::write(_threshold);\n"
#~ "            _set_owners(public_keys.len(), public_keys);\n"
#~ "        }\n"
#~ "\n"
#~ "        //GETTERS\n"
#~ "        //Get number of confirmations for a given transaction index\n"
#~ "        #[view]\n"
#~ "        fn get_confirmations(tx_index : felt252) -> usize {\n"
#~ "            tx_confirms::read(tx_index)\n"
#~ "        }\n"
#~ "\n"
#~ "        //Get the number of owners of this account\n"
#~ "        #[view]\n"
#~ "        fn get_num_owners() -> usize {\n"
#~ "            num_owners::read()\n"
#~ "        }\n"
#~ "\n"
#~ "\n"
#~ "        //Get the public key of the owners\n"
#~ "        //TODO - Recursively add the owners into an array and return, maybe wait for loops to be enabled\n"
#~ "\n"
#~ "\n"
#~ "        //EXTERNAL FUNCTIONS\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn submit_tx(public_key: felt252) {\n"
#~ "\n"
#~ "            //Need to check if caller is one of the owners.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "            //Updating the transaction index\n"
#~ "            let tx_index = curr_tx_index::read();\n"
#~ "\n"
#~ "            //`true` if a signature is valid and `false` otherwise.\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            transactions::write(tx_index, tx_info.transaction_hash);\n"
#~ "            curr_tx_index::write(tx_index + 1);\n"
#~ "\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
#~ "\n"
#~ "            let transaction_hash = transactions::read(tx_index);\n"
#~ "            //TBD: Assert that tx_hash is not null\n"
#~ "\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let executed = tx_is_executed::read(tx_index);\n"
#~ "\n"
#~ "            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
#~ "\n"
#~ "            let caller = get_caller_address();\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "\n"
#~ "             assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            let confirmed = has_confirmed::read((caller, tx_index));\n"
#~ "\n"
#~ "            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
#~ "            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
#~ "            has_confirmed::write((caller, tx_index), true);\n"
#~ "\n"
#~ "\n"
#~ "        }\n"
#~ "\n"
#~ "        //An example function to validate that there are at least two signatures\n"
#~ "        fn validate_transaction(public_key: felt252) -> felt252 {\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "            let caller = get_caller_address();\n"
#~ "            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "            //`true` if a signature is valid and `false` otherwise.\n"
#~ "            assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            starknet::VALIDATED\n"
#~ "        }\n"
#~ "\n"
#~ "        //INTERNAL FUNCTION\n"
#~ "        //Function to add the public keys of the multisig in permanent storage\n"
#~ "        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
#~ "            if owners_len == 0_usize {\n"
#~ "            }\n"
#~ "\n"
#~ "            index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
#~ "            owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
#~ "            _set_owners(owners_len - 1_u32, public_keys);\n"
#~ "        }\n"
#~ "\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate_deploy__(\n"
#~ "            class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        fn __validate__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>, public_key_: felt252\n"
#~ "        ) -> felt252 {\n"
#~ "            validate_transaction(public_key_)\n"
#~ "        }\n"
#~ "\n"
#~ "        #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
#~ "            tx_index: felt252\n"
#~ "        ) -> Span::<felt252> {\n"
#~ "            // Validate caller.\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            //Multisig check here\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let owners_len = num_owners::read();\n"
#~ "            //Subtracting one for the submitter\n"
#~ "            let required_confirmations = threshold::read() - 1_usize;\n"
#~ "            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
#~ "\n"
#~ "            tx_is_executed::write(tx_index, true);\n"
#~ "\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                contract_address, entry_point_selector, calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    //INTERNAL FUNCTION\n"
#~ "    //Function to add the public keys of the multisig in permanent storage\n"
#~ "    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
#~ "        if owners_len == 0_usize {\n"
#~ "        }\n"
#~ "\n"
#~ "        index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
#~ "        owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
#~ "        _set_owners(owners_len - 1_u32, public_keys);\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    //INTERNAL FUNCTION\n"
#~ "    //Function to add the public keys of the multisig in permanent storage\n"
#~ "    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
#~ "        if owners_len == 0_usize {\n"
#~ "        }\n"
#~ "\n"
#~ "        index_to_owner::write(owners_len, *public_keys.at(owners_len - 1_usize));\n"
#~ "        owner_to_index::write(*public_keys.at(owners_len - 1_usize), owners_len);\n"
#~ "        _set_owners(owners_len - 1_u32, public_keys);\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn submit_tx(public_key: felt252) {\n"
#~ "\n"
#~ "        //Need to check if caller is one of the owners.\n"
#~ "        let tx_info = starknet::get_tx_info().unbox();\n"
#~ "        let signature: Span<felt252> = tx_info.signature;\n"
#~ "        let caller = get_caller_address();\n"
#~ "        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "        //Updating the transaction index\n"
#~ "        let tx_index = curr_tx_index::read();\n"
#~ "\n"
#~ "        //`true` if a signature is valid and `false` otherwise.\n"
#~ "        assert(\n"
#~ "            check_ecdsa_signature(\n"
#~ "                message_hash: tx_info.transaction_hash,\n"
#~ "                public_key: public_key,\n"
#~ "                signature_r: *signature.at(0_u32),\n"
#~ "                signature_s: *signature.at(1_u32),\n"
#~ "            ),\n"
#~ "            'INVALID_SIGNATURE',\n"
#~ "        );\n"
#~ "\n"
#~ "        transactions::write(tx_index, tx_info.transaction_hash);\n"
#~ "        curr_tx_index::write(tx_index + 1);\n"
#~ "\n"
#~ "    }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "    fn submit_tx(public_key: felt252) {\n"
#~ "\n"
#~ "        //Need to check if caller is one of the owners.\n"
#~ "        let tx_info = starknet::get_tx_info().unbox();\n"
#~ "        let signature: Span<felt252> = tx_info.signature;\n"
#~ "        let caller = get_caller_address();\n"
#~ "        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
#~ "\n"
#~ "        //Updating the transaction index\n"
#~ "        let tx_index = curr_tx_index::read();\n"
#~ "\n"
#~ "        //`true` if a signature is valid and `false` otherwise.\n"
#~ "        assert(\n"
#~ "            check_ecdsa_signature(\n"
#~ "                message_hash: tx_info.transaction_hash,\n"
#~ "                public_key: public_key,\n"
#~ "                signature_r: *signature.at(0_u32),\n"
#~ "                signature_s: *signature.at(1_u32),\n"
#~ "            ),\n"
#~ "            'INVALID_SIGNATURE',\n"
#~ "        );\n"
#~ "\n"
#~ "        transactions::write(tx_index, tx_info.transaction_hash);\n"
#~ "        curr_tx_index::write(tx_index + 1);\n"
#~ "\n"
#~ "    }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "        #[external]\n"
#~ "        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
#~ "\n"
#~ "            let transaction_hash = transactions::read(tx_index);\n"
#~ "            //TBD: Assert that tx_hash is not null\n"
#~ "\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let executed = tx_is_executed::read(tx_index);\n"
#~ "\n"
#~ "            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
#~ "\n"
#~ "            let caller = get_caller_address();\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "\n"
#~ "             assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            let confirmed = has_confirmed::read((caller, tx_index));\n"
#~ "\n"
#~ "            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
#~ "            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
#~ "            has_confirmed::write((caller, tx_index), true);\n"
#~ "        }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "        #[external]\n"
#~ "        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
#~ "\n"
#~ "            let transaction_hash = transactions::read(tx_index);\n"
#~ "            //TBD: Assert that tx_hash is not null\n"
#~ "\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let executed = tx_is_executed::read(tx_index);\n"
#~ "\n"
#~ "            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
#~ "\n"
#~ "            let caller = get_caller_address();\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            let signature: Span<felt252> = tx_info.signature;\n"
#~ "\n"
#~ "             assert(\n"
#~ "                check_ecdsa_signature(\n"
#~ "                    message_hash: tx_info.transaction_hash,\n"
#~ "                    public_key: public_key,\n"
#~ "                    signature_r: *signature.at(0_u32),\n"
#~ "                    signature_s: *signature.at(1_u32),\n"
#~ "                ),\n"
#~ "                'INVALID_SIGNATURE',\n"
#~ "            );\n"
#~ "\n"
#~ "            let confirmed = has_confirmed::read((caller, tx_index));\n"
#~ "\n"
#~ "            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
#~ "            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
#~ "            has_confirmed::write((caller, tx_index), true);\n"
#~ "        }\n"
#~ "```"

#~ msgid ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
#~ "            tx_index: felt252\n"
#~ "        ) -> Span::<felt252> {\n"
#~ "            // Validate caller.\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            //Multisig check here\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let owners_len = num_owners::read();\n"
#~ "            //Subtracting one for the submitter\n"
#~ "            let required_confirmations = threshold::read() - 1_usize;\n"
#~ "            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
#~ "\n"
#~ "            tx_is_executed::write(tx_index, true);\n"
#~ "\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                contract_address, entry_point_selector, calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "```"
#~ msgstr ""
#~ "```rust\n"
#~ "    #[external]\n"
#~ "        #[raw_output]\n"
#~ "        fn __execute__(\n"
#~ "            contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>,\n"
#~ "            tx_index: felt252\n"
#~ "        ) -> Span::<felt252> {\n"
#~ "            // Validate caller.\n"
#~ "            assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n"
#~ "\n"
#~ "            // Check the tx version here, since version 0 transaction skip the __validate__ function.\n"
#~ "            let tx_info = starknet::get_tx_info().unbox();\n"
#~ "            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
#~ "\n"
#~ "            //Multisig check here\n"
#~ "            let num_confirmations = tx_confirms::read(tx_index);\n"
#~ "            let owners_len = num_owners::read();\n"
#~ "            //Subtracting one for the submitter\n"
#~ "            let required_confirmations = threshold::read() - 1_usize;\n"
#~ "            assert(num_confirmations >= required_confirmations, 'MINIMUM_50%_CONFIRMATIONS');\n"
#~ "\n"
#~ "            tx_is_executed::write(tx_index, true);\n"
#~ "\n"
#~ "            starknet::call_contract_syscall(\n"
#~ "                contract_address, entry_point_selector, calldata.span()\n"
#~ "            ).unwrap_syscall()\n"
#~ "        }\n"
#~ "```"

#, fuzzy
#~ msgid "# Auto-Payments ğŸš§"
#~ msgstr "è‡ªåŠ¨ä»˜æ¬¾ ğŸš§"

#, fuzzy
#~ msgid "# Alternative Signature Schemes ğŸš§"
#~ msgstr "æ›¿ä»£ç­¾åæ–¹æ¡ˆ ğŸš§"

#~ msgid "Compile, Deploy, Interact"
#~ msgstr "ç¼–è¯‘ã€éƒ¨ç½²ã€äº¤äº’"

#~ msgid "Starkli: A CLI interface ğŸš§"
#~ msgstr "Starkliï¼šCLI ç•Œé¢ ğŸš§"

#~ msgid "Fee Mechanism ğŸš§"
#~ msgstr "è´¹ç”¨æœºåˆ¶ ğŸš§"

#~ msgid "For deeper insights into Starknet and Cairo:"
#~ msgstr "æ›´æ·±å…¥åœ°äº†è§£Starknetå’ŒCairoï¼š"

#~ msgid ""
#~ "- [The Starknet Book](https://book.starknet.io): For mastering\n"
#~ "  Starknet\n"
#~ "\n"
#~ "- [The Cairo Book](https://cairo-book.github.io/): For mastering Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1):\n"
#~ "  Practical tutorials and examples"
#~ msgstr ""
#~ "- [Starknetä¹‹ä¹¦](https://book.starknet.io)ï¼šç”¨äºæŒæ¡Starknet\n"
#~ "\n"
#~ "- [Cairoä¹‹ä¹¦](https://cairo-book.github.io/)ï¼šç”¨äºæŒæ¡Cairo\n"
#~ "\n"
#~ "- [Starklings](https://github.com/shramee/starklings-cairo1)ï¼š\n"
#~ "  å®ç”¨æ•™ç¨‹å’Œç¤ºä¾‹"

#~ msgid "Youâ€™ll see a list that contains scarb, cairo and sierra version."
#~ msgstr "ä½ ä¼šçœ‹åˆ°ä¸€ä¸ªåŒ…å« scarbã€cairo å’Œ sierra ç‰ˆæœ¬çš„åˆ—è¡¨ã€‚"

#~ msgid ""
#~ "1.  Use Braavos or Argent X browser extensions to create your smart\n"
#~ "    wallet.\n"
#~ "\n"
#~ "2.  Follow the provided instructions for your chosen wallet (Argent or\n"
#~ "    Braavos).\n"
#~ "\n"
#~ "3.  Fund your wallet with ETH. Use [Starknet Goerli\n"
#~ "    Faucet](https://faucet.goerli.starknet.io/) as needed."
#~ msgstr ""
#~ "1.  ä½¿ç”¨ Braavos æˆ– Argent X æµè§ˆå™¨æ‰©å±•åˆ›å»ºæ‚¨çš„æ™ºèƒ½é’±åŒ…ã€‚\n"
#~ "\n"
#~ "2.  æŒ‰ç…§æ‰€é€‰é’±åŒ…ï¼ˆArgent æˆ–Braavosï¼‰ã€‚\n"
#~ "\n"
#~ "3.  ç”¨ ETH ä¸ºé’±åŒ…å……å€¼ã€‚æ ¹æ®éœ€è¦ä½ å¯ä»¥ä½¿ç”¨[Starknet Goerli Faucet](https://faucet.goerli.starknet.io/)è·å–æµ‹è¯•ç”¨ETHã€‚"

#~ msgid "To see the details of your Account Descriptor, run:"
#~ msgstr "è¦æŸ¥çœ‹è´¦æˆ·æè¿°ç¬¦çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·è¿è¡Œï¼š"

#~ msgid "Once installed, confirm it with the version command:"
#~ msgstr "å®‰è£…å®Œæˆåï¼Œä½¿ç”¨ç‰ˆæœ¬å‘½ä»¤è¿›è¡Œç¡®è®¤ï¼š"

#~ msgid ""
#~ "Updating `katana` to its latest version involves going back to the\n"
#~ "`dojo` directory and running the following commands:"
#~ msgstr "å°† `katana` æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬éœ€è¦è¿”å› `dojo` ç›®å½•å¹¶è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#~ msgid ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # If you are using a local Starknet node, ensure to stop it first.\n"
#~ "    cargo install --path ./crates/katana --locked --force"
#~ msgstr ""
#~ "cd ~/.dojo/dojo\n"
#~ "    git pull\n"
#~ "\n"
#~ "    # å¦‚æœä½¿ç”¨æœ¬åœ° Starknet èŠ‚ç‚¹ï¼Œè¯·ç¡®ä¿å…ˆåœæ­¢å®ƒã€‚\n"
#~ "    cargo install --path ./crates/katana --locked --force"

#~ msgid ""
#~ "- Starknet.js GitHub Repository:\n"
#~ "  <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Official Starknet.js Website and documentation:\n"
#~ "  <https://www.starknetjs.com/>"
#~ msgstr ""
#~ "- Starknet.js GitHub ä»“åº“ï¼š\n"
#~ "  <https://github.com/0xs34n/starknet.js>\n"
#~ "\n"
#~ "- Starknet.js å®˜æ–¹ç½‘ç«™å’Œæ–‡æ¡£ï¼š\n"
#~ "  <https://www.starknetjs.com/>"

#~ msgid ""
#~ "Stay tuned for more updates on Starknet.js, including detailed guides,\n"
#~ "examples, and comprehensive documentation."
#~ msgstr "è¯·ç»§ç»­å…³æ³¨æœ‰å…³ Starknet.js çš„æ›´å¤šæ›´æ–°ï¼ŒåŒ…æ‹¬è¯¦ç»†çš„æŒ‡å—ã€ç¤ºä¾‹å’Œå…¨é¢çš„æ–‡æ¡£ã€‚"

#~ msgid "## Forge"
#~ msgstr "## Forge"

#~ msgid "## Creating a New Project"
#~ msgstr "## åˆ›å»ºæ–°é¡¹ç›®"

#~ msgid ""
#~ "- src/ contains the source code for all your contracts.\n"
#~ "- tests/ is where your test files are located.\n"
#~ "- Scarb.toml contains the project and `snforge` configuration.\n"
#~ "Make sure that the casm code generation is enabled in the Scarb.toml file:"
#~ msgstr ""
#~ "- src/ åŒ…å«æ‰€æœ‰åˆçº¦çš„æºä»£ç ã€‚\n"
#~ "- tests/ å­˜æ”¾æµ‹è¯•æ–‡ä»¶ã€‚\n"
#~ "- Scarb.toml åŒ…å«é¡¹ç›®å’Œ `snforge` é…ç½®ã€‚\n"
#~ "ç¡®ä¿åœ¨ Scarb.toml æ–‡ä»¶ä¸­å¯ç”¨äº† casm ä»£ç ç”Ÿæˆï¼š"

#~ msgid "Make sure that the version in the tag matches the version of snforge. You can check the installed snforge version with the following command:"
#~ msgstr "ç¡®ä¿æ ‡ç­¾ä¸­çš„ç‰ˆæœ¬ä¸ snforge çš„ç‰ˆæœ¬ä¸€è‡´ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ£€æŸ¥å·²å®‰è£…çš„ snforge ç‰ˆæœ¬ï¼š"

#~ msgid "Now, you are ready to use `snforge` with your existing Scarb project."
#~ msgstr "ç°åœ¨ï¼Œæ‚¨å¯ä»¥åœ¨ç°æœ‰ Scarb é¡¹ç›®ä¸­ä½¿ç”¨ `snforge` äº†ã€‚"

#~ msgid ""
#~ "To run tests using the Starknet Foundry `snforge` command, follow these instructions. We will cover `test execution`, `test filtering`, `running specific tests`, and `handling test execution "
#~ "failures`."
#~ msgstr "è¦ä½¿ç”¨ Starknet Foundry `snforge` å‘½ä»¤è¿è¡Œæµ‹è¯•ï¼Œè¯·éµå¾ªä»¥ä¸‹è¯´æ˜ã€‚æˆ‘ä»¬å°†ä»‹ç» `test execution`ï¼Œ `test filtering`ï¼Œ `running specific tests`å’Œ `handling test execution failures`ã€‚"

#~ msgid "This command collects and runs tests within the specified package. Here's an example output:"
#~ msgstr "è¯¥å‘½ä»¤æ”¶é›†å¹¶è¿è¡ŒæŒ‡å®šè½¯ä»¶åŒ…å†…çš„æµ‹è¯•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªè¾“å‡ºç¤ºä¾‹ï¼š"

#~ msgid "### Running a Specific Test"
#~ msgstr "### è¿è¡Œç‰¹å®šæµ‹è¯•"

#~ msgid "To run a specific test, you can use the `--exact` flag along with the filter string. Ensure that you use a fully qualified test name, including the module name:"
#~ msgstr "è¦è¿è¡Œç‰¹å®šæµ‹è¯•ï¼Œå¯ä»¥ä½¿ç”¨ `--exact` æ ‡å¿—å’Œè¿‡æ»¤å™¨å­—ç¬¦ä¸²ã€‚ç¡®ä¿ä½¿ç”¨å®Œå…¨åˆæ ¼çš„æµ‹è¯•åç§°ï¼ŒåŒ…æ‹¬æ¨¡å—åç§°ï¼š"

#~ msgid "### Stopping Test Execution After First Failed Test"
#~ msgstr "### åœ¨é¦–æ¬¡æµ‹è¯•å¤±è´¥ååœæ­¢æµ‹è¯•æ‰§è¡Œ"

#~ msgid "## Testing Starknet contract with `snforge` (Example)"
#~ msgstr "## ä½¿ç”¨ `snforge` æµ‹è¯•Starknetåˆçº¦ï¼ˆç¤ºä¾‹ï¼‰"

#~ msgid "It should be noted that the name written after `mod` is the contract name which would be referenced later on; in this case, it is `HelloStarknet`."
#~ msgstr "åº”è¯¥æ³¨æ„çš„æ˜¯ï¼Œå†™åœ¨ `mod` åé¢çš„åç§°æ˜¯ç¨åå°†å¼•ç”¨çš„åˆçº¦åç§°ï¼›åœ¨æœ¬ä¾‹ä¸­ï¼Œå®ƒæ˜¯ `HelloStarknet`ã€‚"

#~ msgid "Now we are ready to run `snforge`. once you run the `snforge` command, you should get the below output"
#~ msgstr "ç°åœ¨ï¼Œæˆ‘ä»¬å‡†å¤‡è¿è¡Œ `snforge`ã€‚è¿è¡Œ `snforge` å‘½ä»¤åï¼Œä¼šå¾—åˆ°ä»¥ä¸‹è¾“å‡ºç»“æœ"

#~ msgid "## snforge Commands"
#~ msgstr "## snforge å‘½ä»¤"

#~ msgid ""
#~ "- Running `snforge` in the Current Directory\n"
#~ "To run the snforge command in the current directory, simply execute the following command:"
#~ msgstr ""
#~ "- åœ¨å½“å‰ç›®å½•ä¸‹è¿è¡Œ `snforge`\n"
#~ "è¦åœ¨å½“å‰ç›®å½•ä¸‹è¿è¡Œ snforge å‘½ä»¤ï¼Œåªéœ€æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š"

#~ msgid ""
#~ "- `-e, --exact`: Use the `-e` or `--exact` option to run a test with a name that exactly matches the provided test filter. The test filter should be a fully qualified test name, including the "
#~ "package name. For example, instead of specifying just `my_test`, use `package_name::my_test` as the test filter.\n"
#~ "\n"
#~ "- `--init` <NAME>: The `--init` <NAME> option allows you to create a new directory and forge project with the specified name <NAME>.\n"
#~ "\n"
#~ "- `-x`, `--exit-first`: By using the` -x` or `--exit-first` option, you can stop the execution of tests after the first test failure is encountered."
#~ msgstr ""
#~ "- `-e,--exact`ï¼šä½¿ç”¨ `-e` æˆ– `--exact` é€‰é¡¹è¿è¡Œåç§°ä¸æ‰€æä¾›çš„æµ‹è¯•è¿‡æ»¤å™¨å®Œå…¨åŒ¹é…çš„æµ‹è¯•ã€‚æµ‹è¯•è¿‡æ»¤å™¨åº”è¯¥æ˜¯ä¸€ä¸ªå®Œæ•´çš„æµ‹è¯•åç§°ï¼ŒåŒ…æ‹¬è½¯ä»¶åŒ…åç§°ã€‚ä¾‹å¦‚ï¼Œä½¿ç”¨ `package_name::my_test` ä½œä¸ºæµ‹è¯•è¿‡æ»¤å™¨ï¼Œè€Œä¸æ˜¯åª"
#~ "æŒ‡å®š `my_test`ã€‚\n"
#~ "\n"
#~ "- `--init`<NAME>: `--init`<NAME> é€‰é¡¹å…è®¸åˆ›å»ºä¸€ä¸ªæ–°ç›®å½•ï¼Œå¹¶ä»¥æŒ‡å®šçš„åç§°åˆ›å»ºé¡¹ç›®<NAME> ã€‚\n"
#~ "\n"
#~ "- `-x`, `--exit-first`ï¼šé€šè¿‡ä½¿ç”¨ ` -x` æˆ– `--exit-first` é€‰é¡¹ï¼Œå¯ä»¥åœ¨ç¬¬ä¸€æ¬¡æµ‹è¯•å¤±è´¥ååœæ­¢æ‰§è¡Œæµ‹è¯•ã€‚"

#~ msgid "### Package Selection"
#~ msgstr "### åŒ…é€‰æ‹©"

#~ msgid ""
#~ "- `-p`, `--package`: The `-p` or `--package` option is used to specify the packages on which to run the `snforge` command. You can either provide a concrete package name (e.g., foobar) or use a "
#~ "prefix glob (e.g., foo*) to match multiple packages.\n"
#~ "\n"
#~ "- `-w`, `--workspace`: Use the `-w` or `--workspace` option to run tests for all packages in the workspace."
#~ msgstr ""
#~ "- `-p`, `--package`ï¼š`-p`æˆ–\"--package \"é€‰é¡¹ç”¨äºæŒ‡å®šè¿è¡Œ `snforge` å‘½ä»¤çš„è½¯ä»¶åŒ…ã€‚ä½ å¯ä»¥æä¾›ä¸€ä¸ªå…·ä½“çš„è½¯ä»¶åŒ…åç§°ï¼ˆä¾‹å¦‚ï¼Œfoobarï¼‰ï¼Œæˆ–è€…ä½¿ç”¨å‰ç¼€ globï¼ˆä¾‹å¦‚ï¼Œfoo*ï¼‰æ¥åŒ¹é…å¤šä¸ªè½¯ä»¶åŒ…ã€‚\n"
#~ "\n"
#~ "- w\"ã€\"--workspace\"ï¼šä½¿ç”¨ `-w` æˆ– `--workspace` é€‰é¡¹å¯è¿è¡Œå·¥ä½œåŒºä¸­æ‰€æœ‰è½¯ä»¶åŒ…çš„æµ‹è¯•ã€‚"

#~ msgid ""
#~ "- `-r`, `--fuzzer-runs` <FUZZER_RUNS>: Specify the number of fuzzer runs using the `-r` or `--fuzzer-runs` option, followed by the desired number of runs <FUZZER_RUNS>.\n"
#~ "\n"
#~ "- `-s`, `--fuzzer-seed` <FUZZER_SEED>: Set the seed for the fuzzer by using the `-s` or `--fuzzer-seed` option, followed by the desired seed value <FUZZER_SEED>."
#~ msgstr ""
#~ "- `-r`ã€`--fuzzer-runs` <FUZZER_RUNS>ï¼šä½¿ç”¨`-r`æˆ–`--fuzzer-runs`é€‰é¡¹æŒ‡å®šæ¨¡ç³Šå™¨çš„è¿è¡Œæ¬¡æ•°ï¼Œä¹‹åæ˜¯æ‰€éœ€çš„è¿è¡Œæ¬¡æ•° <FUZZER_RUNS>ã€‚\n"
#~ "\n"
#~ "- `-s`, `--fuzzer-seed` <FUZZER_SEED>ï¼šä½¿ç”¨`-s`æˆ–`-fuzzer-seed`é€‰é¡¹è®¾ç½®æ¨¡ç³Šå™¨çš„ç§å­å€¼ï¼Œåé¢è·Ÿæ‰€éœ€çš„ç§å­å€¼<FUZZER_SEED>ã€‚"

#~ msgid "- `-c`, `--clean-cache`: To clean the `snforge` cache directory, simply use the `-c` or `--clean-cache` option."
#~ msgstr "- `-c`ã€`--clean-cache`ï¼šè¦æ¸…ç† `snforge` ç¼“å­˜ç›®å½•ï¼Œåªéœ€ä½¿ç”¨ `-c` æˆ– `--clean-cache` é€‰é¡¹ã€‚"

#~ msgid "### Help and Version Information"
#~ msgstr "#### å¸®åŠ©å’Œç‰ˆæœ¬ä¿¡æ¯"

#~ msgid ""
#~ "- `-h`,` --help`: Use the `-h` or `--help` option to print the help information, providing guidance on how to use `snforge`.\n"
#~ "\n"
#~ "- `-V`, `--version`: To display the current version of `snforge`, use the `-V` or `--version` option."
#~ msgstr ""
#~ "- `-h`, `--help`ï¼šä½¿ç”¨ `-h` æˆ– `--help` é€‰é¡¹æ‰“å°å¸®åŠ©ä¿¡æ¯ï¼Œæä¾›å¦‚ä½•ä½¿ç”¨ `snforge` çš„æŒ‡å¯¼ã€‚\n"
#~ "\n"
#~ "- `-V`, `--version`ï¼šè¦æ˜¾ç¤º `snforge` çš„å½“å‰ç‰ˆæœ¬ï¼Œä½¿ç”¨ `-V` æˆ– `--version` é€‰é¡¹ã€‚"

#~ msgid "Note: Replace <NAME>, <FUZZER_RUNS>, and <FUZZER_SEED> with your specific values when using the `snforge` command."
#~ msgstr "æ³¨æ„ï¼šåœ¨ä½¿ç”¨ `snforge` å‘½ä»¤æ—¶ï¼Œè¯·å°†<NAME> ã€<FUZZER_RUNS> å’Œ<FUZZER_SEED> æ›¿æ¢ä¸ºæ‚¨çš„ç‰¹å®šå€¼ã€‚"
